/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import * as models from "../index.js";

export const InputZscalerHecType = {
  ZscalerHec: "zscaler_hec",
} as const;
export type InputZscalerHecType = OpenEnum<typeof InputZscalerHecType>;

export type InputZscalerHecConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputZscalerHecMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputZscalerHecMode = OpenEnum<typeof InputZscalerHecMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputZscalerHecCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputZscalerHecCompression = OpenEnum<
  typeof InputZscalerHecCompression
>;

export type InputZscalerHecPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputZscalerHecMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputZscalerHecCompression | undefined;
};

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const InputZscalerHecAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type InputZscalerHecAuthenticationMethod = OpenEnum<
  typeof InputZscalerHecAuthenticationMethod
>;

export type InputZscalerHecAuthTokenMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputZscalerHecAuthToken = {
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: InputZscalerHecAuthenticationMethod | undefined;
  tokenSecret?: any | undefined;
  token?: any | undefined;
  enabled?: boolean | undefined;
  description?: string | undefined;
  /**
   * Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
   */
  allowedIndexesAtToken?: Array<string> | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<InputZscalerHecAuthTokenMetadatum> | undefined;
};

export const InputZscalerHecMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputZscalerHecMinimumTLSVersion = OpenEnum<
  typeof InputZscalerHecMinimumTLSVersion
>;

export const InputZscalerHecMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputZscalerHecMaximumTLSVersion = OpenEnum<
  typeof InputZscalerHecMaximumTLSVersion
>;

export type InputZscalerHecTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputZscalerHecMinimumTLSVersion | undefined;
  maxVersion?: InputZscalerHecMaximumTLSVersion | undefined;
};

export type InputZscalerHecMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputZscalerHec = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputZscalerHecType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputZscalerHecConnection> | undefined;
  pq?: InputZscalerHecPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputZscalerHecAuthToken> | undefined;
  tls?: InputZscalerHecTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
   */
  hecAPI?: string | undefined;
  /**
   * Fields to add to every event. May be overridden by fields added at the token or request level.
   */
  metadata?: Array<InputZscalerHecMetadatum> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Whether to enable Zscaler HEC acknowledgements
   */
  hecAcks?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export const InputSecurityLakeType = {
  SecurityLake: "security_lake",
} as const;
export type InputSecurityLakeType = OpenEnum<typeof InputSecurityLakeType>;

export type InputSecurityLakeConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSecurityLakeMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSecurityLakeMode = OpenEnum<typeof InputSecurityLakeMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSecurityLakeCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSecurityLakeCompression = OpenEnum<
  typeof InputSecurityLakeCompression
>;

export type InputSecurityLakePq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSecurityLakeMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSecurityLakeCompression | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const InputSecurityLakeAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type InputSecurityLakeAuthenticationMethod = OpenEnum<
  typeof InputSecurityLakeAuthenticationMethod
>;

/**
 * Signature version to use for signing S3 requests
 */
export const InputSecurityLakeSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type InputSecurityLakeSignatureVersion = OpenEnum<
  typeof InputSecurityLakeSignatureVersion
>;

export type InputSecurityLakePreprocess = {
  disabled?: boolean | undefined;
  /**
   * Command to feed the data through (via stdin) and process its output (stdout)
   */
  command?: string | undefined;
  /**
   * Arguments to be added to the custom command
   */
  args?: Array<string> | undefined;
};

export type InputSecurityLakeMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSecurityLakeCheckpointing = {
  /**
   * Resume processing files after an interruption
   */
  enabled?: boolean | undefined;
  /**
   * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored.
   */
  retries?: number | undefined;
};

export const InputSecurityLakeTagAfterProcessing = {
  False: "false",
  True: "true",
} as const;
export type InputSecurityLakeTagAfterProcessing = OpenEnum<
  typeof InputSecurityLakeTagAfterProcessing
>;

export type InputSecurityLake = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSecurityLakeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSecurityLakeConnection> | undefined;
  pq?: InputSecurityLakePq | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: InputSecurityLakeAuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: InputSecurityLakeSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: InputSecurityLakePreprocess | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputSecurityLakeMetadatum> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: InputSecurityLakeCheckpointing | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: InputSecurityLakeTagAfterProcessing | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export const InputNetflowType = {
  Netflow: "netflow",
} as const;
export type InputNetflowType = OpenEnum<typeof InputNetflowType>;

export type InputNetflowConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputNetflowMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputNetflowMode = OpenEnum<typeof InputNetflowMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputNetflowCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputNetflowCompression = OpenEnum<typeof InputNetflowCompression>;

export type InputNetflowPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputNetflowMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputNetflowCompression | undefined;
};

export type InputNetflowMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputNetflow = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputNetflowType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputNetflowConnection> | undefined;
  pq?: InputNetflowPq | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  /**
   * Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
   */
  enablePassThrough?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
   */
  templateCacheMinutes?: number | undefined;
  /**
   * Accept messages in Netflow V5 format.
   */
  v5Enabled?: boolean | undefined;
  /**
   * Accept messages in Netflow V9 format.
   */
  v9Enabled?: boolean | undefined;
  /**
   * Accept messages in IPFIX format.
   */
  ipfixEnabled?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputNetflowMetadatum> | undefined;
  description?: string | undefined;
};

export const InputWizType = {
  Wiz: "wiz",
} as const;
export type InputWizType = OpenEnum<typeof InputWizType>;

export type InputWizConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputWizMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputWizMode = OpenEnum<typeof InputWizMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputWizCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputWizCompression = OpenEnum<typeof InputWizCompression>;

export type InputWizPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputWizMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputWizCompression | undefined;
};

export type InputWizContentConfig = {
  /**
   * The name of the Wiz query
   */
  contentType: string;
  contentDescription?: string | undefined;
  enabled?: boolean | undefined;
};

export type InputWizMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const InputWizRetryType = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type InputWizRetryType = OpenEnum<typeof InputWizRetryType>;

export type InputWizRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: InputWizRetryType | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Enter client secret directly, or select a stored secret
 */
export const InputWizAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter client secret directly, or select a stored secret
 */
export type InputWizAuthenticationMethod = OpenEnum<
  typeof InputWizAuthenticationMethod
>;

export type InputWiz = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputWizType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputWizConnection> | undefined;
  pq?: InputWizPq | undefined;
  /**
   * The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
   */
  endpoint?: string | undefined;
  /**
   * The authentication URL to generate an OAuth token
   */
  authUrl: string;
  /**
   * The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
   */
  authAudienceOverride?: string | undefined;
  /**
   * The client ID of the Wiz application
   */
  clientId: string;
  contentConfig: Array<InputWizContentConfig>;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputWizMetadatum> | undefined;
  retryRules?: InputWizRetryRules | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: InputWizAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * The client secret of the Wiz application
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputJournalFilesType = {
  JournalFiles: "journal_files",
} as const;
export type InputJournalFilesType = OpenEnum<typeof InputJournalFilesType>;

export type InputJournalFilesConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputJournalFilesMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputJournalFilesMode = OpenEnum<typeof InputJournalFilesMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputJournalFilesCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputJournalFilesCompression = OpenEnum<
  typeof InputJournalFilesCompression
>;

export type InputJournalFilesPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputJournalFilesMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputJournalFilesCompression | undefined;
};

export type CreateInputRule = {
  /**
   * JavaScript expression applied to Journal objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputJournalFilesMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputJournalFiles = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputJournalFilesType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputJournalFilesConnection> | undefined;
  pq?: InputJournalFilesPq | undefined;
  /**
   * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
   */
  path: string;
  /**
   * Time, in seconds, between scanning for journals.
   */
  interval?: number | undefined;
  /**
   * The full path of discovered journals are matched against this wildcard list.
   */
  journals: Array<string>;
  /**
   * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<CreateInputRule> | undefined;
  /**
   * Skip log messages that are not part of the current boot session.
   */
  currentBoot?: boolean | undefined;
  /**
   * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputJournalFilesMetadatum> | undefined;
  description?: string | undefined;
};

export const InputRawUdpType = {
  RawUdp: "raw_udp",
} as const;
export type InputRawUdpType = OpenEnum<typeof InputRawUdpType>;

export type InputRawUdpConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputRawUdpMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputRawUdpMode = OpenEnum<typeof InputRawUdpMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputRawUdpCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputRawUdpCompression = OpenEnum<typeof InputRawUdpCompression>;

export type InputRawUdpPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputRawUdpMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputRawUdpCompression | undefined;
};

export type InputRawUdpMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputRawUdp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputRawUdpType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputRawUdpConnection> | undefined;
  pq?: InputRawUdpPq | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
   */
  ingestRawBytes?: boolean | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputRawUdpMetadatum> | undefined;
  description?: string | undefined;
};

export const InputWinEventLogsType = {
  WinEventLogs: "win_event_logs",
} as const;
export type InputWinEventLogsType = OpenEnum<typeof InputWinEventLogsType>;

export type InputWinEventLogsConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputWinEventLogsMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputWinEventLogsMode = OpenEnum<typeof InputWinEventLogsMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputWinEventLogsCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputWinEventLogsCompression = OpenEnum<
  typeof InputWinEventLogsCompression
>;

export type InputWinEventLogsPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputWinEventLogsMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputWinEventLogsCompression | undefined;
};

/**
 * Read all stored and future event logs, or only future events
 */
export const ReadMode = {
  Oldest: "oldest",
  Newest: "newest",
} as const;
/**
 * Read all stored and future event logs, or only future events
 */
export type ReadMode = OpenEnum<typeof ReadMode>;

/**
 * Format of individual events
 */
export const EventFormat = {
  Json: "json",
  Xml: "xml",
} as const;
/**
 * Format of individual events
 */
export type EventFormat = OpenEnum<typeof EventFormat>;

export type InputWinEventLogsMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputWinEventLogs = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWinEventLogsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputWinEventLogsConnection> | undefined;
  pq?: InputWinEventLogsPq | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat | undefined;
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputWinEventLogsMetadatum> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
};

export const InputWefType = {
  Wef: "wef",
} as const;
export type InputWefType = OpenEnum<typeof InputWefType>;

export type InputWefConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputWefMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputWefMode = OpenEnum<typeof InputWefMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputWefCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputWefCompression = OpenEnum<typeof InputWefCompression>;

export type InputWefPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputWefMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputWefCompression | undefined;
};

/**
 * How to authenticate incoming client connections
 */
export const InputWefAuthenticationMethod = {
  ClientCert: "clientCert",
  Kerberos: "kerberos",
} as const;
/**
 * How to authenticate incoming client connections
 */
export type InputWefAuthenticationMethod = OpenEnum<
  typeof InputWefAuthenticationMethod
>;

export const InputWefMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputWefMinimumTLSVersion = OpenEnum<
  typeof InputWefMinimumTLSVersion
>;

export const InputWefMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputWefMaximumTLSVersion = OpenEnum<
  typeof InputWefMaximumTLSVersion
>;

export type MTLSSettings = {
  /**
   * Enable TLS
   */
  disabled?: boolean | undefined;
  /**
   * Required for WEF certificate authentication
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Required for WEF certificate authentication
   */
  requestCert?: boolean | undefined;
  /**
   * Name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath: string;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath: string;
  /**
   * Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it.
   */
  caPath: string;
  /**
   * Regex matching allowable common names in peer certificates' subject attribute
   */
  commonNameRegex?: string | undefined;
  minVersion?: InputWefMinimumTLSVersion | undefined;
  maxVersion?: InputWefMaximumTLSVersion | undefined;
  /**
   * Enable OCSP check of certificate
   */
  ocspCheck?: boolean | undefined;
  keytab?: any | undefined;
  principal?: any | undefined;
  /**
   * If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors.
   */
  ocspCheckFailClose?: boolean | undefined;
};

/**
 * Content format in which the endpoint should deliver events
 */
export const CreateInputFormat = {
  Raw: "Raw",
  RenderedText: "RenderedText",
} as const;
/**
 * Content format in which the endpoint should deliver events
 */
export type CreateInputFormat = OpenEnum<typeof CreateInputFormat>;

export const QueryBuilderMode = {
  Simple: "simple",
  Xml: "xml",
} as const;
export type QueryBuilderMode = OpenEnum<typeof QueryBuilderMode>;

export type SubscriptionMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type Subscription = {
  subscriptionName: string;
  /**
   * Version UUID for this subscription. If any subscription parameters are modified, this value will change.
   */
  version?: string | undefined;
  /**
   * Content format in which the endpoint should deliver events
   */
  contentFormat?: CreateInputFormat | undefined;
  /**
   * Maximum time (in seconds) between endpoint checkins before considering it unavailable
   */
  heartbeatInterval?: number | undefined;
  /**
   * Interval (in seconds) over which the endpoint should collect events before sending them to Stream
   */
  batchTimeout?: number | undefined;
  /**
   * Newly subscribed endpoints will send previously existing events. Disable to receive new events only.
   */
  readExistingEvents?: boolean | undefined;
  /**
   * Keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events'. See [Cribl Docs](https://docs.cribl.io/stream/sources-wef/#subscriptions) for more details.
   */
  sendBookmarks?: boolean | undefined;
  /**
   * Receive compressed events from the source
   */
  compress?: boolean | undefined;
  /**
   * The DNS names of the endpoints that should forward these events. You may use wildcards, such as *.mydomain.com
   */
  targets: Array<string>;
  /**
   * The RFC-3066 locale the Windows clients should use when sending events. Defaults to "en-US".
   */
  locale?: string | undefined;
  querySelector?: QueryBuilderMode | undefined;
  /**
   * Fields to add to events ingested under this subscription
   */
  metadata?: Array<SubscriptionMetadatum> | undefined;
};

export type InputWefMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputWef = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputWefType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputWefConnection> | undefined;
  pq?: InputWefPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  /**
   * How to authenticate incoming client connections
   */
  authMethod?: InputWefAuthenticationMethod | undefined;
  tls?: MTLSSettings | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
   */
  caFingerprint?: string | undefined;
  /**
   * Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
   */
  keytab?: string | undefined;
  /**
   * Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
   */
  principal?: string | undefined;
  /**
   * Allow events to be ingested even if their MachineID does not match the client certificate CN
   */
  allowMachineIdMismatch?: boolean | undefined;
  /**
   * Subscriptions to events on forwarding endpoints
   */
  subscriptions: Array<Subscription>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputWefMetadatum> | undefined;
  description?: string | undefined;
  /**
   * Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
   */
  logFingerprintMismatch?: boolean | undefined;
};

export const InputTcpType = {
  Tcp: "tcp",
} as const;
export type InputTcpType = OpenEnum<typeof InputTcpType>;

export type InputTcpConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputTcpMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputTcpMode = OpenEnum<typeof InputTcpMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputTcpCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputTcpCompression = OpenEnum<typeof InputTcpCompression>;

export type InputTcpPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputTcpMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputTcpCompression | undefined;
};

export const InputTcpMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputTcpMinimumTLSVersion = OpenEnum<
  typeof InputTcpMinimumTLSVersion
>;

export const InputTcpMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputTcpMaximumTLSVersion = OpenEnum<
  typeof InputTcpMaximumTLSVersion
>;

export type InputTcpTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputTcpMinimumTLSVersion | undefined;
  maxVersion?: InputTcpMaximumTLSVersion | undefined;
};

export type InputTcpMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputTcpPreprocess = {
  disabled?: boolean | undefined;
  /**
   * Command to feed the data through (via stdin) and process its output (stdout)
   */
  command?: string | undefined;
  /**
   * Arguments to be added to the custom command
   */
  args?: Array<string> | undefined;
};

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const InputTcpAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type InputTcpAuthenticationMethod = OpenEnum<
  typeof InputTcpAuthenticationMethod
>;

export type InputTcp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputTcpType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputTcpConnection> | undefined;
  pq?: InputTcpPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputTcpTLSSettingsServerSide | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputTcpMetadatum> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  preprocess?: InputTcpPreprocess | undefined;
  description?: string | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: InputTcpAuthenticationMethod | undefined;
};

export const InputSyslogType2 = {
  Syslog: "syslog",
} as const;
export type InputSyslogType2 = OpenEnum<typeof InputSyslogType2>;

export type InputSyslogConnection2 = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSyslogMode2 = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSyslogMode2 = OpenEnum<typeof InputSyslogMode2>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSyslogCompression2 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSyslogCompression2 = OpenEnum<typeof InputSyslogCompression2>;

export type InputSyslogPq2 = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSyslogMode2 | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSyslogCompression2 | undefined;
};

export const InputSyslogMinimumTLSVersion2 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSyslogMinimumTLSVersion2 = OpenEnum<
  typeof InputSyslogMinimumTLSVersion2
>;

export const InputSyslogMaximumTLSVersion2 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSyslogMaximumTLSVersion2 = OpenEnum<
  typeof InputSyslogMaximumTLSVersion2
>;

export type InputSyslogTLSSettingsServerSide2 = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputSyslogMinimumTLSVersion2 | undefined;
  maxVersion?: InputSyslogMaximumTLSVersion2 | undefined;
};

export type InputSyslogMetadatum2 = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSyslog2 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSyslogType2;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSyslogConnection2> | undefined;
  pq?: InputSyslogPq2 | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort: number;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * Treat UDP packet data received as full syslog message
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Wildcard list of fields to keep from source data; * = ALL (default)
   */
  keepFieldsList?: Array<string> | undefined;
  /**
   * Enable if incoming messages use octet counting per RFC 6587.
   */
  octetCounting?: boolean | undefined;
  /**
   * Enable if we should infer the syslog framing of the incoming messages.
   */
  inferFraming?: boolean | undefined;
  /**
   * Enable if we should infer octet counting only if the messages comply with RFC 5424.
   */
  strictlyInferOctetCounting?: boolean | undefined;
  /**
   * Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
   */
  allowNonStandardAppName?: boolean | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  tls?: InputSyslogTLSSettingsServerSide2 | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputSyslogMetadatum2> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
  /**
   * When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
   */
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

export const InputSyslogType1 = {
  Syslog: "syslog",
} as const;
export type InputSyslogType1 = OpenEnum<typeof InputSyslogType1>;

export type InputSyslogConnection1 = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSyslogMode1 = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSyslogMode1 = OpenEnum<typeof InputSyslogMode1>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSyslogCompression1 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSyslogCompression1 = OpenEnum<typeof InputSyslogCompression1>;

export type InputSyslogPq1 = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSyslogMode1 | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSyslogCompression1 | undefined;
};

export const InputSyslogMinimumTLSVersion1 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSyslogMinimumTLSVersion1 = OpenEnum<
  typeof InputSyslogMinimumTLSVersion1
>;

export const InputSyslogMaximumTLSVersion1 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSyslogMaximumTLSVersion1 = OpenEnum<
  typeof InputSyslogMaximumTLSVersion1
>;

export type InputSyslogTLSSettingsServerSide1 = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputSyslogMinimumTLSVersion1 | undefined;
  maxVersion?: InputSyslogMaximumTLSVersion1 | undefined;
};

export type InputSyslogMetadatum1 = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSyslog1 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSyslogType1;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSyslogConnection1> | undefined;
  pq?: InputSyslogPq1 | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort: number;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * Treat UDP packet data received as full syslog message
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Wildcard list of fields to keep from source data; * = ALL (default)
   */
  keepFieldsList?: Array<string> | undefined;
  /**
   * Enable if incoming messages use octet counting per RFC 6587.
   */
  octetCounting?: boolean | undefined;
  /**
   * Enable if we should infer the syslog framing of the incoming messages.
   */
  inferFraming?: boolean | undefined;
  /**
   * Enable if we should infer octet counting only if the messages comply with RFC 5424.
   */
  strictlyInferOctetCounting?: boolean | undefined;
  /**
   * Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
   */
  allowNonStandardAppName?: boolean | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  tls?: InputSyslogTLSSettingsServerSide1 | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputSyslogMetadatum1> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
  /**
   * When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
   */
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

export type InputSyslogUnion = InputSyslog1 | InputSyslog2;

export const InputSqsType = {
  Sqs: "sqs",
} as const;
export type InputSqsType = OpenEnum<typeof InputSqsType>;

export type InputSqsConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSqsMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSqsMode = OpenEnum<typeof InputSqsMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSqsCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSqsCompression = OpenEnum<typeof InputSqsCompression>;

export type InputSqsPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSqsMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSqsCompression | undefined;
};

/**
 * The queue type used (or created)
 */
export const CreateInputQueueType = {
  Standard: "standard",
  Fifo: "fifo",
} as const;
/**
 * The queue type used (or created)
 */
export type CreateInputQueueType = OpenEnum<typeof CreateInputQueueType>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const InputSqsAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type InputSqsAuthenticationMethod = OpenEnum<
  typeof InputSqsAuthenticationMethod
>;

/**
 * Signature version to use for signing SQS requests
 */
export const InputSqsSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing SQS requests
 */
export type InputSqsSignatureVersion = OpenEnum<
  typeof InputSqsSignatureVersion
>;

export type InputSqsMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSqs = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputSqsType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSqsConnection> | undefined;
  pq?: InputSqsPq | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * The queue type used (or created)
   */
  queueType?: CreateInputQueueType | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * Create queue if it does not exist
   */
  createQueue?: boolean | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: InputSqsAuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing SQS requests
   */
  signatureVersion?: InputSqsSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access SQS
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputSqsMetadatum> | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
};

export const InputModelDrivenTelemetryType = {
  ModelDrivenTelemetry: "model_driven_telemetry",
} as const;
export type InputModelDrivenTelemetryType = OpenEnum<
  typeof InputModelDrivenTelemetryType
>;

export type InputModelDrivenTelemetryConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputModelDrivenTelemetryMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputModelDrivenTelemetryMode = OpenEnum<
  typeof InputModelDrivenTelemetryMode
>;

/**
 * Codec to use to compress the persisted data
 */
export const InputModelDrivenTelemetryCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputModelDrivenTelemetryCompression = OpenEnum<
  typeof InputModelDrivenTelemetryCompression
>;

export type InputModelDrivenTelemetryPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputModelDrivenTelemetryMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputModelDrivenTelemetryCompression | undefined;
};

export const InputModelDrivenTelemetryMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputModelDrivenTelemetryMinimumTLSVersion = OpenEnum<
  typeof InputModelDrivenTelemetryMinimumTLSVersion
>;

export const InputModelDrivenTelemetryMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputModelDrivenTelemetryMaximumTLSVersion = OpenEnum<
  typeof InputModelDrivenTelemetryMaximumTLSVersion
>;

export type InputModelDrivenTelemetryTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputModelDrivenTelemetryMinimumTLSVersion | undefined;
  maxVersion?: InputModelDrivenTelemetryMaximumTLSVersion | undefined;
};

export type InputModelDrivenTelemetryMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputModelDrivenTelemetry = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputModelDrivenTelemetryType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputModelDrivenTelemetryConnection> | undefined;
  pq?: InputModelDrivenTelemetryPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: InputModelDrivenTelemetryTLSSettingsServerSide | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputModelDrivenTelemetryMetadatum> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
   */
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

export const InputOpenTelemetryType = {
  OpenTelemetry: "open_telemetry",
} as const;
export type InputOpenTelemetryType = OpenEnum<typeof InputOpenTelemetryType>;

export type InputOpenTelemetryConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputOpenTelemetryMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputOpenTelemetryMode = OpenEnum<typeof InputOpenTelemetryMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputOpenTelemetryCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputOpenTelemetryCompression = OpenEnum<
  typeof InputOpenTelemetryCompression
>;

export type InputOpenTelemetryPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputOpenTelemetryMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputOpenTelemetryCompression | undefined;
};

export const InputOpenTelemetryMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputOpenTelemetryMinimumTLSVersion = OpenEnum<
  typeof InputOpenTelemetryMinimumTLSVersion
>;

export const InputOpenTelemetryMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputOpenTelemetryMaximumTLSVersion = OpenEnum<
  typeof InputOpenTelemetryMaximumTLSVersion
>;

export type InputOpenTelemetryTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputOpenTelemetryMinimumTLSVersion | undefined;
  maxVersion?: InputOpenTelemetryMaximumTLSVersion | undefined;
};

/**
 * Select whether to leverage gRPC or HTTP for OpenTelemetry
 */
export const InputOpenTelemetryProtocol = {
  Grpc: "grpc",
  Http: "http",
} as const;
/**
 * Select whether to leverage gRPC or HTTP for OpenTelemetry
 */
export type InputOpenTelemetryProtocol = OpenEnum<
  typeof InputOpenTelemetryProtocol
>;

/**
 * The version of OTLP Protobuf definitions to use when interpreting received data
 */
export const CreateInputOTLPVersion = {
  ZeroDot10Dot0: "0.10.0",
  OneDot3Dot1: "1.3.1",
} as const;
/**
 * The version of OTLP Protobuf definitions to use when interpreting received data
 */
export type CreateInputOTLPVersion = OpenEnum<typeof CreateInputOTLPVersion>;

/**
 * OpenTelemetry authentication type
 */
export const InputOpenTelemetryAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * OpenTelemetry authentication type
 */
export type InputOpenTelemetryAuthenticationType = OpenEnum<
  typeof InputOpenTelemetryAuthenticationType
>;

export type InputOpenTelemetryMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputOpenTelemetryOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type InputOpenTelemetryOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputOpenTelemetry = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputOpenTelemetryType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputOpenTelemetryConnection> | undefined;
  pq?: InputOpenTelemetryPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: InputOpenTelemetryTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: any | undefined;
  captureHeaders?: any | undefined;
  activityLogSampleRate?: any | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Select whether to leverage gRPC or HTTP for OpenTelemetry
   */
  protocol?: InputOpenTelemetryProtocol | undefined;
  /**
   * Enable to extract each incoming span to a separate event
   */
  extractSpans?: boolean | undefined;
  /**
   * Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
   */
  extractMetrics?: boolean | undefined;
  /**
   * The version of OTLP Protobuf definitions to use when interpreting received data
   */
  otlpVersion?: CreateInputOTLPVersion | undefined;
  /**
   * OpenTelemetry authentication type
   */
  authType?: InputOpenTelemetryAuthenticationType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputOpenTelemetryMetadatum> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<InputOpenTelemetryOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<InputOpenTelemetryOauthHeader> | undefined;
  /**
   * Enable to extract each incoming log record to a separate event
   */
  extractLogs?: boolean | undefined;
};

export const InputSnmpType = {
  Snmp: "snmp",
} as const;
export type InputSnmpType = OpenEnum<typeof InputSnmpType>;

export type InputSnmpConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSnmpMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSnmpMode = OpenEnum<typeof InputSnmpMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSnmpCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSnmpCompression = OpenEnum<typeof InputSnmpCompression>;

export type InputSnmpPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSnmpMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSnmpCompression | undefined;
};

export const AuthenticationProtocol = {
  None: "none",
  Md5: "md5",
  Sha: "sha",
  Sha224: "sha224",
  Sha256: "sha256",
  Sha384: "sha384",
  Sha512: "sha512",
} as const;
export type AuthenticationProtocol = OpenEnum<typeof AuthenticationProtocol>;

export type V3User = {
  name: string;
  authProtocol?: AuthenticationProtocol | undefined;
  authKey?: any | undefined;
  privProtocol?: string | undefined;
};

/**
 * Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
 */
export type SNMPv3Authentication = {
  v3AuthEnabled?: boolean | undefined;
  /**
   * Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps.
   */
  allowUnmatchedTrap?: boolean | undefined;
  /**
   * User credentials for receiving v3 traps
   */
  v3Users?: Array<V3User> | undefined;
};

export type InputSnmpMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSnmp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputSnmpType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSnmpConnection> | undefined;
  pq?: InputSnmpPq | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * UDP port to receive SNMP traps on. Defaults to 162.
   */
  port?: number | undefined;
  /**
   * Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
   */
  snmpV3Auth?: SNMPv3Authentication | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputSnmpMetadatum> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * If enabled, parses varbinds as an array of objects that include OID, value, and type
   */
  varbindsWithTypes?: boolean | undefined;
  /**
   * If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
   */
  bestEffortParsing?: boolean | undefined;
  description?: string | undefined;
};

export const InputS3InventoryType = {
  S3Inventory: "s3_inventory",
} as const;
export type InputS3InventoryType = OpenEnum<typeof InputS3InventoryType>;

export type InputS3InventoryConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputS3InventoryMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputS3InventoryMode = OpenEnum<typeof InputS3InventoryMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputS3InventoryCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputS3InventoryCompression = OpenEnum<
  typeof InputS3InventoryCompression
>;

export type InputS3InventoryPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputS3InventoryMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputS3InventoryCompression | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const InputS3InventoryAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type InputS3InventoryAuthenticationMethod = OpenEnum<
  typeof InputS3InventoryAuthenticationMethod
>;

/**
 * Signature version to use for signing S3 requests
 */
export const InputS3InventorySignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type InputS3InventorySignatureVersion = OpenEnum<
  typeof InputS3InventorySignatureVersion
>;

export type InputS3InventoryPreprocess = {
  disabled?: boolean | undefined;
  /**
   * Command to feed the data through (via stdin) and process its output (stdout)
   */
  command?: string | undefined;
  /**
   * Arguments to be added to the custom command
   */
  args?: Array<string> | undefined;
};

export type InputS3InventoryMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputS3InventoryCheckpointing = {
  /**
   * Resume processing files after an interruption
   */
  enabled?: boolean | undefined;
  /**
   * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored.
   */
  retries?: number | undefined;
};

export const InputS3InventoryTagAfterProcessing = {
  False: "false",
  True: "true",
} as const;
export type InputS3InventoryTagAfterProcessing = OpenEnum<
  typeof InputS3InventoryTagAfterProcessing
>;

export type InputS3Inventory = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputS3InventoryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputS3InventoryConnection> | undefined;
  pq?: InputS3InventoryPq | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: InputS3InventoryAuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: InputS3InventorySignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: InputS3InventoryPreprocess | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputS3InventoryMetadatum> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: InputS3InventoryCheckpointing | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
   */
  checksumSuffix?: string | undefined;
  /**
   * Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
   */
  maxManifestSizeKB?: number | undefined;
  /**
   * If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
   */
  validateInventoryFiles?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: InputS3InventoryTagAfterProcessing | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export const InputS3Type = {
  S3: "s3",
} as const;
export type InputS3Type = OpenEnum<typeof InputS3Type>;

export type InputS3Connection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputS3Mode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputS3Mode = OpenEnum<typeof InputS3Mode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputS3Compression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputS3Compression = OpenEnum<typeof InputS3Compression>;

export type InputS3Pq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputS3Mode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputS3Compression | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const InputS3AuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type InputS3AuthenticationMethod = OpenEnum<
  typeof InputS3AuthenticationMethod
>;

/**
 * Signature version to use for signing S3 requests
 */
export const InputS3SignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type InputS3SignatureVersion = OpenEnum<typeof InputS3SignatureVersion>;

export type InputS3Preprocess = {
  disabled?: boolean | undefined;
  /**
   * Command to feed the data through (via stdin) and process its output (stdout)
   */
  command?: string | undefined;
  /**
   * Arguments to be added to the custom command
   */
  args?: Array<string> | undefined;
};

export type InputS3Metadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputS3Checkpointing = {
  /**
   * Resume processing files after an interruption
   */
  enabled?: boolean | undefined;
  /**
   * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored.
   */
  retries?: number | undefined;
};

export type InputS3 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputS3Type;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputS3Connection> | undefined;
  pq?: InputS3Pq | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: InputS3AuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: InputS3SignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: InputS3Preprocess | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputS3Metadatum> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: InputS3Checkpointing | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
   */
  tagAfterProcessing?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export const InputMetricsType = {
  Metrics: "metrics",
} as const;
export type InputMetricsType = OpenEnum<typeof InputMetricsType>;

export type InputMetricsConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputMetricsMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputMetricsMode = OpenEnum<typeof InputMetricsMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputMetricsCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputMetricsCompression = OpenEnum<typeof InputMetricsCompression>;

export type InputMetricsPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputMetricsMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputMetricsCompression | undefined;
};

export const InputMetricsMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputMetricsMinimumTLSVersion = OpenEnum<
  typeof InputMetricsMinimumTLSVersion
>;

export const InputMetricsMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputMetricsMaximumTLSVersion = OpenEnum<
  typeof InputMetricsMaximumTLSVersion
>;

export type InputMetricsTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputMetricsMinimumTLSVersion | undefined;
  maxVersion?: InputMetricsMaximumTLSVersion | undefined;
};

export type InputMetricsMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputMetrics = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputMetricsConnection> | undefined;
  pq?: InputMetricsPq | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  tls?: InputMetricsTLSSettingsServerSide | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputMetricsMetadatum> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

export const InputKinesisType = {
  Kinesis: "kinesis",
} as const;
export type InputKinesisType = OpenEnum<typeof InputKinesisType>;

export type InputKinesisConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputKinesisMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputKinesisMode = OpenEnum<typeof InputKinesisMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputKinesisCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputKinesisCompression = OpenEnum<typeof InputKinesisCompression>;

export type InputKinesisPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputKinesisMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputKinesisCompression | undefined;
};

/**
 * Location at which to start reading a shard for the first time
 */
export const ShardIteratorStart = {
  TrimHorizon: "TRIM_HORIZON",
  Latest: "LATEST",
} as const;
/**
 * Location at which to start reading a shard for the first time
 */
export type ShardIteratorStart = OpenEnum<typeof ShardIteratorStart>;

/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export const CreateInputRecordDataFormat = {
  Cribl: "cribl",
  Ndjson: "ndjson",
  Cloudwatch: "cloudwatch",
  Line: "line",
} as const;
/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export type CreateInputRecordDataFormat = OpenEnum<
  typeof CreateInputRecordDataFormat
>;

/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export const ShardLoadBalancing = {
  ConsistentHashing: "ConsistentHashing",
  RoundRobin: "RoundRobin",
} as const;
/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export type ShardLoadBalancing = OpenEnum<typeof ShardLoadBalancing>;

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const InputKinesisAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type InputKinesisAuthenticationMethod = OpenEnum<
  typeof InputKinesisAuthenticationMethod
>;

/**
 * Signature version to use for signing Kinesis stream requests
 */
export const InputKinesisSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing Kinesis stream requests
 */
export type InputKinesisSignatureVersion = OpenEnum<
  typeof InputKinesisSignatureVersion
>;

export type InputKinesisMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputKinesis = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputKinesisType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputKinesisConnection> | undefined;
  pq?: InputKinesisPq | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: CreateInputRecordDataFormat | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: InputKinesisAuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Kinesis stream requests
   */
  signatureVersion?: InputKinesisSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputKinesisMetadatum> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export const InputHttpRawType = {
  HttpRaw: "http_raw",
} as const;
export type InputHttpRawType = OpenEnum<typeof InputHttpRawType>;

export type InputHttpRawConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputHttpRawMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputHttpRawMode = OpenEnum<typeof InputHttpRawMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputHttpRawCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputHttpRawCompression = OpenEnum<typeof InputHttpRawCompression>;

export type InputHttpRawPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputHttpRawMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputHttpRawCompression | undefined;
};

export const InputHttpRawMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputHttpRawMinimumTLSVersion = OpenEnum<
  typeof InputHttpRawMinimumTLSVersion
>;

export const InputHttpRawMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputHttpRawMaximumTLSVersion = OpenEnum<
  typeof InputHttpRawMaximumTLSVersion
>;

export type InputHttpRawTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputHttpRawMinimumTLSVersion | undefined;
  maxVersion?: InputHttpRawMaximumTLSVersion | undefined;
};

export type InputHttpRawMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputHttpRawAuthTokensExtMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputHttpRawAuthTokensExt = {
  /**
   * Shared secret to be provided by any client (Authorization: <token>)
   */
  token: string;
  description?: string | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<InputHttpRawAuthTokensExtMetadatum> | undefined;
};

export type InputHttpRaw = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputHttpRawType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputHttpRawConnection> | undefined;
  pq?: InputHttpRawPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: InputHttpRawTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputHttpRawMetadatum> | undefined;
  /**
   * List of URI paths accepted by this input, wildcards are supported, e.g /api/v* /hook. Defaults to allow all.
   */
  allowedPaths?: Array<string> | undefined;
  /**
   * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
   */
  allowedMethods?: Array<string> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<InputHttpRawAuthTokensExt> | undefined;
  description?: string | undefined;
};

export const InputDatagenType = {
  Datagen: "datagen",
} as const;
export type InputDatagenType = OpenEnum<typeof InputDatagenType>;

export type InputDatagenConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputDatagenMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputDatagenMode = OpenEnum<typeof InputDatagenMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputDatagenCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputDatagenCompression = OpenEnum<typeof InputDatagenCompression>;

export type InputDatagenPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputDatagenMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputDatagenCompression | undefined;
};

export type Sample = {
  sample: string;
  /**
   * Maximum number of events to generate per second per Worker Node. Defaults to 10.
   */
  eventsPerSec?: number | undefined;
};

export type InputDatagenMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputDatagen = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputDatagenType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputDatagenConnection> | undefined;
  pq?: InputDatagenPq | undefined;
  samples: Array<Sample>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputDatagenMetadatum> | undefined;
  description?: string | undefined;
};

export const InputDatadogAgentType = {
  DatadogAgent: "datadog_agent",
} as const;
export type InputDatadogAgentType = OpenEnum<typeof InputDatadogAgentType>;

export type InputDatadogAgentConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputDatadogAgentMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputDatadogAgentMode = OpenEnum<typeof InputDatadogAgentMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputDatadogAgentCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputDatadogAgentCompression = OpenEnum<
  typeof InputDatadogAgentCompression
>;

export type InputDatadogAgentPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputDatadogAgentMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputDatadogAgentCompression | undefined;
};

export const InputDatadogAgentMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputDatadogAgentMinimumTLSVersion = OpenEnum<
  typeof InputDatadogAgentMinimumTLSVersion
>;

export const InputDatadogAgentMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputDatadogAgentMaximumTLSVersion = OpenEnum<
  typeof InputDatadogAgentMaximumTLSVersion
>;

export type InputDatadogAgentTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputDatadogAgentMinimumTLSVersion | undefined;
  maxVersion?: InputDatadogAgentMaximumTLSVersion | undefined;
};

export type InputDatadogAgentMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputDatadogAgentProxyMode = {
  /**
   * Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid.
   */
  enabled?: boolean | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
};

export type InputDatadogAgent = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputDatadogAgentType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputDatadogAgentConnection> | undefined;
  pq?: InputDatadogAgentPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputDatadogAgentTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
   */
  extractMetrics?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputDatadogAgentMetadatum> | undefined;
  proxyMode?: InputDatadogAgentProxyMode | undefined;
  description?: string | undefined;
};

export const InputCrowdstrikeType = {
  Crowdstrike: "crowdstrike",
} as const;
export type InputCrowdstrikeType = OpenEnum<typeof InputCrowdstrikeType>;

export type InputCrowdstrikeConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputCrowdstrikeMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputCrowdstrikeMode = OpenEnum<typeof InputCrowdstrikeMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputCrowdstrikeCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputCrowdstrikeCompression = OpenEnum<
  typeof InputCrowdstrikeCompression
>;

export type InputCrowdstrikePq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputCrowdstrikeMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputCrowdstrikeCompression | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const InputCrowdstrikeAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type InputCrowdstrikeAuthenticationMethod = OpenEnum<
  typeof InputCrowdstrikeAuthenticationMethod
>;

/**
 * Signature version to use for signing S3 requests
 */
export const InputCrowdstrikeSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing S3 requests
 */
export type InputCrowdstrikeSignatureVersion = OpenEnum<
  typeof InputCrowdstrikeSignatureVersion
>;

export type InputCrowdstrikePreprocess = {
  disabled?: boolean | undefined;
  /**
   * Command to feed the data through (via stdin) and process its output (stdout)
   */
  command?: string | undefined;
  /**
   * Arguments to be added to the custom command
   */
  args?: Array<string> | undefined;
};

export type InputCrowdstrikeMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputCrowdstrikeCheckpointing = {
  /**
   * Resume processing files after an interruption
   */
  enabled?: boolean | undefined;
  /**
   * The number of times to retry processing when a processing error occurs. If Skip file on error is enabled, this setting is ignored.
   */
  retries?: number | undefined;
};

export const InputCrowdstrikeTagAfterProcessing = {
  False: "false",
  True: "true",
} as const;
export type InputCrowdstrikeTagAfterProcessing = OpenEnum<
  typeof InputCrowdstrikeTagAfterProcessing
>;

export type InputCrowdstrike = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCrowdstrikeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputCrowdstrikeConnection> | undefined;
  pq?: InputCrowdstrikePq | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: InputCrowdstrikeAuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: InputCrowdstrikeSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: InputCrowdstrikePreprocess | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputCrowdstrikeMetadatum> | undefined;
  checkpointing?: InputCrowdstrikeCheckpointing | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: InputCrowdstrikeTagAfterProcessing | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export const InputTcpjsonType = {
  Tcpjson: "tcpjson",
} as const;
export type InputTcpjsonType = OpenEnum<typeof InputTcpjsonType>;

export type InputTcpjsonConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputTcpjsonMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputTcpjsonMode = OpenEnum<typeof InputTcpjsonMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputTcpjsonCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputTcpjsonCompression = OpenEnum<typeof InputTcpjsonCompression>;

export type InputTcpjsonPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputTcpjsonMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputTcpjsonCompression | undefined;
};

export const InputTcpjsonMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputTcpjsonMinimumTLSVersion = OpenEnum<
  typeof InputTcpjsonMinimumTLSVersion
>;

export const InputTcpjsonMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputTcpjsonMaximumTLSVersion = OpenEnum<
  typeof InputTcpjsonMaximumTLSVersion
>;

export type InputTcpjsonTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputTcpjsonMinimumTLSVersion | undefined;
  maxVersion?: InputTcpjsonMaximumTLSVersion | undefined;
};

export type InputTcpjsonMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const InputTcpjsonAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type InputTcpjsonAuthenticationMethod = OpenEnum<
  typeof InputTcpjsonAuthenticationMethod
>;

export type InputTcpjson = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputTcpjsonType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputTcpjsonConnection> | undefined;
  pq?: InputTcpjsonPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputTcpjsonTLSSettingsServerSide | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputTcpjsonMetadatum> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: InputTcpjsonAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputCriblLakeHttpType = {
  CriblLakeHttp: "cribl_lake_http",
} as const;
export type InputCriblLakeHttpType = OpenEnum<typeof InputCriblLakeHttpType>;

export type InputCriblLakeHttpConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputCriblLakeHttpMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputCriblLakeHttpMode = OpenEnum<typeof InputCriblLakeHttpMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputCriblLakeHttpCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputCriblLakeHttpCompression = OpenEnum<
  typeof InputCriblLakeHttpCompression
>;

export type InputCriblLakeHttpPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputCriblLakeHttpMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputCriblLakeHttpCompression | undefined;
};

export const InputCriblLakeHttpMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputCriblLakeHttpMinimumTLSVersion = OpenEnum<
  typeof InputCriblLakeHttpMinimumTLSVersion
>;

export const InputCriblLakeHttpMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputCriblLakeHttpMaximumTLSVersion = OpenEnum<
  typeof InputCriblLakeHttpMaximumTLSVersion
>;

export type InputCriblLakeHttpTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputCriblLakeHttpMinimumTLSVersion | undefined;
  maxVersion?: InputCriblLakeHttpMaximumTLSVersion | undefined;
};

export type InputCriblLakeHttpMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputCriblLakeHttp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputCriblLakeHttpType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputCriblLakeHttpConnection> | undefined;
  pq?: InputCriblLakeHttpPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: InputCriblLakeHttpTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputCriblLakeHttpMetadatum> | undefined;
  description?: string | undefined;
};

export const InputCriblHttpType = {
  CriblHttp: "cribl_http",
} as const;
export type InputCriblHttpType = OpenEnum<typeof InputCriblHttpType>;

export type InputCriblHttpConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputCriblHttpMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputCriblHttpMode = OpenEnum<typeof InputCriblHttpMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputCriblHttpCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputCriblHttpCompression = OpenEnum<
  typeof InputCriblHttpCompression
>;

export type InputCriblHttpPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputCriblHttpMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputCriblHttpCompression | undefined;
};

export const InputCriblHttpMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputCriblHttpMinimumTLSVersion = OpenEnum<
  typeof InputCriblHttpMinimumTLSVersion
>;

export const InputCriblHttpMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputCriblHttpMaximumTLSVersion = OpenEnum<
  typeof InputCriblHttpMaximumTLSVersion
>;

export type InputCriblHttpTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputCriblHttpMinimumTLSVersion | undefined;
  maxVersion?: InputCriblHttpMaximumTLSVersion | undefined;
};

export type InputCriblHttpMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputCriblHttp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputCriblHttpType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputCriblHttpConnection> | undefined;
  pq?: InputCriblHttpPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: InputCriblHttpTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputCriblHttpMetadatum> | undefined;
  description?: string | undefined;
};

export const InputCriblTcpType = {
  CriblTcp: "cribl_tcp",
} as const;
export type InputCriblTcpType = OpenEnum<typeof InputCriblTcpType>;

export type InputCriblTcpConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputCriblTcpMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputCriblTcpMode = OpenEnum<typeof InputCriblTcpMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputCriblTcpCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputCriblTcpCompression = OpenEnum<
  typeof InputCriblTcpCompression
>;

export type InputCriblTcpPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputCriblTcpMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputCriblTcpCompression | undefined;
};

export const InputCriblTcpMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputCriblTcpMinimumTLSVersion = OpenEnum<
  typeof InputCriblTcpMinimumTLSVersion
>;

export const InputCriblTcpMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputCriblTcpMaximumTLSVersion = OpenEnum<
  typeof InputCriblTcpMaximumTLSVersion
>;

export type InputCriblTcpTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputCriblTcpMinimumTLSVersion | undefined;
  maxVersion?: InputCriblTcpMaximumTLSVersion | undefined;
};

export type InputCriblTcpMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputCriblTcp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputCriblTcpType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputCriblTcpConnection> | undefined;
  pq?: InputCriblTcpPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputCriblTcpTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputCriblTcpMetadatum> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
};

export const InputGooglePubsubType = {
  GooglePubsub: "google_pubsub",
} as const;
export type InputGooglePubsubType = OpenEnum<typeof InputGooglePubsubType>;

export type InputGooglePubsubConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputGooglePubsubMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputGooglePubsubMode = OpenEnum<typeof InputGooglePubsubMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputGooglePubsubCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputGooglePubsubCompression = OpenEnum<
  typeof InputGooglePubsubCompression
>;

export type InputGooglePubsubPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputGooglePubsubMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputGooglePubsubCompression | undefined;
};

/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export const CreateInputGoogleAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
 */
export type CreateInputGoogleAuthenticationMethod = OpenEnum<
  typeof CreateInputGoogleAuthenticationMethod
>;

export type InputGooglePubsubMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputGooglePubsub = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputGooglePubsubType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputGooglePubsubConnection> | undefined;
  pq?: InputGooglePubsubPq | undefined;
  /**
   * ID of the topic to receive events from
   */
  topicName: string;
  /**
   * ID of the subscription to use when receiving events
   */
  subscriptionName: string;
  /**
   * Create topic if it does not exist
   */
  createTopic?: boolean | undefined;
  /**
   * Create subscription if it does not exist
   */
  createSubscription?: boolean | undefined;
  /**
   * Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   */
  region?: string | undefined;
  /**
   * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
   */
  googleAuthMethod?: CreateInputGoogleAuthenticationMethod | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  secret?: string | undefined;
  /**
   * If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
   */
  maxBacklog?: number | undefined;
  /**
   * How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
   */
  concurrency?: number | undefined;
  /**
   * Pull request timeout, in milliseconds
   */
  requestTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputGooglePubsubMetadatum> | undefined;
  description?: string | undefined;
  /**
   * Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
   */
  orderedDelivery?: boolean | undefined;
};

export const InputFirehoseType = {
  Firehose: "firehose",
} as const;
export type InputFirehoseType = OpenEnum<typeof InputFirehoseType>;

export type InputFirehoseConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputFirehoseMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputFirehoseMode = OpenEnum<typeof InputFirehoseMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputFirehoseCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputFirehoseCompression = OpenEnum<
  typeof InputFirehoseCompression
>;

export type InputFirehosePq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputFirehoseMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputFirehoseCompression | undefined;
};

export const InputFirehoseMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputFirehoseMinimumTLSVersion = OpenEnum<
  typeof InputFirehoseMinimumTLSVersion
>;

export const InputFirehoseMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputFirehoseMaximumTLSVersion = OpenEnum<
  typeof InputFirehoseMaximumTLSVersion
>;

export type InputFirehoseTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputFirehoseMinimumTLSVersion | undefined;
  maxVersion?: InputFirehoseMaximumTLSVersion | undefined;
};

export type InputFirehoseMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputFirehose = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputFirehoseType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputFirehoseConnection> | undefined;
  pq?: InputFirehosePq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: InputFirehoseTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputFirehoseMetadatum> | undefined;
  description?: string | undefined;
};

export const InputExecType = {
  Exec: "exec",
} as const;
export type InputExecType = OpenEnum<typeof InputExecType>;

export type InputExecConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputExecMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputExecMode = OpenEnum<typeof InputExecMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputExecCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputExecCompression = OpenEnum<typeof InputExecCompression>;

export type InputExecPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputExecMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputExecCompression | undefined;
};

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const ScheduleType = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type ScheduleType = OpenEnum<typeof ScheduleType>;

export type InputExecMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputExec = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputExecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputExecConnection> | undefined;
  pq?: InputExecPq | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: ScheduleType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputExecMetadatum> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

export const InputEventhubType = {
  Eventhub: "eventhub",
} as const;
export type InputEventhubType = OpenEnum<typeof InputEventhubType>;

export type InputEventhubConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputEventhubMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputEventhubMode = OpenEnum<typeof InputEventhubMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputEventhubCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputEventhubCompression = OpenEnum<
  typeof InputEventhubCompression
>;

export type InputEventhubPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputEventhubMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputEventhubCompression | undefined;
};

export const InputEventhubSASLMechanism = {
  Plain: "plain",
  Oauthbearer: "oauthbearer",
} as const;
export type InputEventhubSASLMechanism = OpenEnum<
  typeof InputEventhubSASLMechanism
>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type InputEventhubAuthentication = {
  disabled?: boolean | undefined;
  mechanism?: InputEventhubSASLMechanism | undefined;
};

export type InputEventhubTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another trusted CA (such as the system's)
   */
  rejectUnauthorized?: boolean | undefined;
};

export type InputEventhubMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputEventhub = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputEventhubType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputEventhubConnection> | undefined;
  pq?: InputEventhubPq | undefined;
  /**
   * List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
   */
  brokers: Array<string>;
  /**
   * The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
   */
  topics: Array<string>;
  /**
   * The consumer group this instance belongs to. Default is 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Start reading from earliest available data; relevant only during initial subscription
   */
  fromBeginning?: boolean | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: InputEventhubAuthentication | undefined;
  tls?: InputEventhubTLSSettingsClientSide | undefined;
  /**
   *       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
   *       Value must be lower than rebalanceTimeout.
   *       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Minimize duplicate events by starting only one consumer for each topic partition
   */
  minimizeDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputEventhubMetadatum> | undefined;
  description?: string | undefined;
};

export const InputOffice365MsgTraceType = {
  Office365MsgTrace: "office365_msg_trace",
} as const;
export type InputOffice365MsgTraceType = OpenEnum<
  typeof InputOffice365MsgTraceType
>;

export type InputOffice365MsgTraceConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputOffice365MsgTraceMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputOffice365MsgTraceMode = OpenEnum<
  typeof InputOffice365MsgTraceMode
>;

/**
 * Codec to use to compress the persisted data
 */
export const InputOffice365MsgTraceCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputOffice365MsgTraceCompression = OpenEnum<
  typeof InputOffice365MsgTraceCompression
>;

export type InputOffice365MsgTracePq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputOffice365MsgTraceMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputOffice365MsgTraceCompression | undefined;
};

/**
 * Select authentication method.
 */
export const InputOffice365MsgTraceAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  OauthCert: "oauthCert",
} as const;
/**
 * Select authentication method.
 */
export type InputOffice365MsgTraceAuthenticationMethod = OpenEnum<
  typeof InputOffice365MsgTraceAuthenticationMethod
>;

/**
 * Log Level (verbosity) for collection runtime behavior.
 */
export const InputOffice365MsgTraceLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
  Silly: "silly",
} as const;
/**
 * Log Level (verbosity) for collection runtime behavior.
 */
export type InputOffice365MsgTraceLogLevel = OpenEnum<
  typeof InputOffice365MsgTraceLogLevel
>;

export type InputOffice365MsgTraceMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const InputOffice365MsgTraceRetryType = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type InputOffice365MsgTraceRetryType = OpenEnum<
  typeof InputOffice365MsgTraceRetryType
>;

export type InputOffice365MsgTraceRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: InputOffice365MsgTraceRetryType | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export const InputOffice365MsgTraceSubscriptionPlan = {
  EnterpriseGcc: "enterprise_gcc",
  Gcc: "gcc",
  GccHigh: "gcc_high",
  Dod: "dod",
} as const;
/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export type InputOffice365MsgTraceSubscriptionPlan = OpenEnum<
  typeof InputOffice365MsgTraceSubscriptionPlan
>;

export type CertOptions = {
  /**
   * The name of the predefined certificate.
   */
  certificateName?: string | undefined;
  /**
   * Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS.
   */
  privKeyPath: string;
  /**
   * Passphrase to use to decrypt the private key.
   */
  passphrase?: string | undefined;
  /**
   * Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS.
   */
  certPath: string;
};

export type InputOffice365MsgTrace = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputOffice365MsgTraceType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputOffice365MsgTraceConnection> | undefined;
  pq?: InputOffice365MsgTracePq | undefined;
  /**
   * URL to use when retrieving report data.
   */
  url?: string | undefined;
  /**
   * How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
   */
  interval?: number | undefined;
  /**
   * Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
   */
  startDate?: string | undefined;
  /**
   * Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
   */
  endDate?: string | undefined;
  /**
   * HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
   */
  timeout?: number | undefined;
  /**
   * Disables time filtering of events when a date range is specified.
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Select authentication method.
   */
  authType?: InputOffice365MsgTraceAuthenticationMethod | undefined;
  /**
   * Reschedule tasks that failed with non-fatal errors
   */
  rescheduleDroppedTasks?: boolean | undefined;
  /**
   * Maximum number of times a task can be rescheduled
   */
  maxTaskReschedule?: number | undefined;
  /**
   * Log Level (verbosity) for collection runtime behavior.
   */
  logLevel?: InputOffice365MsgTraceLogLevel | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputOffice365MsgTraceMetadatum> | undefined;
  retryRules?: InputOffice365MsgTraceRetryRules | undefined;
  description?: string | undefined;
  /**
   * Username to run Message Trace API call.
   */
  username?: string | undefined;
  /**
   * Password to run Message Trace API call.
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials.
   */
  credentialsSecret?: string | undefined;
  /**
   * client_secret to pass in the OAuth request parameter.
   */
  clientSecret?: string | undefined;
  /**
   * Directory ID (tenant identifier) in Azure Active Directory.
   */
  tenantId?: string | undefined;
  /**
   * client_id to pass in the OAuth request parameter.
   */
  clientId?: string | undefined;
  /**
   * Resource to pass in the OAuth request parameter.
   */
  resource?: string | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: InputOffice365MsgTraceSubscriptionPlan | undefined;
  /**
   * Select or create a secret that references your client_secret to pass in the OAuth request parameter.
   */
  textSecret?: string | undefined;
  certOptions?: CertOptions | undefined;
};

export const InputOffice365ServiceType = {
  Office365Service: "office365_service",
} as const;
export type InputOffice365ServiceType = OpenEnum<
  typeof InputOffice365ServiceType
>;

export type InputOffice365ServiceConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputOffice365ServiceMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputOffice365ServiceMode = OpenEnum<
  typeof InputOffice365ServiceMode
>;

/**
 * Codec to use to compress the persisted data
 */
export const InputOffice365ServiceCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputOffice365ServiceCompression = OpenEnum<
  typeof InputOffice365ServiceCompression
>;

export type InputOffice365ServicePq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputOffice365ServiceMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputOffice365ServiceCompression | undefined;
};

/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export const InputOffice365ServiceSubscriptionPlan = {
  EnterpriseGcc: "enterprise_gcc",
  Gcc: "gcc",
  GccHigh: "gcc_high",
  Dod: "dod",
} as const;
/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export type InputOffice365ServiceSubscriptionPlan = OpenEnum<
  typeof InputOffice365ServiceSubscriptionPlan
>;

export type InputOffice365ServiceMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Collector runtime Log Level
 */
export const InputOffice365ServiceLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime Log Level
 */
export type InputOffice365ServiceLogLevel = OpenEnum<
  typeof InputOffice365ServiceLogLevel
>;

export type InputOffice365ServiceContentConfig = {
  /**
   * Office 365 Services API Content Type
   */
  contentType?: string | undefined;
  /**
   * If interval type is minutes the value entered must evenly divisible by 60 or save will fail
   */
  description?: string | undefined;
  interval?: number | undefined;
  /**
   * Collector runtime Log Level
   */
  logLevel?: InputOffice365ServiceLogLevel | undefined;
  enabled?: boolean | undefined;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const InputOffice365ServiceRetryType = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type InputOffice365ServiceRetryType = OpenEnum<
  typeof InputOffice365ServiceRetryType
>;

export type InputOffice365ServiceRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: InputOffice365ServiceRetryType | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Enter client secret directly, or select a stored secret
 */
export const InputOffice365ServiceAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter client secret directly, or select a stored secret
 */
export type InputOffice365ServiceAuthenticationMethod = OpenEnum<
  typeof InputOffice365ServiceAuthenticationMethod
>;

export type InputOffice365Service = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputOffice365ServiceType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputOffice365ServiceConnection> | undefined;
  pq?: InputOffice365ServicePq | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: InputOffice365ServiceSubscriptionPlan | undefined;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputOffice365ServiceMetadatum> | undefined;
  /**
   * Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<InputOffice365ServiceContentConfig> | undefined;
  retryRules?: InputOffice365ServiceRetryRules | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: InputOffice365ServiceAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputOffice365MgmtType = {
  Office365Mgmt: "office365_mgmt",
} as const;
export type InputOffice365MgmtType = OpenEnum<typeof InputOffice365MgmtType>;

export type InputOffice365MgmtConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputOffice365MgmtMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputOffice365MgmtMode = OpenEnum<typeof InputOffice365MgmtMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputOffice365MgmtCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputOffice365MgmtCompression = OpenEnum<
  typeof InputOffice365MgmtCompression
>;

export type InputOffice365MgmtPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputOffice365MgmtMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputOffice365MgmtCompression | undefined;
};

/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export const InputOffice365MgmtSubscriptionPlan = {
  EnterpriseGcc: "enterprise_gcc",
  Gcc: "gcc",
  GccHigh: "gcc_high",
  Dod: "dod",
} as const;
/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export type InputOffice365MgmtSubscriptionPlan = OpenEnum<
  typeof InputOffice365MgmtSubscriptionPlan
>;

export type InputOffice365MgmtMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Collector runtime Log Level
 */
export const InputOffice365MgmtLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime Log Level
 */
export type InputOffice365MgmtLogLevel = OpenEnum<
  typeof InputOffice365MgmtLogLevel
>;

export type InputOffice365MgmtContentConfig = {
  /**
   * Office 365 Management Activity API Content Type
   */
  contentType?: string | undefined;
  /**
   * If interval type is minutes the value entered must evenly divisible by 60 or save will fail
   */
  description?: string | undefined;
  interval?: number | undefined;
  /**
   * Collector runtime Log Level
   */
  logLevel?: InputOffice365MgmtLogLevel | undefined;
  enabled?: boolean | undefined;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const InputOffice365MgmtRetryType = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type InputOffice365MgmtRetryType = OpenEnum<
  typeof InputOffice365MgmtRetryType
>;

export type InputOffice365MgmtRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: InputOffice365MgmtRetryType | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Enter client secret directly, or select a stored secret
 */
export const InputOffice365MgmtAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter client secret directly, or select a stored secret
 */
export type InputOffice365MgmtAuthenticationMethod = OpenEnum<
  typeof InputOffice365MgmtAuthenticationMethod
>;

export type InputOffice365Mgmt = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputOffice365MgmtType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputOffice365MgmtConnection> | undefined;
  pq?: InputOffice365MgmtPq | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: InputOffice365MgmtSubscriptionPlan | undefined;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputOffice365MgmtMetadatum> | undefined;
  /**
   * Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
   */
  publisherIdentifier?: string | undefined;
  /**
   * Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<InputOffice365MgmtContentConfig> | undefined;
  /**
   * Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
   */
  ingestionLag?: number | undefined;
  retryRules?: InputOffice365MgmtRetryRules | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: InputOffice365MgmtAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputEdgePrometheusType = {
  EdgePrometheus: "edge_prometheus",
} as const;
export type InputEdgePrometheusType = OpenEnum<typeof InputEdgePrometheusType>;

export type InputEdgePrometheusConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputEdgePrometheusMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputEdgePrometheusMode = OpenEnum<typeof InputEdgePrometheusMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputEdgePrometheusPqCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputEdgePrometheusPqCompression = OpenEnum<
  typeof InputEdgePrometheusPqCompression
>;

export type InputEdgePrometheusPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputEdgePrometheusMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputEdgePrometheusPqCompression | undefined;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputEdgePrometheusDiscoveryType = {
  Static: "static",
  Dns: "dns",
  Ec2: "ec2",
  K8sNode: "k8s-node",
  K8sPods: "k8s-pods",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputEdgePrometheusDiscoveryType = OpenEnum<
  typeof InputEdgePrometheusDiscoveryType
>;

/**
 * Data compression format. Default is gzip.
 */
export const PersistenceCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Data compression format. Default is gzip.
 */
export type PersistenceCompression = OpenEnum<typeof PersistenceCompression>;

export type DiskSpooling = {
  /**
   * Spool events on disk for Cribl Edge and Search. Default is disabled.
   */
  enable?: boolean | undefined;
  /**
   * Time period for grouping spooled events. Default is 10m.
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h.
   */
  maxDataTime?: string | undefined;
  /**
   * Data compression format. Default is gzip.
   */
  compress?: PersistenceCompression | undefined;
};

export type InputEdgePrometheusMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Enter credentials directly, or select a stored secret
 */
export const InputEdgePrometheusAuthTypeAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  Kubernetes: "kubernetes",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type InputEdgePrometheusAuthTypeAuthenticationMethod = OpenEnum<
  typeof InputEdgePrometheusAuthTypeAuthenticationMethod
>;

/**
 * Protocol to use when collecting metrics
 */
export const TargetProtocol = {
  Http: "http",
  Https: "https",
} as const;
/**
 * Protocol to use when collecting metrics
 */
export type TargetProtocol = OpenEnum<typeof TargetProtocol>;

export type Target = {
  /**
   * Protocol to use when collecting metrics
   */
  protocol?: TargetProtocol | undefined;
  /**
   * Name of host from which to pull metrics.
   */
  host: string;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  port?: number | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  path?: string | undefined;
};

/**
 * DNS Record type to resolve
 */
export const InputEdgePrometheusRecordType = {
  Srv: "SRV",
  A: "A",
  Aaaa: "AAAA",
} as const;
/**
 * DNS Record type to resolve
 */
export type InputEdgePrometheusRecordType = OpenEnum<
  typeof InputEdgePrometheusRecordType
>;

/**
 * Protocol to use when collecting metrics
 */
export const ScrapeProtocolProtocol = {
  Http: "http",
  Https: "https",
} as const;
/**
 * Protocol to use when collecting metrics
 */
export type ScrapeProtocolProtocol = OpenEnum<typeof ScrapeProtocolProtocol>;

export type InputEdgePrometheusSearchFilter = {
  /**
   * Search filter attribute name, see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html for more information. Attributes can be manually entered if not present in the drop down list
   */
  name: string;
  /**
   * Search Filter Values, if empty only "running" EC2 instances will be returned
   */
  values: Array<string>;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod =
  OpenEnum<
    typeof InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod
  >;

/**
 * Signature version to use for signing EC2 requests
 */
export const InputEdgePrometheusSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing EC2 requests
 */
export type InputEdgePrometheusSignatureVersion = OpenEnum<
  typeof InputEdgePrometheusSignatureVersion
>;

export type PodFilter = {
  /**
   * JavaScript expression applied to pods objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputEdgePrometheus = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputEdgePrometheusType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputEdgePrometheusConnection> | undefined;
  pq?: InputEdgePrometheusPq | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputEdgePrometheusDiscoveryType | undefined;
  /**
   * How often in seconds to scrape targets for metrics.
   */
  interval?: number | undefined;
  /**
   * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
   */
  timeout?: number | undefined;
  persistence?: DiskSpooling | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputEdgePrometheusMetadatum> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputEdgePrometheusAuthTypeAuthenticationMethod | undefined;
  description?: string | undefined;
  targets?: Array<Target> | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: InputEdgePrometheusRecordType | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ScrapeProtocolProtocol | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<InputEdgePrometheusSearchFilter> | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?:
    | InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod
    | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: InputEdgePrometheusSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocolExpr?: string | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePortExpr?: string | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePathExpr?: string | undefined;
  /**
   *   Add rules to decide which pods to discover for metrics.
   *
   * @remarks
   *   Pods are searched if no rules are given or of all the rules'
   *   expressions evaluate to true.
   */
  podFilter?: Array<PodFilter> | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const InputPrometheusType = {
  Prometheus: "prometheus",
} as const;
export type InputPrometheusType = OpenEnum<typeof InputPrometheusType>;

export type InputPrometheusConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputPrometheusMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputPrometheusMode = OpenEnum<typeof InputPrometheusMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputPrometheusCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputPrometheusCompression = OpenEnum<
  typeof InputPrometheusCompression
>;

export type InputPrometheusPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputPrometheusMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputPrometheusCompression | undefined;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType = {
  Static: "static",
  Dns: "dns",
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType = OpenEnum<
  typeof InputPrometheusDiscoveryType
>;

/**
 * Collector runtime Log Level
 */
export const InputPrometheusLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime Log Level
 */
export type InputPrometheusLogLevel = OpenEnum<typeof InputPrometheusLogLevel>;

export type InputPrometheusMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Enter credentials directly, or select a stored secret
 */
export const InputPrometheusAuthTypeAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type InputPrometheusAuthTypeAuthenticationMethod = OpenEnum<
  typeof InputPrometheusAuthTypeAuthenticationMethod
>;

/**
 * DNS Record type to resolve
 */
export const InputPrometheusRecordType = {
  Srv: "SRV",
  A: "A",
  Aaaa: "AAAA",
} as const;
/**
 * DNS Record type to resolve
 */
export type InputPrometheusRecordType = OpenEnum<
  typeof InputPrometheusRecordType
>;

/**
 * Protocol to use when collecting metrics
 */
export const MetricsProtocol = {
  Http: "http",
  Https: "https",
} as const;
/**
 * Protocol to use when collecting metrics
 */
export type MetricsProtocol = OpenEnum<typeof MetricsProtocol>;

export type InputPrometheusSearchFilter = {
  /**
   * Search filter attribute name, see: https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeInstances.html for more information. Attributes can be manually entered if not present in the drop down list
   */
  name: string;
  /**
   * Search Filter Values, if empty only "running" EC2 instances will be returned
   */
  values: Array<string>;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const InputPrometheusAwsAuthenticationMethodAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type InputPrometheusAwsAuthenticationMethodAuthenticationMethod =
  OpenEnum<typeof InputPrometheusAwsAuthenticationMethodAuthenticationMethod>;

/**
 * Signature version to use for signing EC2 requests
 */
export const InputPrometheusSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing EC2 requests
 */
export type InputPrometheusSignatureVersion = OpenEnum<
  typeof InputPrometheusSignatureVersion
>;

export type InputPrometheus = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputPrometheusType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputPrometheusConnection> | undefined;
  pq?: InputPrometheusPq | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType | undefined;
  /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   */
  interval?: number | undefined;
  /**
   * Collector runtime Log Level
   */
  logLevel?: InputPrometheusLogLevel | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputPrometheusMetadatum> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputPrometheusAuthTypeAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: InputPrometheusRecordType | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: MetricsProtocol | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<InputPrometheusSearchFilter> | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?:
    | InputPrometheusAwsAuthenticationMethodAuthenticationMethod
    | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: InputPrometheusSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const InputPrometheusRwType = {
  PrometheusRw: "prometheus_rw",
} as const;
export type InputPrometheusRwType = OpenEnum<typeof InputPrometheusRwType>;

export type InputPrometheusRwConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputPrometheusRwMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputPrometheusRwMode = OpenEnum<typeof InputPrometheusRwMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputPrometheusRwCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputPrometheusRwCompression = OpenEnum<
  typeof InputPrometheusRwCompression
>;

export type InputPrometheusRwPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputPrometheusRwMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputPrometheusRwCompression | undefined;
};

export const InputPrometheusRwMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputPrometheusRwMinimumTLSVersion = OpenEnum<
  typeof InputPrometheusRwMinimumTLSVersion
>;

export const InputPrometheusRwMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputPrometheusRwMaximumTLSVersion = OpenEnum<
  typeof InputPrometheusRwMaximumTLSVersion
>;

export type InputPrometheusRwTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputPrometheusRwMinimumTLSVersion | undefined;
  maxVersion?: InputPrometheusRwMaximumTLSVersion | undefined;
};

/**
 * Remote Write authentication type
 */
export const InputPrometheusRwAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Remote Write authentication type
 */
export type InputPrometheusRwAuthenticationType = OpenEnum<
  typeof InputPrometheusRwAuthenticationType
>;

export type InputPrometheusRwMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputPrometheusRwOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type InputPrometheusRwOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputPrometheusRw = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputPrometheusRwType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputPrometheusRwConnection> | undefined;
  pq?: InputPrometheusRwPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputPrometheusRwTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
   */
  prometheusAPI?: string | undefined;
  /**
   * Remote Write authentication type
   */
  authType?: InputPrometheusRwAuthenticationType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputPrometheusRwMetadatum> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<InputPrometheusRwOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<InputPrometheusRwOauthHeader> | undefined;
};

export const InputLokiType = {
  Loki: "loki",
} as const;
export type InputLokiType = OpenEnum<typeof InputLokiType>;

export type InputLokiConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputLokiMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputLokiMode = OpenEnum<typeof InputLokiMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputLokiCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputLokiCompression = OpenEnum<typeof InputLokiCompression>;

export type InputLokiPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputLokiMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputLokiCompression | undefined;
};

export const InputLokiMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputLokiMinimumTLSVersion = OpenEnum<
  typeof InputLokiMinimumTLSVersion
>;

export const InputLokiMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputLokiMaximumTLSVersion = OpenEnum<
  typeof InputLokiMaximumTLSVersion
>;

export type InputLokiTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputLokiMinimumTLSVersion | undefined;
  maxVersion?: InputLokiMaximumTLSVersion | undefined;
};

/**
 * Loki logs authentication type
 */
export const InputLokiAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Loki logs authentication type
 */
export type InputLokiAuthenticationType = OpenEnum<
  typeof InputLokiAuthenticationType
>;

export type InputLokiMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputLokiOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type InputLokiOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputLoki = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputLokiType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputLokiConnection> | undefined;
  pq?: InputLokiPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputLokiTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
   */
  lokiAPI?: string | undefined;
  /**
   * Loki logs authentication type
   */
  authType?: InputLokiAuthenticationType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputLokiMetadatum> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<InputLokiOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<InputLokiOauthHeader> | undefined;
};

export const InputGrafanaType2 = {
  Grafana: "grafana",
} as const;
export type InputGrafanaType2 = OpenEnum<typeof InputGrafanaType2>;

export type InputGrafanaConnection2 = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputGrafanaMode2 = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputGrafanaMode2 = OpenEnum<typeof InputGrafanaMode2>;

/**
 * Codec to use to compress the persisted data
 */
export const InputGrafanaCompression2 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputGrafanaCompression2 = OpenEnum<
  typeof InputGrafanaCompression2
>;

export type InputGrafanaPq2 = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputGrafanaMode2 | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputGrafanaCompression2 | undefined;
};

export const InputGrafanaMinimumTLSVersion2 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputGrafanaMinimumTLSVersion2 = OpenEnum<
  typeof InputGrafanaMinimumTLSVersion2
>;

export const InputGrafanaMaximumTLSVersion2 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputGrafanaMaximumTLSVersion2 = OpenEnum<
  typeof InputGrafanaMaximumTLSVersion2
>;

export type InputGrafanaTLSSettingsServerSide2 = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputGrafanaMinimumTLSVersion2 | undefined;
  maxVersion?: InputGrafanaMaximumTLSVersion2 | undefined;
};

/**
 * Remote Write authentication type
 */
export const PrometheusAuthAuthenticationType2 = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Remote Write authentication type
 */
export type PrometheusAuthAuthenticationType2 = OpenEnum<
  typeof PrometheusAuthAuthenticationType2
>;

export type PrometheusAuthOauthParam2 = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type PrometheusAuthOauthHeader2 = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type PrometheusAuth2 = {
  /**
   * Remote Write authentication type
   */
  authType?: PrometheusAuthAuthenticationType2 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<PrometheusAuthOauthParam2> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<PrometheusAuthOauthHeader2> | undefined;
};

/**
 * Loki logs authentication type
 */
export const LokiAuthAuthenticationType2 = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Loki logs authentication type
 */
export type LokiAuthAuthenticationType2 = OpenEnum<
  typeof LokiAuthAuthenticationType2
>;

export type LokiAuthOauthParam2 = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type LokiAuthOauthHeader2 = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type LokiAuth2 = {
  /**
   * Loki logs authentication type
   */
  authType?: LokiAuthAuthenticationType2 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<LokiAuthOauthParam2> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<LokiAuthOauthHeader2> | undefined;
};

export type InputGrafanaMetadatum2 = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputGrafana2 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputGrafanaType2 | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputGrafanaConnection2> | undefined;
  pq?: InputGrafanaPq2 | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputGrafanaTLSSettingsServerSide2 | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
   */
  prometheusAPI?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
   */
  lokiAPI?: string | undefined;
  prometheusAuth?: PrometheusAuth2 | undefined;
  lokiAuth?: LokiAuth2 | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputGrafanaMetadatum2> | undefined;
  description?: string | undefined;
};

export const InputGrafanaType1 = {
  Grafana: "grafana",
} as const;
export type InputGrafanaType1 = OpenEnum<typeof InputGrafanaType1>;

export type InputGrafanaConnection1 = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputGrafanaMode1 = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputGrafanaMode1 = OpenEnum<typeof InputGrafanaMode1>;

/**
 * Codec to use to compress the persisted data
 */
export const InputGrafanaCompression1 = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputGrafanaCompression1 = OpenEnum<
  typeof InputGrafanaCompression1
>;

export type InputGrafanaPq1 = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputGrafanaMode1 | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputGrafanaCompression1 | undefined;
};

export const InputGrafanaMinimumTLSVersion1 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputGrafanaMinimumTLSVersion1 = OpenEnum<
  typeof InputGrafanaMinimumTLSVersion1
>;

export const InputGrafanaMaximumTLSVersion1 = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputGrafanaMaximumTLSVersion1 = OpenEnum<
  typeof InputGrafanaMaximumTLSVersion1
>;

export type InputGrafanaTLSSettingsServerSide1 = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputGrafanaMinimumTLSVersion1 | undefined;
  maxVersion?: InputGrafanaMaximumTLSVersion1 | undefined;
};

/**
 * Remote Write authentication type
 */
export const PrometheusAuthAuthenticationType1 = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Remote Write authentication type
 */
export type PrometheusAuthAuthenticationType1 = OpenEnum<
  typeof PrometheusAuthAuthenticationType1
>;

export type PrometheusAuthOauthParam1 = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type PrometheusAuthOauthHeader1 = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type PrometheusAuth1 = {
  /**
   * Remote Write authentication type
   */
  authType?: PrometheusAuthAuthenticationType1 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<PrometheusAuthOauthParam1> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<PrometheusAuthOauthHeader1> | undefined;
};

/**
 * Loki logs authentication type
 */
export const LokiAuthAuthenticationType1 = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Loki logs authentication type
 */
export type LokiAuthAuthenticationType1 = OpenEnum<
  typeof LokiAuthAuthenticationType1
>;

export type LokiAuthOauthParam1 = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type LokiAuthOauthHeader1 = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type LokiAuth1 = {
  /**
   * Loki logs authentication type
   */
  authType?: LokiAuthAuthenticationType1 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<LokiAuthOauthParam1> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<LokiAuthOauthHeader1> | undefined;
};

export type InputGrafanaMetadatum1 = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputGrafana1 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputGrafanaType1 | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputGrafanaConnection1> | undefined;
  pq?: InputGrafanaPq1 | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputGrafanaTLSSettingsServerSide1 | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
   */
  prometheusAPI?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
   */
  lokiAPI?: string | undefined;
  prometheusAuth?: PrometheusAuth1 | undefined;
  lokiAuth?: LokiAuth1 | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputGrafanaMetadatum1> | undefined;
  description?: string | undefined;
};

export type InputGrafanaUnion = InputGrafana1 | InputGrafana2;

export const InputConfluentCloudType = {
  ConfluentCloud: "confluent_cloud",
} as const;
export type InputConfluentCloudType = OpenEnum<typeof InputConfluentCloudType>;

export type InputConfluentCloudConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputConfluentCloudMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputConfluentCloudMode = OpenEnum<typeof InputConfluentCloudMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputConfluentCloudCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputConfluentCloudCompression = OpenEnum<
  typeof InputConfluentCloudCompression
>;

export type InputConfluentCloudPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputConfluentCloudMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputConfluentCloudCompression | undefined;
};

export const InputConfluentCloudMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputConfluentCloudMinimumTLSVersion = OpenEnum<
  typeof InputConfluentCloudMinimumTLSVersion
>;

export const InputConfluentCloudMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputConfluentCloudMaximumTLSVersion = OpenEnum<
  typeof InputConfluentCloudMaximumTLSVersion
>;

export type InputConfluentCloudTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: InputConfluentCloudMinimumTLSVersion | undefined;
  maxVersion?: InputConfluentCloudMaximumTLSVersion | undefined;
};

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type InputConfluentCloudAuth = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion = OpenEnum<
  typeof InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion
>;

export const InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion = OpenEnum<
  typeof InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion
>;

export type InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?:
    | InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion
    | undefined;
  maxVersion?:
    | InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion
    | undefined;
};

export type InputConfluentCloudKafkaSchemaRegistryAuthentication = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: InputConfluentCloudAuth | undefined;
  tls?: InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide | undefined;
};

export const InputConfluentCloudSASLMechanism = {
  Plain: "plain",
  ScramSha256: "scram-sha-256",
  ScramSha512: "scram-sha-512",
  Kerberos: "kerberos",
} as const;
export type InputConfluentCloudSASLMechanism = OpenEnum<
  typeof InputConfluentCloudSASLMechanism
>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type InputConfluentCloudAuthentication = {
  disabled?: boolean | undefined;
  mechanism?: InputConfluentCloudSASLMechanism | undefined;
};

export type InputConfluentCloudMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputConfluentCloud = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputConfluentCloudType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputConfluentCloudConnection> | undefined;
  pq?: InputConfluentCloudPq | undefined;
  /**
   * List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
   */
  brokers: Array<string>;
  tls?: InputConfluentCloudTLSSettingsClientSide | undefined;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | InputConfluentCloudKafkaSchemaRegistryAuthentication
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: InputConfluentCloudAuthentication | undefined;
  /**
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputConfluentCloudMetadatum> | undefined;
  description?: string | undefined;
};

export const InputElasticType = {
  Elastic: "elastic",
} as const;
export type InputElasticType = OpenEnum<typeof InputElasticType>;

export type InputElasticConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputElasticMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputElasticMode = OpenEnum<typeof InputElasticMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputElasticCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputElasticCompression = OpenEnum<typeof InputElasticCompression>;

export type InputElasticPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputElasticMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputElasticCompression | undefined;
};

export const InputElasticMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputElasticMinimumTLSVersion = OpenEnum<
  typeof InputElasticMinimumTLSVersion
>;

export const InputElasticMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputElasticMaximumTLSVersion = OpenEnum<
  typeof InputElasticMaximumTLSVersion
>;

export type InputElasticTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputElasticMinimumTLSVersion | undefined;
  maxVersion?: InputElasticMaximumTLSVersion | undefined;
};

export const InputElasticAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  AuthTokens: "authTokens",
} as const;
export type InputElasticAuthenticationType = OpenEnum<
  typeof InputElasticAuthenticationType
>;

/**
 * The API version to use for communicating with the server
 */
export const CreateInputAPIVersion = {
  SixDot8Dot4: "6.8.4",
  EightDot3Dot2: "8.3.2",
  Custom: "custom",
} as const;
/**
 * The API version to use for communicating with the server
 */
export type CreateInputAPIVersion = OpenEnum<typeof CreateInputAPIVersion>;

export type CreateInputExtraHttpHeader = {
  name?: string | undefined;
  value: string;
};

export type InputElasticMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Enter credentials directly, or select a stored secret
 */
export const InputElasticAuthenticationMethod = {
  None: "none",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type InputElasticAuthenticationMethod = OpenEnum<
  typeof InputElasticAuthenticationMethod
>;

export type InputElasticProxyMode = {
  /**
   * Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications. See [Cribl Docs](https://docs.cribl.io/stream/sources-elastic/#proxy-mode) for more details.
   */
  enabled?: boolean | undefined;
  /**
   * URL of the Elastic server to proxy non-bulk requests to, such as http://elastic:9200
   */
  url?: string | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * List of headers to remove from the request to proxy
   */
  removeHeaders?: Array<string> | undefined;
  /**
   * Amount of time, in seconds, to wait for a proxy request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputElasticAuthenticationMethod | undefined;
};

export type InputElastic = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputElasticType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputElasticConnection> | undefined;
  pq?: InputElasticPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputElasticTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
   */
  elasticAPI?: string | undefined;
  authType?: InputElasticAuthenticationType | undefined;
  /**
   * The API version to use for communicating with the server
   */
  apiVersion?: CreateInputAPIVersion | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<CreateInputExtraHttpHeader> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputElasticMetadatum> | undefined;
  proxyMode?: InputElasticProxyMode | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Bearer tokens to include in the authorization header
   */
  authTokens?: Array<string> | undefined;
  /**
   * Custom version information to respond to requests
   */
  customAPIVersion?: string | undefined;
};

export const InputAzureBlobType = {
  AzureBlob: "azure_blob",
} as const;
export type InputAzureBlobType = OpenEnum<typeof InputAzureBlobType>;

export type InputAzureBlobConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputAzureBlobMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputAzureBlobMode = OpenEnum<typeof InputAzureBlobMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputAzureBlobCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputAzureBlobCompression = OpenEnum<
  typeof InputAzureBlobCompression
>;

export type InputAzureBlobPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputAzureBlobMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputAzureBlobCompression | undefined;
};

export type InputAzureBlobMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export const InputAzureBlobAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  ClientSecret: "clientSecret",
  ClientCert: "clientCert",
} as const;
export type InputAzureBlobAuthenticationMethod = OpenEnum<
  typeof InputAzureBlobAuthenticationMethod
>;

export type CreateInputCertificate = {
  /**
   * The certificate you registered as credentials for your app in the Azure portal
   */
  certificateName: string;
};

export type InputAzureBlob = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputAzureBlobType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputAzureBlobConnection> | undefined;
  pq?: InputAzureBlobPq | undefined;
  /**
   * The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
   */
  maxMessages?: number | undefined;
  /**
   * The duration (in seconds) which pollers should be validated and restarted if exited
   */
  servicePeriodSecs?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputAzureBlobMetadatum> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  authType?: InputAzureBlobAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
   */
  connectionString?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The name of your Azure storage account
   */
  storageAccountName?: string | undefined;
  /**
   * The service principal's tenant ID
   */
  tenantId?: string | undefined;
  /**
   * The service principal's client ID
   */
  clientId?: string | undefined;
  /**
   * The Azure cloud to use. Defaults to Azure Public Cloud.
   */
  azureCloud?: string | undefined;
  /**
   * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
   */
  endpointSuffix?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  clientTextSecret?: string | undefined;
  certificate?: CreateInputCertificate | undefined;
};

export const InputSplunkHecType = {
  SplunkHec: "splunk_hec",
} as const;
export type InputSplunkHecType = OpenEnum<typeof InputSplunkHecType>;

export type InputSplunkHecConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSplunkHecMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSplunkHecMode = OpenEnum<typeof InputSplunkHecMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSplunkHecCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSplunkHecCompression = OpenEnum<
  typeof InputSplunkHecCompression
>;

export type InputSplunkHecPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSplunkHecMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSplunkHecCompression | undefined;
};

/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export const InputSplunkHecAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
 */
export type InputSplunkHecAuthenticationMethod = OpenEnum<
  typeof InputSplunkHecAuthenticationMethod
>;

export type InputSplunkHecAuthTokenMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSplunkHecAuthToken = {
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: InputSplunkHecAuthenticationMethod | undefined;
  tokenSecret?: any | undefined;
  token?: any | undefined;
  enabled?: boolean | undefined;
  /**
   * Optional token description
   */
  description?: string | undefined;
  /**
   * Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
   */
  allowedIndexesAtToken?: Array<string> | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<InputSplunkHecAuthTokenMetadatum> | undefined;
};

export const InputSplunkHecMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSplunkHecMinimumTLSVersion = OpenEnum<
  typeof InputSplunkHecMinimumTLSVersion
>;

export const InputSplunkHecMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSplunkHecMaximumTLSVersion = OpenEnum<
  typeof InputSplunkHecMaximumTLSVersion
>;

export type InputSplunkHecTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputSplunkHecMinimumTLSVersion | undefined;
  maxVersion?: InputSplunkHecMaximumTLSVersion | undefined;
};

export type InputSplunkHecMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSplunkHec = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputSplunkHecType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSplunkHecConnection> | undefined;
  pq?: InputSplunkHecPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputSplunkHecAuthToken> | undefined;
  tls?: InputSplunkHecTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
   */
  splunkHecAPI?: string | undefined;
  /**
   * Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
   */
  metadata?: Array<InputSplunkHecMetadatum> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Enable Splunk HEC acknowledgements
   */
  splunkHecAcks?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export const InputSplunkSearchType = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType = OpenEnum<typeof InputSplunkSearchType>;

export type InputSplunkSearchConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSplunkSearchMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSplunkSearchMode = OpenEnum<typeof InputSplunkSearchMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSplunkSearchCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSplunkSearchCompression = OpenEnum<
  typeof InputSplunkSearchCompression
>;

export type InputSplunkSearchPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSplunkSearchMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSplunkSearchCompression | undefined;
};

/**
 * Format of the returned output
 */
export const OutputMode = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type OutputMode = OpenEnum<typeof OutputMode>;

export type EndpointParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
   */
  value: string;
};

export type EndpointHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
   */
  value: string;
};

/**
 * Collector runtime log level (verbosity)
 */
export const InputSplunkSearchLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime log level (verbosity)
 */
export type InputSplunkSearchLogLevel = OpenEnum<
  typeof InputSplunkSearchLogLevel
>;

export type InputSplunkSearchMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const InputSplunkSearchRetryType = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type InputSplunkSearchRetryType = OpenEnum<
  typeof InputSplunkSearchRetryType
>;

export type InputSplunkSearchRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: InputSplunkSearchRetryType | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Splunk Search authentication type
 */
export const InputSplunkSearchAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Splunk Search authentication type
 */
export type InputSplunkSearchAuthenticationType = OpenEnum<
  typeof InputSplunkSearchAuthenticationType
>;

export type InputSplunkSearchOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type InputSplunkSearchOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputSplunkSearch = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputSplunkSearchType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSplunkSearchConnection> | undefined;
  pq?: InputSplunkSearchPq | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputMode | undefined;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<EndpointParam> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<EndpointHeader> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: InputSplunkSearchLogLevel | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputSplunkSearchMetadatum> | undefined;
  retryRules?: InputSplunkSearchRetryRules | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: InputSplunkSearchAuthenticationType | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<InputSplunkSearchOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<InputSplunkSearchOauthHeader> | undefined;
};

export const InputSplunkType = {
  Splunk: "splunk",
} as const;
export type InputSplunkType = OpenEnum<typeof InputSplunkType>;

export type InputSplunkConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputSplunkMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputSplunkMode = OpenEnum<typeof InputSplunkMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputSplunkPqCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputSplunkPqCompression = OpenEnum<
  typeof InputSplunkPqCompression
>;

export type InputSplunkPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputSplunkMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputSplunkPqCompression | undefined;
};

export const InputSplunkMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSplunkMinimumTLSVersion = OpenEnum<
  typeof InputSplunkMinimumTLSVersion
>;

export const InputSplunkMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputSplunkMaximumTLSVersion = OpenEnum<
  typeof InputSplunkMaximumTLSVersion
>;

export type InputSplunkTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputSplunkMinimumTLSVersion | undefined;
  maxVersion?: InputSplunkMaximumTLSVersion | undefined;
};

export type InputSplunkMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputSplunkAuthToken = {
  /**
   * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
   */
  token: string;
  description?: string | undefined;
};

/**
 * The highest S2S protocol version to advertise during handshake
 */
export const CreateInputMaxS2SVersion = {
  V3: "v3",
  V4: "v4",
} as const;
/**
 * The highest S2S protocol version to advertise during handshake
 */
export type CreateInputMaxS2SVersion = OpenEnum<
  typeof CreateInputMaxS2SVersion
>;

/**
 * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
 */
export const InputSplunkCompression = {
  Disabled: "disabled",
  Auto: "auto",
  Always: "always",
} as const;
/**
 * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
 */
export type InputSplunkCompression = OpenEnum<typeof InputSplunkCompression>;

export type InputSplunk = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputSplunkType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputSplunkConnection> | undefined;
  pq?: InputSplunkPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputSplunkTLSSettingsServerSide | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputSplunkMetadatum> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputSplunkAuthToken> | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: CreateInputMaxS2SVersion | undefined;
  description?: string | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
   */
  compress?: InputSplunkCompression | undefined;
};

export const InputHttpType = {
  Http: "http",
} as const;
export type InputHttpType = OpenEnum<typeof InputHttpType>;

export type InputHttpConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputHttpMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputHttpMode = OpenEnum<typeof InputHttpMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputHttpCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputHttpCompression = OpenEnum<typeof InputHttpCompression>;

export type InputHttpPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputHttpMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputHttpCompression | undefined;
};

export const InputHttpMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputHttpMinimumTLSVersion = OpenEnum<
  typeof InputHttpMinimumTLSVersion
>;

export const InputHttpMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputHttpMaximumTLSVersion = OpenEnum<
  typeof InputHttpMaximumTLSVersion
>;

export type InputHttpTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputHttpMinimumTLSVersion | undefined;
  maxVersion?: InputHttpMaximumTLSVersion | undefined;
};

export type InputHttpMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputHttpAuthTokensExtMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputHttpAuthTokensExt = {
  /**
   * Shared secret to be provided by any client (Authorization: <token>)
   */
  token: string;
  description?: string | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<InputHttpAuthTokensExtMetadatum> | undefined;
};

export type InputHttp = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputHttpType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputHttpConnection> | undefined;
  pq?: InputHttpPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: InputHttpTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
   */
  criblAPI?: string | undefined;
  /**
   * Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
   */
  elasticAPI?: string | undefined;
  /**
   * Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
   */
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputHttpMetadatum> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<InputHttpAuthTokensExt> | undefined;
  description?: string | undefined;
};

export const InputMskType = {
  Msk: "msk",
} as const;
export type InputMskType = OpenEnum<typeof InputMskType>;

export type InputMskConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputMskMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputMskMode = OpenEnum<typeof InputMskMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputMskCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputMskCompression = OpenEnum<typeof InputMskCompression>;

export type InputMskPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputMskMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputMskCompression | undefined;
};

export type InputMskMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type InputMskAuth = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const InputMskKafkaSchemaRegistryMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputMskKafkaSchemaRegistryMinimumTLSVersion = OpenEnum<
  typeof InputMskKafkaSchemaRegistryMinimumTLSVersion
>;

export const InputMskKafkaSchemaRegistryMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputMskKafkaSchemaRegistryMaximumTLSVersion = OpenEnum<
  typeof InputMskKafkaSchemaRegistryMaximumTLSVersion
>;

export type InputMskKafkaSchemaRegistryTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: InputMskKafkaSchemaRegistryMinimumTLSVersion | undefined;
  maxVersion?: InputMskKafkaSchemaRegistryMaximumTLSVersion | undefined;
};

export type InputMskKafkaSchemaRegistryAuthentication = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: InputMskAuth | undefined;
  tls?: InputMskKafkaSchemaRegistryTLSSettingsClientSide | undefined;
};

/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export const InputMskAuthenticationMethod = {
  Auto: "auto",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * AWS authentication method. Choose Auto to use IAM roles.
 */
export type InputMskAuthenticationMethod = OpenEnum<
  typeof InputMskAuthenticationMethod
>;

/**
 * Signature version to use for signing MSK cluster requests
 */
export const InputMskSignatureVersion = {
  V2: "v2",
  V4: "v4",
} as const;
/**
 * Signature version to use for signing MSK cluster requests
 */
export type InputMskSignatureVersion = OpenEnum<
  typeof InputMskSignatureVersion
>;

export const InputMskMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputMskMinimumTLSVersion = OpenEnum<
  typeof InputMskMinimumTLSVersion
>;

export const InputMskMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputMskMaximumTLSVersion = OpenEnum<
  typeof InputMskMaximumTLSVersion
>;

export type InputMskTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: InputMskMinimumTLSVersion | undefined;
  maxVersion?: InputMskMaximumTLSVersion | undefined;
};

export type InputMsk = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputMskType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputMskConnection> | undefined;
  pq?: InputMskPq | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  /**
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputMskMetadatum> | undefined;
  kafkaSchemaRegistry?: InputMskKafkaSchemaRegistryAuthentication | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: InputMskAuthenticationMethod | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the MSK cluster is located
   */
  region: string;
  /**
   * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: InputMskSignatureVersion | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access MSK
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  tls?: InputMskTLSSettingsClientSide | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export const InputKafkaType = {
  Kafka: "kafka",
} as const;
export type InputKafkaType = OpenEnum<typeof InputKafkaType>;

export type InputKafkaConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputKafkaMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputKafkaMode = OpenEnum<typeof InputKafkaMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputKafkaCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputKafkaCompression = OpenEnum<typeof InputKafkaCompression>;

export type InputKafkaPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputKafkaMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputKafkaCompression | undefined;
};

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type InputKafkaAuth = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const InputKafkaKafkaSchemaRegistryMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputKafkaKafkaSchemaRegistryMinimumTLSVersion = OpenEnum<
  typeof InputKafkaKafkaSchemaRegistryMinimumTLSVersion
>;

export const InputKafkaKafkaSchemaRegistryMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputKafkaKafkaSchemaRegistryMaximumTLSVersion = OpenEnum<
  typeof InputKafkaKafkaSchemaRegistryMaximumTLSVersion
>;

export type InputKafkaKafkaSchemaRegistryTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: InputKafkaKafkaSchemaRegistryMinimumTLSVersion | undefined;
  maxVersion?: InputKafkaKafkaSchemaRegistryMaximumTLSVersion | undefined;
};

export type InputKafkaKafkaSchemaRegistryAuthentication = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: InputKafkaAuth | undefined;
  tls?: InputKafkaKafkaSchemaRegistryTLSSettingsClientSide | undefined;
};

export const InputKafkaSASLMechanism = {
  Plain: "plain",
  ScramSha256: "scram-sha-256",
  ScramSha512: "scram-sha-512",
  Kerberos: "kerberos",
} as const;
export type InputKafkaSASLMechanism = OpenEnum<typeof InputKafkaSASLMechanism>;

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type InputKafkaAuthentication = {
  disabled?: boolean | undefined;
  mechanism?: InputKafkaSASLMechanism | undefined;
};

export const InputKafkaMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputKafkaMinimumTLSVersion = OpenEnum<
  typeof InputKafkaMinimumTLSVersion
>;

export const InputKafkaMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputKafkaMaximumTLSVersion = OpenEnum<
  typeof InputKafkaMaximumTLSVersion
>;

export type InputKafkaTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: InputKafkaMinimumTLSVersion | undefined;
  maxVersion?: InputKafkaMaximumTLSVersion | undefined;
};

export type InputKafkaMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputKafka = {
  /**
   * Unique ID for this input
   */
  id: string;
  type?: InputKafkaType | undefined;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputKafkaConnection> | undefined;
  pq?: InputKafkaPq | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?: InputKafkaKafkaSchemaRegistryAuthentication | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: InputKafkaAuthentication | undefined;
  tls?: InputKafkaTLSSettingsClientSide | undefined;
  /**
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputKafkaMetadatum> | undefined;
  description?: string | undefined;
};

/**
 * New Source object
 */
export type CreateInputRequest =
  | InputMsk
  | InputWiz
  | InputKafka
  | InputAzureBlob
  | InputConfluentCloud
  | InputOffice365Mgmt
  | InputOffice365Service
  | InputEventhub
  | InputExec
  | InputGooglePubsub
  | InputCrowdstrike
  | InputDatagen
  | InputKinesis
  | InputS3
  | InputS3Inventory
  | InputWinEventLogs
  | InputJournalFiles
  | InputSecurityLake
  | InputHttp
  | InputSplunk
  | InputSplunkSearch
  | InputSplunkHec
  | InputElastic
  | InputLoki
  | InputPrometheusRw
  | InputFirehose
  | models.InputCribl
  | InputCriblTcp
  | InputCriblHttp
  | InputCriblLakeHttp
  | InputTcpjson
  | models.InputSystemMetrics
  | models.InputSystemState
  | models.InputKubeMetrics
  | models.InputKubeLogs
  | models.InputKubeEvents
  | models.InputWindowsMetrics
  | InputDatadogAgent
  | InputHttpRaw
  | models.InputCriblmetrics
  | InputMetrics
  | InputSqs
  | models.InputFile
  | InputTcp
  | models.InputAppscope
  | InputWef
  | InputRawUdp
  | InputZscalerHec
  | models.InputCollection
  | InputPrometheus
  | InputEdgePrometheus
  | InputOffice365MsgTrace
  | InputSnmp
  | InputOpenTelemetry
  | InputModelDrivenTelemetry
  | InputNetflow
  | InputGrafana1
  | InputGrafana2
  | InputSyslog1
  | InputSyslog2;

/**
 * a list of Source objects
 */
export type CreateInputResponse = {
  /**
   * number of items present in the items array
   */
  count?: number | undefined;
  items?: Array<models.Input> | undefined;
};

/** @internal */
export const InputZscalerHecType$inboundSchema: z.ZodType<
  InputZscalerHecType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputZscalerHecType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputZscalerHecType$outboundSchema: z.ZodType<
  InputZscalerHecType,
  z.ZodTypeDef,
  InputZscalerHecType
> = z.union([
  z.nativeEnum(InputZscalerHecType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecType$ {
  /** @deprecated use `InputZscalerHecType$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHecType$inboundSchema;
  /** @deprecated use `InputZscalerHecType$outboundSchema` instead. */
  export const outboundSchema = InputZscalerHecType$outboundSchema;
}

/** @internal */
export const InputZscalerHecConnection$inboundSchema: z.ZodType<
  InputZscalerHecConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputZscalerHecConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputZscalerHecConnection$outboundSchema: z.ZodType<
  InputZscalerHecConnection$Outbound,
  z.ZodTypeDef,
  InputZscalerHecConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecConnection$ {
  /** @deprecated use `InputZscalerHecConnection$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHecConnection$inboundSchema;
  /** @deprecated use `InputZscalerHecConnection$outboundSchema` instead. */
  export const outboundSchema = InputZscalerHecConnection$outboundSchema;
  /** @deprecated use `InputZscalerHecConnection$Outbound` instead. */
  export type Outbound = InputZscalerHecConnection$Outbound;
}

export function inputZscalerHecConnectionToJSON(
  inputZscalerHecConnection: InputZscalerHecConnection,
): string {
  return JSON.stringify(
    InputZscalerHecConnection$outboundSchema.parse(inputZscalerHecConnection),
  );
}

export function inputZscalerHecConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputZscalerHecConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputZscalerHecConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputZscalerHecConnection' from JSON`,
  );
}

/** @internal */
export const InputZscalerHecMode$inboundSchema: z.ZodType<
  InputZscalerHecMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputZscalerHecMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputZscalerHecMode$outboundSchema: z.ZodType<
  InputZscalerHecMode,
  z.ZodTypeDef,
  InputZscalerHecMode
> = z.union([
  z.nativeEnum(InputZscalerHecMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecMode$ {
  /** @deprecated use `InputZscalerHecMode$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHecMode$inboundSchema;
  /** @deprecated use `InputZscalerHecMode$outboundSchema` instead. */
  export const outboundSchema = InputZscalerHecMode$outboundSchema;
}

/** @internal */
export const InputZscalerHecCompression$inboundSchema: z.ZodType<
  InputZscalerHecCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputZscalerHecCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputZscalerHecCompression$outboundSchema: z.ZodType<
  InputZscalerHecCompression,
  z.ZodTypeDef,
  InputZscalerHecCompression
> = z.union([
  z.nativeEnum(InputZscalerHecCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecCompression$ {
  /** @deprecated use `InputZscalerHecCompression$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHecCompression$inboundSchema;
  /** @deprecated use `InputZscalerHecCompression$outboundSchema` instead. */
  export const outboundSchema = InputZscalerHecCompression$outboundSchema;
}

/** @internal */
export const InputZscalerHecPq$inboundSchema: z.ZodType<
  InputZscalerHecPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputZscalerHecMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputZscalerHecCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputZscalerHecPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputZscalerHecPq$outboundSchema: z.ZodType<
  InputZscalerHecPq$Outbound,
  z.ZodTypeDef,
  InputZscalerHecPq
> = z.object({
  mode: InputZscalerHecMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputZscalerHecCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecPq$ {
  /** @deprecated use `InputZscalerHecPq$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHecPq$inboundSchema;
  /** @deprecated use `InputZscalerHecPq$outboundSchema` instead. */
  export const outboundSchema = InputZscalerHecPq$outboundSchema;
  /** @deprecated use `InputZscalerHecPq$Outbound` instead. */
  export type Outbound = InputZscalerHecPq$Outbound;
}

export function inputZscalerHecPqToJSON(
  inputZscalerHecPq: InputZscalerHecPq,
): string {
  return JSON.stringify(
    InputZscalerHecPq$outboundSchema.parse(inputZscalerHecPq),
  );
}

export function inputZscalerHecPqFromJSON(
  jsonString: string,
): SafeParseResult<InputZscalerHecPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputZscalerHecPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputZscalerHecPq' from JSON`,
  );
}

/** @internal */
export const InputZscalerHecAuthenticationMethod$inboundSchema: z.ZodType<
  InputZscalerHecAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputZscalerHecAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputZscalerHecAuthenticationMethod$outboundSchema: z.ZodType<
  InputZscalerHecAuthenticationMethod,
  z.ZodTypeDef,
  InputZscalerHecAuthenticationMethod
> = z.union([
  z.nativeEnum(InputZscalerHecAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecAuthenticationMethod$ {
  /** @deprecated use `InputZscalerHecAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputZscalerHecAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputZscalerHecAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputZscalerHecAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputZscalerHecAuthTokenMetadatum$inboundSchema: z.ZodType<
  InputZscalerHecAuthTokenMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputZscalerHecAuthTokenMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputZscalerHecAuthTokenMetadatum$outboundSchema: z.ZodType<
  InputZscalerHecAuthTokenMetadatum$Outbound,
  z.ZodTypeDef,
  InputZscalerHecAuthTokenMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecAuthTokenMetadatum$ {
  /** @deprecated use `InputZscalerHecAuthTokenMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHecAuthTokenMetadatum$inboundSchema;
  /** @deprecated use `InputZscalerHecAuthTokenMetadatum$outboundSchema` instead. */
  export const outboundSchema =
    InputZscalerHecAuthTokenMetadatum$outboundSchema;
  /** @deprecated use `InputZscalerHecAuthTokenMetadatum$Outbound` instead. */
  export type Outbound = InputZscalerHecAuthTokenMetadatum$Outbound;
}

export function inputZscalerHecAuthTokenMetadatumToJSON(
  inputZscalerHecAuthTokenMetadatum: InputZscalerHecAuthTokenMetadatum,
): string {
  return JSON.stringify(
    InputZscalerHecAuthTokenMetadatum$outboundSchema.parse(
      inputZscalerHecAuthTokenMetadatum,
    ),
  );
}

export function inputZscalerHecAuthTokenMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputZscalerHecAuthTokenMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputZscalerHecAuthTokenMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputZscalerHecAuthTokenMetadatum' from JSON`,
  );
}

/** @internal */
export const InputZscalerHecAuthToken$inboundSchema: z.ZodType<
  InputZscalerHecAuthToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: InputZscalerHecAuthenticationMethod$inboundSchema.default("manual"),
  tokenSecret: z.any().optional(),
  token: z.any().optional(),
  enabled: z.boolean().default(true),
  description: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
  metadata: z.array(
    z.lazy(() => InputZscalerHecAuthTokenMetadatum$inboundSchema),
  ).optional(),
});

/** @internal */
export type InputZscalerHecAuthToken$Outbound = {
  authType: string;
  tokenSecret?: any | undefined;
  token?: any | undefined;
  enabled: boolean;
  description?: string | undefined;
  allowedIndexesAtToken?: Array<string> | undefined;
  metadata?: Array<InputZscalerHecAuthTokenMetadatum$Outbound> | undefined;
};

/** @internal */
export const InputZscalerHecAuthToken$outboundSchema: z.ZodType<
  InputZscalerHecAuthToken$Outbound,
  z.ZodTypeDef,
  InputZscalerHecAuthToken
> = z.object({
  authType: InputZscalerHecAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  tokenSecret: z.any().optional(),
  token: z.any().optional(),
  enabled: z.boolean().default(true),
  description: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
  metadata: z.array(
    z.lazy(() => InputZscalerHecAuthTokenMetadatum$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecAuthToken$ {
  /** @deprecated use `InputZscalerHecAuthToken$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHecAuthToken$inboundSchema;
  /** @deprecated use `InputZscalerHecAuthToken$outboundSchema` instead. */
  export const outboundSchema = InputZscalerHecAuthToken$outboundSchema;
  /** @deprecated use `InputZscalerHecAuthToken$Outbound` instead. */
  export type Outbound = InputZscalerHecAuthToken$Outbound;
}

export function inputZscalerHecAuthTokenToJSON(
  inputZscalerHecAuthToken: InputZscalerHecAuthToken,
): string {
  return JSON.stringify(
    InputZscalerHecAuthToken$outboundSchema.parse(inputZscalerHecAuthToken),
  );
}

export function inputZscalerHecAuthTokenFromJSON(
  jsonString: string,
): SafeParseResult<InputZscalerHecAuthToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputZscalerHecAuthToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputZscalerHecAuthToken' from JSON`,
  );
}

/** @internal */
export const InputZscalerHecMinimumTLSVersion$inboundSchema: z.ZodType<
  InputZscalerHecMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputZscalerHecMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputZscalerHecMinimumTLSVersion$outboundSchema: z.ZodType<
  InputZscalerHecMinimumTLSVersion,
  z.ZodTypeDef,
  InputZscalerHecMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputZscalerHecMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecMinimumTLSVersion$ {
  /** @deprecated use `InputZscalerHecMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHecMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputZscalerHecMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputZscalerHecMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputZscalerHecMaximumTLSVersion$inboundSchema: z.ZodType<
  InputZscalerHecMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputZscalerHecMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputZscalerHecMaximumTLSVersion$outboundSchema: z.ZodType<
  InputZscalerHecMaximumTLSVersion,
  z.ZodTypeDef,
  InputZscalerHecMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputZscalerHecMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecMaximumTLSVersion$ {
  /** @deprecated use `InputZscalerHecMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHecMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputZscalerHecMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputZscalerHecMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputZscalerHecTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputZscalerHecTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputZscalerHecMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputZscalerHecMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputZscalerHecTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputZscalerHecTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputZscalerHecTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputZscalerHecTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputZscalerHecMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputZscalerHecMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecTLSSettingsServerSide$ {
  /** @deprecated use `InputZscalerHecTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema =
    InputZscalerHecTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputZscalerHecTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputZscalerHecTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputZscalerHecTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputZscalerHecTLSSettingsServerSide$Outbound;
}

export function inputZscalerHecTLSSettingsServerSideToJSON(
  inputZscalerHecTLSSettingsServerSide: InputZscalerHecTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputZscalerHecTLSSettingsServerSide$outboundSchema.parse(
      inputZscalerHecTLSSettingsServerSide,
    ),
  );
}

export function inputZscalerHecTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputZscalerHecTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputZscalerHecTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputZscalerHecTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputZscalerHecMetadatum$inboundSchema: z.ZodType<
  InputZscalerHecMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputZscalerHecMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputZscalerHecMetadatum$outboundSchema: z.ZodType<
  InputZscalerHecMetadatum$Outbound,
  z.ZodTypeDef,
  InputZscalerHecMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHecMetadatum$ {
  /** @deprecated use `InputZscalerHecMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHecMetadatum$inboundSchema;
  /** @deprecated use `InputZscalerHecMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputZscalerHecMetadatum$outboundSchema;
  /** @deprecated use `InputZscalerHecMetadatum$Outbound` instead. */
  export type Outbound = InputZscalerHecMetadatum$Outbound;
}

export function inputZscalerHecMetadatumToJSON(
  inputZscalerHecMetadatum: InputZscalerHecMetadatum,
): string {
  return JSON.stringify(
    InputZscalerHecMetadatum$outboundSchema.parse(inputZscalerHecMetadatum),
  );
}

export function inputZscalerHecMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputZscalerHecMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputZscalerHecMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputZscalerHecMetadatum' from JSON`,
  );
}

/** @internal */
export const InputZscalerHec$inboundSchema: z.ZodType<
  InputZscalerHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputZscalerHecType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputZscalerHecConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputZscalerHecPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.lazy(() => InputZscalerHecAuthToken$inboundSchema))
    .optional(),
  tls: z.lazy(() => InputZscalerHecTLSSettingsServerSide$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.any().optional(),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  hecAPI: z.string().default("/services/collector"),
  metadata: z.array(z.lazy(() => InputZscalerHecMetadatum$inboundSchema))
    .optional(),
  allowedIndexes: z.array(z.string()).optional(),
  hecAcks: z.boolean().default(false),
  accessControlAllowOrigin: z.array(z.string()).optional(),
  accessControlAllowHeaders: z.array(z.string()).optional(),
  emitTokenMetrics: z.boolean().default(false),
  description: z.string().optional(),
});

/** @internal */
export type InputZscalerHec$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputZscalerHecConnection$Outbound> | undefined;
  pq?: InputZscalerHecPq$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<InputZscalerHecAuthToken$Outbound> | undefined;
  tls?: InputZscalerHecTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  hecAPI: string;
  metadata?: Array<InputZscalerHecMetadatum$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  hecAcks: boolean;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputZscalerHec$outboundSchema: z.ZodType<
  InputZscalerHec$Outbound,
  z.ZodTypeDef,
  InputZscalerHec
> = z.object({
  id: z.string(),
  type: InputZscalerHecType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputZscalerHecConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputZscalerHecPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.lazy(() => InputZscalerHecAuthToken$outboundSchema))
    .optional(),
  tls: z.lazy(() => InputZscalerHecTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.any().optional(),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  hecAPI: z.string().default("/services/collector"),
  metadata: z.array(z.lazy(() => InputZscalerHecMetadatum$outboundSchema))
    .optional(),
  allowedIndexes: z.array(z.string()).optional(),
  hecAcks: z.boolean().default(false),
  accessControlAllowOrigin: z.array(z.string()).optional(),
  accessControlAllowHeaders: z.array(z.string()).optional(),
  emitTokenMetrics: z.boolean().default(false),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputZscalerHec$ {
  /** @deprecated use `InputZscalerHec$inboundSchema` instead. */
  export const inboundSchema = InputZscalerHec$inboundSchema;
  /** @deprecated use `InputZscalerHec$outboundSchema` instead. */
  export const outboundSchema = InputZscalerHec$outboundSchema;
  /** @deprecated use `InputZscalerHec$Outbound` instead. */
  export type Outbound = InputZscalerHec$Outbound;
}

export function inputZscalerHecToJSON(
  inputZscalerHec: InputZscalerHec,
): string {
  return JSON.stringify(InputZscalerHec$outboundSchema.parse(inputZscalerHec));
}

export function inputZscalerHecFromJSON(
  jsonString: string,
): SafeParseResult<InputZscalerHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputZscalerHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputZscalerHec' from JSON`,
  );
}

/** @internal */
export const InputSecurityLakeType$inboundSchema: z.ZodType<
  InputSecurityLakeType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSecurityLakeType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSecurityLakeType$outboundSchema: z.ZodType<
  InputSecurityLakeType,
  z.ZodTypeDef,
  InputSecurityLakeType
> = z.union([
  z.nativeEnum(InputSecurityLakeType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLakeType$ {
  /** @deprecated use `InputSecurityLakeType$inboundSchema` instead. */
  export const inboundSchema = InputSecurityLakeType$inboundSchema;
  /** @deprecated use `InputSecurityLakeType$outboundSchema` instead. */
  export const outboundSchema = InputSecurityLakeType$outboundSchema;
}

/** @internal */
export const InputSecurityLakeConnection$inboundSchema: z.ZodType<
  InputSecurityLakeConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputSecurityLakeConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSecurityLakeConnection$outboundSchema: z.ZodType<
  InputSecurityLakeConnection$Outbound,
  z.ZodTypeDef,
  InputSecurityLakeConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLakeConnection$ {
  /** @deprecated use `InputSecurityLakeConnection$inboundSchema` instead. */
  export const inboundSchema = InputSecurityLakeConnection$inboundSchema;
  /** @deprecated use `InputSecurityLakeConnection$outboundSchema` instead. */
  export const outboundSchema = InputSecurityLakeConnection$outboundSchema;
  /** @deprecated use `InputSecurityLakeConnection$Outbound` instead. */
  export type Outbound = InputSecurityLakeConnection$Outbound;
}

export function inputSecurityLakeConnectionToJSON(
  inputSecurityLakeConnection: InputSecurityLakeConnection,
): string {
  return JSON.stringify(
    InputSecurityLakeConnection$outboundSchema.parse(
      inputSecurityLakeConnection,
    ),
  );
}

export function inputSecurityLakeConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputSecurityLakeConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSecurityLakeConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSecurityLakeConnection' from JSON`,
  );
}

/** @internal */
export const InputSecurityLakeMode$inboundSchema: z.ZodType<
  InputSecurityLakeMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSecurityLakeMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSecurityLakeMode$outboundSchema: z.ZodType<
  InputSecurityLakeMode,
  z.ZodTypeDef,
  InputSecurityLakeMode
> = z.union([
  z.nativeEnum(InputSecurityLakeMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLakeMode$ {
  /** @deprecated use `InputSecurityLakeMode$inboundSchema` instead. */
  export const inboundSchema = InputSecurityLakeMode$inboundSchema;
  /** @deprecated use `InputSecurityLakeMode$outboundSchema` instead. */
  export const outboundSchema = InputSecurityLakeMode$outboundSchema;
}

/** @internal */
export const InputSecurityLakeCompression$inboundSchema: z.ZodType<
  InputSecurityLakeCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSecurityLakeCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSecurityLakeCompression$outboundSchema: z.ZodType<
  InputSecurityLakeCompression,
  z.ZodTypeDef,
  InputSecurityLakeCompression
> = z.union([
  z.nativeEnum(InputSecurityLakeCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLakeCompression$ {
  /** @deprecated use `InputSecurityLakeCompression$inboundSchema` instead. */
  export const inboundSchema = InputSecurityLakeCompression$inboundSchema;
  /** @deprecated use `InputSecurityLakeCompression$outboundSchema` instead. */
  export const outboundSchema = InputSecurityLakeCompression$outboundSchema;
}

/** @internal */
export const InputSecurityLakePq$inboundSchema: z.ZodType<
  InputSecurityLakePq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSecurityLakeMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSecurityLakeCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputSecurityLakePq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputSecurityLakePq$outboundSchema: z.ZodType<
  InputSecurityLakePq$Outbound,
  z.ZodTypeDef,
  InputSecurityLakePq
> = z.object({
  mode: InputSecurityLakeMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSecurityLakeCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLakePq$ {
  /** @deprecated use `InputSecurityLakePq$inboundSchema` instead. */
  export const inboundSchema = InputSecurityLakePq$inboundSchema;
  /** @deprecated use `InputSecurityLakePq$outboundSchema` instead. */
  export const outboundSchema = InputSecurityLakePq$outboundSchema;
  /** @deprecated use `InputSecurityLakePq$Outbound` instead. */
  export type Outbound = InputSecurityLakePq$Outbound;
}

export function inputSecurityLakePqToJSON(
  inputSecurityLakePq: InputSecurityLakePq,
): string {
  return JSON.stringify(
    InputSecurityLakePq$outboundSchema.parse(inputSecurityLakePq),
  );
}

export function inputSecurityLakePqFromJSON(
  jsonString: string,
): SafeParseResult<InputSecurityLakePq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSecurityLakePq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSecurityLakePq' from JSON`,
  );
}

/** @internal */
export const InputSecurityLakeAuthenticationMethod$inboundSchema: z.ZodType<
  InputSecurityLakeAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSecurityLakeAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSecurityLakeAuthenticationMethod$outboundSchema: z.ZodType<
  InputSecurityLakeAuthenticationMethod,
  z.ZodTypeDef,
  InputSecurityLakeAuthenticationMethod
> = z.union([
  z.nativeEnum(InputSecurityLakeAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLakeAuthenticationMethod$ {
  /** @deprecated use `InputSecurityLakeAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputSecurityLakeAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputSecurityLakeAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputSecurityLakeAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputSecurityLakeSignatureVersion$inboundSchema: z.ZodType<
  InputSecurityLakeSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSecurityLakeSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSecurityLakeSignatureVersion$outboundSchema: z.ZodType<
  InputSecurityLakeSignatureVersion,
  z.ZodTypeDef,
  InputSecurityLakeSignatureVersion
> = z.union([
  z.nativeEnum(InputSecurityLakeSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLakeSignatureVersion$ {
  /** @deprecated use `InputSecurityLakeSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = InputSecurityLakeSignatureVersion$inboundSchema;
  /** @deprecated use `InputSecurityLakeSignatureVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputSecurityLakeSignatureVersion$outboundSchema;
}

/** @internal */
export const InputSecurityLakePreprocess$inboundSchema: z.ZodType<
  InputSecurityLakePreprocess,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/** @internal */
export type InputSecurityLakePreprocess$Outbound = {
  disabled: boolean;
  command?: string | undefined;
  args?: Array<string> | undefined;
};

/** @internal */
export const InputSecurityLakePreprocess$outboundSchema: z.ZodType<
  InputSecurityLakePreprocess$Outbound,
  z.ZodTypeDef,
  InputSecurityLakePreprocess
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLakePreprocess$ {
  /** @deprecated use `InputSecurityLakePreprocess$inboundSchema` instead. */
  export const inboundSchema = InputSecurityLakePreprocess$inboundSchema;
  /** @deprecated use `InputSecurityLakePreprocess$outboundSchema` instead. */
  export const outboundSchema = InputSecurityLakePreprocess$outboundSchema;
  /** @deprecated use `InputSecurityLakePreprocess$Outbound` instead. */
  export type Outbound = InputSecurityLakePreprocess$Outbound;
}

export function inputSecurityLakePreprocessToJSON(
  inputSecurityLakePreprocess: InputSecurityLakePreprocess,
): string {
  return JSON.stringify(
    InputSecurityLakePreprocess$outboundSchema.parse(
      inputSecurityLakePreprocess,
    ),
  );
}

export function inputSecurityLakePreprocessFromJSON(
  jsonString: string,
): SafeParseResult<InputSecurityLakePreprocess, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSecurityLakePreprocess$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSecurityLakePreprocess' from JSON`,
  );
}

/** @internal */
export const InputSecurityLakeMetadatum$inboundSchema: z.ZodType<
  InputSecurityLakeMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSecurityLakeMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSecurityLakeMetadatum$outboundSchema: z.ZodType<
  InputSecurityLakeMetadatum$Outbound,
  z.ZodTypeDef,
  InputSecurityLakeMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLakeMetadatum$ {
  /** @deprecated use `InputSecurityLakeMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputSecurityLakeMetadatum$inboundSchema;
  /** @deprecated use `InputSecurityLakeMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputSecurityLakeMetadatum$outboundSchema;
  /** @deprecated use `InputSecurityLakeMetadatum$Outbound` instead. */
  export type Outbound = InputSecurityLakeMetadatum$Outbound;
}

export function inputSecurityLakeMetadatumToJSON(
  inputSecurityLakeMetadatum: InputSecurityLakeMetadatum,
): string {
  return JSON.stringify(
    InputSecurityLakeMetadatum$outboundSchema.parse(inputSecurityLakeMetadatum),
  );
}

export function inputSecurityLakeMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputSecurityLakeMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSecurityLakeMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSecurityLakeMetadatum' from JSON`,
  );
}

/** @internal */
export const InputSecurityLakeCheckpointing$inboundSchema: z.ZodType<
  InputSecurityLakeCheckpointing,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/** @internal */
export type InputSecurityLakeCheckpointing$Outbound = {
  enabled: boolean;
  retries: number;
};

/** @internal */
export const InputSecurityLakeCheckpointing$outboundSchema: z.ZodType<
  InputSecurityLakeCheckpointing$Outbound,
  z.ZodTypeDef,
  InputSecurityLakeCheckpointing
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLakeCheckpointing$ {
  /** @deprecated use `InputSecurityLakeCheckpointing$inboundSchema` instead. */
  export const inboundSchema = InputSecurityLakeCheckpointing$inboundSchema;
  /** @deprecated use `InputSecurityLakeCheckpointing$outboundSchema` instead. */
  export const outboundSchema = InputSecurityLakeCheckpointing$outboundSchema;
  /** @deprecated use `InputSecurityLakeCheckpointing$Outbound` instead. */
  export type Outbound = InputSecurityLakeCheckpointing$Outbound;
}

export function inputSecurityLakeCheckpointingToJSON(
  inputSecurityLakeCheckpointing: InputSecurityLakeCheckpointing,
): string {
  return JSON.stringify(
    InputSecurityLakeCheckpointing$outboundSchema.parse(
      inputSecurityLakeCheckpointing,
    ),
  );
}

export function inputSecurityLakeCheckpointingFromJSON(
  jsonString: string,
): SafeParseResult<InputSecurityLakeCheckpointing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSecurityLakeCheckpointing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSecurityLakeCheckpointing' from JSON`,
  );
}

/** @internal */
export const InputSecurityLakeTagAfterProcessing$inboundSchema: z.ZodType<
  InputSecurityLakeTagAfterProcessing,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSecurityLakeTagAfterProcessing),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSecurityLakeTagAfterProcessing$outboundSchema: z.ZodType<
  InputSecurityLakeTagAfterProcessing,
  z.ZodTypeDef,
  InputSecurityLakeTagAfterProcessing
> = z.union([
  z.nativeEnum(InputSecurityLakeTagAfterProcessing),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLakeTagAfterProcessing$ {
  /** @deprecated use `InputSecurityLakeTagAfterProcessing$inboundSchema` instead. */
  export const inboundSchema =
    InputSecurityLakeTagAfterProcessing$inboundSchema;
  /** @deprecated use `InputSecurityLakeTagAfterProcessing$outboundSchema` instead. */
  export const outboundSchema =
    InputSecurityLakeTagAfterProcessing$outboundSchema;
}

/** @internal */
export const InputSecurityLake$inboundSchema: z.ZodType<
  InputSecurityLake,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputSecurityLakeType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSecurityLakeConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSecurityLakePq$inboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: InputSecurityLakeAuthenticationMethod$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputSecurityLakeSignatureVersion$inboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => InputSecurityLakePreprocess$inboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => InputSecurityLakeMetadatum$inboundSchema))
    .optional(),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  checkpointing: z.lazy(() => InputSecurityLakeCheckpointing$inboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  encoding: z.string().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: InputSecurityLakeTagAfterProcessing$inboundSchema
    .optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/** @internal */
export type InputSecurityLake$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSecurityLakeConnection$Outbound> | undefined;
  pq?: InputSecurityLakePq$Outbound | undefined;
  queueName: string;
  fileFilter: string;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  maxMessages: number;
  visibilityTimeout: number;
  numReceivers: number;
  socketTimeout: number;
  skipOnError: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  enableSQSAssumeRole: boolean;
  preprocess?: InputSecurityLakePreprocess$Outbound | undefined;
  metadata?: Array<InputSecurityLakeMetadatum$Outbound> | undefined;
  parquetChunkSizeMB: number;
  parquetChunkDownloadTimeout: number;
  checkpointing?: InputSecurityLakeCheckpointing$Outbound | undefined;
  pollTimeout: number;
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputSecurityLake$outboundSchema: z.ZodType<
  InputSecurityLake$Outbound,
  z.ZodTypeDef,
  InputSecurityLake
> = z.object({
  id: z.string(),
  type: InputSecurityLakeType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSecurityLakeConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSecurityLakePq$outboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: InputSecurityLakeAuthenticationMethod$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputSecurityLakeSignatureVersion$outboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => InputSecurityLakePreprocess$outboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => InputSecurityLakeMetadatum$outboundSchema))
    .optional(),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  checkpointing: z.lazy(() => InputSecurityLakeCheckpointing$outboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  encoding: z.string().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: InputSecurityLakeTagAfterProcessing$outboundSchema
    .optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSecurityLake$ {
  /** @deprecated use `InputSecurityLake$inboundSchema` instead. */
  export const inboundSchema = InputSecurityLake$inboundSchema;
  /** @deprecated use `InputSecurityLake$outboundSchema` instead. */
  export const outboundSchema = InputSecurityLake$outboundSchema;
  /** @deprecated use `InputSecurityLake$Outbound` instead. */
  export type Outbound = InputSecurityLake$Outbound;
}

export function inputSecurityLakeToJSON(
  inputSecurityLake: InputSecurityLake,
): string {
  return JSON.stringify(
    InputSecurityLake$outboundSchema.parse(inputSecurityLake),
  );
}

export function inputSecurityLakeFromJSON(
  jsonString: string,
): SafeParseResult<InputSecurityLake, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSecurityLake$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSecurityLake' from JSON`,
  );
}

/** @internal */
export const InputNetflowType$inboundSchema: z.ZodType<
  InputNetflowType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputNetflowType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputNetflowType$outboundSchema: z.ZodType<
  InputNetflowType,
  z.ZodTypeDef,
  InputNetflowType
> = z.union([
  z.nativeEnum(InputNetflowType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputNetflowType$ {
  /** @deprecated use `InputNetflowType$inboundSchema` instead. */
  export const inboundSchema = InputNetflowType$inboundSchema;
  /** @deprecated use `InputNetflowType$outboundSchema` instead. */
  export const outboundSchema = InputNetflowType$outboundSchema;
}

/** @internal */
export const InputNetflowConnection$inboundSchema: z.ZodType<
  InputNetflowConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputNetflowConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputNetflowConnection$outboundSchema: z.ZodType<
  InputNetflowConnection$Outbound,
  z.ZodTypeDef,
  InputNetflowConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputNetflowConnection$ {
  /** @deprecated use `InputNetflowConnection$inboundSchema` instead. */
  export const inboundSchema = InputNetflowConnection$inboundSchema;
  /** @deprecated use `InputNetflowConnection$outboundSchema` instead. */
  export const outboundSchema = InputNetflowConnection$outboundSchema;
  /** @deprecated use `InputNetflowConnection$Outbound` instead. */
  export type Outbound = InputNetflowConnection$Outbound;
}

export function inputNetflowConnectionToJSON(
  inputNetflowConnection: InputNetflowConnection,
): string {
  return JSON.stringify(
    InputNetflowConnection$outboundSchema.parse(inputNetflowConnection),
  );
}

export function inputNetflowConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputNetflowConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputNetflowConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputNetflowConnection' from JSON`,
  );
}

/** @internal */
export const InputNetflowMode$inboundSchema: z.ZodType<
  InputNetflowMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputNetflowMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputNetflowMode$outboundSchema: z.ZodType<
  InputNetflowMode,
  z.ZodTypeDef,
  InputNetflowMode
> = z.union([
  z.nativeEnum(InputNetflowMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputNetflowMode$ {
  /** @deprecated use `InputNetflowMode$inboundSchema` instead. */
  export const inboundSchema = InputNetflowMode$inboundSchema;
  /** @deprecated use `InputNetflowMode$outboundSchema` instead. */
  export const outboundSchema = InputNetflowMode$outboundSchema;
}

/** @internal */
export const InputNetflowCompression$inboundSchema: z.ZodType<
  InputNetflowCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputNetflowCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputNetflowCompression$outboundSchema: z.ZodType<
  InputNetflowCompression,
  z.ZodTypeDef,
  InputNetflowCompression
> = z.union([
  z.nativeEnum(InputNetflowCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputNetflowCompression$ {
  /** @deprecated use `InputNetflowCompression$inboundSchema` instead. */
  export const inboundSchema = InputNetflowCompression$inboundSchema;
  /** @deprecated use `InputNetflowCompression$outboundSchema` instead. */
  export const outboundSchema = InputNetflowCompression$outboundSchema;
}

/** @internal */
export const InputNetflowPq$inboundSchema: z.ZodType<
  InputNetflowPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputNetflowMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputNetflowCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputNetflowPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputNetflowPq$outboundSchema: z.ZodType<
  InputNetflowPq$Outbound,
  z.ZodTypeDef,
  InputNetflowPq
> = z.object({
  mode: InputNetflowMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputNetflowCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputNetflowPq$ {
  /** @deprecated use `InputNetflowPq$inboundSchema` instead. */
  export const inboundSchema = InputNetflowPq$inboundSchema;
  /** @deprecated use `InputNetflowPq$outboundSchema` instead. */
  export const outboundSchema = InputNetflowPq$outboundSchema;
  /** @deprecated use `InputNetflowPq$Outbound` instead. */
  export type Outbound = InputNetflowPq$Outbound;
}

export function inputNetflowPqToJSON(inputNetflowPq: InputNetflowPq): string {
  return JSON.stringify(InputNetflowPq$outboundSchema.parse(inputNetflowPq));
}

export function inputNetflowPqFromJSON(
  jsonString: string,
): SafeParseResult<InputNetflowPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputNetflowPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputNetflowPq' from JSON`,
  );
}

/** @internal */
export const InputNetflowMetadatum$inboundSchema: z.ZodType<
  InputNetflowMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputNetflowMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputNetflowMetadatum$outboundSchema: z.ZodType<
  InputNetflowMetadatum$Outbound,
  z.ZodTypeDef,
  InputNetflowMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputNetflowMetadatum$ {
  /** @deprecated use `InputNetflowMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputNetflowMetadatum$inboundSchema;
  /** @deprecated use `InputNetflowMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputNetflowMetadatum$outboundSchema;
  /** @deprecated use `InputNetflowMetadatum$Outbound` instead. */
  export type Outbound = InputNetflowMetadatum$Outbound;
}

export function inputNetflowMetadatumToJSON(
  inputNetflowMetadatum: InputNetflowMetadatum,
): string {
  return JSON.stringify(
    InputNetflowMetadatum$outboundSchema.parse(inputNetflowMetadatum),
  );
}

export function inputNetflowMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputNetflowMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputNetflowMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputNetflowMetadatum' from JSON`,
  );
}

/** @internal */
export const InputNetflow$inboundSchema: z.ZodType<
  InputNetflow,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputNetflowType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputNetflowConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputNetflowPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(2055),
  enablePassThrough: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  udpSocketRxBufSize: z.number().optional(),
  templateCacheMinutes: z.number().default(30),
  v5Enabled: z.boolean().default(true),
  v9Enabled: z.boolean().default(true),
  ipfixEnabled: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputNetflowMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputNetflow$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputNetflowConnection$Outbound> | undefined;
  pq?: InputNetflowPq$Outbound | undefined;
  host: string;
  port: number;
  enablePassThrough: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  udpSocketRxBufSize?: number | undefined;
  templateCacheMinutes: number;
  v5Enabled: boolean;
  v9Enabled: boolean;
  ipfixEnabled: boolean;
  metadata?: Array<InputNetflowMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputNetflow$outboundSchema: z.ZodType<
  InputNetflow$Outbound,
  z.ZodTypeDef,
  InputNetflow
> = z.object({
  id: z.string(),
  type: InputNetflowType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputNetflowConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputNetflowPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(2055),
  enablePassThrough: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  udpSocketRxBufSize: z.number().optional(),
  templateCacheMinutes: z.number().default(30),
  v5Enabled: z.boolean().default(true),
  v9Enabled: z.boolean().default(true),
  ipfixEnabled: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputNetflowMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputNetflow$ {
  /** @deprecated use `InputNetflow$inboundSchema` instead. */
  export const inboundSchema = InputNetflow$inboundSchema;
  /** @deprecated use `InputNetflow$outboundSchema` instead. */
  export const outboundSchema = InputNetflow$outboundSchema;
  /** @deprecated use `InputNetflow$Outbound` instead. */
  export type Outbound = InputNetflow$Outbound;
}

export function inputNetflowToJSON(inputNetflow: InputNetflow): string {
  return JSON.stringify(InputNetflow$outboundSchema.parse(inputNetflow));
}

export function inputNetflowFromJSON(
  jsonString: string,
): SafeParseResult<InputNetflow, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputNetflow$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputNetflow' from JSON`,
  );
}

/** @internal */
export const InputWizType$inboundSchema: z.ZodType<
  InputWizType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWizType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWizType$outboundSchema: z.ZodType<
  InputWizType,
  z.ZodTypeDef,
  InputWizType
> = z.union([
  z.nativeEnum(InputWizType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizType$ {
  /** @deprecated use `InputWizType$inboundSchema` instead. */
  export const inboundSchema = InputWizType$inboundSchema;
  /** @deprecated use `InputWizType$outboundSchema` instead. */
  export const outboundSchema = InputWizType$outboundSchema;
}

/** @internal */
export const InputWizConnection$inboundSchema: z.ZodType<
  InputWizConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputWizConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputWizConnection$outboundSchema: z.ZodType<
  InputWizConnection$Outbound,
  z.ZodTypeDef,
  InputWizConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizConnection$ {
  /** @deprecated use `InputWizConnection$inboundSchema` instead. */
  export const inboundSchema = InputWizConnection$inboundSchema;
  /** @deprecated use `InputWizConnection$outboundSchema` instead. */
  export const outboundSchema = InputWizConnection$outboundSchema;
  /** @deprecated use `InputWizConnection$Outbound` instead. */
  export type Outbound = InputWizConnection$Outbound;
}

export function inputWizConnectionToJSON(
  inputWizConnection: InputWizConnection,
): string {
  return JSON.stringify(
    InputWizConnection$outboundSchema.parse(inputWizConnection),
  );
}

export function inputWizConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputWizConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizConnection' from JSON`,
  );
}

/** @internal */
export const InputWizMode$inboundSchema: z.ZodType<
  InputWizMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWizMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWizMode$outboundSchema: z.ZodType<
  InputWizMode,
  z.ZodTypeDef,
  InputWizMode
> = z.union([
  z.nativeEnum(InputWizMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizMode$ {
  /** @deprecated use `InputWizMode$inboundSchema` instead. */
  export const inboundSchema = InputWizMode$inboundSchema;
  /** @deprecated use `InputWizMode$outboundSchema` instead. */
  export const outboundSchema = InputWizMode$outboundSchema;
}

/** @internal */
export const InputWizCompression$inboundSchema: z.ZodType<
  InputWizCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWizCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWizCompression$outboundSchema: z.ZodType<
  InputWizCompression,
  z.ZodTypeDef,
  InputWizCompression
> = z.union([
  z.nativeEnum(InputWizCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizCompression$ {
  /** @deprecated use `InputWizCompression$inboundSchema` instead. */
  export const inboundSchema = InputWizCompression$inboundSchema;
  /** @deprecated use `InputWizCompression$outboundSchema` instead. */
  export const outboundSchema = InputWizCompression$outboundSchema;
}

/** @internal */
export const InputWizPq$inboundSchema: z.ZodType<
  InputWizPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWizMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWizCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputWizPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputWizPq$outboundSchema: z.ZodType<
  InputWizPq$Outbound,
  z.ZodTypeDef,
  InputWizPq
> = z.object({
  mode: InputWizMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWizCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizPq$ {
  /** @deprecated use `InputWizPq$inboundSchema` instead. */
  export const inboundSchema = InputWizPq$inboundSchema;
  /** @deprecated use `InputWizPq$outboundSchema` instead. */
  export const outboundSchema = InputWizPq$outboundSchema;
  /** @deprecated use `InputWizPq$Outbound` instead. */
  export type Outbound = InputWizPq$Outbound;
}

export function inputWizPqToJSON(inputWizPq: InputWizPq): string {
  return JSON.stringify(InputWizPq$outboundSchema.parse(inputWizPq));
}

export function inputWizPqFromJSON(
  jsonString: string,
): SafeParseResult<InputWizPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizPq' from JSON`,
  );
}

/** @internal */
export const InputWizContentConfig$inboundSchema: z.ZodType<
  InputWizContentConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  contentType: z.string(),
  contentDescription: z.string().optional(),
  enabled: z.boolean().default(false),
});

/** @internal */
export type InputWizContentConfig$Outbound = {
  contentType: string;
  contentDescription?: string | undefined;
  enabled: boolean;
};

/** @internal */
export const InputWizContentConfig$outboundSchema: z.ZodType<
  InputWizContentConfig$Outbound,
  z.ZodTypeDef,
  InputWizContentConfig
> = z.object({
  contentType: z.string(),
  contentDescription: z.string().optional(),
  enabled: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizContentConfig$ {
  /** @deprecated use `InputWizContentConfig$inboundSchema` instead. */
  export const inboundSchema = InputWizContentConfig$inboundSchema;
  /** @deprecated use `InputWizContentConfig$outboundSchema` instead. */
  export const outboundSchema = InputWizContentConfig$outboundSchema;
  /** @deprecated use `InputWizContentConfig$Outbound` instead. */
  export type Outbound = InputWizContentConfig$Outbound;
}

export function inputWizContentConfigToJSON(
  inputWizContentConfig: InputWizContentConfig,
): string {
  return JSON.stringify(
    InputWizContentConfig$outboundSchema.parse(inputWizContentConfig),
  );
}

export function inputWizContentConfigFromJSON(
  jsonString: string,
): SafeParseResult<InputWizContentConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizContentConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizContentConfig' from JSON`,
  );
}

/** @internal */
export const InputWizMetadatum$inboundSchema: z.ZodType<
  InputWizMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputWizMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputWizMetadatum$outboundSchema: z.ZodType<
  InputWizMetadatum$Outbound,
  z.ZodTypeDef,
  InputWizMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizMetadatum$ {
  /** @deprecated use `InputWizMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputWizMetadatum$inboundSchema;
  /** @deprecated use `InputWizMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputWizMetadatum$outboundSchema;
  /** @deprecated use `InputWizMetadatum$Outbound` instead. */
  export type Outbound = InputWizMetadatum$Outbound;
}

export function inputWizMetadatumToJSON(
  inputWizMetadatum: InputWizMetadatum,
): string {
  return JSON.stringify(
    InputWizMetadatum$outboundSchema.parse(inputWizMetadatum),
  );
}

export function inputWizMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputWizMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizMetadatum' from JSON`,
  );
}

/** @internal */
export const InputWizRetryType$inboundSchema: z.ZodType<
  InputWizRetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWizRetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWizRetryType$outboundSchema: z.ZodType<
  InputWizRetryType,
  z.ZodTypeDef,
  InputWizRetryType
> = z.union([
  z.nativeEnum(InputWizRetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizRetryType$ {
  /** @deprecated use `InputWizRetryType$inboundSchema` instead. */
  export const inboundSchema = InputWizRetryType$inboundSchema;
  /** @deprecated use `InputWizRetryType$outboundSchema` instead. */
  export const outboundSchema = InputWizRetryType$outboundSchema;
}

/** @internal */
export const InputWizRetryRules$inboundSchema: z.ZodType<
  InputWizRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InputWizRetryType$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type InputWizRetryRules$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const InputWizRetryRules$outboundSchema: z.ZodType<
  InputWizRetryRules$Outbound,
  z.ZodTypeDef,
  InputWizRetryRules
> = z.object({
  type: InputWizRetryType$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizRetryRules$ {
  /** @deprecated use `InputWizRetryRules$inboundSchema` instead. */
  export const inboundSchema = InputWizRetryRules$inboundSchema;
  /** @deprecated use `InputWizRetryRules$outboundSchema` instead. */
  export const outboundSchema = InputWizRetryRules$outboundSchema;
  /** @deprecated use `InputWizRetryRules$Outbound` instead. */
  export type Outbound = InputWizRetryRules$Outbound;
}

export function inputWizRetryRulesToJSON(
  inputWizRetryRules: InputWizRetryRules,
): string {
  return JSON.stringify(
    InputWizRetryRules$outboundSchema.parse(inputWizRetryRules),
  );
}

export function inputWizRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<InputWizRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizRetryRules' from JSON`,
  );
}

/** @internal */
export const InputWizAuthenticationMethod$inboundSchema: z.ZodType<
  InputWizAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWizAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWizAuthenticationMethod$outboundSchema: z.ZodType<
  InputWizAuthenticationMethod,
  z.ZodTypeDef,
  InputWizAuthenticationMethod
> = z.union([
  z.nativeEnum(InputWizAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizAuthenticationMethod$ {
  /** @deprecated use `InputWizAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputWizAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputWizAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = InputWizAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputWiz$inboundSchema: z.ZodType<
  InputWiz,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputWizType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWizConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputWizPq$inboundSchema).optional(),
  endpoint: z.string().default("https://api.<region>.app.wiz.io/graphql"),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => InputWizContentConfig$inboundSchema)),
  requestTimeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputWizMetadatum$inboundSchema)).optional(),
  retryRules: z.lazy(() => InputWizRetryRules$inboundSchema).optional(),
  authType: InputWizAuthenticationMethod$inboundSchema.default("manual"),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/** @internal */
export type InputWiz$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputWizConnection$Outbound> | undefined;
  pq?: InputWizPq$Outbound | undefined;
  endpoint: string;
  authUrl: string;
  authAudienceOverride?: string | undefined;
  clientId: string;
  contentConfig: Array<InputWizContentConfig$Outbound>;
  requestTimeout: number;
  keepAliveTime: number;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<InputWizMetadatum$Outbound> | undefined;
  retryRules?: InputWizRetryRules$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputWiz$outboundSchema: z.ZodType<
  InputWiz$Outbound,
  z.ZodTypeDef,
  InputWiz
> = z.object({
  id: z.string(),
  type: InputWizType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWizConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputWizPq$outboundSchema).optional(),
  endpoint: z.string().default("https://api.<region>.app.wiz.io/graphql"),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => InputWizContentConfig$outboundSchema)),
  requestTimeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputWizMetadatum$outboundSchema)).optional(),
  retryRules: z.lazy(() => InputWizRetryRules$outboundSchema).optional(),
  authType: InputWizAuthenticationMethod$outboundSchema.default("manual"),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWiz$ {
  /** @deprecated use `InputWiz$inboundSchema` instead. */
  export const inboundSchema = InputWiz$inboundSchema;
  /** @deprecated use `InputWiz$outboundSchema` instead. */
  export const outboundSchema = InputWiz$outboundSchema;
  /** @deprecated use `InputWiz$Outbound` instead. */
  export type Outbound = InputWiz$Outbound;
}

export function inputWizToJSON(inputWiz: InputWiz): string {
  return JSON.stringify(InputWiz$outboundSchema.parse(inputWiz));
}

export function inputWizFromJSON(
  jsonString: string,
): SafeParseResult<InputWiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWiz' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesType$inboundSchema: z.ZodType<
  InputJournalFilesType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputJournalFilesType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputJournalFilesType$outboundSchema: z.ZodType<
  InputJournalFilesType,
  z.ZodTypeDef,
  InputJournalFilesType
> = z.union([
  z.nativeEnum(InputJournalFilesType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesType$ {
  /** @deprecated use `InputJournalFilesType$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesType$inboundSchema;
  /** @deprecated use `InputJournalFilesType$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesType$outboundSchema;
}

/** @internal */
export const InputJournalFilesConnection$inboundSchema: z.ZodType<
  InputJournalFilesConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputJournalFilesConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputJournalFilesConnection$outboundSchema: z.ZodType<
  InputJournalFilesConnection$Outbound,
  z.ZodTypeDef,
  InputJournalFilesConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesConnection$ {
  /** @deprecated use `InputJournalFilesConnection$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesConnection$inboundSchema;
  /** @deprecated use `InputJournalFilesConnection$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesConnection$outboundSchema;
  /** @deprecated use `InputJournalFilesConnection$Outbound` instead. */
  export type Outbound = InputJournalFilesConnection$Outbound;
}

export function inputJournalFilesConnectionToJSON(
  inputJournalFilesConnection: InputJournalFilesConnection,
): string {
  return JSON.stringify(
    InputJournalFilesConnection$outboundSchema.parse(
      inputJournalFilesConnection,
    ),
  );
}

export function inputJournalFilesConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputJournalFilesConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputJournalFilesConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputJournalFilesConnection' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesMode$inboundSchema: z.ZodType<
  InputJournalFilesMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputJournalFilesMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputJournalFilesMode$outboundSchema: z.ZodType<
  InputJournalFilesMode,
  z.ZodTypeDef,
  InputJournalFilesMode
> = z.union([
  z.nativeEnum(InputJournalFilesMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesMode$ {
  /** @deprecated use `InputJournalFilesMode$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesMode$inboundSchema;
  /** @deprecated use `InputJournalFilesMode$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesMode$outboundSchema;
}

/** @internal */
export const InputJournalFilesCompression$inboundSchema: z.ZodType<
  InputJournalFilesCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputJournalFilesCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputJournalFilesCompression$outboundSchema: z.ZodType<
  InputJournalFilesCompression,
  z.ZodTypeDef,
  InputJournalFilesCompression
> = z.union([
  z.nativeEnum(InputJournalFilesCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesCompression$ {
  /** @deprecated use `InputJournalFilesCompression$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesCompression$inboundSchema;
  /** @deprecated use `InputJournalFilesCompression$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesCompression$outboundSchema;
}

/** @internal */
export const InputJournalFilesPq$inboundSchema: z.ZodType<
  InputJournalFilesPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputJournalFilesMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputJournalFilesCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputJournalFilesPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputJournalFilesPq$outboundSchema: z.ZodType<
  InputJournalFilesPq$Outbound,
  z.ZodTypeDef,
  InputJournalFilesPq
> = z.object({
  mode: InputJournalFilesMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputJournalFilesCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesPq$ {
  /** @deprecated use `InputJournalFilesPq$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesPq$inboundSchema;
  /** @deprecated use `InputJournalFilesPq$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesPq$outboundSchema;
  /** @deprecated use `InputJournalFilesPq$Outbound` instead. */
  export type Outbound = InputJournalFilesPq$Outbound;
}

export function inputJournalFilesPqToJSON(
  inputJournalFilesPq: InputJournalFilesPq,
): string {
  return JSON.stringify(
    InputJournalFilesPq$outboundSchema.parse(inputJournalFilesPq),
  );
}

export function inputJournalFilesPqFromJSON(
  jsonString: string,
): SafeParseResult<InputJournalFilesPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputJournalFilesPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputJournalFilesPq' from JSON`,
  );
}

/** @internal */
export const CreateInputRule$inboundSchema: z.ZodType<
  CreateInputRule,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

/** @internal */
export type CreateInputRule$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const CreateInputRule$outboundSchema: z.ZodType<
  CreateInputRule$Outbound,
  z.ZodTypeDef,
  CreateInputRule
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputRule$ {
  /** @deprecated use `CreateInputRule$inboundSchema` instead. */
  export const inboundSchema = CreateInputRule$inboundSchema;
  /** @deprecated use `CreateInputRule$outboundSchema` instead. */
  export const outboundSchema = CreateInputRule$outboundSchema;
  /** @deprecated use `CreateInputRule$Outbound` instead. */
  export type Outbound = CreateInputRule$Outbound;
}

export function createInputRuleToJSON(
  createInputRule: CreateInputRule,
): string {
  return JSON.stringify(CreateInputRule$outboundSchema.parse(createInputRule));
}

export function createInputRuleFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputRule, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputRule$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputRule' from JSON`,
  );
}

/** @internal */
export const InputJournalFilesMetadatum$inboundSchema: z.ZodType<
  InputJournalFilesMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputJournalFilesMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputJournalFilesMetadatum$outboundSchema: z.ZodType<
  InputJournalFilesMetadatum$Outbound,
  z.ZodTypeDef,
  InputJournalFilesMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFilesMetadatum$ {
  /** @deprecated use `InputJournalFilesMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputJournalFilesMetadatum$inboundSchema;
  /** @deprecated use `InputJournalFilesMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputJournalFilesMetadatum$outboundSchema;
  /** @deprecated use `InputJournalFilesMetadatum$Outbound` instead. */
  export type Outbound = InputJournalFilesMetadatum$Outbound;
}

export function inputJournalFilesMetadatumToJSON(
  inputJournalFilesMetadatum: InputJournalFilesMetadatum,
): string {
  return JSON.stringify(
    InputJournalFilesMetadatum$outboundSchema.parse(inputJournalFilesMetadatum),
  );
}

export function inputJournalFilesMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputJournalFilesMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputJournalFilesMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputJournalFilesMetadatum' from JSON`,
  );
}

/** @internal */
export const InputJournalFiles$inboundSchema: z.ZodType<
  InputJournalFiles,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputJournalFilesType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputJournalFilesConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputJournalFilesPq$inboundSchema).optional(),
  path: z.string(),
  interval: z.number().default(10),
  journals: z.array(z.string()),
  rules: z.array(z.lazy(() => CreateInputRule$inboundSchema)).optional(),
  currentBoot: z.boolean().default(false),
  maxAgeDur: z.string().optional(),
  metadata: z.array(z.lazy(() => InputJournalFilesMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputJournalFiles$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputJournalFilesConnection$Outbound> | undefined;
  pq?: InputJournalFilesPq$Outbound | undefined;
  path: string;
  interval: number;
  journals: Array<string>;
  rules?: Array<CreateInputRule$Outbound> | undefined;
  currentBoot: boolean;
  maxAgeDur?: string | undefined;
  metadata?: Array<InputJournalFilesMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputJournalFiles$outboundSchema: z.ZodType<
  InputJournalFiles$Outbound,
  z.ZodTypeDef,
  InputJournalFiles
> = z.object({
  id: z.string(),
  type: InputJournalFilesType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputJournalFilesConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputJournalFilesPq$outboundSchema).optional(),
  path: z.string(),
  interval: z.number().default(10),
  journals: z.array(z.string()),
  rules: z.array(z.lazy(() => CreateInputRule$outboundSchema)).optional(),
  currentBoot: z.boolean().default(false),
  maxAgeDur: z.string().optional(),
  metadata: z.array(z.lazy(() => InputJournalFilesMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputJournalFiles$ {
  /** @deprecated use `InputJournalFiles$inboundSchema` instead. */
  export const inboundSchema = InputJournalFiles$inboundSchema;
  /** @deprecated use `InputJournalFiles$outboundSchema` instead. */
  export const outboundSchema = InputJournalFiles$outboundSchema;
  /** @deprecated use `InputJournalFiles$Outbound` instead. */
  export type Outbound = InputJournalFiles$Outbound;
}

export function inputJournalFilesToJSON(
  inputJournalFiles: InputJournalFiles,
): string {
  return JSON.stringify(
    InputJournalFiles$outboundSchema.parse(inputJournalFiles),
  );
}

export function inputJournalFilesFromJSON(
  jsonString: string,
): SafeParseResult<InputJournalFiles, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputJournalFiles$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputJournalFiles' from JSON`,
  );
}

/** @internal */
export const InputRawUdpType$inboundSchema: z.ZodType<
  InputRawUdpType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputRawUdpType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputRawUdpType$outboundSchema: z.ZodType<
  InputRawUdpType,
  z.ZodTypeDef,
  InputRawUdpType
> = z.union([
  z.nativeEnum(InputRawUdpType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputRawUdpType$ {
  /** @deprecated use `InputRawUdpType$inboundSchema` instead. */
  export const inboundSchema = InputRawUdpType$inboundSchema;
  /** @deprecated use `InputRawUdpType$outboundSchema` instead. */
  export const outboundSchema = InputRawUdpType$outboundSchema;
}

/** @internal */
export const InputRawUdpConnection$inboundSchema: z.ZodType<
  InputRawUdpConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputRawUdpConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputRawUdpConnection$outboundSchema: z.ZodType<
  InputRawUdpConnection$Outbound,
  z.ZodTypeDef,
  InputRawUdpConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputRawUdpConnection$ {
  /** @deprecated use `InputRawUdpConnection$inboundSchema` instead. */
  export const inboundSchema = InputRawUdpConnection$inboundSchema;
  /** @deprecated use `InputRawUdpConnection$outboundSchema` instead. */
  export const outboundSchema = InputRawUdpConnection$outboundSchema;
  /** @deprecated use `InputRawUdpConnection$Outbound` instead. */
  export type Outbound = InputRawUdpConnection$Outbound;
}

export function inputRawUdpConnectionToJSON(
  inputRawUdpConnection: InputRawUdpConnection,
): string {
  return JSON.stringify(
    InputRawUdpConnection$outboundSchema.parse(inputRawUdpConnection),
  );
}

export function inputRawUdpConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputRawUdpConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputRawUdpConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputRawUdpConnection' from JSON`,
  );
}

/** @internal */
export const InputRawUdpMode$inboundSchema: z.ZodType<
  InputRawUdpMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputRawUdpMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputRawUdpMode$outboundSchema: z.ZodType<
  InputRawUdpMode,
  z.ZodTypeDef,
  InputRawUdpMode
> = z.union([
  z.nativeEnum(InputRawUdpMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputRawUdpMode$ {
  /** @deprecated use `InputRawUdpMode$inboundSchema` instead. */
  export const inboundSchema = InputRawUdpMode$inboundSchema;
  /** @deprecated use `InputRawUdpMode$outboundSchema` instead. */
  export const outboundSchema = InputRawUdpMode$outboundSchema;
}

/** @internal */
export const InputRawUdpCompression$inboundSchema: z.ZodType<
  InputRawUdpCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputRawUdpCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputRawUdpCompression$outboundSchema: z.ZodType<
  InputRawUdpCompression,
  z.ZodTypeDef,
  InputRawUdpCompression
> = z.union([
  z.nativeEnum(InputRawUdpCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputRawUdpCompression$ {
  /** @deprecated use `InputRawUdpCompression$inboundSchema` instead. */
  export const inboundSchema = InputRawUdpCompression$inboundSchema;
  /** @deprecated use `InputRawUdpCompression$outboundSchema` instead. */
  export const outboundSchema = InputRawUdpCompression$outboundSchema;
}

/** @internal */
export const InputRawUdpPq$inboundSchema: z.ZodType<
  InputRawUdpPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputRawUdpMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputRawUdpCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputRawUdpPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputRawUdpPq$outboundSchema: z.ZodType<
  InputRawUdpPq$Outbound,
  z.ZodTypeDef,
  InputRawUdpPq
> = z.object({
  mode: InputRawUdpMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputRawUdpCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputRawUdpPq$ {
  /** @deprecated use `InputRawUdpPq$inboundSchema` instead. */
  export const inboundSchema = InputRawUdpPq$inboundSchema;
  /** @deprecated use `InputRawUdpPq$outboundSchema` instead. */
  export const outboundSchema = InputRawUdpPq$outboundSchema;
  /** @deprecated use `InputRawUdpPq$Outbound` instead. */
  export type Outbound = InputRawUdpPq$Outbound;
}

export function inputRawUdpPqToJSON(inputRawUdpPq: InputRawUdpPq): string {
  return JSON.stringify(InputRawUdpPq$outboundSchema.parse(inputRawUdpPq));
}

export function inputRawUdpPqFromJSON(
  jsonString: string,
): SafeParseResult<InputRawUdpPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputRawUdpPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputRawUdpPq' from JSON`,
  );
}

/** @internal */
export const InputRawUdpMetadatum$inboundSchema: z.ZodType<
  InputRawUdpMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputRawUdpMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputRawUdpMetadatum$outboundSchema: z.ZodType<
  InputRawUdpMetadatum$Outbound,
  z.ZodTypeDef,
  InputRawUdpMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputRawUdpMetadatum$ {
  /** @deprecated use `InputRawUdpMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputRawUdpMetadatum$inboundSchema;
  /** @deprecated use `InputRawUdpMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputRawUdpMetadatum$outboundSchema;
  /** @deprecated use `InputRawUdpMetadatum$Outbound` instead. */
  export type Outbound = InputRawUdpMetadatum$Outbound;
}

export function inputRawUdpMetadatumToJSON(
  inputRawUdpMetadatum: InputRawUdpMetadatum,
): string {
  return JSON.stringify(
    InputRawUdpMetadatum$outboundSchema.parse(inputRawUdpMetadatum),
  );
}

export function inputRawUdpMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputRawUdpMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputRawUdpMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputRawUdpMetadatum' from JSON`,
  );
}

/** @internal */
export const InputRawUdp$inboundSchema: z.ZodType<
  InputRawUdp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputRawUdpType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputRawUdpConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputRawUdpPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  singleMsgUdpPackets: z.boolean().default(false),
  ingestRawBytes: z.boolean().default(false),
  udpSocketRxBufSize: z.number().optional(),
  metadata: z.array(z.lazy(() => InputRawUdpMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputRawUdp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputRawUdpConnection$Outbound> | undefined;
  pq?: InputRawUdpPq$Outbound | undefined;
  host: string;
  port: number;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  singleMsgUdpPackets: boolean;
  ingestRawBytes: boolean;
  udpSocketRxBufSize?: number | undefined;
  metadata?: Array<InputRawUdpMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputRawUdp$outboundSchema: z.ZodType<
  InputRawUdp$Outbound,
  z.ZodTypeDef,
  InputRawUdp
> = z.object({
  id: z.string(),
  type: InputRawUdpType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputRawUdpConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputRawUdpPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  singleMsgUdpPackets: z.boolean().default(false),
  ingestRawBytes: z.boolean().default(false),
  udpSocketRxBufSize: z.number().optional(),
  metadata: z.array(z.lazy(() => InputRawUdpMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputRawUdp$ {
  /** @deprecated use `InputRawUdp$inboundSchema` instead. */
  export const inboundSchema = InputRawUdp$inboundSchema;
  /** @deprecated use `InputRawUdp$outboundSchema` instead. */
  export const outboundSchema = InputRawUdp$outboundSchema;
  /** @deprecated use `InputRawUdp$Outbound` instead. */
  export type Outbound = InputRawUdp$Outbound;
}

export function inputRawUdpToJSON(inputRawUdp: InputRawUdp): string {
  return JSON.stringify(InputRawUdp$outboundSchema.parse(inputRawUdp));
}

export function inputRawUdpFromJSON(
  jsonString: string,
): SafeParseResult<InputRawUdp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputRawUdp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputRawUdp' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogsType$inboundSchema: z.ZodType<
  InputWinEventLogsType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWinEventLogsType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWinEventLogsType$outboundSchema: z.ZodType<
  InputWinEventLogsType,
  z.ZodTypeDef,
  InputWinEventLogsType
> = z.union([
  z.nativeEnum(InputWinEventLogsType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsType$ {
  /** @deprecated use `InputWinEventLogsType$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsType$inboundSchema;
  /** @deprecated use `InputWinEventLogsType$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsType$outboundSchema;
}

/** @internal */
export const InputWinEventLogsConnection$inboundSchema: z.ZodType<
  InputWinEventLogsConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputWinEventLogsConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputWinEventLogsConnection$outboundSchema: z.ZodType<
  InputWinEventLogsConnection$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsConnection$ {
  /** @deprecated use `InputWinEventLogsConnection$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsConnection$inboundSchema;
  /** @deprecated use `InputWinEventLogsConnection$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsConnection$outboundSchema;
  /** @deprecated use `InputWinEventLogsConnection$Outbound` instead. */
  export type Outbound = InputWinEventLogsConnection$Outbound;
}

export function inputWinEventLogsConnectionToJSON(
  inputWinEventLogsConnection: InputWinEventLogsConnection,
): string {
  return JSON.stringify(
    InputWinEventLogsConnection$outboundSchema.parse(
      inputWinEventLogsConnection,
    ),
  );
}

export function inputWinEventLogsConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsConnection' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogsMode$inboundSchema: z.ZodType<
  InputWinEventLogsMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWinEventLogsMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWinEventLogsMode$outboundSchema: z.ZodType<
  InputWinEventLogsMode,
  z.ZodTypeDef,
  InputWinEventLogsMode
> = z.union([
  z.nativeEnum(InputWinEventLogsMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsMode$ {
  /** @deprecated use `InputWinEventLogsMode$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsMode$inboundSchema;
  /** @deprecated use `InputWinEventLogsMode$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsMode$outboundSchema;
}

/** @internal */
export const InputWinEventLogsCompression$inboundSchema: z.ZodType<
  InputWinEventLogsCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWinEventLogsCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWinEventLogsCompression$outboundSchema: z.ZodType<
  InputWinEventLogsCompression,
  z.ZodTypeDef,
  InputWinEventLogsCompression
> = z.union([
  z.nativeEnum(InputWinEventLogsCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsCompression$ {
  /** @deprecated use `InputWinEventLogsCompression$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsCompression$inboundSchema;
  /** @deprecated use `InputWinEventLogsCompression$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsCompression$outboundSchema;
}

/** @internal */
export const InputWinEventLogsPq$inboundSchema: z.ZodType<
  InputWinEventLogsPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWinEventLogsMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWinEventLogsCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputWinEventLogsPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputWinEventLogsPq$outboundSchema: z.ZodType<
  InputWinEventLogsPq$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsPq
> = z.object({
  mode: InputWinEventLogsMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWinEventLogsCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsPq$ {
  /** @deprecated use `InputWinEventLogsPq$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsPq$inboundSchema;
  /** @deprecated use `InputWinEventLogsPq$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsPq$outboundSchema;
  /** @deprecated use `InputWinEventLogsPq$Outbound` instead. */
  export type Outbound = InputWinEventLogsPq$Outbound;
}

export function inputWinEventLogsPqToJSON(
  inputWinEventLogsPq: InputWinEventLogsPq,
): string {
  return JSON.stringify(
    InputWinEventLogsPq$outboundSchema.parse(inputWinEventLogsPq),
  );
}

export function inputWinEventLogsPqFromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsPq' from JSON`,
  );
}

/** @internal */
export const ReadMode$inboundSchema: z.ZodType<
  ReadMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ReadMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ReadMode$outboundSchema: z.ZodType<
  ReadMode,
  z.ZodTypeDef,
  ReadMode
> = z.union([
  z.nativeEnum(ReadMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReadMode$ {
  /** @deprecated use `ReadMode$inboundSchema` instead. */
  export const inboundSchema = ReadMode$inboundSchema;
  /** @deprecated use `ReadMode$outboundSchema` instead. */
  export const outboundSchema = ReadMode$outboundSchema;
}

/** @internal */
export const EventFormat$inboundSchema: z.ZodType<
  EventFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EventFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EventFormat$outboundSchema: z.ZodType<
  EventFormat,
  z.ZodTypeDef,
  EventFormat
> = z.union([
  z.nativeEnum(EventFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventFormat$ {
  /** @deprecated use `EventFormat$inboundSchema` instead. */
  export const inboundSchema = EventFormat$inboundSchema;
  /** @deprecated use `EventFormat$outboundSchema` instead. */
  export const outboundSchema = EventFormat$outboundSchema;
}

/** @internal */
export const InputWinEventLogsMetadatum$inboundSchema: z.ZodType<
  InputWinEventLogsMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputWinEventLogsMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputWinEventLogsMetadatum$outboundSchema: z.ZodType<
  InputWinEventLogsMetadatum$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsMetadatum$ {
  /** @deprecated use `InputWinEventLogsMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsMetadatum$inboundSchema;
  /** @deprecated use `InputWinEventLogsMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsMetadatum$outboundSchema;
  /** @deprecated use `InputWinEventLogsMetadatum$Outbound` instead. */
  export type Outbound = InputWinEventLogsMetadatum$Outbound;
}

export function inputWinEventLogsMetadatumToJSON(
  inputWinEventLogsMetadatum: InputWinEventLogsMetadatum,
): string {
  return JSON.stringify(
    InputWinEventLogsMetadatum$outboundSchema.parse(inputWinEventLogsMetadatum),
  );
}

export function inputWinEventLogsMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsMetadatum' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogs$inboundSchema: z.ZodType<
  InputWinEventLogs,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputWinEventLogsType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWinEventLogsConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputWinEventLogsPq$inboundSchema).optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode$inboundSchema.default("oldest"),
  eventFormat: EventFormat$inboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(z.lazy(() => InputWinEventLogsMetadatum$inboundSchema))
    .optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
});

/** @internal */
export type InputWinEventLogs$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputWinEventLogsConnection$Outbound> | undefined;
  pq?: InputWinEventLogsPq$Outbound | undefined;
  logNames: Array<string>;
  readMode: string;
  eventFormat: string;
  disableNativeModule: boolean;
  interval: number;
  batchSize: number;
  metadata?: Array<InputWinEventLogsMetadatum$Outbound> | undefined;
  maxEventBytes: number;
  description?: string | undefined;
};

/** @internal */
export const InputWinEventLogs$outboundSchema: z.ZodType<
  InputWinEventLogs$Outbound,
  z.ZodTypeDef,
  InputWinEventLogs
> = z.object({
  id: z.string(),
  type: InputWinEventLogsType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWinEventLogsConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputWinEventLogsPq$outboundSchema).optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode$outboundSchema.default("oldest"),
  eventFormat: EventFormat$outboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(z.lazy(() => InputWinEventLogsMetadatum$outboundSchema))
    .optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogs$ {
  /** @deprecated use `InputWinEventLogs$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogs$inboundSchema;
  /** @deprecated use `InputWinEventLogs$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogs$outboundSchema;
  /** @deprecated use `InputWinEventLogs$Outbound` instead. */
  export type Outbound = InputWinEventLogs$Outbound;
}

export function inputWinEventLogsToJSON(
  inputWinEventLogs: InputWinEventLogs,
): string {
  return JSON.stringify(
    InputWinEventLogs$outboundSchema.parse(inputWinEventLogs),
  );
}

export function inputWinEventLogsFromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogs' from JSON`,
  );
}

/** @internal */
export const InputWefType$inboundSchema: z.ZodType<
  InputWefType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWefType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWefType$outboundSchema: z.ZodType<
  InputWefType,
  z.ZodTypeDef,
  InputWefType
> = z.union([
  z.nativeEnum(InputWefType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWefType$ {
  /** @deprecated use `InputWefType$inboundSchema` instead. */
  export const inboundSchema = InputWefType$inboundSchema;
  /** @deprecated use `InputWefType$outboundSchema` instead. */
  export const outboundSchema = InputWefType$outboundSchema;
}

/** @internal */
export const InputWefConnection$inboundSchema: z.ZodType<
  InputWefConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputWefConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputWefConnection$outboundSchema: z.ZodType<
  InputWefConnection$Outbound,
  z.ZodTypeDef,
  InputWefConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWefConnection$ {
  /** @deprecated use `InputWefConnection$inboundSchema` instead. */
  export const inboundSchema = InputWefConnection$inboundSchema;
  /** @deprecated use `InputWefConnection$outboundSchema` instead. */
  export const outboundSchema = InputWefConnection$outboundSchema;
  /** @deprecated use `InputWefConnection$Outbound` instead. */
  export type Outbound = InputWefConnection$Outbound;
}

export function inputWefConnectionToJSON(
  inputWefConnection: InputWefConnection,
): string {
  return JSON.stringify(
    InputWefConnection$outboundSchema.parse(inputWefConnection),
  );
}

export function inputWefConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputWefConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWefConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWefConnection' from JSON`,
  );
}

/** @internal */
export const InputWefMode$inboundSchema: z.ZodType<
  InputWefMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWefMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWefMode$outboundSchema: z.ZodType<
  InputWefMode,
  z.ZodTypeDef,
  InputWefMode
> = z.union([
  z.nativeEnum(InputWefMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWefMode$ {
  /** @deprecated use `InputWefMode$inboundSchema` instead. */
  export const inboundSchema = InputWefMode$inboundSchema;
  /** @deprecated use `InputWefMode$outboundSchema` instead. */
  export const outboundSchema = InputWefMode$outboundSchema;
}

/** @internal */
export const InputWefCompression$inboundSchema: z.ZodType<
  InputWefCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWefCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWefCompression$outboundSchema: z.ZodType<
  InputWefCompression,
  z.ZodTypeDef,
  InputWefCompression
> = z.union([
  z.nativeEnum(InputWefCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWefCompression$ {
  /** @deprecated use `InputWefCompression$inboundSchema` instead. */
  export const inboundSchema = InputWefCompression$inboundSchema;
  /** @deprecated use `InputWefCompression$outboundSchema` instead. */
  export const outboundSchema = InputWefCompression$outboundSchema;
}

/** @internal */
export const InputWefPq$inboundSchema: z.ZodType<
  InputWefPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWefMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWefCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputWefPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputWefPq$outboundSchema: z.ZodType<
  InputWefPq$Outbound,
  z.ZodTypeDef,
  InputWefPq
> = z.object({
  mode: InputWefMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWefCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWefPq$ {
  /** @deprecated use `InputWefPq$inboundSchema` instead. */
  export const inboundSchema = InputWefPq$inboundSchema;
  /** @deprecated use `InputWefPq$outboundSchema` instead. */
  export const outboundSchema = InputWefPq$outboundSchema;
  /** @deprecated use `InputWefPq$Outbound` instead. */
  export type Outbound = InputWefPq$Outbound;
}

export function inputWefPqToJSON(inputWefPq: InputWefPq): string {
  return JSON.stringify(InputWefPq$outboundSchema.parse(inputWefPq));
}

export function inputWefPqFromJSON(
  jsonString: string,
): SafeParseResult<InputWefPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWefPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWefPq' from JSON`,
  );
}

/** @internal */
export const InputWefAuthenticationMethod$inboundSchema: z.ZodType<
  InputWefAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWefAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWefAuthenticationMethod$outboundSchema: z.ZodType<
  InputWefAuthenticationMethod,
  z.ZodTypeDef,
  InputWefAuthenticationMethod
> = z.union([
  z.nativeEnum(InputWefAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWefAuthenticationMethod$ {
  /** @deprecated use `InputWefAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputWefAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputWefAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = InputWefAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputWefMinimumTLSVersion$inboundSchema: z.ZodType<
  InputWefMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWefMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWefMinimumTLSVersion$outboundSchema: z.ZodType<
  InputWefMinimumTLSVersion,
  z.ZodTypeDef,
  InputWefMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputWefMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWefMinimumTLSVersion$ {
  /** @deprecated use `InputWefMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputWefMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputWefMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputWefMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputWefMaximumTLSVersion$inboundSchema: z.ZodType<
  InputWefMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWefMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWefMaximumTLSVersion$outboundSchema: z.ZodType<
  InputWefMaximumTLSVersion,
  z.ZodTypeDef,
  InputWefMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputWefMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWefMaximumTLSVersion$ {
  /** @deprecated use `InputWefMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputWefMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputWefMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputWefMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const MTLSSettings$inboundSchema: z.ZodType<
  MTLSSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  requestCert: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
  caPath: z.string(),
  commonNameRegex: z.string().default("/.*/"),
  minVersion: InputWefMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputWefMaximumTLSVersion$inboundSchema.optional(),
  ocspCheck: z.boolean().default(false),
  keytab: z.any().optional(),
  principal: z.any().optional(),
  ocspCheckFailClose: z.boolean().default(false),
});

/** @internal */
export type MTLSSettings$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  requestCert: boolean;
  certificateName?: string | undefined;
  privKeyPath: string;
  passphrase?: string | undefined;
  certPath: string;
  caPath: string;
  commonNameRegex: string;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
  ocspCheck: boolean;
  keytab?: any | undefined;
  principal?: any | undefined;
  ocspCheckFailClose: boolean;
};

/** @internal */
export const MTLSSettings$outboundSchema: z.ZodType<
  MTLSSettings$Outbound,
  z.ZodTypeDef,
  MTLSSettings
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  requestCert: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
  caPath: z.string(),
  commonNameRegex: z.string().default("/.*/"),
  minVersion: InputWefMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputWefMaximumTLSVersion$outboundSchema.optional(),
  ocspCheck: z.boolean().default(false),
  keytab: z.any().optional(),
  principal: z.any().optional(),
  ocspCheckFailClose: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MTLSSettings$ {
  /** @deprecated use `MTLSSettings$inboundSchema` instead. */
  export const inboundSchema = MTLSSettings$inboundSchema;
  /** @deprecated use `MTLSSettings$outboundSchema` instead. */
  export const outboundSchema = MTLSSettings$outboundSchema;
  /** @deprecated use `MTLSSettings$Outbound` instead. */
  export type Outbound = MTLSSettings$Outbound;
}

export function mTLSSettingsToJSON(mtlsSettings: MTLSSettings): string {
  return JSON.stringify(MTLSSettings$outboundSchema.parse(mtlsSettings));
}

export function mTLSSettingsFromJSON(
  jsonString: string,
): SafeParseResult<MTLSSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MTLSSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MTLSSettings' from JSON`,
  );
}

/** @internal */
export const CreateInputFormat$inboundSchema: z.ZodType<
  CreateInputFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CreateInputFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CreateInputFormat$outboundSchema: z.ZodType<
  CreateInputFormat,
  z.ZodTypeDef,
  CreateInputFormat
> = z.union([
  z.nativeEnum(CreateInputFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputFormat$ {
  /** @deprecated use `CreateInputFormat$inboundSchema` instead. */
  export const inboundSchema = CreateInputFormat$inboundSchema;
  /** @deprecated use `CreateInputFormat$outboundSchema` instead. */
  export const outboundSchema = CreateInputFormat$outboundSchema;
}

/** @internal */
export const QueryBuilderMode$inboundSchema: z.ZodType<
  QueryBuilderMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(QueryBuilderMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const QueryBuilderMode$outboundSchema: z.ZodType<
  QueryBuilderMode,
  z.ZodTypeDef,
  QueryBuilderMode
> = z.union([
  z.nativeEnum(QueryBuilderMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace QueryBuilderMode$ {
  /** @deprecated use `QueryBuilderMode$inboundSchema` instead. */
  export const inboundSchema = QueryBuilderMode$inboundSchema;
  /** @deprecated use `QueryBuilderMode$outboundSchema` instead. */
  export const outboundSchema = QueryBuilderMode$outboundSchema;
}

/** @internal */
export const SubscriptionMetadatum$inboundSchema: z.ZodType<
  SubscriptionMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type SubscriptionMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SubscriptionMetadatum$outboundSchema: z.ZodType<
  SubscriptionMetadatum$Outbound,
  z.ZodTypeDef,
  SubscriptionMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SubscriptionMetadatum$ {
  /** @deprecated use `SubscriptionMetadatum$inboundSchema` instead. */
  export const inboundSchema = SubscriptionMetadatum$inboundSchema;
  /** @deprecated use `SubscriptionMetadatum$outboundSchema` instead. */
  export const outboundSchema = SubscriptionMetadatum$outboundSchema;
  /** @deprecated use `SubscriptionMetadatum$Outbound` instead. */
  export type Outbound = SubscriptionMetadatum$Outbound;
}

export function subscriptionMetadatumToJSON(
  subscriptionMetadatum: SubscriptionMetadatum,
): string {
  return JSON.stringify(
    SubscriptionMetadatum$outboundSchema.parse(subscriptionMetadatum),
  );
}

export function subscriptionMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<SubscriptionMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SubscriptionMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SubscriptionMetadatum' from JSON`,
  );
}

/** @internal */
export const Subscription$inboundSchema: z.ZodType<
  Subscription,
  z.ZodTypeDef,
  unknown
> = z.object({
  subscriptionName: z.string(),
  version: z.string().optional(),
  contentFormat: CreateInputFormat$inboundSchema.default("Raw"),
  heartbeatInterval: z.number().default(60),
  batchTimeout: z.number().default(60),
  readExistingEvents: z.boolean().default(false),
  sendBookmarks: z.boolean().default(true),
  compress: z.boolean().default(true),
  targets: z.array(z.string()),
  locale: z.string().default("en-US"),
  querySelector: QueryBuilderMode$inboundSchema.default("simple"),
  metadata: z.array(z.lazy(() => SubscriptionMetadatum$inboundSchema))
    .optional(),
});

/** @internal */
export type Subscription$Outbound = {
  subscriptionName: string;
  version?: string | undefined;
  contentFormat: string;
  heartbeatInterval: number;
  batchTimeout: number;
  readExistingEvents: boolean;
  sendBookmarks: boolean;
  compress: boolean;
  targets: Array<string>;
  locale: string;
  querySelector: string;
  metadata?: Array<SubscriptionMetadatum$Outbound> | undefined;
};

/** @internal */
export const Subscription$outboundSchema: z.ZodType<
  Subscription$Outbound,
  z.ZodTypeDef,
  Subscription
> = z.object({
  subscriptionName: z.string(),
  version: z.string().optional(),
  contentFormat: CreateInputFormat$outboundSchema.default("Raw"),
  heartbeatInterval: z.number().default(60),
  batchTimeout: z.number().default(60),
  readExistingEvents: z.boolean().default(false),
  sendBookmarks: z.boolean().default(true),
  compress: z.boolean().default(true),
  targets: z.array(z.string()),
  locale: z.string().default("en-US"),
  querySelector: QueryBuilderMode$outboundSchema.default("simple"),
  metadata: z.array(z.lazy(() => SubscriptionMetadatum$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Subscription$ {
  /** @deprecated use `Subscription$inboundSchema` instead. */
  export const inboundSchema = Subscription$inboundSchema;
  /** @deprecated use `Subscription$outboundSchema` instead. */
  export const outboundSchema = Subscription$outboundSchema;
  /** @deprecated use `Subscription$Outbound` instead. */
  export type Outbound = Subscription$Outbound;
}

export function subscriptionToJSON(subscription: Subscription): string {
  return JSON.stringify(Subscription$outboundSchema.parse(subscription));
}

export function subscriptionFromJSON(
  jsonString: string,
): SafeParseResult<Subscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Subscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Subscription' from JSON`,
  );
}

/** @internal */
export const InputWefMetadatum$inboundSchema: z.ZodType<
  InputWefMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputWefMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputWefMetadatum$outboundSchema: z.ZodType<
  InputWefMetadatum$Outbound,
  z.ZodTypeDef,
  InputWefMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWefMetadatum$ {
  /** @deprecated use `InputWefMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputWefMetadatum$inboundSchema;
  /** @deprecated use `InputWefMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputWefMetadatum$outboundSchema;
  /** @deprecated use `InputWefMetadatum$Outbound` instead. */
  export type Outbound = InputWefMetadatum$Outbound;
}

export function inputWefMetadatumToJSON(
  inputWefMetadatum: InputWefMetadatum,
): string {
  return JSON.stringify(
    InputWefMetadatum$outboundSchema.parse(inputWefMetadatum),
  );
}

export function inputWefMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputWefMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWefMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWefMetadatum' from JSON`,
  );
}

/** @internal */
export const InputWef$inboundSchema: z.ZodType<
  InputWef,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputWefType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWefConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputWefPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(5986),
  authMethod: InputWefAuthenticationMethod$inboundSchema.default("clientCert"),
  tls: z.lazy(() => MTLSSettings$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  keepAliveTimeout: z.number().default(90),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  socketTimeout: z.number().default(0),
  caFingerprint: z.string().optional(),
  keytab: z.string().optional(),
  principal: z.string().optional(),
  allowMachineIdMismatch: z.boolean().default(false),
  subscriptions: z.array(z.lazy(() => Subscription$inboundSchema)),
  metadata: z.array(z.lazy(() => InputWefMetadatum$inboundSchema)).optional(),
  description: z.string().optional(),
  logFingerprintMismatch: z.boolean().default(false),
});

/** @internal */
export type InputWef$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputWefConnection$Outbound> | undefined;
  pq?: InputWefPq$Outbound | undefined;
  host: string;
  port: number;
  authMethod: string;
  tls?: MTLSSettings$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  socketTimeout: number;
  caFingerprint?: string | undefined;
  keytab?: string | undefined;
  principal?: string | undefined;
  allowMachineIdMismatch: boolean;
  subscriptions: Array<Subscription$Outbound>;
  metadata?: Array<InputWefMetadatum$Outbound> | undefined;
  description?: string | undefined;
  logFingerprintMismatch: boolean;
};

/** @internal */
export const InputWef$outboundSchema: z.ZodType<
  InputWef$Outbound,
  z.ZodTypeDef,
  InputWef
> = z.object({
  id: z.string(),
  type: InputWefType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWefConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputWefPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(5986),
  authMethod: InputWefAuthenticationMethod$outboundSchema.default("clientCert"),
  tls: z.lazy(() => MTLSSettings$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  keepAliveTimeout: z.number().default(90),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  socketTimeout: z.number().default(0),
  caFingerprint: z.string().optional(),
  keytab: z.string().optional(),
  principal: z.string().optional(),
  allowMachineIdMismatch: z.boolean().default(false),
  subscriptions: z.array(z.lazy(() => Subscription$outboundSchema)),
  metadata: z.array(z.lazy(() => InputWefMetadatum$outboundSchema)).optional(),
  description: z.string().optional(),
  logFingerprintMismatch: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWef$ {
  /** @deprecated use `InputWef$inboundSchema` instead. */
  export const inboundSchema = InputWef$inboundSchema;
  /** @deprecated use `InputWef$outboundSchema` instead. */
  export const outboundSchema = InputWef$outboundSchema;
  /** @deprecated use `InputWef$Outbound` instead. */
  export type Outbound = InputWef$Outbound;
}

export function inputWefToJSON(inputWef: InputWef): string {
  return JSON.stringify(InputWef$outboundSchema.parse(inputWef));
}

export function inputWefFromJSON(
  jsonString: string,
): SafeParseResult<InputWef, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWef$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWef' from JSON`,
  );
}

/** @internal */
export const InputTcpType$inboundSchema: z.ZodType<
  InputTcpType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpType$outboundSchema: z.ZodType<
  InputTcpType,
  z.ZodTypeDef,
  InputTcpType
> = z.union([
  z.nativeEnum(InputTcpType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpType$ {
  /** @deprecated use `InputTcpType$inboundSchema` instead. */
  export const inboundSchema = InputTcpType$inboundSchema;
  /** @deprecated use `InputTcpType$outboundSchema` instead. */
  export const outboundSchema = InputTcpType$outboundSchema;
}

/** @internal */
export const InputTcpConnection$inboundSchema: z.ZodType<
  InputTcpConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputTcpConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputTcpConnection$outboundSchema: z.ZodType<
  InputTcpConnection$Outbound,
  z.ZodTypeDef,
  InputTcpConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpConnection$ {
  /** @deprecated use `InputTcpConnection$inboundSchema` instead. */
  export const inboundSchema = InputTcpConnection$inboundSchema;
  /** @deprecated use `InputTcpConnection$outboundSchema` instead. */
  export const outboundSchema = InputTcpConnection$outboundSchema;
  /** @deprecated use `InputTcpConnection$Outbound` instead. */
  export type Outbound = InputTcpConnection$Outbound;
}

export function inputTcpConnectionToJSON(
  inputTcpConnection: InputTcpConnection,
): string {
  return JSON.stringify(
    InputTcpConnection$outboundSchema.parse(inputTcpConnection),
  );
}

export function inputTcpConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputTcpConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcpConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcpConnection' from JSON`,
  );
}

/** @internal */
export const InputTcpMode$inboundSchema: z.ZodType<
  InputTcpMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpMode$outboundSchema: z.ZodType<
  InputTcpMode,
  z.ZodTypeDef,
  InputTcpMode
> = z.union([
  z.nativeEnum(InputTcpMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpMode$ {
  /** @deprecated use `InputTcpMode$inboundSchema` instead. */
  export const inboundSchema = InputTcpMode$inboundSchema;
  /** @deprecated use `InputTcpMode$outboundSchema` instead. */
  export const outboundSchema = InputTcpMode$outboundSchema;
}

/** @internal */
export const InputTcpCompression$inboundSchema: z.ZodType<
  InputTcpCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpCompression$outboundSchema: z.ZodType<
  InputTcpCompression,
  z.ZodTypeDef,
  InputTcpCompression
> = z.union([
  z.nativeEnum(InputTcpCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpCompression$ {
  /** @deprecated use `InputTcpCompression$inboundSchema` instead. */
  export const inboundSchema = InputTcpCompression$inboundSchema;
  /** @deprecated use `InputTcpCompression$outboundSchema` instead. */
  export const outboundSchema = InputTcpCompression$outboundSchema;
}

/** @internal */
export const InputTcpPq$inboundSchema: z.ZodType<
  InputTcpPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputTcpMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputTcpCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputTcpPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputTcpPq$outboundSchema: z.ZodType<
  InputTcpPq$Outbound,
  z.ZodTypeDef,
  InputTcpPq
> = z.object({
  mode: InputTcpMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputTcpCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpPq$ {
  /** @deprecated use `InputTcpPq$inboundSchema` instead. */
  export const inboundSchema = InputTcpPq$inboundSchema;
  /** @deprecated use `InputTcpPq$outboundSchema` instead. */
  export const outboundSchema = InputTcpPq$outboundSchema;
  /** @deprecated use `InputTcpPq$Outbound` instead. */
  export type Outbound = InputTcpPq$Outbound;
}

export function inputTcpPqToJSON(inputTcpPq: InputTcpPq): string {
  return JSON.stringify(InputTcpPq$outboundSchema.parse(inputTcpPq));
}

export function inputTcpPqFromJSON(
  jsonString: string,
): SafeParseResult<InputTcpPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcpPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcpPq' from JSON`,
  );
}

/** @internal */
export const InputTcpMinimumTLSVersion$inboundSchema: z.ZodType<
  InputTcpMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpMinimumTLSVersion$outboundSchema: z.ZodType<
  InputTcpMinimumTLSVersion,
  z.ZodTypeDef,
  InputTcpMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputTcpMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpMinimumTLSVersion$ {
  /** @deprecated use `InputTcpMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputTcpMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputTcpMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputTcpMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputTcpMaximumTLSVersion$inboundSchema: z.ZodType<
  InputTcpMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpMaximumTLSVersion$outboundSchema: z.ZodType<
  InputTcpMaximumTLSVersion,
  z.ZodTypeDef,
  InputTcpMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputTcpMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpMaximumTLSVersion$ {
  /** @deprecated use `InputTcpMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputTcpMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputTcpMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputTcpMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputTcpTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputTcpTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputTcpMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputTcpMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputTcpTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputTcpTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputTcpTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputTcpTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputTcpMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputTcpMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpTLSSettingsServerSide$ {
  /** @deprecated use `InputTcpTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputTcpTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputTcpTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema = InputTcpTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputTcpTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputTcpTLSSettingsServerSide$Outbound;
}

export function inputTcpTLSSettingsServerSideToJSON(
  inputTcpTLSSettingsServerSide: InputTcpTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputTcpTLSSettingsServerSide$outboundSchema.parse(
      inputTcpTLSSettingsServerSide,
    ),
  );
}

export function inputTcpTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputTcpTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcpTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcpTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputTcpMetadatum$inboundSchema: z.ZodType<
  InputTcpMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputTcpMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputTcpMetadatum$outboundSchema: z.ZodType<
  InputTcpMetadatum$Outbound,
  z.ZodTypeDef,
  InputTcpMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpMetadatum$ {
  /** @deprecated use `InputTcpMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputTcpMetadatum$inboundSchema;
  /** @deprecated use `InputTcpMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputTcpMetadatum$outboundSchema;
  /** @deprecated use `InputTcpMetadatum$Outbound` instead. */
  export type Outbound = InputTcpMetadatum$Outbound;
}

export function inputTcpMetadatumToJSON(
  inputTcpMetadatum: InputTcpMetadatum,
): string {
  return JSON.stringify(
    InputTcpMetadatum$outboundSchema.parse(inputTcpMetadatum),
  );
}

export function inputTcpMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputTcpMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcpMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcpMetadatum' from JSON`,
  );
}

/** @internal */
export const InputTcpPreprocess$inboundSchema: z.ZodType<
  InputTcpPreprocess,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/** @internal */
export type InputTcpPreprocess$Outbound = {
  disabled: boolean;
  command?: string | undefined;
  args?: Array<string> | undefined;
};

/** @internal */
export const InputTcpPreprocess$outboundSchema: z.ZodType<
  InputTcpPreprocess$Outbound,
  z.ZodTypeDef,
  InputTcpPreprocess
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpPreprocess$ {
  /** @deprecated use `InputTcpPreprocess$inboundSchema` instead. */
  export const inboundSchema = InputTcpPreprocess$inboundSchema;
  /** @deprecated use `InputTcpPreprocess$outboundSchema` instead. */
  export const outboundSchema = InputTcpPreprocess$outboundSchema;
  /** @deprecated use `InputTcpPreprocess$Outbound` instead. */
  export type Outbound = InputTcpPreprocess$Outbound;
}

export function inputTcpPreprocessToJSON(
  inputTcpPreprocess: InputTcpPreprocess,
): string {
  return JSON.stringify(
    InputTcpPreprocess$outboundSchema.parse(inputTcpPreprocess),
  );
}

export function inputTcpPreprocessFromJSON(
  jsonString: string,
): SafeParseResult<InputTcpPreprocess, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcpPreprocess$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcpPreprocess' from JSON`,
  );
}

/** @internal */
export const InputTcpAuthenticationMethod$inboundSchema: z.ZodType<
  InputTcpAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpAuthenticationMethod$outboundSchema: z.ZodType<
  InputTcpAuthenticationMethod,
  z.ZodTypeDef,
  InputTcpAuthenticationMethod
> = z.union([
  z.nativeEnum(InputTcpAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpAuthenticationMethod$ {
  /** @deprecated use `InputTcpAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputTcpAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputTcpAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = InputTcpAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputTcp$inboundSchema: z.ZodType<
  InputTcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputTcpType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputTcpConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputTcpPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputTcpTLSSettingsServerSide$inboundSchema).optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputTcpMetadatum$inboundSchema)).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: z.lazy(() => InputTcpPreprocess$inboundSchema).optional(),
  description: z.string().optional(),
  authType: InputTcpAuthenticationMethod$inboundSchema.default("manual"),
});

/** @internal */
export type InputTcp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputTcpConnection$Outbound> | undefined;
  pq?: InputTcpPq$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputTcpTLSSettingsServerSide$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<InputTcpMetadatum$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableHeader: boolean;
  preprocess?: InputTcpPreprocess$Outbound | undefined;
  description?: string | undefined;
  authType: string;
};

/** @internal */
export const InputTcp$outboundSchema: z.ZodType<
  InputTcp$Outbound,
  z.ZodTypeDef,
  InputTcp
> = z.object({
  id: z.string(),
  type: InputTcpType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputTcpConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputTcpPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputTcpTLSSettingsServerSide$outboundSchema).optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputTcpMetadatum$outboundSchema)).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: z.lazy(() => InputTcpPreprocess$outboundSchema).optional(),
  description: z.string().optional(),
  authType: InputTcpAuthenticationMethod$outboundSchema.default("manual"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcp$ {
  /** @deprecated use `InputTcp$inboundSchema` instead. */
  export const inboundSchema = InputTcp$inboundSchema;
  /** @deprecated use `InputTcp$outboundSchema` instead. */
  export const outboundSchema = InputTcp$outboundSchema;
  /** @deprecated use `InputTcp$Outbound` instead. */
  export type Outbound = InputTcp$Outbound;
}

export function inputTcpToJSON(inputTcp: InputTcp): string {
  return JSON.stringify(InputTcp$outboundSchema.parse(inputTcp));
}

export function inputTcpFromJSON(
  jsonString: string,
): SafeParseResult<InputTcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcp' from JSON`,
  );
}

/** @internal */
export const InputSyslogType2$inboundSchema: z.ZodType<
  InputSyslogType2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSyslogType2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSyslogType2$outboundSchema: z.ZodType<
  InputSyslogType2,
  z.ZodTypeDef,
  InputSyslogType2
> = z.union([
  z.nativeEnum(InputSyslogType2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogType2$ {
  /** @deprecated use `InputSyslogType2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogType2$inboundSchema;
  /** @deprecated use `InputSyslogType2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogType2$outboundSchema;
}

/** @internal */
export const InputSyslogConnection2$inboundSchema: z.ZodType<
  InputSyslogConnection2,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputSyslogConnection2$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSyslogConnection2$outboundSchema: z.ZodType<
  InputSyslogConnection2$Outbound,
  z.ZodTypeDef,
  InputSyslogConnection2
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogConnection2$ {
  /** @deprecated use `InputSyslogConnection2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogConnection2$inboundSchema;
  /** @deprecated use `InputSyslogConnection2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogConnection2$outboundSchema;
  /** @deprecated use `InputSyslogConnection2$Outbound` instead. */
  export type Outbound = InputSyslogConnection2$Outbound;
}

export function inputSyslogConnection2ToJSON(
  inputSyslogConnection2: InputSyslogConnection2,
): string {
  return JSON.stringify(
    InputSyslogConnection2$outboundSchema.parse(inputSyslogConnection2),
  );
}

export function inputSyslogConnection2FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogConnection2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogConnection2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogConnection2' from JSON`,
  );
}

/** @internal */
export const InputSyslogMode2$inboundSchema: z.ZodType<
  InputSyslogMode2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSyslogMode2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSyslogMode2$outboundSchema: z.ZodType<
  InputSyslogMode2,
  z.ZodTypeDef,
  InputSyslogMode2
> = z.union([
  z.nativeEnum(InputSyslogMode2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMode2$ {
  /** @deprecated use `InputSyslogMode2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMode2$inboundSchema;
  /** @deprecated use `InputSyslogMode2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMode2$outboundSchema;
}

/** @internal */
export const InputSyslogCompression2$inboundSchema: z.ZodType<
  InputSyslogCompression2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSyslogCompression2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSyslogCompression2$outboundSchema: z.ZodType<
  InputSyslogCompression2,
  z.ZodTypeDef,
  InputSyslogCompression2
> = z.union([
  z.nativeEnum(InputSyslogCompression2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogCompression2$ {
  /** @deprecated use `InputSyslogCompression2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogCompression2$inboundSchema;
  /** @deprecated use `InputSyslogCompression2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogCompression2$outboundSchema;
}

/** @internal */
export const InputSyslogPq2$inboundSchema: z.ZodType<
  InputSyslogPq2,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSyslogMode2$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSyslogCompression2$inboundSchema.default("none"),
});

/** @internal */
export type InputSyslogPq2$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputSyslogPq2$outboundSchema: z.ZodType<
  InputSyslogPq2$Outbound,
  z.ZodTypeDef,
  InputSyslogPq2
> = z.object({
  mode: InputSyslogMode2$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSyslogCompression2$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogPq2$ {
  /** @deprecated use `InputSyslogPq2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogPq2$inboundSchema;
  /** @deprecated use `InputSyslogPq2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogPq2$outboundSchema;
  /** @deprecated use `InputSyslogPq2$Outbound` instead. */
  export type Outbound = InputSyslogPq2$Outbound;
}

export function inputSyslogPq2ToJSON(inputSyslogPq2: InputSyslogPq2): string {
  return JSON.stringify(InputSyslogPq2$outboundSchema.parse(inputSyslogPq2));
}

export function inputSyslogPq2FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogPq2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogPq2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogPq2' from JSON`,
  );
}

/** @internal */
export const InputSyslogMinimumTLSVersion2$inboundSchema: z.ZodType<
  InputSyslogMinimumTLSVersion2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSyslogMinimumTLSVersion2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSyslogMinimumTLSVersion2$outboundSchema: z.ZodType<
  InputSyslogMinimumTLSVersion2,
  z.ZodTypeDef,
  InputSyslogMinimumTLSVersion2
> = z.union([
  z.nativeEnum(InputSyslogMinimumTLSVersion2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMinimumTLSVersion2$ {
  /** @deprecated use `InputSyslogMinimumTLSVersion2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMinimumTLSVersion2$inboundSchema;
  /** @deprecated use `InputSyslogMinimumTLSVersion2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMinimumTLSVersion2$outboundSchema;
}

/** @internal */
export const InputSyslogMaximumTLSVersion2$inboundSchema: z.ZodType<
  InputSyslogMaximumTLSVersion2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSyslogMaximumTLSVersion2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSyslogMaximumTLSVersion2$outboundSchema: z.ZodType<
  InputSyslogMaximumTLSVersion2,
  z.ZodTypeDef,
  InputSyslogMaximumTLSVersion2
> = z.union([
  z.nativeEnum(InputSyslogMaximumTLSVersion2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMaximumTLSVersion2$ {
  /** @deprecated use `InputSyslogMaximumTLSVersion2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMaximumTLSVersion2$inboundSchema;
  /** @deprecated use `InputSyslogMaximumTLSVersion2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMaximumTLSVersion2$outboundSchema;
}

/** @internal */
export const InputSyslogTLSSettingsServerSide2$inboundSchema: z.ZodType<
  InputSyslogTLSSettingsServerSide2,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSyslogMinimumTLSVersion2$inboundSchema.optional(),
  maxVersion: InputSyslogMaximumTLSVersion2$inboundSchema.optional(),
});

/** @internal */
export type InputSyslogTLSSettingsServerSide2$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputSyslogTLSSettingsServerSide2$outboundSchema: z.ZodType<
  InputSyslogTLSSettingsServerSide2$Outbound,
  z.ZodTypeDef,
  InputSyslogTLSSettingsServerSide2
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSyslogMinimumTLSVersion2$outboundSchema.optional(),
  maxVersion: InputSyslogMaximumTLSVersion2$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogTLSSettingsServerSide2$ {
  /** @deprecated use `InputSyslogTLSSettingsServerSide2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogTLSSettingsServerSide2$inboundSchema;
  /** @deprecated use `InputSyslogTLSSettingsServerSide2$outboundSchema` instead. */
  export const outboundSchema =
    InputSyslogTLSSettingsServerSide2$outboundSchema;
  /** @deprecated use `InputSyslogTLSSettingsServerSide2$Outbound` instead. */
  export type Outbound = InputSyslogTLSSettingsServerSide2$Outbound;
}

export function inputSyslogTLSSettingsServerSide2ToJSON(
  inputSyslogTLSSettingsServerSide2: InputSyslogTLSSettingsServerSide2,
): string {
  return JSON.stringify(
    InputSyslogTLSSettingsServerSide2$outboundSchema.parse(
      inputSyslogTLSSettingsServerSide2,
    ),
  );
}

export function inputSyslogTLSSettingsServerSide2FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogTLSSettingsServerSide2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogTLSSettingsServerSide2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogTLSSettingsServerSide2' from JSON`,
  );
}

/** @internal */
export const InputSyslogMetadatum2$inboundSchema: z.ZodType<
  InputSyslogMetadatum2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSyslogMetadatum2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSyslogMetadatum2$outboundSchema: z.ZodType<
  InputSyslogMetadatum2$Outbound,
  z.ZodTypeDef,
  InputSyslogMetadatum2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMetadatum2$ {
  /** @deprecated use `InputSyslogMetadatum2$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMetadatum2$inboundSchema;
  /** @deprecated use `InputSyslogMetadatum2$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMetadatum2$outboundSchema;
  /** @deprecated use `InputSyslogMetadatum2$Outbound` instead. */
  export type Outbound = InputSyslogMetadatum2$Outbound;
}

export function inputSyslogMetadatum2ToJSON(
  inputSyslogMetadatum2: InputSyslogMetadatum2,
): string {
  return JSON.stringify(
    InputSyslogMetadatum2$outboundSchema.parse(inputSyslogMetadatum2),
  );
}

export function inputSyslogMetadatum2FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogMetadatum2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogMetadatum2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogMetadatum2' from JSON`,
  );
}

/** @internal */
export const InputSyslog2$inboundSchema: z.ZodType<
  InputSyslog2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputSyslogType2$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSyslogConnection2$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSyslogPq2$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  timestampTimezone: z.string().default("local"),
  singleMsgUdpPackets: z.boolean().default(false),
  enableProxyHeader: z.boolean().default(false),
  keepFieldsList: z.array(z.string()).optional(),
  octetCounting: z.boolean().default(false),
  inferFraming: z.boolean().default(true),
  strictlyInferOctetCounting: z.boolean().default(true),
  allowNonStandardAppName: z.boolean().default(false),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  tls: z.lazy(() => InputSyslogTLSSettingsServerSide2$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputSyslogMetadatum2$inboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
  enableEnhancedProxyHeaderParsing: z.boolean().optional(),
});

/** @internal */
export type InputSyslog2$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSyslogConnection2$Outbound> | undefined;
  pq?: InputSyslogPq2$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort: number;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  timestampTimezone: string;
  singleMsgUdpPackets: boolean;
  enableProxyHeader: boolean;
  keepFieldsList?: Array<string> | undefined;
  octetCounting: boolean;
  inferFraming: boolean;
  strictlyInferOctetCounting: boolean;
  allowNonStandardAppName: boolean;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  tls?: InputSyslogTLSSettingsServerSide2$Outbound | undefined;
  metadata?: Array<InputSyslogMetadatum2$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  enableLoadBalancing: boolean;
  description?: string | undefined;
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

/** @internal */
export const InputSyslog2$outboundSchema: z.ZodType<
  InputSyslog2$Outbound,
  z.ZodTypeDef,
  InputSyslog2
> = z.object({
  id: z.string(),
  type: InputSyslogType2$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSyslogConnection2$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSyslogPq2$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  timestampTimezone: z.string().default("local"),
  singleMsgUdpPackets: z.boolean().default(false),
  enableProxyHeader: z.boolean().default(false),
  keepFieldsList: z.array(z.string()).optional(),
  octetCounting: z.boolean().default(false),
  inferFraming: z.boolean().default(true),
  strictlyInferOctetCounting: z.boolean().default(true),
  allowNonStandardAppName: z.boolean().default(false),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  tls: z.lazy(() => InputSyslogTLSSettingsServerSide2$outboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => InputSyslogMetadatum2$outboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
  enableEnhancedProxyHeaderParsing: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslog2$ {
  /** @deprecated use `InputSyslog2$inboundSchema` instead. */
  export const inboundSchema = InputSyslog2$inboundSchema;
  /** @deprecated use `InputSyslog2$outboundSchema` instead. */
  export const outboundSchema = InputSyslog2$outboundSchema;
  /** @deprecated use `InputSyslog2$Outbound` instead. */
  export type Outbound = InputSyslog2$Outbound;
}

export function inputSyslog2ToJSON(inputSyslog2: InputSyslog2): string {
  return JSON.stringify(InputSyslog2$outboundSchema.parse(inputSyslog2));
}

export function inputSyslog2FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslog2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslog2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslog2' from JSON`,
  );
}

/** @internal */
export const InputSyslogType1$inboundSchema: z.ZodType<
  InputSyslogType1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSyslogType1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSyslogType1$outboundSchema: z.ZodType<
  InputSyslogType1,
  z.ZodTypeDef,
  InputSyslogType1
> = z.union([
  z.nativeEnum(InputSyslogType1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogType1$ {
  /** @deprecated use `InputSyslogType1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogType1$inboundSchema;
  /** @deprecated use `InputSyslogType1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogType1$outboundSchema;
}

/** @internal */
export const InputSyslogConnection1$inboundSchema: z.ZodType<
  InputSyslogConnection1,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputSyslogConnection1$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSyslogConnection1$outboundSchema: z.ZodType<
  InputSyslogConnection1$Outbound,
  z.ZodTypeDef,
  InputSyslogConnection1
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogConnection1$ {
  /** @deprecated use `InputSyslogConnection1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogConnection1$inboundSchema;
  /** @deprecated use `InputSyslogConnection1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogConnection1$outboundSchema;
  /** @deprecated use `InputSyslogConnection1$Outbound` instead. */
  export type Outbound = InputSyslogConnection1$Outbound;
}

export function inputSyslogConnection1ToJSON(
  inputSyslogConnection1: InputSyslogConnection1,
): string {
  return JSON.stringify(
    InputSyslogConnection1$outboundSchema.parse(inputSyslogConnection1),
  );
}

export function inputSyslogConnection1FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogConnection1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogConnection1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogConnection1' from JSON`,
  );
}

/** @internal */
export const InputSyslogMode1$inboundSchema: z.ZodType<
  InputSyslogMode1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSyslogMode1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSyslogMode1$outboundSchema: z.ZodType<
  InputSyslogMode1,
  z.ZodTypeDef,
  InputSyslogMode1
> = z.union([
  z.nativeEnum(InputSyslogMode1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMode1$ {
  /** @deprecated use `InputSyslogMode1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMode1$inboundSchema;
  /** @deprecated use `InputSyslogMode1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMode1$outboundSchema;
}

/** @internal */
export const InputSyslogCompression1$inboundSchema: z.ZodType<
  InputSyslogCompression1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSyslogCompression1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSyslogCompression1$outboundSchema: z.ZodType<
  InputSyslogCompression1,
  z.ZodTypeDef,
  InputSyslogCompression1
> = z.union([
  z.nativeEnum(InputSyslogCompression1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogCompression1$ {
  /** @deprecated use `InputSyslogCompression1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogCompression1$inboundSchema;
  /** @deprecated use `InputSyslogCompression1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogCompression1$outboundSchema;
}

/** @internal */
export const InputSyslogPq1$inboundSchema: z.ZodType<
  InputSyslogPq1,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSyslogMode1$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSyslogCompression1$inboundSchema.default("none"),
});

/** @internal */
export type InputSyslogPq1$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputSyslogPq1$outboundSchema: z.ZodType<
  InputSyslogPq1$Outbound,
  z.ZodTypeDef,
  InputSyslogPq1
> = z.object({
  mode: InputSyslogMode1$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSyslogCompression1$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogPq1$ {
  /** @deprecated use `InputSyslogPq1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogPq1$inboundSchema;
  /** @deprecated use `InputSyslogPq1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogPq1$outboundSchema;
  /** @deprecated use `InputSyslogPq1$Outbound` instead. */
  export type Outbound = InputSyslogPq1$Outbound;
}

export function inputSyslogPq1ToJSON(inputSyslogPq1: InputSyslogPq1): string {
  return JSON.stringify(InputSyslogPq1$outboundSchema.parse(inputSyslogPq1));
}

export function inputSyslogPq1FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogPq1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogPq1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogPq1' from JSON`,
  );
}

/** @internal */
export const InputSyslogMinimumTLSVersion1$inboundSchema: z.ZodType<
  InputSyslogMinimumTLSVersion1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSyslogMinimumTLSVersion1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSyslogMinimumTLSVersion1$outboundSchema: z.ZodType<
  InputSyslogMinimumTLSVersion1,
  z.ZodTypeDef,
  InputSyslogMinimumTLSVersion1
> = z.union([
  z.nativeEnum(InputSyslogMinimumTLSVersion1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMinimumTLSVersion1$ {
  /** @deprecated use `InputSyslogMinimumTLSVersion1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMinimumTLSVersion1$inboundSchema;
  /** @deprecated use `InputSyslogMinimumTLSVersion1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMinimumTLSVersion1$outboundSchema;
}

/** @internal */
export const InputSyslogMaximumTLSVersion1$inboundSchema: z.ZodType<
  InputSyslogMaximumTLSVersion1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSyslogMaximumTLSVersion1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSyslogMaximumTLSVersion1$outboundSchema: z.ZodType<
  InputSyslogMaximumTLSVersion1,
  z.ZodTypeDef,
  InputSyslogMaximumTLSVersion1
> = z.union([
  z.nativeEnum(InputSyslogMaximumTLSVersion1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMaximumTLSVersion1$ {
  /** @deprecated use `InputSyslogMaximumTLSVersion1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMaximumTLSVersion1$inboundSchema;
  /** @deprecated use `InputSyslogMaximumTLSVersion1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMaximumTLSVersion1$outboundSchema;
}

/** @internal */
export const InputSyslogTLSSettingsServerSide1$inboundSchema: z.ZodType<
  InputSyslogTLSSettingsServerSide1,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSyslogMinimumTLSVersion1$inboundSchema.optional(),
  maxVersion: InputSyslogMaximumTLSVersion1$inboundSchema.optional(),
});

/** @internal */
export type InputSyslogTLSSettingsServerSide1$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputSyslogTLSSettingsServerSide1$outboundSchema: z.ZodType<
  InputSyslogTLSSettingsServerSide1$Outbound,
  z.ZodTypeDef,
  InputSyslogTLSSettingsServerSide1
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSyslogMinimumTLSVersion1$outboundSchema.optional(),
  maxVersion: InputSyslogMaximumTLSVersion1$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogTLSSettingsServerSide1$ {
  /** @deprecated use `InputSyslogTLSSettingsServerSide1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogTLSSettingsServerSide1$inboundSchema;
  /** @deprecated use `InputSyslogTLSSettingsServerSide1$outboundSchema` instead. */
  export const outboundSchema =
    InputSyslogTLSSettingsServerSide1$outboundSchema;
  /** @deprecated use `InputSyslogTLSSettingsServerSide1$Outbound` instead. */
  export type Outbound = InputSyslogTLSSettingsServerSide1$Outbound;
}

export function inputSyslogTLSSettingsServerSide1ToJSON(
  inputSyslogTLSSettingsServerSide1: InputSyslogTLSSettingsServerSide1,
): string {
  return JSON.stringify(
    InputSyslogTLSSettingsServerSide1$outboundSchema.parse(
      inputSyslogTLSSettingsServerSide1,
    ),
  );
}

export function inputSyslogTLSSettingsServerSide1FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogTLSSettingsServerSide1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogTLSSettingsServerSide1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogTLSSettingsServerSide1' from JSON`,
  );
}

/** @internal */
export const InputSyslogMetadatum1$inboundSchema: z.ZodType<
  InputSyslogMetadatum1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSyslogMetadatum1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSyslogMetadatum1$outboundSchema: z.ZodType<
  InputSyslogMetadatum1$Outbound,
  z.ZodTypeDef,
  InputSyslogMetadatum1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogMetadatum1$ {
  /** @deprecated use `InputSyslogMetadatum1$inboundSchema` instead. */
  export const inboundSchema = InputSyslogMetadatum1$inboundSchema;
  /** @deprecated use `InputSyslogMetadatum1$outboundSchema` instead. */
  export const outboundSchema = InputSyslogMetadatum1$outboundSchema;
  /** @deprecated use `InputSyslogMetadatum1$Outbound` instead. */
  export type Outbound = InputSyslogMetadatum1$Outbound;
}

export function inputSyslogMetadatum1ToJSON(
  inputSyslogMetadatum1: InputSyslogMetadatum1,
): string {
  return JSON.stringify(
    InputSyslogMetadatum1$outboundSchema.parse(inputSyslogMetadatum1),
  );
}

export function inputSyslogMetadatum1FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogMetadatum1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogMetadatum1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogMetadatum1' from JSON`,
  );
}

/** @internal */
export const InputSyslog1$inboundSchema: z.ZodType<
  InputSyslog1,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputSyslogType1$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSyslogConnection1$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSyslogPq1$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  timestampTimezone: z.string().default("local"),
  singleMsgUdpPackets: z.boolean().default(false),
  enableProxyHeader: z.boolean().default(false),
  keepFieldsList: z.array(z.string()).optional(),
  octetCounting: z.boolean().default(false),
  inferFraming: z.boolean().default(true),
  strictlyInferOctetCounting: z.boolean().default(true),
  allowNonStandardAppName: z.boolean().default(false),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  tls: z.lazy(() => InputSyslogTLSSettingsServerSide1$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputSyslogMetadatum1$inboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
  enableEnhancedProxyHeaderParsing: z.boolean().optional(),
});

/** @internal */
export type InputSyslog1$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSyslogConnection1$Outbound> | undefined;
  pq?: InputSyslogPq1$Outbound | undefined;
  host: string;
  udpPort: number;
  tcpPort?: number | undefined;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  timestampTimezone: string;
  singleMsgUdpPackets: boolean;
  enableProxyHeader: boolean;
  keepFieldsList?: Array<string> | undefined;
  octetCounting: boolean;
  inferFraming: boolean;
  strictlyInferOctetCounting: boolean;
  allowNonStandardAppName: boolean;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  tls?: InputSyslogTLSSettingsServerSide1$Outbound | undefined;
  metadata?: Array<InputSyslogMetadatum1$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  enableLoadBalancing: boolean;
  description?: string | undefined;
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

/** @internal */
export const InputSyslog1$outboundSchema: z.ZodType<
  InputSyslog1$Outbound,
  z.ZodTypeDef,
  InputSyslog1
> = z.object({
  id: z.string(),
  type: InputSyslogType1$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSyslogConnection1$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSyslogPq1$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  timestampTimezone: z.string().default("local"),
  singleMsgUdpPackets: z.boolean().default(false),
  enableProxyHeader: z.boolean().default(false),
  keepFieldsList: z.array(z.string()).optional(),
  octetCounting: z.boolean().default(false),
  inferFraming: z.boolean().default(true),
  strictlyInferOctetCounting: z.boolean().default(true),
  allowNonStandardAppName: z.boolean().default(false),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  tls: z.lazy(() => InputSyslogTLSSettingsServerSide1$outboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => InputSyslogMetadatum1$outboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
  enableEnhancedProxyHeaderParsing: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslog1$ {
  /** @deprecated use `InputSyslog1$inboundSchema` instead. */
  export const inboundSchema = InputSyslog1$inboundSchema;
  /** @deprecated use `InputSyslog1$outboundSchema` instead. */
  export const outboundSchema = InputSyslog1$outboundSchema;
  /** @deprecated use `InputSyslog1$Outbound` instead. */
  export type Outbound = InputSyslog1$Outbound;
}

export function inputSyslog1ToJSON(inputSyslog1: InputSyslog1): string {
  return JSON.stringify(InputSyslog1$outboundSchema.parse(inputSyslog1));
}

export function inputSyslog1FromJSON(
  jsonString: string,
): SafeParseResult<InputSyslog1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslog1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslog1' from JSON`,
  );
}

/** @internal */
export const InputSyslogUnion$inboundSchema: z.ZodType<
  InputSyslogUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputSyslog1$inboundSchema),
  z.lazy(() => InputSyslog2$inboundSchema),
]);

/** @internal */
export type InputSyslogUnion$Outbound =
  | InputSyslog1$Outbound
  | InputSyslog2$Outbound;

/** @internal */
export const InputSyslogUnion$outboundSchema: z.ZodType<
  InputSyslogUnion$Outbound,
  z.ZodTypeDef,
  InputSyslogUnion
> = z.union([
  z.lazy(() => InputSyslog1$outboundSchema),
  z.lazy(() => InputSyslog2$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSyslogUnion$ {
  /** @deprecated use `InputSyslogUnion$inboundSchema` instead. */
  export const inboundSchema = InputSyslogUnion$inboundSchema;
  /** @deprecated use `InputSyslogUnion$outboundSchema` instead. */
  export const outboundSchema = InputSyslogUnion$outboundSchema;
  /** @deprecated use `InputSyslogUnion$Outbound` instead. */
  export type Outbound = InputSyslogUnion$Outbound;
}

export function inputSyslogUnionToJSON(
  inputSyslogUnion: InputSyslogUnion,
): string {
  return JSON.stringify(
    InputSyslogUnion$outboundSchema.parse(inputSyslogUnion),
  );
}

export function inputSyslogUnionFromJSON(
  jsonString: string,
): SafeParseResult<InputSyslogUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSyslogUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSyslogUnion' from JSON`,
  );
}

/** @internal */
export const InputSqsType$inboundSchema: z.ZodType<
  InputSqsType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSqsType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSqsType$outboundSchema: z.ZodType<
  InputSqsType,
  z.ZodTypeDef,
  InputSqsType
> = z.union([
  z.nativeEnum(InputSqsType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSqsType$ {
  /** @deprecated use `InputSqsType$inboundSchema` instead. */
  export const inboundSchema = InputSqsType$inboundSchema;
  /** @deprecated use `InputSqsType$outboundSchema` instead. */
  export const outboundSchema = InputSqsType$outboundSchema;
}

/** @internal */
export const InputSqsConnection$inboundSchema: z.ZodType<
  InputSqsConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputSqsConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSqsConnection$outboundSchema: z.ZodType<
  InputSqsConnection$Outbound,
  z.ZodTypeDef,
  InputSqsConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSqsConnection$ {
  /** @deprecated use `InputSqsConnection$inboundSchema` instead. */
  export const inboundSchema = InputSqsConnection$inboundSchema;
  /** @deprecated use `InputSqsConnection$outboundSchema` instead. */
  export const outboundSchema = InputSqsConnection$outboundSchema;
  /** @deprecated use `InputSqsConnection$Outbound` instead. */
  export type Outbound = InputSqsConnection$Outbound;
}

export function inputSqsConnectionToJSON(
  inputSqsConnection: InputSqsConnection,
): string {
  return JSON.stringify(
    InputSqsConnection$outboundSchema.parse(inputSqsConnection),
  );
}

export function inputSqsConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputSqsConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSqsConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSqsConnection' from JSON`,
  );
}

/** @internal */
export const InputSqsMode$inboundSchema: z.ZodType<
  InputSqsMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSqsMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSqsMode$outboundSchema: z.ZodType<
  InputSqsMode,
  z.ZodTypeDef,
  InputSqsMode
> = z.union([
  z.nativeEnum(InputSqsMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSqsMode$ {
  /** @deprecated use `InputSqsMode$inboundSchema` instead. */
  export const inboundSchema = InputSqsMode$inboundSchema;
  /** @deprecated use `InputSqsMode$outboundSchema` instead. */
  export const outboundSchema = InputSqsMode$outboundSchema;
}

/** @internal */
export const InputSqsCompression$inboundSchema: z.ZodType<
  InputSqsCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSqsCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSqsCompression$outboundSchema: z.ZodType<
  InputSqsCompression,
  z.ZodTypeDef,
  InputSqsCompression
> = z.union([
  z.nativeEnum(InputSqsCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSqsCompression$ {
  /** @deprecated use `InputSqsCompression$inboundSchema` instead. */
  export const inboundSchema = InputSqsCompression$inboundSchema;
  /** @deprecated use `InputSqsCompression$outboundSchema` instead. */
  export const outboundSchema = InputSqsCompression$outboundSchema;
}

/** @internal */
export const InputSqsPq$inboundSchema: z.ZodType<
  InputSqsPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSqsMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSqsCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputSqsPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputSqsPq$outboundSchema: z.ZodType<
  InputSqsPq$Outbound,
  z.ZodTypeDef,
  InputSqsPq
> = z.object({
  mode: InputSqsMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSqsCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSqsPq$ {
  /** @deprecated use `InputSqsPq$inboundSchema` instead. */
  export const inboundSchema = InputSqsPq$inboundSchema;
  /** @deprecated use `InputSqsPq$outboundSchema` instead. */
  export const outboundSchema = InputSqsPq$outboundSchema;
  /** @deprecated use `InputSqsPq$Outbound` instead. */
  export type Outbound = InputSqsPq$Outbound;
}

export function inputSqsPqToJSON(inputSqsPq: InputSqsPq): string {
  return JSON.stringify(InputSqsPq$outboundSchema.parse(inputSqsPq));
}

export function inputSqsPqFromJSON(
  jsonString: string,
): SafeParseResult<InputSqsPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSqsPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSqsPq' from JSON`,
  );
}

/** @internal */
export const CreateInputQueueType$inboundSchema: z.ZodType<
  CreateInputQueueType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CreateInputQueueType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CreateInputQueueType$outboundSchema: z.ZodType<
  CreateInputQueueType,
  z.ZodTypeDef,
  CreateInputQueueType
> = z.union([
  z.nativeEnum(CreateInputQueueType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputQueueType$ {
  /** @deprecated use `CreateInputQueueType$inboundSchema` instead. */
  export const inboundSchema = CreateInputQueueType$inboundSchema;
  /** @deprecated use `CreateInputQueueType$outboundSchema` instead. */
  export const outboundSchema = CreateInputQueueType$outboundSchema;
}

/** @internal */
export const InputSqsAuthenticationMethod$inboundSchema: z.ZodType<
  InputSqsAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSqsAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSqsAuthenticationMethod$outboundSchema: z.ZodType<
  InputSqsAuthenticationMethod,
  z.ZodTypeDef,
  InputSqsAuthenticationMethod
> = z.union([
  z.nativeEnum(InputSqsAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSqsAuthenticationMethod$ {
  /** @deprecated use `InputSqsAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputSqsAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputSqsAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = InputSqsAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputSqsSignatureVersion$inboundSchema: z.ZodType<
  InputSqsSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSqsSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSqsSignatureVersion$outboundSchema: z.ZodType<
  InputSqsSignatureVersion,
  z.ZodTypeDef,
  InputSqsSignatureVersion
> = z.union([
  z.nativeEnum(InputSqsSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSqsSignatureVersion$ {
  /** @deprecated use `InputSqsSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = InputSqsSignatureVersion$inboundSchema;
  /** @deprecated use `InputSqsSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = InputSqsSignatureVersion$outboundSchema;
}

/** @internal */
export const InputSqsMetadatum$inboundSchema: z.ZodType<
  InputSqsMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSqsMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSqsMetadatum$outboundSchema: z.ZodType<
  InputSqsMetadatum$Outbound,
  z.ZodTypeDef,
  InputSqsMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSqsMetadatum$ {
  /** @deprecated use `InputSqsMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputSqsMetadatum$inboundSchema;
  /** @deprecated use `InputSqsMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputSqsMetadatum$outboundSchema;
  /** @deprecated use `InputSqsMetadatum$Outbound` instead. */
  export type Outbound = InputSqsMetadatum$Outbound;
}

export function inputSqsMetadatumToJSON(
  inputSqsMetadatum: InputSqsMetadatum,
): string {
  return JSON.stringify(
    InputSqsMetadatum$outboundSchema.parse(inputSqsMetadatum),
  );
}

export function inputSqsMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputSqsMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSqsMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSqsMetadatum' from JSON`,
  );
}

/** @internal */
export const InputSqs$inboundSchema: z.ZodType<
  InputSqs,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputSqsType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSqsConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSqsPq$inboundSchema).optional(),
  queueName: z.string(),
  queueType: CreateInputQueueType$inboundSchema.default("standard"),
  awsAccountId: z.string().optional(),
  createQueue: z.boolean().default(false),
  awsAuthenticationMethod: InputSqsAuthenticationMethod$inboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputSqsSignatureVersion$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxMessages: z.number().default(10),
  visibilityTimeout: z.number().default(600),
  metadata: z.array(z.lazy(() => InputSqsMetadatum$inboundSchema)).optional(),
  pollTimeout: z.number().default(10),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  numReceivers: z.number().default(3),
});

/** @internal */
export type InputSqs$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSqsConnection$Outbound> | undefined;
  pq?: InputSqsPq$Outbound | undefined;
  queueName: string;
  queueType: string;
  awsAccountId?: string | undefined;
  createQueue: boolean;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  maxMessages: number;
  visibilityTimeout: number;
  metadata?: Array<InputSqsMetadatum$Outbound> | undefined;
  pollTimeout: number;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  numReceivers: number;
};

/** @internal */
export const InputSqs$outboundSchema: z.ZodType<
  InputSqs$Outbound,
  z.ZodTypeDef,
  InputSqs
> = z.object({
  id: z.string(),
  type: InputSqsType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSqsConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSqsPq$outboundSchema).optional(),
  queueName: z.string(),
  queueType: CreateInputQueueType$outboundSchema.default("standard"),
  awsAccountId: z.string().optional(),
  createQueue: z.boolean().default(false),
  awsAuthenticationMethod: InputSqsAuthenticationMethod$outboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputSqsSignatureVersion$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  maxMessages: z.number().default(10),
  visibilityTimeout: z.number().default(600),
  metadata: z.array(z.lazy(() => InputSqsMetadatum$outboundSchema)).optional(),
  pollTimeout: z.number().default(10),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  numReceivers: z.number().default(3),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSqs$ {
  /** @deprecated use `InputSqs$inboundSchema` instead. */
  export const inboundSchema = InputSqs$inboundSchema;
  /** @deprecated use `InputSqs$outboundSchema` instead. */
  export const outboundSchema = InputSqs$outboundSchema;
  /** @deprecated use `InputSqs$Outbound` instead. */
  export type Outbound = InputSqs$Outbound;
}

export function inputSqsToJSON(inputSqs: InputSqs): string {
  return JSON.stringify(InputSqs$outboundSchema.parse(inputSqs));
}

export function inputSqsFromJSON(
  jsonString: string,
): SafeParseResult<InputSqs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSqs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSqs' from JSON`,
  );
}

/** @internal */
export const InputModelDrivenTelemetryType$inboundSchema: z.ZodType<
  InputModelDrivenTelemetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputModelDrivenTelemetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputModelDrivenTelemetryType$outboundSchema: z.ZodType<
  InputModelDrivenTelemetryType,
  z.ZodTypeDef,
  InputModelDrivenTelemetryType
> = z.union([
  z.nativeEnum(InputModelDrivenTelemetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModelDrivenTelemetryType$ {
  /** @deprecated use `InputModelDrivenTelemetryType$inboundSchema` instead. */
  export const inboundSchema = InputModelDrivenTelemetryType$inboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryType$outboundSchema` instead. */
  export const outboundSchema = InputModelDrivenTelemetryType$outboundSchema;
}

/** @internal */
export const InputModelDrivenTelemetryConnection$inboundSchema: z.ZodType<
  InputModelDrivenTelemetryConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputModelDrivenTelemetryConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputModelDrivenTelemetryConnection$outboundSchema: z.ZodType<
  InputModelDrivenTelemetryConnection$Outbound,
  z.ZodTypeDef,
  InputModelDrivenTelemetryConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModelDrivenTelemetryConnection$ {
  /** @deprecated use `InputModelDrivenTelemetryConnection$inboundSchema` instead. */
  export const inboundSchema =
    InputModelDrivenTelemetryConnection$inboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryConnection$outboundSchema` instead. */
  export const outboundSchema =
    InputModelDrivenTelemetryConnection$outboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryConnection$Outbound` instead. */
  export type Outbound = InputModelDrivenTelemetryConnection$Outbound;
}

export function inputModelDrivenTelemetryConnectionToJSON(
  inputModelDrivenTelemetryConnection: InputModelDrivenTelemetryConnection,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetryConnection$outboundSchema.parse(
      inputModelDrivenTelemetryConnection,
    ),
  );
}

export function inputModelDrivenTelemetryConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputModelDrivenTelemetryConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputModelDrivenTelemetryConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputModelDrivenTelemetryConnection' from JSON`,
  );
}

/** @internal */
export const InputModelDrivenTelemetryMode$inboundSchema: z.ZodType<
  InputModelDrivenTelemetryMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputModelDrivenTelemetryMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputModelDrivenTelemetryMode$outboundSchema: z.ZodType<
  InputModelDrivenTelemetryMode,
  z.ZodTypeDef,
  InputModelDrivenTelemetryMode
> = z.union([
  z.nativeEnum(InputModelDrivenTelemetryMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModelDrivenTelemetryMode$ {
  /** @deprecated use `InputModelDrivenTelemetryMode$inboundSchema` instead. */
  export const inboundSchema = InputModelDrivenTelemetryMode$inboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryMode$outboundSchema` instead. */
  export const outboundSchema = InputModelDrivenTelemetryMode$outboundSchema;
}

/** @internal */
export const InputModelDrivenTelemetryCompression$inboundSchema: z.ZodType<
  InputModelDrivenTelemetryCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputModelDrivenTelemetryCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputModelDrivenTelemetryCompression$outboundSchema: z.ZodType<
  InputModelDrivenTelemetryCompression,
  z.ZodTypeDef,
  InputModelDrivenTelemetryCompression
> = z.union([
  z.nativeEnum(InputModelDrivenTelemetryCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModelDrivenTelemetryCompression$ {
  /** @deprecated use `InputModelDrivenTelemetryCompression$inboundSchema` instead. */
  export const inboundSchema =
    InputModelDrivenTelemetryCompression$inboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryCompression$outboundSchema` instead. */
  export const outboundSchema =
    InputModelDrivenTelemetryCompression$outboundSchema;
}

/** @internal */
export const InputModelDrivenTelemetryPq$inboundSchema: z.ZodType<
  InputModelDrivenTelemetryPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputModelDrivenTelemetryMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputModelDrivenTelemetryCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputModelDrivenTelemetryPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputModelDrivenTelemetryPq$outboundSchema: z.ZodType<
  InputModelDrivenTelemetryPq$Outbound,
  z.ZodTypeDef,
  InputModelDrivenTelemetryPq
> = z.object({
  mode: InputModelDrivenTelemetryMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputModelDrivenTelemetryCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModelDrivenTelemetryPq$ {
  /** @deprecated use `InputModelDrivenTelemetryPq$inboundSchema` instead. */
  export const inboundSchema = InputModelDrivenTelemetryPq$inboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryPq$outboundSchema` instead. */
  export const outboundSchema = InputModelDrivenTelemetryPq$outboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryPq$Outbound` instead. */
  export type Outbound = InputModelDrivenTelemetryPq$Outbound;
}

export function inputModelDrivenTelemetryPqToJSON(
  inputModelDrivenTelemetryPq: InputModelDrivenTelemetryPq,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetryPq$outboundSchema.parse(
      inputModelDrivenTelemetryPq,
    ),
  );
}

export function inputModelDrivenTelemetryPqFromJSON(
  jsonString: string,
): SafeParseResult<InputModelDrivenTelemetryPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputModelDrivenTelemetryPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputModelDrivenTelemetryPq' from JSON`,
  );
}

/** @internal */
export const InputModelDrivenTelemetryMinimumTLSVersion$inboundSchema:
  z.ZodType<InputModelDrivenTelemetryMinimumTLSVersion, z.ZodTypeDef, unknown> =
    z
      .union([
        z.nativeEnum(InputModelDrivenTelemetryMinimumTLSVersion),
        z.string().transform(catchUnrecognizedEnum),
      ]);

/** @internal */
export const InputModelDrivenTelemetryMinimumTLSVersion$outboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryMinimumTLSVersion,
    z.ZodTypeDef,
    InputModelDrivenTelemetryMinimumTLSVersion
  > = z.union([
    z.nativeEnum(InputModelDrivenTelemetryMinimumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModelDrivenTelemetryMinimumTLSVersion$ {
  /** @deprecated use `InputModelDrivenTelemetryMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputModelDrivenTelemetryMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputModelDrivenTelemetryMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputModelDrivenTelemetryMaximumTLSVersion$inboundSchema:
  z.ZodType<InputModelDrivenTelemetryMaximumTLSVersion, z.ZodTypeDef, unknown> =
    z
      .union([
        z.nativeEnum(InputModelDrivenTelemetryMaximumTLSVersion),
        z.string().transform(catchUnrecognizedEnum),
      ]);

/** @internal */
export const InputModelDrivenTelemetryMaximumTLSVersion$outboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryMaximumTLSVersion,
    z.ZodTypeDef,
    InputModelDrivenTelemetryMaximumTLSVersion
  > = z.union([
    z.nativeEnum(InputModelDrivenTelemetryMaximumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModelDrivenTelemetryMaximumTLSVersion$ {
  /** @deprecated use `InputModelDrivenTelemetryMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputModelDrivenTelemetryMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputModelDrivenTelemetryMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputModelDrivenTelemetryTLSSettingsServerSide$inboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryTLSSettingsServerSide,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    certificateName: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    caPath: z.string().optional(),
    requestCert: z.boolean().default(false),
    rejectUnauthorized: z.any().optional(),
    commonNameRegex: z.any().optional(),
    minVersion: InputModelDrivenTelemetryMinimumTLSVersion$inboundSchema
      .optional(),
    maxVersion: InputModelDrivenTelemetryMaximumTLSVersion$inboundSchema
      .optional(),
  });

/** @internal */
export type InputModelDrivenTelemetryTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputModelDrivenTelemetryTLSSettingsServerSide$outboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryTLSSettingsServerSide$Outbound,
    z.ZodTypeDef,
    InputModelDrivenTelemetryTLSSettingsServerSide
  > = z.object({
    disabled: z.boolean().default(true),
    certificateName: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    caPath: z.string().optional(),
    requestCert: z.boolean().default(false),
    rejectUnauthorized: z.any().optional(),
    commonNameRegex: z.any().optional(),
    minVersion: InputModelDrivenTelemetryMinimumTLSVersion$outboundSchema
      .optional(),
    maxVersion: InputModelDrivenTelemetryMaximumTLSVersion$outboundSchema
      .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModelDrivenTelemetryTLSSettingsServerSide$ {
  /** @deprecated use `InputModelDrivenTelemetryTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema =
    InputModelDrivenTelemetryTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputModelDrivenTelemetryTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryTLSSettingsServerSide$Outbound` instead. */
  export type Outbound =
    InputModelDrivenTelemetryTLSSettingsServerSide$Outbound;
}

export function inputModelDrivenTelemetryTLSSettingsServerSideToJSON(
  inputModelDrivenTelemetryTLSSettingsServerSide:
    InputModelDrivenTelemetryTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetryTLSSettingsServerSide$outboundSchema.parse(
      inputModelDrivenTelemetryTLSSettingsServerSide,
    ),
  );
}

export function inputModelDrivenTelemetryTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<
  InputModelDrivenTelemetryTLSSettingsServerSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputModelDrivenTelemetryTLSSettingsServerSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputModelDrivenTelemetryTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputModelDrivenTelemetryMetadatum$inboundSchema: z.ZodType<
  InputModelDrivenTelemetryMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputModelDrivenTelemetryMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputModelDrivenTelemetryMetadatum$outboundSchema: z.ZodType<
  InputModelDrivenTelemetryMetadatum$Outbound,
  z.ZodTypeDef,
  InputModelDrivenTelemetryMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModelDrivenTelemetryMetadatum$ {
  /** @deprecated use `InputModelDrivenTelemetryMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputModelDrivenTelemetryMetadatum$inboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryMetadatum$outboundSchema` instead. */
  export const outboundSchema =
    InputModelDrivenTelemetryMetadatum$outboundSchema;
  /** @deprecated use `InputModelDrivenTelemetryMetadatum$Outbound` instead. */
  export type Outbound = InputModelDrivenTelemetryMetadatum$Outbound;
}

export function inputModelDrivenTelemetryMetadatumToJSON(
  inputModelDrivenTelemetryMetadatum: InputModelDrivenTelemetryMetadatum,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetryMetadatum$outboundSchema.parse(
      inputModelDrivenTelemetryMetadatum,
    ),
  );
}

export function inputModelDrivenTelemetryMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputModelDrivenTelemetryMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputModelDrivenTelemetryMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputModelDrivenTelemetryMetadatum' from JSON`,
  );
}

/** @internal */
export const InputModelDrivenTelemetry$inboundSchema: z.ZodType<
  InputModelDrivenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputModelDrivenTelemetryType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputModelDrivenTelemetryConnection$inboundSchema),
  ).optional(),
  pq: z.lazy(() => InputModelDrivenTelemetryPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(57000),
  tls: z.lazy(() =>
    InputModelDrivenTelemetryTLSSettingsServerSide$inboundSchema
  ).optional(),
  metadata: z.array(
    z.lazy(() => InputModelDrivenTelemetryMetadatum$inboundSchema),
  ).optional(),
  maxActiveCxn: z.number().default(1000),
  shutdownTimeoutMs: z.number().default(5000),
  description: z.string().optional(),
});

/** @internal */
export type InputModelDrivenTelemetry$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputModelDrivenTelemetryConnection$Outbound> | undefined;
  pq?: InputModelDrivenTelemetryPq$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputModelDrivenTelemetryTLSSettingsServerSide$Outbound | undefined;
  metadata?: Array<InputModelDrivenTelemetryMetadatum$Outbound> | undefined;
  maxActiveCxn: number;
  shutdownTimeoutMs: number;
  description?: string | undefined;
};

/** @internal */
export const InputModelDrivenTelemetry$outboundSchema: z.ZodType<
  InputModelDrivenTelemetry$Outbound,
  z.ZodTypeDef,
  InputModelDrivenTelemetry
> = z.object({
  id: z.string(),
  type: InputModelDrivenTelemetryType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputModelDrivenTelemetryConnection$outboundSchema),
  ).optional(),
  pq: z.lazy(() => InputModelDrivenTelemetryPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(57000),
  tls: z.lazy(() =>
    InputModelDrivenTelemetryTLSSettingsServerSide$outboundSchema
  ).optional(),
  metadata: z.array(
    z.lazy(() => InputModelDrivenTelemetryMetadatum$outboundSchema),
  ).optional(),
  maxActiveCxn: z.number().default(1000),
  shutdownTimeoutMs: z.number().default(5000),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputModelDrivenTelemetry$ {
  /** @deprecated use `InputModelDrivenTelemetry$inboundSchema` instead. */
  export const inboundSchema = InputModelDrivenTelemetry$inboundSchema;
  /** @deprecated use `InputModelDrivenTelemetry$outboundSchema` instead. */
  export const outboundSchema = InputModelDrivenTelemetry$outboundSchema;
  /** @deprecated use `InputModelDrivenTelemetry$Outbound` instead. */
  export type Outbound = InputModelDrivenTelemetry$Outbound;
}

export function inputModelDrivenTelemetryToJSON(
  inputModelDrivenTelemetry: InputModelDrivenTelemetry,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetry$outboundSchema.parse(inputModelDrivenTelemetry),
  );
}

export function inputModelDrivenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<InputModelDrivenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputModelDrivenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputModelDrivenTelemetry' from JSON`,
  );
}

/** @internal */
export const InputOpenTelemetryType$inboundSchema: z.ZodType<
  InputOpenTelemetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOpenTelemetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOpenTelemetryType$outboundSchema: z.ZodType<
  InputOpenTelemetryType,
  z.ZodTypeDef,
  InputOpenTelemetryType
> = z.union([
  z.nativeEnum(InputOpenTelemetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryType$ {
  /** @deprecated use `InputOpenTelemetryType$inboundSchema` instead. */
  export const inboundSchema = InputOpenTelemetryType$inboundSchema;
  /** @deprecated use `InputOpenTelemetryType$outboundSchema` instead. */
  export const outboundSchema = InputOpenTelemetryType$outboundSchema;
}

/** @internal */
export const InputOpenTelemetryConnection$inboundSchema: z.ZodType<
  InputOpenTelemetryConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputOpenTelemetryConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputOpenTelemetryConnection$outboundSchema: z.ZodType<
  InputOpenTelemetryConnection$Outbound,
  z.ZodTypeDef,
  InputOpenTelemetryConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryConnection$ {
  /** @deprecated use `InputOpenTelemetryConnection$inboundSchema` instead. */
  export const inboundSchema = InputOpenTelemetryConnection$inboundSchema;
  /** @deprecated use `InputOpenTelemetryConnection$outboundSchema` instead. */
  export const outboundSchema = InputOpenTelemetryConnection$outboundSchema;
  /** @deprecated use `InputOpenTelemetryConnection$Outbound` instead. */
  export type Outbound = InputOpenTelemetryConnection$Outbound;
}

export function inputOpenTelemetryConnectionToJSON(
  inputOpenTelemetryConnection: InputOpenTelemetryConnection,
): string {
  return JSON.stringify(
    InputOpenTelemetryConnection$outboundSchema.parse(
      inputOpenTelemetryConnection,
    ),
  );
}

export function inputOpenTelemetryConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputOpenTelemetryConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOpenTelemetryConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOpenTelemetryConnection' from JSON`,
  );
}

/** @internal */
export const InputOpenTelemetryMode$inboundSchema: z.ZodType<
  InputOpenTelemetryMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOpenTelemetryMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOpenTelemetryMode$outboundSchema: z.ZodType<
  InputOpenTelemetryMode,
  z.ZodTypeDef,
  InputOpenTelemetryMode
> = z.union([
  z.nativeEnum(InputOpenTelemetryMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryMode$ {
  /** @deprecated use `InputOpenTelemetryMode$inboundSchema` instead. */
  export const inboundSchema = InputOpenTelemetryMode$inboundSchema;
  /** @deprecated use `InputOpenTelemetryMode$outboundSchema` instead. */
  export const outboundSchema = InputOpenTelemetryMode$outboundSchema;
}

/** @internal */
export const InputOpenTelemetryCompression$inboundSchema: z.ZodType<
  InputOpenTelemetryCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOpenTelemetryCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOpenTelemetryCompression$outboundSchema: z.ZodType<
  InputOpenTelemetryCompression,
  z.ZodTypeDef,
  InputOpenTelemetryCompression
> = z.union([
  z.nativeEnum(InputOpenTelemetryCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryCompression$ {
  /** @deprecated use `InputOpenTelemetryCompression$inboundSchema` instead. */
  export const inboundSchema = InputOpenTelemetryCompression$inboundSchema;
  /** @deprecated use `InputOpenTelemetryCompression$outboundSchema` instead. */
  export const outboundSchema = InputOpenTelemetryCompression$outboundSchema;
}

/** @internal */
export const InputOpenTelemetryPq$inboundSchema: z.ZodType<
  InputOpenTelemetryPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputOpenTelemetryMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputOpenTelemetryCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputOpenTelemetryPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputOpenTelemetryPq$outboundSchema: z.ZodType<
  InputOpenTelemetryPq$Outbound,
  z.ZodTypeDef,
  InputOpenTelemetryPq
> = z.object({
  mode: InputOpenTelemetryMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputOpenTelemetryCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryPq$ {
  /** @deprecated use `InputOpenTelemetryPq$inboundSchema` instead. */
  export const inboundSchema = InputOpenTelemetryPq$inboundSchema;
  /** @deprecated use `InputOpenTelemetryPq$outboundSchema` instead. */
  export const outboundSchema = InputOpenTelemetryPq$outboundSchema;
  /** @deprecated use `InputOpenTelemetryPq$Outbound` instead. */
  export type Outbound = InputOpenTelemetryPq$Outbound;
}

export function inputOpenTelemetryPqToJSON(
  inputOpenTelemetryPq: InputOpenTelemetryPq,
): string {
  return JSON.stringify(
    InputOpenTelemetryPq$outboundSchema.parse(inputOpenTelemetryPq),
  );
}

export function inputOpenTelemetryPqFromJSON(
  jsonString: string,
): SafeParseResult<InputOpenTelemetryPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOpenTelemetryPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOpenTelemetryPq' from JSON`,
  );
}

/** @internal */
export const InputOpenTelemetryMinimumTLSVersion$inboundSchema: z.ZodType<
  InputOpenTelemetryMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOpenTelemetryMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOpenTelemetryMinimumTLSVersion$outboundSchema: z.ZodType<
  InputOpenTelemetryMinimumTLSVersion,
  z.ZodTypeDef,
  InputOpenTelemetryMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputOpenTelemetryMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryMinimumTLSVersion$ {
  /** @deprecated use `InputOpenTelemetryMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputOpenTelemetryMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputOpenTelemetryMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputOpenTelemetryMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputOpenTelemetryMaximumTLSVersion$inboundSchema: z.ZodType<
  InputOpenTelemetryMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOpenTelemetryMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOpenTelemetryMaximumTLSVersion$outboundSchema: z.ZodType<
  InputOpenTelemetryMaximumTLSVersion,
  z.ZodTypeDef,
  InputOpenTelemetryMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputOpenTelemetryMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryMaximumTLSVersion$ {
  /** @deprecated use `InputOpenTelemetryMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputOpenTelemetryMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputOpenTelemetryMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputOpenTelemetryMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputOpenTelemetryTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputOpenTelemetryTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputOpenTelemetryMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputOpenTelemetryMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputOpenTelemetryTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputOpenTelemetryTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputOpenTelemetryTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputOpenTelemetryTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputOpenTelemetryMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputOpenTelemetryMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryTLSSettingsServerSide$ {
  /** @deprecated use `InputOpenTelemetryTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema =
    InputOpenTelemetryTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputOpenTelemetryTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputOpenTelemetryTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputOpenTelemetryTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputOpenTelemetryTLSSettingsServerSide$Outbound;
}

export function inputOpenTelemetryTLSSettingsServerSideToJSON(
  inputOpenTelemetryTLSSettingsServerSide:
    InputOpenTelemetryTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputOpenTelemetryTLSSettingsServerSide$outboundSchema.parse(
      inputOpenTelemetryTLSSettingsServerSide,
    ),
  );
}

export function inputOpenTelemetryTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<
  InputOpenTelemetryTLSSettingsServerSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputOpenTelemetryTLSSettingsServerSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputOpenTelemetryTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputOpenTelemetryProtocol$inboundSchema: z.ZodType<
  InputOpenTelemetryProtocol,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOpenTelemetryProtocol),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOpenTelemetryProtocol$outboundSchema: z.ZodType<
  InputOpenTelemetryProtocol,
  z.ZodTypeDef,
  InputOpenTelemetryProtocol
> = z.union([
  z.nativeEnum(InputOpenTelemetryProtocol),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryProtocol$ {
  /** @deprecated use `InputOpenTelemetryProtocol$inboundSchema` instead. */
  export const inboundSchema = InputOpenTelemetryProtocol$inboundSchema;
  /** @deprecated use `InputOpenTelemetryProtocol$outboundSchema` instead. */
  export const outboundSchema = InputOpenTelemetryProtocol$outboundSchema;
}

/** @internal */
export const CreateInputOTLPVersion$inboundSchema: z.ZodType<
  CreateInputOTLPVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CreateInputOTLPVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CreateInputOTLPVersion$outboundSchema: z.ZodType<
  CreateInputOTLPVersion,
  z.ZodTypeDef,
  CreateInputOTLPVersion
> = z.union([
  z.nativeEnum(CreateInputOTLPVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputOTLPVersion$ {
  /** @deprecated use `CreateInputOTLPVersion$inboundSchema` instead. */
  export const inboundSchema = CreateInputOTLPVersion$inboundSchema;
  /** @deprecated use `CreateInputOTLPVersion$outboundSchema` instead. */
  export const outboundSchema = CreateInputOTLPVersion$outboundSchema;
}

/** @internal */
export const InputOpenTelemetryAuthenticationType$inboundSchema: z.ZodType<
  InputOpenTelemetryAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOpenTelemetryAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOpenTelemetryAuthenticationType$outboundSchema: z.ZodType<
  InputOpenTelemetryAuthenticationType,
  z.ZodTypeDef,
  InputOpenTelemetryAuthenticationType
> = z.union([
  z.nativeEnum(InputOpenTelemetryAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryAuthenticationType$ {
  /** @deprecated use `InputOpenTelemetryAuthenticationType$inboundSchema` instead. */
  export const inboundSchema =
    InputOpenTelemetryAuthenticationType$inboundSchema;
  /** @deprecated use `InputOpenTelemetryAuthenticationType$outboundSchema` instead. */
  export const outboundSchema =
    InputOpenTelemetryAuthenticationType$outboundSchema;
}

/** @internal */
export const InputOpenTelemetryMetadatum$inboundSchema: z.ZodType<
  InputOpenTelemetryMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputOpenTelemetryMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputOpenTelemetryMetadatum$outboundSchema: z.ZodType<
  InputOpenTelemetryMetadatum$Outbound,
  z.ZodTypeDef,
  InputOpenTelemetryMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryMetadatum$ {
  /** @deprecated use `InputOpenTelemetryMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputOpenTelemetryMetadatum$inboundSchema;
  /** @deprecated use `InputOpenTelemetryMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputOpenTelemetryMetadatum$outboundSchema;
  /** @deprecated use `InputOpenTelemetryMetadatum$Outbound` instead. */
  export type Outbound = InputOpenTelemetryMetadatum$Outbound;
}

export function inputOpenTelemetryMetadatumToJSON(
  inputOpenTelemetryMetadatum: InputOpenTelemetryMetadatum,
): string {
  return JSON.stringify(
    InputOpenTelemetryMetadatum$outboundSchema.parse(
      inputOpenTelemetryMetadatum,
    ),
  );
}

export function inputOpenTelemetryMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputOpenTelemetryMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOpenTelemetryMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOpenTelemetryMetadatum' from JSON`,
  );
}

/** @internal */
export const InputOpenTelemetryOauthParam$inboundSchema: z.ZodType<
  InputOpenTelemetryOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputOpenTelemetryOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputOpenTelemetryOauthParam$outboundSchema: z.ZodType<
  InputOpenTelemetryOauthParam$Outbound,
  z.ZodTypeDef,
  InputOpenTelemetryOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryOauthParam$ {
  /** @deprecated use `InputOpenTelemetryOauthParam$inboundSchema` instead. */
  export const inboundSchema = InputOpenTelemetryOauthParam$inboundSchema;
  /** @deprecated use `InputOpenTelemetryOauthParam$outboundSchema` instead. */
  export const outboundSchema = InputOpenTelemetryOauthParam$outboundSchema;
  /** @deprecated use `InputOpenTelemetryOauthParam$Outbound` instead. */
  export type Outbound = InputOpenTelemetryOauthParam$Outbound;
}

export function inputOpenTelemetryOauthParamToJSON(
  inputOpenTelemetryOauthParam: InputOpenTelemetryOauthParam,
): string {
  return JSON.stringify(
    InputOpenTelemetryOauthParam$outboundSchema.parse(
      inputOpenTelemetryOauthParam,
    ),
  );
}

export function inputOpenTelemetryOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<InputOpenTelemetryOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOpenTelemetryOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOpenTelemetryOauthParam' from JSON`,
  );
}

/** @internal */
export const InputOpenTelemetryOauthHeader$inboundSchema: z.ZodType<
  InputOpenTelemetryOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputOpenTelemetryOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputOpenTelemetryOauthHeader$outboundSchema: z.ZodType<
  InputOpenTelemetryOauthHeader$Outbound,
  z.ZodTypeDef,
  InputOpenTelemetryOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetryOauthHeader$ {
  /** @deprecated use `InputOpenTelemetryOauthHeader$inboundSchema` instead. */
  export const inboundSchema = InputOpenTelemetryOauthHeader$inboundSchema;
  /** @deprecated use `InputOpenTelemetryOauthHeader$outboundSchema` instead. */
  export const outboundSchema = InputOpenTelemetryOauthHeader$outboundSchema;
  /** @deprecated use `InputOpenTelemetryOauthHeader$Outbound` instead. */
  export type Outbound = InputOpenTelemetryOauthHeader$Outbound;
}

export function inputOpenTelemetryOauthHeaderToJSON(
  inputOpenTelemetryOauthHeader: InputOpenTelemetryOauthHeader,
): string {
  return JSON.stringify(
    InputOpenTelemetryOauthHeader$outboundSchema.parse(
      inputOpenTelemetryOauthHeader,
    ),
  );
}

export function inputOpenTelemetryOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<InputOpenTelemetryOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOpenTelemetryOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOpenTelemetryOauthHeader' from JSON`,
  );
}

/** @internal */
export const InputOpenTelemetry$inboundSchema: z.ZodType<
  InputOpenTelemetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputOpenTelemetryType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputOpenTelemetryConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputOpenTelemetryPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(4317),
  tls: z.lazy(() => InputOpenTelemetryTLSSettingsServerSide$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.any().optional(),
  captureHeaders: z.any().optional(),
  activityLogSampleRate: z.any().optional(),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(15),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  protocol: InputOpenTelemetryProtocol$inboundSchema.default("grpc"),
  extractSpans: z.boolean().default(false),
  extractMetrics: z.boolean().default(false),
  otlpVersion: CreateInputOTLPVersion$inboundSchema.default("0.10.0"),
  authType: InputOpenTelemetryAuthenticationType$inboundSchema.default("none"),
  metadata: z.array(z.lazy(() => InputOpenTelemetryMetadatum$inboundSchema))
    .optional(),
  maxActiveCxn: z.number().default(1000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => InputOpenTelemetryOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(
    z.lazy(() => InputOpenTelemetryOauthHeader$inboundSchema),
  ).optional(),
  extractLogs: z.boolean().default(false),
});

/** @internal */
export type InputOpenTelemetry$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputOpenTelemetryConnection$Outbound> | undefined;
  pq?: InputOpenTelemetryPq$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputOpenTelemetryTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader?: any | undefined;
  captureHeaders?: any | undefined;
  activityLogSampleRate?: any | undefined;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  protocol: string;
  extractSpans: boolean;
  extractMetrics: boolean;
  otlpVersion: string;
  authType: string;
  metadata?: Array<InputOpenTelemetryMetadatum$Outbound> | undefined;
  maxActiveCxn: number;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<InputOpenTelemetryOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<InputOpenTelemetryOauthHeader$Outbound> | undefined;
  extractLogs: boolean;
};

/** @internal */
export const InputOpenTelemetry$outboundSchema: z.ZodType<
  InputOpenTelemetry$Outbound,
  z.ZodTypeDef,
  InputOpenTelemetry
> = z.object({
  id: z.string(),
  type: InputOpenTelemetryType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputOpenTelemetryConnection$outboundSchema),
  ).optional(),
  pq: z.lazy(() => InputOpenTelemetryPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(4317),
  tls: z.lazy(() => InputOpenTelemetryTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.any().optional(),
  captureHeaders: z.any().optional(),
  activityLogSampleRate: z.any().optional(),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(15),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  protocol: InputOpenTelemetryProtocol$outboundSchema.default("grpc"),
  extractSpans: z.boolean().default(false),
  extractMetrics: z.boolean().default(false),
  otlpVersion: CreateInputOTLPVersion$outboundSchema.default("0.10.0"),
  authType: InputOpenTelemetryAuthenticationType$outboundSchema.default("none"),
  metadata: z.array(z.lazy(() => InputOpenTelemetryMetadatum$outboundSchema))
    .optional(),
  maxActiveCxn: z.number().default(1000),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(
    z.lazy(() => InputOpenTelemetryOauthParam$outboundSchema),
  ).optional(),
  oauthHeaders: z.array(
    z.lazy(() => InputOpenTelemetryOauthHeader$outboundSchema),
  ).optional(),
  extractLogs: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOpenTelemetry$ {
  /** @deprecated use `InputOpenTelemetry$inboundSchema` instead. */
  export const inboundSchema = InputOpenTelemetry$inboundSchema;
  /** @deprecated use `InputOpenTelemetry$outboundSchema` instead. */
  export const outboundSchema = InputOpenTelemetry$outboundSchema;
  /** @deprecated use `InputOpenTelemetry$Outbound` instead. */
  export type Outbound = InputOpenTelemetry$Outbound;
}

export function inputOpenTelemetryToJSON(
  inputOpenTelemetry: InputOpenTelemetry,
): string {
  return JSON.stringify(
    InputOpenTelemetry$outboundSchema.parse(inputOpenTelemetry),
  );
}

export function inputOpenTelemetryFromJSON(
  jsonString: string,
): SafeParseResult<InputOpenTelemetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOpenTelemetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOpenTelemetry' from JSON`,
  );
}

/** @internal */
export const InputSnmpType$inboundSchema: z.ZodType<
  InputSnmpType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSnmpType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSnmpType$outboundSchema: z.ZodType<
  InputSnmpType,
  z.ZodTypeDef,
  InputSnmpType
> = z.union([
  z.nativeEnum(InputSnmpType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSnmpType$ {
  /** @deprecated use `InputSnmpType$inboundSchema` instead. */
  export const inboundSchema = InputSnmpType$inboundSchema;
  /** @deprecated use `InputSnmpType$outboundSchema` instead. */
  export const outboundSchema = InputSnmpType$outboundSchema;
}

/** @internal */
export const InputSnmpConnection$inboundSchema: z.ZodType<
  InputSnmpConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputSnmpConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSnmpConnection$outboundSchema: z.ZodType<
  InputSnmpConnection$Outbound,
  z.ZodTypeDef,
  InputSnmpConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSnmpConnection$ {
  /** @deprecated use `InputSnmpConnection$inboundSchema` instead. */
  export const inboundSchema = InputSnmpConnection$inboundSchema;
  /** @deprecated use `InputSnmpConnection$outboundSchema` instead. */
  export const outboundSchema = InputSnmpConnection$outboundSchema;
  /** @deprecated use `InputSnmpConnection$Outbound` instead. */
  export type Outbound = InputSnmpConnection$Outbound;
}

export function inputSnmpConnectionToJSON(
  inputSnmpConnection: InputSnmpConnection,
): string {
  return JSON.stringify(
    InputSnmpConnection$outboundSchema.parse(inputSnmpConnection),
  );
}

export function inputSnmpConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputSnmpConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSnmpConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSnmpConnection' from JSON`,
  );
}

/** @internal */
export const InputSnmpMode$inboundSchema: z.ZodType<
  InputSnmpMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSnmpMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSnmpMode$outboundSchema: z.ZodType<
  InputSnmpMode,
  z.ZodTypeDef,
  InputSnmpMode
> = z.union([
  z.nativeEnum(InputSnmpMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSnmpMode$ {
  /** @deprecated use `InputSnmpMode$inboundSchema` instead. */
  export const inboundSchema = InputSnmpMode$inboundSchema;
  /** @deprecated use `InputSnmpMode$outboundSchema` instead. */
  export const outboundSchema = InputSnmpMode$outboundSchema;
}

/** @internal */
export const InputSnmpCompression$inboundSchema: z.ZodType<
  InputSnmpCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSnmpCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSnmpCompression$outboundSchema: z.ZodType<
  InputSnmpCompression,
  z.ZodTypeDef,
  InputSnmpCompression
> = z.union([
  z.nativeEnum(InputSnmpCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSnmpCompression$ {
  /** @deprecated use `InputSnmpCompression$inboundSchema` instead. */
  export const inboundSchema = InputSnmpCompression$inboundSchema;
  /** @deprecated use `InputSnmpCompression$outboundSchema` instead. */
  export const outboundSchema = InputSnmpCompression$outboundSchema;
}

/** @internal */
export const InputSnmpPq$inboundSchema: z.ZodType<
  InputSnmpPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSnmpMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSnmpCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputSnmpPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputSnmpPq$outboundSchema: z.ZodType<
  InputSnmpPq$Outbound,
  z.ZodTypeDef,
  InputSnmpPq
> = z.object({
  mode: InputSnmpMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSnmpCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSnmpPq$ {
  /** @deprecated use `InputSnmpPq$inboundSchema` instead. */
  export const inboundSchema = InputSnmpPq$inboundSchema;
  /** @deprecated use `InputSnmpPq$outboundSchema` instead. */
  export const outboundSchema = InputSnmpPq$outboundSchema;
  /** @deprecated use `InputSnmpPq$Outbound` instead. */
  export type Outbound = InputSnmpPq$Outbound;
}

export function inputSnmpPqToJSON(inputSnmpPq: InputSnmpPq): string {
  return JSON.stringify(InputSnmpPq$outboundSchema.parse(inputSnmpPq));
}

export function inputSnmpPqFromJSON(
  jsonString: string,
): SafeParseResult<InputSnmpPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSnmpPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSnmpPq' from JSON`,
  );
}

/** @internal */
export const AuthenticationProtocol$inboundSchema: z.ZodType<
  AuthenticationProtocol,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(AuthenticationProtocol),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const AuthenticationProtocol$outboundSchema: z.ZodType<
  AuthenticationProtocol,
  z.ZodTypeDef,
  AuthenticationProtocol
> = z.union([
  z.nativeEnum(AuthenticationProtocol),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AuthenticationProtocol$ {
  /** @deprecated use `AuthenticationProtocol$inboundSchema` instead. */
  export const inboundSchema = AuthenticationProtocol$inboundSchema;
  /** @deprecated use `AuthenticationProtocol$outboundSchema` instead. */
  export const outboundSchema = AuthenticationProtocol$outboundSchema;
}

/** @internal */
export const V3User$inboundSchema: z.ZodType<V3User, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string(),
    authProtocol: AuthenticationProtocol$inboundSchema.default("none"),
    authKey: z.any().optional(),
    privProtocol: z.string().default("none"),
  });

/** @internal */
export type V3User$Outbound = {
  name: string;
  authProtocol: string;
  authKey?: any | undefined;
  privProtocol: string;
};

/** @internal */
export const V3User$outboundSchema: z.ZodType<
  V3User$Outbound,
  z.ZodTypeDef,
  V3User
> = z.object({
  name: z.string(),
  authProtocol: AuthenticationProtocol$outboundSchema.default("none"),
  authKey: z.any().optional(),
  privProtocol: z.string().default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace V3User$ {
  /** @deprecated use `V3User$inboundSchema` instead. */
  export const inboundSchema = V3User$inboundSchema;
  /** @deprecated use `V3User$outboundSchema` instead. */
  export const outboundSchema = V3User$outboundSchema;
  /** @deprecated use `V3User$Outbound` instead. */
  export type Outbound = V3User$Outbound;
}

export function v3UserToJSON(v3User: V3User): string {
  return JSON.stringify(V3User$outboundSchema.parse(v3User));
}

export function v3UserFromJSON(
  jsonString: string,
): SafeParseResult<V3User, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => V3User$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'V3User' from JSON`,
  );
}

/** @internal */
export const SNMPv3Authentication$inboundSchema: z.ZodType<
  SNMPv3Authentication,
  z.ZodTypeDef,
  unknown
> = z.object({
  v3AuthEnabled: z.boolean().default(false),
  allowUnmatchedTrap: z.boolean().default(false),
  v3Users: z.array(z.lazy(() => V3User$inboundSchema)).optional(),
});

/** @internal */
export type SNMPv3Authentication$Outbound = {
  v3AuthEnabled: boolean;
  allowUnmatchedTrap: boolean;
  v3Users?: Array<V3User$Outbound> | undefined;
};

/** @internal */
export const SNMPv3Authentication$outboundSchema: z.ZodType<
  SNMPv3Authentication$Outbound,
  z.ZodTypeDef,
  SNMPv3Authentication
> = z.object({
  v3AuthEnabled: z.boolean().default(false),
  allowUnmatchedTrap: z.boolean().default(false),
  v3Users: z.array(z.lazy(() => V3User$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SNMPv3Authentication$ {
  /** @deprecated use `SNMPv3Authentication$inboundSchema` instead. */
  export const inboundSchema = SNMPv3Authentication$inboundSchema;
  /** @deprecated use `SNMPv3Authentication$outboundSchema` instead. */
  export const outboundSchema = SNMPv3Authentication$outboundSchema;
  /** @deprecated use `SNMPv3Authentication$Outbound` instead. */
  export type Outbound = SNMPv3Authentication$Outbound;
}

export function snmPv3AuthenticationToJSON(
  snmPv3Authentication: SNMPv3Authentication,
): string {
  return JSON.stringify(
    SNMPv3Authentication$outboundSchema.parse(snmPv3Authentication),
  );
}

export function snmPv3AuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<SNMPv3Authentication, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SNMPv3Authentication$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SNMPv3Authentication' from JSON`,
  );
}

/** @internal */
export const InputSnmpMetadatum$inboundSchema: z.ZodType<
  InputSnmpMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSnmpMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSnmpMetadatum$outboundSchema: z.ZodType<
  InputSnmpMetadatum$Outbound,
  z.ZodTypeDef,
  InputSnmpMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSnmpMetadatum$ {
  /** @deprecated use `InputSnmpMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputSnmpMetadatum$inboundSchema;
  /** @deprecated use `InputSnmpMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputSnmpMetadatum$outboundSchema;
  /** @deprecated use `InputSnmpMetadatum$Outbound` instead. */
  export type Outbound = InputSnmpMetadatum$Outbound;
}

export function inputSnmpMetadatumToJSON(
  inputSnmpMetadatum: InputSnmpMetadatum,
): string {
  return JSON.stringify(
    InputSnmpMetadatum$outboundSchema.parse(inputSnmpMetadatum),
  );
}

export function inputSnmpMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputSnmpMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSnmpMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSnmpMetadatum' from JSON`,
  );
}

/** @internal */
export const InputSnmp$inboundSchema: z.ZodType<
  InputSnmp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputSnmpType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSnmpConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSnmpPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(162),
  snmpV3Auth: z.lazy(() => SNMPv3Authentication$inboundSchema).optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  metadata: z.array(z.lazy(() => InputSnmpMetadatum$inboundSchema)).optional(),
  udpSocketRxBufSize: z.number().optional(),
  varbindsWithTypes: z.boolean().default(false),
  bestEffortParsing: z.boolean().default(false),
  description: z.string().optional(),
});

/** @internal */
export type InputSnmp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSnmpConnection$Outbound> | undefined;
  pq?: InputSnmpPq$Outbound | undefined;
  host: string;
  port: number;
  snmpV3Auth?: SNMPv3Authentication$Outbound | undefined;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  metadata?: Array<InputSnmpMetadatum$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  varbindsWithTypes: boolean;
  bestEffortParsing: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputSnmp$outboundSchema: z.ZodType<
  InputSnmp$Outbound,
  z.ZodTypeDef,
  InputSnmp
> = z.object({
  id: z.string(),
  type: InputSnmpType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSnmpConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSnmpPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number().default(162),
  snmpV3Auth: z.lazy(() => SNMPv3Authentication$outboundSchema).optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  metadata: z.array(z.lazy(() => InputSnmpMetadatum$outboundSchema)).optional(),
  udpSocketRxBufSize: z.number().optional(),
  varbindsWithTypes: z.boolean().default(false),
  bestEffortParsing: z.boolean().default(false),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSnmp$ {
  /** @deprecated use `InputSnmp$inboundSchema` instead. */
  export const inboundSchema = InputSnmp$inboundSchema;
  /** @deprecated use `InputSnmp$outboundSchema` instead. */
  export const outboundSchema = InputSnmp$outboundSchema;
  /** @deprecated use `InputSnmp$Outbound` instead. */
  export type Outbound = InputSnmp$Outbound;
}

export function inputSnmpToJSON(inputSnmp: InputSnmp): string {
  return JSON.stringify(InputSnmp$outboundSchema.parse(inputSnmp));
}

export function inputSnmpFromJSON(
  jsonString: string,
): SafeParseResult<InputSnmp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSnmp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSnmp' from JSON`,
  );
}

/** @internal */
export const InputS3InventoryType$inboundSchema: z.ZodType<
  InputS3InventoryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputS3InventoryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputS3InventoryType$outboundSchema: z.ZodType<
  InputS3InventoryType,
  z.ZodTypeDef,
  InputS3InventoryType
> = z.union([
  z.nativeEnum(InputS3InventoryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3InventoryType$ {
  /** @deprecated use `InputS3InventoryType$inboundSchema` instead. */
  export const inboundSchema = InputS3InventoryType$inboundSchema;
  /** @deprecated use `InputS3InventoryType$outboundSchema` instead. */
  export const outboundSchema = InputS3InventoryType$outboundSchema;
}

/** @internal */
export const InputS3InventoryConnection$inboundSchema: z.ZodType<
  InputS3InventoryConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputS3InventoryConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputS3InventoryConnection$outboundSchema: z.ZodType<
  InputS3InventoryConnection$Outbound,
  z.ZodTypeDef,
  InputS3InventoryConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3InventoryConnection$ {
  /** @deprecated use `InputS3InventoryConnection$inboundSchema` instead. */
  export const inboundSchema = InputS3InventoryConnection$inboundSchema;
  /** @deprecated use `InputS3InventoryConnection$outboundSchema` instead. */
  export const outboundSchema = InputS3InventoryConnection$outboundSchema;
  /** @deprecated use `InputS3InventoryConnection$Outbound` instead. */
  export type Outbound = InputS3InventoryConnection$Outbound;
}

export function inputS3InventoryConnectionToJSON(
  inputS3InventoryConnection: InputS3InventoryConnection,
): string {
  return JSON.stringify(
    InputS3InventoryConnection$outboundSchema.parse(inputS3InventoryConnection),
  );
}

export function inputS3InventoryConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputS3InventoryConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3InventoryConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3InventoryConnection' from JSON`,
  );
}

/** @internal */
export const InputS3InventoryMode$inboundSchema: z.ZodType<
  InputS3InventoryMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputS3InventoryMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputS3InventoryMode$outboundSchema: z.ZodType<
  InputS3InventoryMode,
  z.ZodTypeDef,
  InputS3InventoryMode
> = z.union([
  z.nativeEnum(InputS3InventoryMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3InventoryMode$ {
  /** @deprecated use `InputS3InventoryMode$inboundSchema` instead. */
  export const inboundSchema = InputS3InventoryMode$inboundSchema;
  /** @deprecated use `InputS3InventoryMode$outboundSchema` instead. */
  export const outboundSchema = InputS3InventoryMode$outboundSchema;
}

/** @internal */
export const InputS3InventoryCompression$inboundSchema: z.ZodType<
  InputS3InventoryCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputS3InventoryCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputS3InventoryCompression$outboundSchema: z.ZodType<
  InputS3InventoryCompression,
  z.ZodTypeDef,
  InputS3InventoryCompression
> = z.union([
  z.nativeEnum(InputS3InventoryCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3InventoryCompression$ {
  /** @deprecated use `InputS3InventoryCompression$inboundSchema` instead. */
  export const inboundSchema = InputS3InventoryCompression$inboundSchema;
  /** @deprecated use `InputS3InventoryCompression$outboundSchema` instead. */
  export const outboundSchema = InputS3InventoryCompression$outboundSchema;
}

/** @internal */
export const InputS3InventoryPq$inboundSchema: z.ZodType<
  InputS3InventoryPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputS3InventoryMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputS3InventoryCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputS3InventoryPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputS3InventoryPq$outboundSchema: z.ZodType<
  InputS3InventoryPq$Outbound,
  z.ZodTypeDef,
  InputS3InventoryPq
> = z.object({
  mode: InputS3InventoryMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputS3InventoryCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3InventoryPq$ {
  /** @deprecated use `InputS3InventoryPq$inboundSchema` instead. */
  export const inboundSchema = InputS3InventoryPq$inboundSchema;
  /** @deprecated use `InputS3InventoryPq$outboundSchema` instead. */
  export const outboundSchema = InputS3InventoryPq$outboundSchema;
  /** @deprecated use `InputS3InventoryPq$Outbound` instead. */
  export type Outbound = InputS3InventoryPq$Outbound;
}

export function inputS3InventoryPqToJSON(
  inputS3InventoryPq: InputS3InventoryPq,
): string {
  return JSON.stringify(
    InputS3InventoryPq$outboundSchema.parse(inputS3InventoryPq),
  );
}

export function inputS3InventoryPqFromJSON(
  jsonString: string,
): SafeParseResult<InputS3InventoryPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3InventoryPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3InventoryPq' from JSON`,
  );
}

/** @internal */
export const InputS3InventoryAuthenticationMethod$inboundSchema: z.ZodType<
  InputS3InventoryAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputS3InventoryAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputS3InventoryAuthenticationMethod$outboundSchema: z.ZodType<
  InputS3InventoryAuthenticationMethod,
  z.ZodTypeDef,
  InputS3InventoryAuthenticationMethod
> = z.union([
  z.nativeEnum(InputS3InventoryAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3InventoryAuthenticationMethod$ {
  /** @deprecated use `InputS3InventoryAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputS3InventoryAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputS3InventoryAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputS3InventoryAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputS3InventorySignatureVersion$inboundSchema: z.ZodType<
  InputS3InventorySignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputS3InventorySignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputS3InventorySignatureVersion$outboundSchema: z.ZodType<
  InputS3InventorySignatureVersion,
  z.ZodTypeDef,
  InputS3InventorySignatureVersion
> = z.union([
  z.nativeEnum(InputS3InventorySignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3InventorySignatureVersion$ {
  /** @deprecated use `InputS3InventorySignatureVersion$inboundSchema` instead. */
  export const inboundSchema = InputS3InventorySignatureVersion$inboundSchema;
  /** @deprecated use `InputS3InventorySignatureVersion$outboundSchema` instead. */
  export const outboundSchema = InputS3InventorySignatureVersion$outboundSchema;
}

/** @internal */
export const InputS3InventoryPreprocess$inboundSchema: z.ZodType<
  InputS3InventoryPreprocess,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/** @internal */
export type InputS3InventoryPreprocess$Outbound = {
  disabled: boolean;
  command?: string | undefined;
  args?: Array<string> | undefined;
};

/** @internal */
export const InputS3InventoryPreprocess$outboundSchema: z.ZodType<
  InputS3InventoryPreprocess$Outbound,
  z.ZodTypeDef,
  InputS3InventoryPreprocess
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3InventoryPreprocess$ {
  /** @deprecated use `InputS3InventoryPreprocess$inboundSchema` instead. */
  export const inboundSchema = InputS3InventoryPreprocess$inboundSchema;
  /** @deprecated use `InputS3InventoryPreprocess$outboundSchema` instead. */
  export const outboundSchema = InputS3InventoryPreprocess$outboundSchema;
  /** @deprecated use `InputS3InventoryPreprocess$Outbound` instead. */
  export type Outbound = InputS3InventoryPreprocess$Outbound;
}

export function inputS3InventoryPreprocessToJSON(
  inputS3InventoryPreprocess: InputS3InventoryPreprocess,
): string {
  return JSON.stringify(
    InputS3InventoryPreprocess$outboundSchema.parse(inputS3InventoryPreprocess),
  );
}

export function inputS3InventoryPreprocessFromJSON(
  jsonString: string,
): SafeParseResult<InputS3InventoryPreprocess, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3InventoryPreprocess$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3InventoryPreprocess' from JSON`,
  );
}

/** @internal */
export const InputS3InventoryMetadatum$inboundSchema: z.ZodType<
  InputS3InventoryMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputS3InventoryMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputS3InventoryMetadatum$outboundSchema: z.ZodType<
  InputS3InventoryMetadatum$Outbound,
  z.ZodTypeDef,
  InputS3InventoryMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3InventoryMetadatum$ {
  /** @deprecated use `InputS3InventoryMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputS3InventoryMetadatum$inboundSchema;
  /** @deprecated use `InputS3InventoryMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputS3InventoryMetadatum$outboundSchema;
  /** @deprecated use `InputS3InventoryMetadatum$Outbound` instead. */
  export type Outbound = InputS3InventoryMetadatum$Outbound;
}

export function inputS3InventoryMetadatumToJSON(
  inputS3InventoryMetadatum: InputS3InventoryMetadatum,
): string {
  return JSON.stringify(
    InputS3InventoryMetadatum$outboundSchema.parse(inputS3InventoryMetadatum),
  );
}

export function inputS3InventoryMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputS3InventoryMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3InventoryMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3InventoryMetadatum' from JSON`,
  );
}

/** @internal */
export const InputS3InventoryCheckpointing$inboundSchema: z.ZodType<
  InputS3InventoryCheckpointing,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/** @internal */
export type InputS3InventoryCheckpointing$Outbound = {
  enabled: boolean;
  retries: number;
};

/** @internal */
export const InputS3InventoryCheckpointing$outboundSchema: z.ZodType<
  InputS3InventoryCheckpointing$Outbound,
  z.ZodTypeDef,
  InputS3InventoryCheckpointing
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3InventoryCheckpointing$ {
  /** @deprecated use `InputS3InventoryCheckpointing$inboundSchema` instead. */
  export const inboundSchema = InputS3InventoryCheckpointing$inboundSchema;
  /** @deprecated use `InputS3InventoryCheckpointing$outboundSchema` instead. */
  export const outboundSchema = InputS3InventoryCheckpointing$outboundSchema;
  /** @deprecated use `InputS3InventoryCheckpointing$Outbound` instead. */
  export type Outbound = InputS3InventoryCheckpointing$Outbound;
}

export function inputS3InventoryCheckpointingToJSON(
  inputS3InventoryCheckpointing: InputS3InventoryCheckpointing,
): string {
  return JSON.stringify(
    InputS3InventoryCheckpointing$outboundSchema.parse(
      inputS3InventoryCheckpointing,
    ),
  );
}

export function inputS3InventoryCheckpointingFromJSON(
  jsonString: string,
): SafeParseResult<InputS3InventoryCheckpointing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3InventoryCheckpointing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3InventoryCheckpointing' from JSON`,
  );
}

/** @internal */
export const InputS3InventoryTagAfterProcessing$inboundSchema: z.ZodType<
  InputS3InventoryTagAfterProcessing,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputS3InventoryTagAfterProcessing),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputS3InventoryTagAfterProcessing$outboundSchema: z.ZodType<
  InputS3InventoryTagAfterProcessing,
  z.ZodTypeDef,
  InputS3InventoryTagAfterProcessing
> = z.union([
  z.nativeEnum(InputS3InventoryTagAfterProcessing),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3InventoryTagAfterProcessing$ {
  /** @deprecated use `InputS3InventoryTagAfterProcessing$inboundSchema` instead. */
  export const inboundSchema = InputS3InventoryTagAfterProcessing$inboundSchema;
  /** @deprecated use `InputS3InventoryTagAfterProcessing$outboundSchema` instead. */
  export const outboundSchema =
    InputS3InventoryTagAfterProcessing$outboundSchema;
}

/** @internal */
export const InputS3Inventory$inboundSchema: z.ZodType<
  InputS3Inventory,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputS3InventoryType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputS3InventoryConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputS3InventoryPq$inboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: InputS3InventoryAuthenticationMethod$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputS3InventorySignatureVersion$inboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => InputS3InventoryPreprocess$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputS3InventoryMetadatum$inboundSchema))
    .optional(),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  checkpointing: z.lazy(() => InputS3InventoryCheckpointing$inboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  checksumSuffix: z.string().default("checksum"),
  maxManifestSizeKB: z.number().int().default(4096),
  validateInventoryFiles: z.boolean().default(false),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: InputS3InventoryTagAfterProcessing$inboundSchema
    .optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/** @internal */
export type InputS3Inventory$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputS3InventoryConnection$Outbound> | undefined;
  pq?: InputS3InventoryPq$Outbound | undefined;
  queueName: string;
  fileFilter: string;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  maxMessages: number;
  visibilityTimeout: number;
  numReceivers: number;
  socketTimeout: number;
  skipOnError: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  enableSQSAssumeRole: boolean;
  preprocess?: InputS3InventoryPreprocess$Outbound | undefined;
  metadata?: Array<InputS3InventoryMetadatum$Outbound> | undefined;
  parquetChunkSizeMB: number;
  parquetChunkDownloadTimeout: number;
  checkpointing?: InputS3InventoryCheckpointing$Outbound | undefined;
  pollTimeout: number;
  checksumSuffix: string;
  maxManifestSizeKB: number;
  validateInventoryFiles: boolean;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputS3Inventory$outboundSchema: z.ZodType<
  InputS3Inventory$Outbound,
  z.ZodTypeDef,
  InputS3Inventory
> = z.object({
  id: z.string(),
  type: InputS3InventoryType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputS3InventoryConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputS3InventoryPq$outboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: InputS3InventoryAuthenticationMethod$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputS3InventorySignatureVersion$outboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => InputS3InventoryPreprocess$outboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => InputS3InventoryMetadatum$outboundSchema))
    .optional(),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  checkpointing: z.lazy(() => InputS3InventoryCheckpointing$outboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  checksumSuffix: z.string().default("checksum"),
  maxManifestSizeKB: z.number().int().default(4096),
  validateInventoryFiles: z.boolean().default(false),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: InputS3InventoryTagAfterProcessing$outboundSchema
    .optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3Inventory$ {
  /** @deprecated use `InputS3Inventory$inboundSchema` instead. */
  export const inboundSchema = InputS3Inventory$inboundSchema;
  /** @deprecated use `InputS3Inventory$outboundSchema` instead. */
  export const outboundSchema = InputS3Inventory$outboundSchema;
  /** @deprecated use `InputS3Inventory$Outbound` instead. */
  export type Outbound = InputS3Inventory$Outbound;
}

export function inputS3InventoryToJSON(
  inputS3Inventory: InputS3Inventory,
): string {
  return JSON.stringify(
    InputS3Inventory$outboundSchema.parse(inputS3Inventory),
  );
}

export function inputS3InventoryFromJSON(
  jsonString: string,
): SafeParseResult<InputS3Inventory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3Inventory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3Inventory' from JSON`,
  );
}

/** @internal */
export const InputS3Type$inboundSchema: z.ZodType<
  InputS3Type,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputS3Type),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputS3Type$outboundSchema: z.ZodType<
  InputS3Type,
  z.ZodTypeDef,
  InputS3Type
> = z.union([
  z.nativeEnum(InputS3Type),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3Type$ {
  /** @deprecated use `InputS3Type$inboundSchema` instead. */
  export const inboundSchema = InputS3Type$inboundSchema;
  /** @deprecated use `InputS3Type$outboundSchema` instead. */
  export const outboundSchema = InputS3Type$outboundSchema;
}

/** @internal */
export const InputS3Connection$inboundSchema: z.ZodType<
  InputS3Connection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputS3Connection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputS3Connection$outboundSchema: z.ZodType<
  InputS3Connection$Outbound,
  z.ZodTypeDef,
  InputS3Connection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3Connection$ {
  /** @deprecated use `InputS3Connection$inboundSchema` instead. */
  export const inboundSchema = InputS3Connection$inboundSchema;
  /** @deprecated use `InputS3Connection$outboundSchema` instead. */
  export const outboundSchema = InputS3Connection$outboundSchema;
  /** @deprecated use `InputS3Connection$Outbound` instead. */
  export type Outbound = InputS3Connection$Outbound;
}

export function inputS3ConnectionToJSON(
  inputS3Connection: InputS3Connection,
): string {
  return JSON.stringify(
    InputS3Connection$outboundSchema.parse(inputS3Connection),
  );
}

export function inputS3ConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputS3Connection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3Connection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3Connection' from JSON`,
  );
}

/** @internal */
export const InputS3Mode$inboundSchema: z.ZodType<
  InputS3Mode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputS3Mode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputS3Mode$outboundSchema: z.ZodType<
  InputS3Mode,
  z.ZodTypeDef,
  InputS3Mode
> = z.union([
  z.nativeEnum(InputS3Mode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3Mode$ {
  /** @deprecated use `InputS3Mode$inboundSchema` instead. */
  export const inboundSchema = InputS3Mode$inboundSchema;
  /** @deprecated use `InputS3Mode$outboundSchema` instead. */
  export const outboundSchema = InputS3Mode$outboundSchema;
}

/** @internal */
export const InputS3Compression$inboundSchema: z.ZodType<
  InputS3Compression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputS3Compression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputS3Compression$outboundSchema: z.ZodType<
  InputS3Compression,
  z.ZodTypeDef,
  InputS3Compression
> = z.union([
  z.nativeEnum(InputS3Compression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3Compression$ {
  /** @deprecated use `InputS3Compression$inboundSchema` instead. */
  export const inboundSchema = InputS3Compression$inboundSchema;
  /** @deprecated use `InputS3Compression$outboundSchema` instead. */
  export const outboundSchema = InputS3Compression$outboundSchema;
}

/** @internal */
export const InputS3Pq$inboundSchema: z.ZodType<
  InputS3Pq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputS3Mode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputS3Compression$inboundSchema.default("none"),
});

/** @internal */
export type InputS3Pq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputS3Pq$outboundSchema: z.ZodType<
  InputS3Pq$Outbound,
  z.ZodTypeDef,
  InputS3Pq
> = z.object({
  mode: InputS3Mode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputS3Compression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3Pq$ {
  /** @deprecated use `InputS3Pq$inboundSchema` instead. */
  export const inboundSchema = InputS3Pq$inboundSchema;
  /** @deprecated use `InputS3Pq$outboundSchema` instead. */
  export const outboundSchema = InputS3Pq$outboundSchema;
  /** @deprecated use `InputS3Pq$Outbound` instead. */
  export type Outbound = InputS3Pq$Outbound;
}

export function inputS3PqToJSON(inputS3Pq: InputS3Pq): string {
  return JSON.stringify(InputS3Pq$outboundSchema.parse(inputS3Pq));
}

export function inputS3PqFromJSON(
  jsonString: string,
): SafeParseResult<InputS3Pq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3Pq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3Pq' from JSON`,
  );
}

/** @internal */
export const InputS3AuthenticationMethod$inboundSchema: z.ZodType<
  InputS3AuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputS3AuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputS3AuthenticationMethod$outboundSchema: z.ZodType<
  InputS3AuthenticationMethod,
  z.ZodTypeDef,
  InputS3AuthenticationMethod
> = z.union([
  z.nativeEnum(InputS3AuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3AuthenticationMethod$ {
  /** @deprecated use `InputS3AuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputS3AuthenticationMethod$inboundSchema;
  /** @deprecated use `InputS3AuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = InputS3AuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputS3SignatureVersion$inboundSchema: z.ZodType<
  InputS3SignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputS3SignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputS3SignatureVersion$outboundSchema: z.ZodType<
  InputS3SignatureVersion,
  z.ZodTypeDef,
  InputS3SignatureVersion
> = z.union([
  z.nativeEnum(InputS3SignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3SignatureVersion$ {
  /** @deprecated use `InputS3SignatureVersion$inboundSchema` instead. */
  export const inboundSchema = InputS3SignatureVersion$inboundSchema;
  /** @deprecated use `InputS3SignatureVersion$outboundSchema` instead. */
  export const outboundSchema = InputS3SignatureVersion$outboundSchema;
}

/** @internal */
export const InputS3Preprocess$inboundSchema: z.ZodType<
  InputS3Preprocess,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/** @internal */
export type InputS3Preprocess$Outbound = {
  disabled: boolean;
  command?: string | undefined;
  args?: Array<string> | undefined;
};

/** @internal */
export const InputS3Preprocess$outboundSchema: z.ZodType<
  InputS3Preprocess$Outbound,
  z.ZodTypeDef,
  InputS3Preprocess
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3Preprocess$ {
  /** @deprecated use `InputS3Preprocess$inboundSchema` instead. */
  export const inboundSchema = InputS3Preprocess$inboundSchema;
  /** @deprecated use `InputS3Preprocess$outboundSchema` instead. */
  export const outboundSchema = InputS3Preprocess$outboundSchema;
  /** @deprecated use `InputS3Preprocess$Outbound` instead. */
  export type Outbound = InputS3Preprocess$Outbound;
}

export function inputS3PreprocessToJSON(
  inputS3Preprocess: InputS3Preprocess,
): string {
  return JSON.stringify(
    InputS3Preprocess$outboundSchema.parse(inputS3Preprocess),
  );
}

export function inputS3PreprocessFromJSON(
  jsonString: string,
): SafeParseResult<InputS3Preprocess, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3Preprocess$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3Preprocess' from JSON`,
  );
}

/** @internal */
export const InputS3Metadatum$inboundSchema: z.ZodType<
  InputS3Metadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputS3Metadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputS3Metadatum$outboundSchema: z.ZodType<
  InputS3Metadatum$Outbound,
  z.ZodTypeDef,
  InputS3Metadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3Metadatum$ {
  /** @deprecated use `InputS3Metadatum$inboundSchema` instead. */
  export const inboundSchema = InputS3Metadatum$inboundSchema;
  /** @deprecated use `InputS3Metadatum$outboundSchema` instead. */
  export const outboundSchema = InputS3Metadatum$outboundSchema;
  /** @deprecated use `InputS3Metadatum$Outbound` instead. */
  export type Outbound = InputS3Metadatum$Outbound;
}

export function inputS3MetadatumToJSON(
  inputS3Metadatum: InputS3Metadatum,
): string {
  return JSON.stringify(
    InputS3Metadatum$outboundSchema.parse(inputS3Metadatum),
  );
}

export function inputS3MetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputS3Metadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3Metadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3Metadatum' from JSON`,
  );
}

/** @internal */
export const InputS3Checkpointing$inboundSchema: z.ZodType<
  InputS3Checkpointing,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/** @internal */
export type InputS3Checkpointing$Outbound = {
  enabled: boolean;
  retries: number;
};

/** @internal */
export const InputS3Checkpointing$outboundSchema: z.ZodType<
  InputS3Checkpointing$Outbound,
  z.ZodTypeDef,
  InputS3Checkpointing
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3Checkpointing$ {
  /** @deprecated use `InputS3Checkpointing$inboundSchema` instead. */
  export const inboundSchema = InputS3Checkpointing$inboundSchema;
  /** @deprecated use `InputS3Checkpointing$outboundSchema` instead. */
  export const outboundSchema = InputS3Checkpointing$outboundSchema;
  /** @deprecated use `InputS3Checkpointing$Outbound` instead. */
  export type Outbound = InputS3Checkpointing$Outbound;
}

export function inputS3CheckpointingToJSON(
  inputS3Checkpointing: InputS3Checkpointing,
): string {
  return JSON.stringify(
    InputS3Checkpointing$outboundSchema.parse(inputS3Checkpointing),
  );
}

export function inputS3CheckpointingFromJSON(
  jsonString: string,
): SafeParseResult<InputS3Checkpointing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3Checkpointing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3Checkpointing' from JSON`,
  );
}

/** @internal */
export const InputS3$inboundSchema: z.ZodType<InputS3, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    type: InputS3Type$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(z.lazy(() => InputS3Connection$inboundSchema))
      .optional(),
    pq: z.lazy(() => InputS3Pq$inboundSchema).optional(),
    queueName: z.string(),
    fileFilter: z.string().default("/.*/"),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: InputS3AuthenticationMethod$inboundSchema.default(
      "auto",
    ),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: InputS3SignatureVersion$inboundSchema.default("v4"),
    reuseConnections: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().default(10000),
    maxMessages: z.number().default(1),
    visibilityTimeout: z.number().default(600),
    numReceivers: z.number().default(1),
    socketTimeout: z.number().default(300),
    skipOnError: z.boolean().default(false),
    enableAssumeRole: z.boolean().default(true),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().default(3600),
    enableSQSAssumeRole: z.boolean().default(false),
    preprocess: z.lazy(() => InputS3Preprocess$inboundSchema).optional(),
    metadata: z.array(z.lazy(() => InputS3Metadatum$inboundSchema)).optional(),
    parquetChunkSizeMB: z.number().default(5),
    parquetChunkDownloadTimeout: z.number().default(600),
    checkpointing: z.lazy(() => InputS3Checkpointing$inboundSchema).optional(),
    pollTimeout: z.number().default(10),
    encoding: z.string().optional(),
    tagAfterProcessing: z.boolean().default(false),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

/** @internal */
export type InputS3$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputS3Connection$Outbound> | undefined;
  pq?: InputS3Pq$Outbound | undefined;
  queueName: string;
  fileFilter: string;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  maxMessages: number;
  visibilityTimeout: number;
  numReceivers: number;
  socketTimeout: number;
  skipOnError: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  enableSQSAssumeRole: boolean;
  preprocess?: InputS3Preprocess$Outbound | undefined;
  metadata?: Array<InputS3Metadatum$Outbound> | undefined;
  parquetChunkSizeMB: number;
  parquetChunkDownloadTimeout: number;
  checkpointing?: InputS3Checkpointing$Outbound | undefined;
  pollTimeout: number;
  encoding?: string | undefined;
  tagAfterProcessing: boolean;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputS3$outboundSchema: z.ZodType<
  InputS3$Outbound,
  z.ZodTypeDef,
  InputS3
> = z.object({
  id: z.string(),
  type: InputS3Type$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputS3Connection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputS3Pq$outboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: InputS3AuthenticationMethod$outboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputS3SignatureVersion$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => InputS3Preprocess$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputS3Metadatum$outboundSchema)).optional(),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  checkpointing: z.lazy(() => InputS3Checkpointing$outboundSchema).optional(),
  pollTimeout: z.number().default(10),
  encoding: z.string().optional(),
  tagAfterProcessing: z.boolean().default(false),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputS3$ {
  /** @deprecated use `InputS3$inboundSchema` instead. */
  export const inboundSchema = InputS3$inboundSchema;
  /** @deprecated use `InputS3$outboundSchema` instead. */
  export const outboundSchema = InputS3$outboundSchema;
  /** @deprecated use `InputS3$Outbound` instead. */
  export type Outbound = InputS3$Outbound;
}

export function inputS3ToJSON(inputS3: InputS3): string {
  return JSON.stringify(InputS3$outboundSchema.parse(inputS3));
}

export function inputS3FromJSON(
  jsonString: string,
): SafeParseResult<InputS3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputS3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputS3' from JSON`,
  );
}

/** @internal */
export const InputMetricsType$inboundSchema: z.ZodType<
  InputMetricsType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMetricsType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMetricsType$outboundSchema: z.ZodType<
  InputMetricsType,
  z.ZodTypeDef,
  InputMetricsType
> = z.union([
  z.nativeEnum(InputMetricsType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsType$ {
  /** @deprecated use `InputMetricsType$inboundSchema` instead. */
  export const inboundSchema = InputMetricsType$inboundSchema;
  /** @deprecated use `InputMetricsType$outboundSchema` instead. */
  export const outboundSchema = InputMetricsType$outboundSchema;
}

/** @internal */
export const InputMetricsConnection$inboundSchema: z.ZodType<
  InputMetricsConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputMetricsConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputMetricsConnection$outboundSchema: z.ZodType<
  InputMetricsConnection$Outbound,
  z.ZodTypeDef,
  InputMetricsConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsConnection$ {
  /** @deprecated use `InputMetricsConnection$inboundSchema` instead. */
  export const inboundSchema = InputMetricsConnection$inboundSchema;
  /** @deprecated use `InputMetricsConnection$outboundSchema` instead. */
  export const outboundSchema = InputMetricsConnection$outboundSchema;
  /** @deprecated use `InputMetricsConnection$Outbound` instead. */
  export type Outbound = InputMetricsConnection$Outbound;
}

export function inputMetricsConnectionToJSON(
  inputMetricsConnection: InputMetricsConnection,
): string {
  return JSON.stringify(
    InputMetricsConnection$outboundSchema.parse(inputMetricsConnection),
  );
}

export function inputMetricsConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsConnection' from JSON`,
  );
}

/** @internal */
export const InputMetricsMode$inboundSchema: z.ZodType<
  InputMetricsMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMetricsMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMetricsMode$outboundSchema: z.ZodType<
  InputMetricsMode,
  z.ZodTypeDef,
  InputMetricsMode
> = z.union([
  z.nativeEnum(InputMetricsMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsMode$ {
  /** @deprecated use `InputMetricsMode$inboundSchema` instead. */
  export const inboundSchema = InputMetricsMode$inboundSchema;
  /** @deprecated use `InputMetricsMode$outboundSchema` instead. */
  export const outboundSchema = InputMetricsMode$outboundSchema;
}

/** @internal */
export const InputMetricsCompression$inboundSchema: z.ZodType<
  InputMetricsCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMetricsCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMetricsCompression$outboundSchema: z.ZodType<
  InputMetricsCompression,
  z.ZodTypeDef,
  InputMetricsCompression
> = z.union([
  z.nativeEnum(InputMetricsCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsCompression$ {
  /** @deprecated use `InputMetricsCompression$inboundSchema` instead. */
  export const inboundSchema = InputMetricsCompression$inboundSchema;
  /** @deprecated use `InputMetricsCompression$outboundSchema` instead. */
  export const outboundSchema = InputMetricsCompression$outboundSchema;
}

/** @internal */
export const InputMetricsPq$inboundSchema: z.ZodType<
  InputMetricsPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputMetricsMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputMetricsCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputMetricsPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputMetricsPq$outboundSchema: z.ZodType<
  InputMetricsPq$Outbound,
  z.ZodTypeDef,
  InputMetricsPq
> = z.object({
  mode: InputMetricsMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputMetricsCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsPq$ {
  /** @deprecated use `InputMetricsPq$inboundSchema` instead. */
  export const inboundSchema = InputMetricsPq$inboundSchema;
  /** @deprecated use `InputMetricsPq$outboundSchema` instead. */
  export const outboundSchema = InputMetricsPq$outboundSchema;
  /** @deprecated use `InputMetricsPq$Outbound` instead. */
  export type Outbound = InputMetricsPq$Outbound;
}

export function inputMetricsPqToJSON(inputMetricsPq: InputMetricsPq): string {
  return JSON.stringify(InputMetricsPq$outboundSchema.parse(inputMetricsPq));
}

export function inputMetricsPqFromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsPq' from JSON`,
  );
}

/** @internal */
export const InputMetricsMinimumTLSVersion$inboundSchema: z.ZodType<
  InputMetricsMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMetricsMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMetricsMinimumTLSVersion$outboundSchema: z.ZodType<
  InputMetricsMinimumTLSVersion,
  z.ZodTypeDef,
  InputMetricsMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputMetricsMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsMinimumTLSVersion$ {
  /** @deprecated use `InputMetricsMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputMetricsMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputMetricsMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputMetricsMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputMetricsMaximumTLSVersion$inboundSchema: z.ZodType<
  InputMetricsMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMetricsMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMetricsMaximumTLSVersion$outboundSchema: z.ZodType<
  InputMetricsMaximumTLSVersion,
  z.ZodTypeDef,
  InputMetricsMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputMetricsMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsMaximumTLSVersion$ {
  /** @deprecated use `InputMetricsMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputMetricsMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputMetricsMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputMetricsMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputMetricsTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputMetricsTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputMetricsMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputMetricsMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputMetricsTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputMetricsTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputMetricsTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputMetricsTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputMetricsMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputMetricsMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsTLSSettingsServerSide$ {
  /** @deprecated use `InputMetricsTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputMetricsTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputMetricsTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputMetricsTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputMetricsTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputMetricsTLSSettingsServerSide$Outbound;
}

export function inputMetricsTLSSettingsServerSideToJSON(
  inputMetricsTLSSettingsServerSide: InputMetricsTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputMetricsTLSSettingsServerSide$outboundSchema.parse(
      inputMetricsTLSSettingsServerSide,
    ),
  );
}

export function inputMetricsTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputMetricsMetadatum$inboundSchema: z.ZodType<
  InputMetricsMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputMetricsMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputMetricsMetadatum$outboundSchema: z.ZodType<
  InputMetricsMetadatum$Outbound,
  z.ZodTypeDef,
  InputMetricsMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsMetadatum$ {
  /** @deprecated use `InputMetricsMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputMetricsMetadatum$inboundSchema;
  /** @deprecated use `InputMetricsMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputMetricsMetadatum$outboundSchema;
  /** @deprecated use `InputMetricsMetadatum$Outbound` instead. */
  export type Outbound = InputMetricsMetadatum$Outbound;
}

export function inputMetricsMetadatumToJSON(
  inputMetricsMetadatum: InputMetricsMetadatum,
): string {
  return JSON.stringify(
    InputMetricsMetadatum$outboundSchema.parse(inputMetricsMetadatum),
  );
}

export function inputMetricsMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsMetadatum' from JSON`,
  );
}

/** @internal */
export const InputMetrics$inboundSchema: z.ZodType<
  InputMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputMetricsType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputMetricsConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputMetricsPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: z.lazy(() => InputMetricsTLSSettingsServerSide$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputMetricsMetadatum$inboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputMetrics$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputMetricsConnection$Outbound> | undefined;
  pq?: InputMetricsPq$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort?: number | undefined;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  enableProxyHeader: boolean;
  tls?: InputMetricsTLSSettingsServerSide$Outbound | undefined;
  metadata?: Array<InputMetricsMetadatum$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetrics$outboundSchema: z.ZodType<
  InputMetrics$Outbound,
  z.ZodTypeDef,
  InputMetrics
> = z.object({
  id: z.string(),
  type: InputMetricsType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputMetricsConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputMetricsPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: z.lazy(() => InputMetricsTLSSettingsServerSide$outboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => InputMetricsMetadatum$outboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetrics$ {
  /** @deprecated use `InputMetrics$inboundSchema` instead. */
  export const inboundSchema = InputMetrics$inboundSchema;
  /** @deprecated use `InputMetrics$outboundSchema` instead. */
  export const outboundSchema = InputMetrics$outboundSchema;
  /** @deprecated use `InputMetrics$Outbound` instead. */
  export type Outbound = InputMetrics$Outbound;
}

export function inputMetricsToJSON(inputMetrics: InputMetrics): string {
  return JSON.stringify(InputMetrics$outboundSchema.parse(inputMetrics));
}

export function inputMetricsFromJSON(
  jsonString: string,
): SafeParseResult<InputMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetrics' from JSON`,
  );
}

/** @internal */
export const InputKinesisType$inboundSchema: z.ZodType<
  InputKinesisType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputKinesisType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputKinesisType$outboundSchema: z.ZodType<
  InputKinesisType,
  z.ZodTypeDef,
  InputKinesisType
> = z.union([
  z.nativeEnum(InputKinesisType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKinesisType$ {
  /** @deprecated use `InputKinesisType$inboundSchema` instead. */
  export const inboundSchema = InputKinesisType$inboundSchema;
  /** @deprecated use `InputKinesisType$outboundSchema` instead. */
  export const outboundSchema = InputKinesisType$outboundSchema;
}

/** @internal */
export const InputKinesisConnection$inboundSchema: z.ZodType<
  InputKinesisConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputKinesisConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputKinesisConnection$outboundSchema: z.ZodType<
  InputKinesisConnection$Outbound,
  z.ZodTypeDef,
  InputKinesisConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKinesisConnection$ {
  /** @deprecated use `InputKinesisConnection$inboundSchema` instead. */
  export const inboundSchema = InputKinesisConnection$inboundSchema;
  /** @deprecated use `InputKinesisConnection$outboundSchema` instead. */
  export const outboundSchema = InputKinesisConnection$outboundSchema;
  /** @deprecated use `InputKinesisConnection$Outbound` instead. */
  export type Outbound = InputKinesisConnection$Outbound;
}

export function inputKinesisConnectionToJSON(
  inputKinesisConnection: InputKinesisConnection,
): string {
  return JSON.stringify(
    InputKinesisConnection$outboundSchema.parse(inputKinesisConnection),
  );
}

export function inputKinesisConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputKinesisConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesisConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesisConnection' from JSON`,
  );
}

/** @internal */
export const InputKinesisMode$inboundSchema: z.ZodType<
  InputKinesisMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputKinesisMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputKinesisMode$outboundSchema: z.ZodType<
  InputKinesisMode,
  z.ZodTypeDef,
  InputKinesisMode
> = z.union([
  z.nativeEnum(InputKinesisMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKinesisMode$ {
  /** @deprecated use `InputKinesisMode$inboundSchema` instead. */
  export const inboundSchema = InputKinesisMode$inboundSchema;
  /** @deprecated use `InputKinesisMode$outboundSchema` instead. */
  export const outboundSchema = InputKinesisMode$outboundSchema;
}

/** @internal */
export const InputKinesisCompression$inboundSchema: z.ZodType<
  InputKinesisCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputKinesisCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputKinesisCompression$outboundSchema: z.ZodType<
  InputKinesisCompression,
  z.ZodTypeDef,
  InputKinesisCompression
> = z.union([
  z.nativeEnum(InputKinesisCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKinesisCompression$ {
  /** @deprecated use `InputKinesisCompression$inboundSchema` instead. */
  export const inboundSchema = InputKinesisCompression$inboundSchema;
  /** @deprecated use `InputKinesisCompression$outboundSchema` instead. */
  export const outboundSchema = InputKinesisCompression$outboundSchema;
}

/** @internal */
export const InputKinesisPq$inboundSchema: z.ZodType<
  InputKinesisPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputKinesisMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputKinesisCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputKinesisPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputKinesisPq$outboundSchema: z.ZodType<
  InputKinesisPq$Outbound,
  z.ZodTypeDef,
  InputKinesisPq
> = z.object({
  mode: InputKinesisMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputKinesisCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKinesisPq$ {
  /** @deprecated use `InputKinesisPq$inboundSchema` instead. */
  export const inboundSchema = InputKinesisPq$inboundSchema;
  /** @deprecated use `InputKinesisPq$outboundSchema` instead. */
  export const outboundSchema = InputKinesisPq$outboundSchema;
  /** @deprecated use `InputKinesisPq$Outbound` instead. */
  export type Outbound = InputKinesisPq$Outbound;
}

export function inputKinesisPqToJSON(inputKinesisPq: InputKinesisPq): string {
  return JSON.stringify(InputKinesisPq$outboundSchema.parse(inputKinesisPq));
}

export function inputKinesisPqFromJSON(
  jsonString: string,
): SafeParseResult<InputKinesisPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesisPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesisPq' from JSON`,
  );
}

/** @internal */
export const ShardIteratorStart$inboundSchema: z.ZodType<
  ShardIteratorStart,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardIteratorStart),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ShardIteratorStart$outboundSchema: z.ZodType<
  ShardIteratorStart,
  z.ZodTypeDef,
  ShardIteratorStart
> = z.union([
  z.nativeEnum(ShardIteratorStart),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ShardIteratorStart$ {
  /** @deprecated use `ShardIteratorStart$inboundSchema` instead. */
  export const inboundSchema = ShardIteratorStart$inboundSchema;
  /** @deprecated use `ShardIteratorStart$outboundSchema` instead. */
  export const outboundSchema = ShardIteratorStart$outboundSchema;
}

/** @internal */
export const CreateInputRecordDataFormat$inboundSchema: z.ZodType<
  CreateInputRecordDataFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CreateInputRecordDataFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CreateInputRecordDataFormat$outboundSchema: z.ZodType<
  CreateInputRecordDataFormat,
  z.ZodTypeDef,
  CreateInputRecordDataFormat
> = z.union([
  z.nativeEnum(CreateInputRecordDataFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputRecordDataFormat$ {
  /** @deprecated use `CreateInputRecordDataFormat$inboundSchema` instead. */
  export const inboundSchema = CreateInputRecordDataFormat$inboundSchema;
  /** @deprecated use `CreateInputRecordDataFormat$outboundSchema` instead. */
  export const outboundSchema = CreateInputRecordDataFormat$outboundSchema;
}

/** @internal */
export const ShardLoadBalancing$inboundSchema: z.ZodType<
  ShardLoadBalancing,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardLoadBalancing),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ShardLoadBalancing$outboundSchema: z.ZodType<
  ShardLoadBalancing,
  z.ZodTypeDef,
  ShardLoadBalancing
> = z.union([
  z.nativeEnum(ShardLoadBalancing),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ShardLoadBalancing$ {
  /** @deprecated use `ShardLoadBalancing$inboundSchema` instead. */
  export const inboundSchema = ShardLoadBalancing$inboundSchema;
  /** @deprecated use `ShardLoadBalancing$outboundSchema` instead. */
  export const outboundSchema = ShardLoadBalancing$outboundSchema;
}

/** @internal */
export const InputKinesisAuthenticationMethod$inboundSchema: z.ZodType<
  InputKinesisAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputKinesisAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputKinesisAuthenticationMethod$outboundSchema: z.ZodType<
  InputKinesisAuthenticationMethod,
  z.ZodTypeDef,
  InputKinesisAuthenticationMethod
> = z.union([
  z.nativeEnum(InputKinesisAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKinesisAuthenticationMethod$ {
  /** @deprecated use `InputKinesisAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputKinesisAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputKinesisAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = InputKinesisAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputKinesisSignatureVersion$inboundSchema: z.ZodType<
  InputKinesisSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputKinesisSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputKinesisSignatureVersion$outboundSchema: z.ZodType<
  InputKinesisSignatureVersion,
  z.ZodTypeDef,
  InputKinesisSignatureVersion
> = z.union([
  z.nativeEnum(InputKinesisSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKinesisSignatureVersion$ {
  /** @deprecated use `InputKinesisSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = InputKinesisSignatureVersion$inboundSchema;
  /** @deprecated use `InputKinesisSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = InputKinesisSignatureVersion$outboundSchema;
}

/** @internal */
export const InputKinesisMetadatum$inboundSchema: z.ZodType<
  InputKinesisMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputKinesisMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputKinesisMetadatum$outboundSchema: z.ZodType<
  InputKinesisMetadatum$Outbound,
  z.ZodTypeDef,
  InputKinesisMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKinesisMetadatum$ {
  /** @deprecated use `InputKinesisMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputKinesisMetadatum$inboundSchema;
  /** @deprecated use `InputKinesisMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputKinesisMetadatum$outboundSchema;
  /** @deprecated use `InputKinesisMetadatum$Outbound` instead. */
  export type Outbound = InputKinesisMetadatum$Outbound;
}

export function inputKinesisMetadatumToJSON(
  inputKinesisMetadatum: InputKinesisMetadatum,
): string {
  return JSON.stringify(
    InputKinesisMetadatum$outboundSchema.parse(inputKinesisMetadatum),
  );
}

export function inputKinesisMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputKinesisMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesisMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesisMetadatum' from JSON`,
  );
}

/** @internal */
export const InputKinesis$inboundSchema: z.ZodType<
  InputKinesis,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputKinesisType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputKinesisConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputKinesisPq$inboundSchema).optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart$inboundSchema.default("TRIM_HORIZON"),
  payloadFormat: CreateInputRecordDataFormat$inboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing$inboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: InputKinesisAuthenticationMethod$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: InputKinesisSignatureVersion$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputKinesisMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/** @internal */
export type InputKinesis$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputKinesisConnection$Outbound> | undefined;
  pq?: InputKinesisPq$Outbound | undefined;
  streamName: string;
  serviceInterval: number;
  shardExpr: string;
  shardIteratorType: string;
  payloadFormat: string;
  getRecordsLimit: number;
  getRecordsLimitTotal: number;
  loadBalancingAlgorithm: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  verifyKPLCheckSums: boolean;
  avoidDuplicates: boolean;
  metadata?: Array<InputKinesisMetadatum$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesis$outboundSchema: z.ZodType<
  InputKinesis$Outbound,
  z.ZodTypeDef,
  InputKinesis
> = z.object({
  id: z.string(),
  type: InputKinesisType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputKinesisConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputKinesisPq$outboundSchema).optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart$outboundSchema.default("TRIM_HORIZON"),
  payloadFormat: CreateInputRecordDataFormat$outboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing$outboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: InputKinesisAuthenticationMethod$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: InputKinesisSignatureVersion$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputKinesisMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKinesis$ {
  /** @deprecated use `InputKinesis$inboundSchema` instead. */
  export const inboundSchema = InputKinesis$inboundSchema;
  /** @deprecated use `InputKinesis$outboundSchema` instead. */
  export const outboundSchema = InputKinesis$outboundSchema;
  /** @deprecated use `InputKinesis$Outbound` instead. */
  export type Outbound = InputKinesis$Outbound;
}

export function inputKinesisToJSON(inputKinesis: InputKinesis): string {
  return JSON.stringify(InputKinesis$outboundSchema.parse(inputKinesis));
}

export function inputKinesisFromJSON(
  jsonString: string,
): SafeParseResult<InputKinesis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesis' from JSON`,
  );
}

/** @internal */
export const InputHttpRawType$inboundSchema: z.ZodType<
  InputHttpRawType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputHttpRawType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputHttpRawType$outboundSchema: z.ZodType<
  InputHttpRawType,
  z.ZodTypeDef,
  InputHttpRawType
> = z.union([
  z.nativeEnum(InputHttpRawType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRawType$ {
  /** @deprecated use `InputHttpRawType$inboundSchema` instead. */
  export const inboundSchema = InputHttpRawType$inboundSchema;
  /** @deprecated use `InputHttpRawType$outboundSchema` instead. */
  export const outboundSchema = InputHttpRawType$outboundSchema;
}

/** @internal */
export const InputHttpRawConnection$inboundSchema: z.ZodType<
  InputHttpRawConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputHttpRawConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputHttpRawConnection$outboundSchema: z.ZodType<
  InputHttpRawConnection$Outbound,
  z.ZodTypeDef,
  InputHttpRawConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRawConnection$ {
  /** @deprecated use `InputHttpRawConnection$inboundSchema` instead. */
  export const inboundSchema = InputHttpRawConnection$inboundSchema;
  /** @deprecated use `InputHttpRawConnection$outboundSchema` instead. */
  export const outboundSchema = InputHttpRawConnection$outboundSchema;
  /** @deprecated use `InputHttpRawConnection$Outbound` instead. */
  export type Outbound = InputHttpRawConnection$Outbound;
}

export function inputHttpRawConnectionToJSON(
  inputHttpRawConnection: InputHttpRawConnection,
): string {
  return JSON.stringify(
    InputHttpRawConnection$outboundSchema.parse(inputHttpRawConnection),
  );
}

export function inputHttpRawConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpRawConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpRawConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpRawConnection' from JSON`,
  );
}

/** @internal */
export const InputHttpRawMode$inboundSchema: z.ZodType<
  InputHttpRawMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputHttpRawMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputHttpRawMode$outboundSchema: z.ZodType<
  InputHttpRawMode,
  z.ZodTypeDef,
  InputHttpRawMode
> = z.union([
  z.nativeEnum(InputHttpRawMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRawMode$ {
  /** @deprecated use `InputHttpRawMode$inboundSchema` instead. */
  export const inboundSchema = InputHttpRawMode$inboundSchema;
  /** @deprecated use `InputHttpRawMode$outboundSchema` instead. */
  export const outboundSchema = InputHttpRawMode$outboundSchema;
}

/** @internal */
export const InputHttpRawCompression$inboundSchema: z.ZodType<
  InputHttpRawCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputHttpRawCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputHttpRawCompression$outboundSchema: z.ZodType<
  InputHttpRawCompression,
  z.ZodTypeDef,
  InputHttpRawCompression
> = z.union([
  z.nativeEnum(InputHttpRawCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRawCompression$ {
  /** @deprecated use `InputHttpRawCompression$inboundSchema` instead. */
  export const inboundSchema = InputHttpRawCompression$inboundSchema;
  /** @deprecated use `InputHttpRawCompression$outboundSchema` instead. */
  export const outboundSchema = InputHttpRawCompression$outboundSchema;
}

/** @internal */
export const InputHttpRawPq$inboundSchema: z.ZodType<
  InputHttpRawPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputHttpRawMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputHttpRawCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputHttpRawPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputHttpRawPq$outboundSchema: z.ZodType<
  InputHttpRawPq$Outbound,
  z.ZodTypeDef,
  InputHttpRawPq
> = z.object({
  mode: InputHttpRawMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputHttpRawCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRawPq$ {
  /** @deprecated use `InputHttpRawPq$inboundSchema` instead. */
  export const inboundSchema = InputHttpRawPq$inboundSchema;
  /** @deprecated use `InputHttpRawPq$outboundSchema` instead. */
  export const outboundSchema = InputHttpRawPq$outboundSchema;
  /** @deprecated use `InputHttpRawPq$Outbound` instead. */
  export type Outbound = InputHttpRawPq$Outbound;
}

export function inputHttpRawPqToJSON(inputHttpRawPq: InputHttpRawPq): string {
  return JSON.stringify(InputHttpRawPq$outboundSchema.parse(inputHttpRawPq));
}

export function inputHttpRawPqFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpRawPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpRawPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpRawPq' from JSON`,
  );
}

/** @internal */
export const InputHttpRawMinimumTLSVersion$inboundSchema: z.ZodType<
  InputHttpRawMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputHttpRawMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputHttpRawMinimumTLSVersion$outboundSchema: z.ZodType<
  InputHttpRawMinimumTLSVersion,
  z.ZodTypeDef,
  InputHttpRawMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputHttpRawMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRawMinimumTLSVersion$ {
  /** @deprecated use `InputHttpRawMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputHttpRawMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputHttpRawMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputHttpRawMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputHttpRawMaximumTLSVersion$inboundSchema: z.ZodType<
  InputHttpRawMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputHttpRawMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputHttpRawMaximumTLSVersion$outboundSchema: z.ZodType<
  InputHttpRawMaximumTLSVersion,
  z.ZodTypeDef,
  InputHttpRawMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputHttpRawMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRawMaximumTLSVersion$ {
  /** @deprecated use `InputHttpRawMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputHttpRawMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputHttpRawMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputHttpRawMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputHttpRawTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputHttpRawTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputHttpRawMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputHttpRawMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputHttpRawTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputHttpRawTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputHttpRawTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputHttpRawTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputHttpRawMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputHttpRawMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRawTLSSettingsServerSide$ {
  /** @deprecated use `InputHttpRawTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputHttpRawTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputHttpRawTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputHttpRawTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputHttpRawTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputHttpRawTLSSettingsServerSide$Outbound;
}

export function inputHttpRawTLSSettingsServerSideToJSON(
  inputHttpRawTLSSettingsServerSide: InputHttpRawTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputHttpRawTLSSettingsServerSide$outboundSchema.parse(
      inputHttpRawTLSSettingsServerSide,
    ),
  );
}

export function inputHttpRawTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpRawTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpRawTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpRawTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputHttpRawMetadatum$inboundSchema: z.ZodType<
  InputHttpRawMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputHttpRawMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputHttpRawMetadatum$outboundSchema: z.ZodType<
  InputHttpRawMetadatum$Outbound,
  z.ZodTypeDef,
  InputHttpRawMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRawMetadatum$ {
  /** @deprecated use `InputHttpRawMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputHttpRawMetadatum$inboundSchema;
  /** @deprecated use `InputHttpRawMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputHttpRawMetadatum$outboundSchema;
  /** @deprecated use `InputHttpRawMetadatum$Outbound` instead. */
  export type Outbound = InputHttpRawMetadatum$Outbound;
}

export function inputHttpRawMetadatumToJSON(
  inputHttpRawMetadatum: InputHttpRawMetadatum,
): string {
  return JSON.stringify(
    InputHttpRawMetadatum$outboundSchema.parse(inputHttpRawMetadatum),
  );
}

export function inputHttpRawMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpRawMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpRawMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpRawMetadatum' from JSON`,
  );
}

/** @internal */
export const InputHttpRawAuthTokensExtMetadatum$inboundSchema: z.ZodType<
  InputHttpRawAuthTokensExtMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputHttpRawAuthTokensExtMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputHttpRawAuthTokensExtMetadatum$outboundSchema: z.ZodType<
  InputHttpRawAuthTokensExtMetadatum$Outbound,
  z.ZodTypeDef,
  InputHttpRawAuthTokensExtMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRawAuthTokensExtMetadatum$ {
  /** @deprecated use `InputHttpRawAuthTokensExtMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputHttpRawAuthTokensExtMetadatum$inboundSchema;
  /** @deprecated use `InputHttpRawAuthTokensExtMetadatum$outboundSchema` instead. */
  export const outboundSchema =
    InputHttpRawAuthTokensExtMetadatum$outboundSchema;
  /** @deprecated use `InputHttpRawAuthTokensExtMetadatum$Outbound` instead. */
  export type Outbound = InputHttpRawAuthTokensExtMetadatum$Outbound;
}

export function inputHttpRawAuthTokensExtMetadatumToJSON(
  inputHttpRawAuthTokensExtMetadatum: InputHttpRawAuthTokensExtMetadatum,
): string {
  return JSON.stringify(
    InputHttpRawAuthTokensExtMetadatum$outboundSchema.parse(
      inputHttpRawAuthTokensExtMetadatum,
    ),
  );
}

export function inputHttpRawAuthTokensExtMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpRawAuthTokensExtMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputHttpRawAuthTokensExtMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpRawAuthTokensExtMetadatum' from JSON`,
  );
}

/** @internal */
export const InputHttpRawAuthTokensExt$inboundSchema: z.ZodType<
  InputHttpRawAuthTokensExt,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  description: z.string().optional(),
  metadata: z.array(
    z.lazy(() => InputHttpRawAuthTokensExtMetadatum$inboundSchema),
  ).optional(),
});

/** @internal */
export type InputHttpRawAuthTokensExt$Outbound = {
  token: string;
  description?: string | undefined;
  metadata?: Array<InputHttpRawAuthTokensExtMetadatum$Outbound> | undefined;
};

/** @internal */
export const InputHttpRawAuthTokensExt$outboundSchema: z.ZodType<
  InputHttpRawAuthTokensExt$Outbound,
  z.ZodTypeDef,
  InputHttpRawAuthTokensExt
> = z.object({
  token: z.string(),
  description: z.string().optional(),
  metadata: z.array(
    z.lazy(() => InputHttpRawAuthTokensExtMetadatum$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRawAuthTokensExt$ {
  /** @deprecated use `InputHttpRawAuthTokensExt$inboundSchema` instead. */
  export const inboundSchema = InputHttpRawAuthTokensExt$inboundSchema;
  /** @deprecated use `InputHttpRawAuthTokensExt$outboundSchema` instead. */
  export const outboundSchema = InputHttpRawAuthTokensExt$outboundSchema;
  /** @deprecated use `InputHttpRawAuthTokensExt$Outbound` instead. */
  export type Outbound = InputHttpRawAuthTokensExt$Outbound;
}

export function inputHttpRawAuthTokensExtToJSON(
  inputHttpRawAuthTokensExt: InputHttpRawAuthTokensExt,
): string {
  return JSON.stringify(
    InputHttpRawAuthTokensExt$outboundSchema.parse(inputHttpRawAuthTokensExt),
  );
}

export function inputHttpRawAuthTokensExtFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpRawAuthTokensExt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpRawAuthTokensExt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpRawAuthTokensExt' from JSON`,
  );
}

/** @internal */
export const InputHttpRaw$inboundSchema: z.ZodType<
  InputHttpRaw,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputHttpRawType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputHttpRawConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputHttpRawPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => InputHttpRawTLSSettingsServerSide$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(z.lazy(() => InputHttpRawMetadatum$inboundSchema))
    .optional(),
  allowedPaths: z.array(z.string()).optional(),
  allowedMethods: z.array(z.string()).optional(),
  authTokensExt: z.array(z.lazy(() => InputHttpRawAuthTokensExt$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputHttpRaw$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputHttpRawConnection$Outbound> | undefined;
  pq?: InputHttpRawPq$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: InputHttpRawTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  metadata?: Array<InputHttpRawMetadatum$Outbound> | undefined;
  allowedPaths?: Array<string> | undefined;
  allowedMethods?: Array<string> | undefined;
  authTokensExt?: Array<InputHttpRawAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttpRaw$outboundSchema: z.ZodType<
  InputHttpRaw$Outbound,
  z.ZodTypeDef,
  InputHttpRaw
> = z.object({
  id: z.string(),
  type: InputHttpRawType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputHttpRawConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputHttpRawPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => InputHttpRawTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(z.lazy(() => InputHttpRawMetadatum$outboundSchema))
    .optional(),
  allowedPaths: z.array(z.string()).optional(),
  allowedMethods: z.array(z.string()).optional(),
  authTokensExt: z.array(z.lazy(() => InputHttpRawAuthTokensExt$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpRaw$ {
  /** @deprecated use `InputHttpRaw$inboundSchema` instead. */
  export const inboundSchema = InputHttpRaw$inboundSchema;
  /** @deprecated use `InputHttpRaw$outboundSchema` instead. */
  export const outboundSchema = InputHttpRaw$outboundSchema;
  /** @deprecated use `InputHttpRaw$Outbound` instead. */
  export type Outbound = InputHttpRaw$Outbound;
}

export function inputHttpRawToJSON(inputHttpRaw: InputHttpRaw): string {
  return JSON.stringify(InputHttpRaw$outboundSchema.parse(inputHttpRaw));
}

export function inputHttpRawFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpRaw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpRaw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpRaw' from JSON`,
  );
}

/** @internal */
export const InputDatagenType$inboundSchema: z.ZodType<
  InputDatagenType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputDatagenType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputDatagenType$outboundSchema: z.ZodType<
  InputDatagenType,
  z.ZodTypeDef,
  InputDatagenType
> = z.union([
  z.nativeEnum(InputDatagenType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenType$ {
  /** @deprecated use `InputDatagenType$inboundSchema` instead. */
  export const inboundSchema = InputDatagenType$inboundSchema;
  /** @deprecated use `InputDatagenType$outboundSchema` instead. */
  export const outboundSchema = InputDatagenType$outboundSchema;
}

/** @internal */
export const InputDatagenConnection$inboundSchema: z.ZodType<
  InputDatagenConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputDatagenConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputDatagenConnection$outboundSchema: z.ZodType<
  InputDatagenConnection$Outbound,
  z.ZodTypeDef,
  InputDatagenConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenConnection$ {
  /** @deprecated use `InputDatagenConnection$inboundSchema` instead. */
  export const inboundSchema = InputDatagenConnection$inboundSchema;
  /** @deprecated use `InputDatagenConnection$outboundSchema` instead. */
  export const outboundSchema = InputDatagenConnection$outboundSchema;
  /** @deprecated use `InputDatagenConnection$Outbound` instead. */
  export type Outbound = InputDatagenConnection$Outbound;
}

export function inputDatagenConnectionToJSON(
  inputDatagenConnection: InputDatagenConnection,
): string {
  return JSON.stringify(
    InputDatagenConnection$outboundSchema.parse(inputDatagenConnection),
  );
}

export function inputDatagenConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputDatagenConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatagenConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatagenConnection' from JSON`,
  );
}

/** @internal */
export const InputDatagenMode$inboundSchema: z.ZodType<
  InputDatagenMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputDatagenMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputDatagenMode$outboundSchema: z.ZodType<
  InputDatagenMode,
  z.ZodTypeDef,
  InputDatagenMode
> = z.union([
  z.nativeEnum(InputDatagenMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenMode$ {
  /** @deprecated use `InputDatagenMode$inboundSchema` instead. */
  export const inboundSchema = InputDatagenMode$inboundSchema;
  /** @deprecated use `InputDatagenMode$outboundSchema` instead. */
  export const outboundSchema = InputDatagenMode$outboundSchema;
}

/** @internal */
export const InputDatagenCompression$inboundSchema: z.ZodType<
  InputDatagenCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputDatagenCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputDatagenCompression$outboundSchema: z.ZodType<
  InputDatagenCompression,
  z.ZodTypeDef,
  InputDatagenCompression
> = z.union([
  z.nativeEnum(InputDatagenCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenCompression$ {
  /** @deprecated use `InputDatagenCompression$inboundSchema` instead. */
  export const inboundSchema = InputDatagenCompression$inboundSchema;
  /** @deprecated use `InputDatagenCompression$outboundSchema` instead. */
  export const outboundSchema = InputDatagenCompression$outboundSchema;
}

/** @internal */
export const InputDatagenPq$inboundSchema: z.ZodType<
  InputDatagenPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputDatagenMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputDatagenCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputDatagenPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputDatagenPq$outboundSchema: z.ZodType<
  InputDatagenPq$Outbound,
  z.ZodTypeDef,
  InputDatagenPq
> = z.object({
  mode: InputDatagenMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputDatagenCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenPq$ {
  /** @deprecated use `InputDatagenPq$inboundSchema` instead. */
  export const inboundSchema = InputDatagenPq$inboundSchema;
  /** @deprecated use `InputDatagenPq$outboundSchema` instead. */
  export const outboundSchema = InputDatagenPq$outboundSchema;
  /** @deprecated use `InputDatagenPq$Outbound` instead. */
  export type Outbound = InputDatagenPq$Outbound;
}

export function inputDatagenPqToJSON(inputDatagenPq: InputDatagenPq): string {
  return JSON.stringify(InputDatagenPq$outboundSchema.parse(inputDatagenPq));
}

export function inputDatagenPqFromJSON(
  jsonString: string,
): SafeParseResult<InputDatagenPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatagenPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatagenPq' from JSON`,
  );
}

/** @internal */
export const Sample$inboundSchema: z.ZodType<Sample, z.ZodTypeDef, unknown> = z
  .object({
    sample: z.string(),
    eventsPerSec: z.number().default(10),
  });

/** @internal */
export type Sample$Outbound = {
  sample: string;
  eventsPerSec: number;
};

/** @internal */
export const Sample$outboundSchema: z.ZodType<
  Sample$Outbound,
  z.ZodTypeDef,
  Sample
> = z.object({
  sample: z.string(),
  eventsPerSec: z.number().default(10),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Sample$ {
  /** @deprecated use `Sample$inboundSchema` instead. */
  export const inboundSchema = Sample$inboundSchema;
  /** @deprecated use `Sample$outboundSchema` instead. */
  export const outboundSchema = Sample$outboundSchema;
  /** @deprecated use `Sample$Outbound` instead. */
  export type Outbound = Sample$Outbound;
}

export function sampleToJSON(sample: Sample): string {
  return JSON.stringify(Sample$outboundSchema.parse(sample));
}

export function sampleFromJSON(
  jsonString: string,
): SafeParseResult<Sample, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Sample$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Sample' from JSON`,
  );
}

/** @internal */
export const InputDatagenMetadatum$inboundSchema: z.ZodType<
  InputDatagenMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputDatagenMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputDatagenMetadatum$outboundSchema: z.ZodType<
  InputDatagenMetadatum$Outbound,
  z.ZodTypeDef,
  InputDatagenMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenMetadatum$ {
  /** @deprecated use `InputDatagenMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputDatagenMetadatum$inboundSchema;
  /** @deprecated use `InputDatagenMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputDatagenMetadatum$outboundSchema;
  /** @deprecated use `InputDatagenMetadatum$Outbound` instead. */
  export type Outbound = InputDatagenMetadatum$Outbound;
}

export function inputDatagenMetadatumToJSON(
  inputDatagenMetadatum: InputDatagenMetadatum,
): string {
  return JSON.stringify(
    InputDatagenMetadatum$outboundSchema.parse(inputDatagenMetadatum),
  );
}

export function inputDatagenMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputDatagenMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatagenMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatagenMetadatum' from JSON`,
  );
}

/** @internal */
export const InputDatagen$inboundSchema: z.ZodType<
  InputDatagen,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputDatagenType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputDatagenConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputDatagenPq$inboundSchema).optional(),
  samples: z.array(z.lazy(() => Sample$inboundSchema)),
  metadata: z.array(z.lazy(() => InputDatagenMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputDatagen$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputDatagenConnection$Outbound> | undefined;
  pq?: InputDatagenPq$Outbound | undefined;
  samples: Array<Sample$Outbound>;
  metadata?: Array<InputDatagenMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatagen$outboundSchema: z.ZodType<
  InputDatagen$Outbound,
  z.ZodTypeDef,
  InputDatagen
> = z.object({
  id: z.string(),
  type: InputDatagenType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputDatagenConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputDatagenPq$outboundSchema).optional(),
  samples: z.array(z.lazy(() => Sample$outboundSchema)),
  metadata: z.array(z.lazy(() => InputDatagenMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagen$ {
  /** @deprecated use `InputDatagen$inboundSchema` instead. */
  export const inboundSchema = InputDatagen$inboundSchema;
  /** @deprecated use `InputDatagen$outboundSchema` instead. */
  export const outboundSchema = InputDatagen$outboundSchema;
  /** @deprecated use `InputDatagen$Outbound` instead. */
  export type Outbound = InputDatagen$Outbound;
}

export function inputDatagenToJSON(inputDatagen: InputDatagen): string {
  return JSON.stringify(InputDatagen$outboundSchema.parse(inputDatagen));
}

export function inputDatagenFromJSON(
  jsonString: string,
): SafeParseResult<InputDatagen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatagen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatagen' from JSON`,
  );
}

/** @internal */
export const InputDatadogAgentType$inboundSchema: z.ZodType<
  InputDatadogAgentType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputDatadogAgentType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputDatadogAgentType$outboundSchema: z.ZodType<
  InputDatadogAgentType,
  z.ZodTypeDef,
  InputDatadogAgentType
> = z.union([
  z.nativeEnum(InputDatadogAgentType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgentType$ {
  /** @deprecated use `InputDatadogAgentType$inboundSchema` instead. */
  export const inboundSchema = InputDatadogAgentType$inboundSchema;
  /** @deprecated use `InputDatadogAgentType$outboundSchema` instead. */
  export const outboundSchema = InputDatadogAgentType$outboundSchema;
}

/** @internal */
export const InputDatadogAgentConnection$inboundSchema: z.ZodType<
  InputDatadogAgentConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputDatadogAgentConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputDatadogAgentConnection$outboundSchema: z.ZodType<
  InputDatadogAgentConnection$Outbound,
  z.ZodTypeDef,
  InputDatadogAgentConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgentConnection$ {
  /** @deprecated use `InputDatadogAgentConnection$inboundSchema` instead. */
  export const inboundSchema = InputDatadogAgentConnection$inboundSchema;
  /** @deprecated use `InputDatadogAgentConnection$outboundSchema` instead. */
  export const outboundSchema = InputDatadogAgentConnection$outboundSchema;
  /** @deprecated use `InputDatadogAgentConnection$Outbound` instead. */
  export type Outbound = InputDatadogAgentConnection$Outbound;
}

export function inputDatadogAgentConnectionToJSON(
  inputDatadogAgentConnection: InputDatadogAgentConnection,
): string {
  return JSON.stringify(
    InputDatadogAgentConnection$outboundSchema.parse(
      inputDatadogAgentConnection,
    ),
  );
}

export function inputDatadogAgentConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputDatadogAgentConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatadogAgentConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatadogAgentConnection' from JSON`,
  );
}

/** @internal */
export const InputDatadogAgentMode$inboundSchema: z.ZodType<
  InputDatadogAgentMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputDatadogAgentMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputDatadogAgentMode$outboundSchema: z.ZodType<
  InputDatadogAgentMode,
  z.ZodTypeDef,
  InputDatadogAgentMode
> = z.union([
  z.nativeEnum(InputDatadogAgentMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgentMode$ {
  /** @deprecated use `InputDatadogAgentMode$inboundSchema` instead. */
  export const inboundSchema = InputDatadogAgentMode$inboundSchema;
  /** @deprecated use `InputDatadogAgentMode$outboundSchema` instead. */
  export const outboundSchema = InputDatadogAgentMode$outboundSchema;
}

/** @internal */
export const InputDatadogAgentCompression$inboundSchema: z.ZodType<
  InputDatadogAgentCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputDatadogAgentCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputDatadogAgentCompression$outboundSchema: z.ZodType<
  InputDatadogAgentCompression,
  z.ZodTypeDef,
  InputDatadogAgentCompression
> = z.union([
  z.nativeEnum(InputDatadogAgentCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgentCompression$ {
  /** @deprecated use `InputDatadogAgentCompression$inboundSchema` instead. */
  export const inboundSchema = InputDatadogAgentCompression$inboundSchema;
  /** @deprecated use `InputDatadogAgentCompression$outboundSchema` instead. */
  export const outboundSchema = InputDatadogAgentCompression$outboundSchema;
}

/** @internal */
export const InputDatadogAgentPq$inboundSchema: z.ZodType<
  InputDatadogAgentPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputDatadogAgentMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputDatadogAgentCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputDatadogAgentPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputDatadogAgentPq$outboundSchema: z.ZodType<
  InputDatadogAgentPq$Outbound,
  z.ZodTypeDef,
  InputDatadogAgentPq
> = z.object({
  mode: InputDatadogAgentMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputDatadogAgentCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgentPq$ {
  /** @deprecated use `InputDatadogAgentPq$inboundSchema` instead. */
  export const inboundSchema = InputDatadogAgentPq$inboundSchema;
  /** @deprecated use `InputDatadogAgentPq$outboundSchema` instead. */
  export const outboundSchema = InputDatadogAgentPq$outboundSchema;
  /** @deprecated use `InputDatadogAgentPq$Outbound` instead. */
  export type Outbound = InputDatadogAgentPq$Outbound;
}

export function inputDatadogAgentPqToJSON(
  inputDatadogAgentPq: InputDatadogAgentPq,
): string {
  return JSON.stringify(
    InputDatadogAgentPq$outboundSchema.parse(inputDatadogAgentPq),
  );
}

export function inputDatadogAgentPqFromJSON(
  jsonString: string,
): SafeParseResult<InputDatadogAgentPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatadogAgentPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatadogAgentPq' from JSON`,
  );
}

/** @internal */
export const InputDatadogAgentMinimumTLSVersion$inboundSchema: z.ZodType<
  InputDatadogAgentMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputDatadogAgentMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputDatadogAgentMinimumTLSVersion$outboundSchema: z.ZodType<
  InputDatadogAgentMinimumTLSVersion,
  z.ZodTypeDef,
  InputDatadogAgentMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputDatadogAgentMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgentMinimumTLSVersion$ {
  /** @deprecated use `InputDatadogAgentMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputDatadogAgentMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputDatadogAgentMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputDatadogAgentMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputDatadogAgentMaximumTLSVersion$inboundSchema: z.ZodType<
  InputDatadogAgentMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputDatadogAgentMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputDatadogAgentMaximumTLSVersion$outboundSchema: z.ZodType<
  InputDatadogAgentMaximumTLSVersion,
  z.ZodTypeDef,
  InputDatadogAgentMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputDatadogAgentMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgentMaximumTLSVersion$ {
  /** @deprecated use `InputDatadogAgentMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputDatadogAgentMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputDatadogAgentMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputDatadogAgentMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputDatadogAgentTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputDatadogAgentTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputDatadogAgentMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputDatadogAgentMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputDatadogAgentTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputDatadogAgentTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputDatadogAgentTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputDatadogAgentTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputDatadogAgentMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputDatadogAgentMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgentTLSSettingsServerSide$ {
  /** @deprecated use `InputDatadogAgentTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema =
    InputDatadogAgentTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputDatadogAgentTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputDatadogAgentTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputDatadogAgentTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputDatadogAgentTLSSettingsServerSide$Outbound;
}

export function inputDatadogAgentTLSSettingsServerSideToJSON(
  inputDatadogAgentTLSSettingsServerSide:
    InputDatadogAgentTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputDatadogAgentTLSSettingsServerSide$outboundSchema.parse(
      inputDatadogAgentTLSSettingsServerSide,
    ),
  );
}

export function inputDatadogAgentTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputDatadogAgentTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputDatadogAgentTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatadogAgentTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputDatadogAgentMetadatum$inboundSchema: z.ZodType<
  InputDatadogAgentMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputDatadogAgentMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputDatadogAgentMetadatum$outboundSchema: z.ZodType<
  InputDatadogAgentMetadatum$Outbound,
  z.ZodTypeDef,
  InputDatadogAgentMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgentMetadatum$ {
  /** @deprecated use `InputDatadogAgentMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputDatadogAgentMetadatum$inboundSchema;
  /** @deprecated use `InputDatadogAgentMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputDatadogAgentMetadatum$outboundSchema;
  /** @deprecated use `InputDatadogAgentMetadatum$Outbound` instead. */
  export type Outbound = InputDatadogAgentMetadatum$Outbound;
}

export function inputDatadogAgentMetadatumToJSON(
  inputDatadogAgentMetadatum: InputDatadogAgentMetadatum,
): string {
  return JSON.stringify(
    InputDatadogAgentMetadatum$outboundSchema.parse(inputDatadogAgentMetadatum),
  );
}

export function inputDatadogAgentMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputDatadogAgentMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatadogAgentMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatadogAgentMetadatum' from JSON`,
  );
}

/** @internal */
export const InputDatadogAgentProxyMode$inboundSchema: z.ZodType<
  InputDatadogAgentProxyMode,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/** @internal */
export type InputDatadogAgentProxyMode$Outbound = {
  enabled: boolean;
  rejectUnauthorized: boolean;
};

/** @internal */
export const InputDatadogAgentProxyMode$outboundSchema: z.ZodType<
  InputDatadogAgentProxyMode$Outbound,
  z.ZodTypeDef,
  InputDatadogAgentProxyMode
> = z.object({
  enabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgentProxyMode$ {
  /** @deprecated use `InputDatadogAgentProxyMode$inboundSchema` instead. */
  export const inboundSchema = InputDatadogAgentProxyMode$inboundSchema;
  /** @deprecated use `InputDatadogAgentProxyMode$outboundSchema` instead. */
  export const outboundSchema = InputDatadogAgentProxyMode$outboundSchema;
  /** @deprecated use `InputDatadogAgentProxyMode$Outbound` instead. */
  export type Outbound = InputDatadogAgentProxyMode$Outbound;
}

export function inputDatadogAgentProxyModeToJSON(
  inputDatadogAgentProxyMode: InputDatadogAgentProxyMode,
): string {
  return JSON.stringify(
    InputDatadogAgentProxyMode$outboundSchema.parse(inputDatadogAgentProxyMode),
  );
}

export function inputDatadogAgentProxyModeFromJSON(
  jsonString: string,
): SafeParseResult<InputDatadogAgentProxyMode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatadogAgentProxyMode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatadogAgentProxyMode' from JSON`,
  );
}

/** @internal */
export const InputDatadogAgent$inboundSchema: z.ZodType<
  InputDatadogAgent,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputDatadogAgentType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputDatadogAgentConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputDatadogAgentPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputDatadogAgentTLSSettingsServerSide$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  extractMetrics: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputDatadogAgentMetadatum$inboundSchema))
    .optional(),
  proxyMode: z.lazy(() => InputDatadogAgentProxyMode$inboundSchema).optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputDatadogAgent$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputDatadogAgentConnection$Outbound> | undefined;
  pq?: InputDatadogAgentPq$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputDatadogAgentTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  extractMetrics: boolean;
  metadata?: Array<InputDatadogAgentMetadatum$Outbound> | undefined;
  proxyMode?: InputDatadogAgentProxyMode$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatadogAgent$outboundSchema: z.ZodType<
  InputDatadogAgent$Outbound,
  z.ZodTypeDef,
  InputDatadogAgent
> = z.object({
  id: z.string(),
  type: InputDatadogAgentType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputDatadogAgentConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputDatadogAgentPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputDatadogAgentTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  extractMetrics: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputDatadogAgentMetadatum$outboundSchema))
    .optional(),
  proxyMode: z.lazy(() => InputDatadogAgentProxyMode$outboundSchema).optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatadogAgent$ {
  /** @deprecated use `InputDatadogAgent$inboundSchema` instead. */
  export const inboundSchema = InputDatadogAgent$inboundSchema;
  /** @deprecated use `InputDatadogAgent$outboundSchema` instead. */
  export const outboundSchema = InputDatadogAgent$outboundSchema;
  /** @deprecated use `InputDatadogAgent$Outbound` instead. */
  export type Outbound = InputDatadogAgent$Outbound;
}

export function inputDatadogAgentToJSON(
  inputDatadogAgent: InputDatadogAgent,
): string {
  return JSON.stringify(
    InputDatadogAgent$outboundSchema.parse(inputDatadogAgent),
  );
}

export function inputDatadogAgentFromJSON(
  jsonString: string,
): SafeParseResult<InputDatadogAgent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatadogAgent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatadogAgent' from JSON`,
  );
}

/** @internal */
export const InputCrowdstrikeType$inboundSchema: z.ZodType<
  InputCrowdstrikeType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCrowdstrikeType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCrowdstrikeType$outboundSchema: z.ZodType<
  InputCrowdstrikeType,
  z.ZodTypeDef,
  InputCrowdstrikeType
> = z.union([
  z.nativeEnum(InputCrowdstrikeType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrikeType$ {
  /** @deprecated use `InputCrowdstrikeType$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrikeType$inboundSchema;
  /** @deprecated use `InputCrowdstrikeType$outboundSchema` instead. */
  export const outboundSchema = InputCrowdstrikeType$outboundSchema;
}

/** @internal */
export const InputCrowdstrikeConnection$inboundSchema: z.ZodType<
  InputCrowdstrikeConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputCrowdstrikeConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputCrowdstrikeConnection$outboundSchema: z.ZodType<
  InputCrowdstrikeConnection$Outbound,
  z.ZodTypeDef,
  InputCrowdstrikeConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrikeConnection$ {
  /** @deprecated use `InputCrowdstrikeConnection$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrikeConnection$inboundSchema;
  /** @deprecated use `InputCrowdstrikeConnection$outboundSchema` instead. */
  export const outboundSchema = InputCrowdstrikeConnection$outboundSchema;
  /** @deprecated use `InputCrowdstrikeConnection$Outbound` instead. */
  export type Outbound = InputCrowdstrikeConnection$Outbound;
}

export function inputCrowdstrikeConnectionToJSON(
  inputCrowdstrikeConnection: InputCrowdstrikeConnection,
): string {
  return JSON.stringify(
    InputCrowdstrikeConnection$outboundSchema.parse(inputCrowdstrikeConnection),
  );
}

export function inputCrowdstrikeConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputCrowdstrikeConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCrowdstrikeConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCrowdstrikeConnection' from JSON`,
  );
}

/** @internal */
export const InputCrowdstrikeMode$inboundSchema: z.ZodType<
  InputCrowdstrikeMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCrowdstrikeMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCrowdstrikeMode$outboundSchema: z.ZodType<
  InputCrowdstrikeMode,
  z.ZodTypeDef,
  InputCrowdstrikeMode
> = z.union([
  z.nativeEnum(InputCrowdstrikeMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrikeMode$ {
  /** @deprecated use `InputCrowdstrikeMode$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrikeMode$inboundSchema;
  /** @deprecated use `InputCrowdstrikeMode$outboundSchema` instead. */
  export const outboundSchema = InputCrowdstrikeMode$outboundSchema;
}

/** @internal */
export const InputCrowdstrikeCompression$inboundSchema: z.ZodType<
  InputCrowdstrikeCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCrowdstrikeCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCrowdstrikeCompression$outboundSchema: z.ZodType<
  InputCrowdstrikeCompression,
  z.ZodTypeDef,
  InputCrowdstrikeCompression
> = z.union([
  z.nativeEnum(InputCrowdstrikeCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrikeCompression$ {
  /** @deprecated use `InputCrowdstrikeCompression$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrikeCompression$inboundSchema;
  /** @deprecated use `InputCrowdstrikeCompression$outboundSchema` instead. */
  export const outboundSchema = InputCrowdstrikeCompression$outboundSchema;
}

/** @internal */
export const InputCrowdstrikePq$inboundSchema: z.ZodType<
  InputCrowdstrikePq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputCrowdstrikeMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputCrowdstrikeCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputCrowdstrikePq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputCrowdstrikePq$outboundSchema: z.ZodType<
  InputCrowdstrikePq$Outbound,
  z.ZodTypeDef,
  InputCrowdstrikePq
> = z.object({
  mode: InputCrowdstrikeMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputCrowdstrikeCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrikePq$ {
  /** @deprecated use `InputCrowdstrikePq$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrikePq$inboundSchema;
  /** @deprecated use `InputCrowdstrikePq$outboundSchema` instead. */
  export const outboundSchema = InputCrowdstrikePq$outboundSchema;
  /** @deprecated use `InputCrowdstrikePq$Outbound` instead. */
  export type Outbound = InputCrowdstrikePq$Outbound;
}

export function inputCrowdstrikePqToJSON(
  inputCrowdstrikePq: InputCrowdstrikePq,
): string {
  return JSON.stringify(
    InputCrowdstrikePq$outboundSchema.parse(inputCrowdstrikePq),
  );
}

export function inputCrowdstrikePqFromJSON(
  jsonString: string,
): SafeParseResult<InputCrowdstrikePq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCrowdstrikePq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCrowdstrikePq' from JSON`,
  );
}

/** @internal */
export const InputCrowdstrikeAuthenticationMethod$inboundSchema: z.ZodType<
  InputCrowdstrikeAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCrowdstrikeAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCrowdstrikeAuthenticationMethod$outboundSchema: z.ZodType<
  InputCrowdstrikeAuthenticationMethod,
  z.ZodTypeDef,
  InputCrowdstrikeAuthenticationMethod
> = z.union([
  z.nativeEnum(InputCrowdstrikeAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrikeAuthenticationMethod$ {
  /** @deprecated use `InputCrowdstrikeAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputCrowdstrikeAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputCrowdstrikeAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputCrowdstrikeAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputCrowdstrikeSignatureVersion$inboundSchema: z.ZodType<
  InputCrowdstrikeSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCrowdstrikeSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCrowdstrikeSignatureVersion$outboundSchema: z.ZodType<
  InputCrowdstrikeSignatureVersion,
  z.ZodTypeDef,
  InputCrowdstrikeSignatureVersion
> = z.union([
  z.nativeEnum(InputCrowdstrikeSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrikeSignatureVersion$ {
  /** @deprecated use `InputCrowdstrikeSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrikeSignatureVersion$inboundSchema;
  /** @deprecated use `InputCrowdstrikeSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = InputCrowdstrikeSignatureVersion$outboundSchema;
}

/** @internal */
export const InputCrowdstrikePreprocess$inboundSchema: z.ZodType<
  InputCrowdstrikePreprocess,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/** @internal */
export type InputCrowdstrikePreprocess$Outbound = {
  disabled: boolean;
  command?: string | undefined;
  args?: Array<string> | undefined;
};

/** @internal */
export const InputCrowdstrikePreprocess$outboundSchema: z.ZodType<
  InputCrowdstrikePreprocess$Outbound,
  z.ZodTypeDef,
  InputCrowdstrikePreprocess
> = z.object({
  disabled: z.boolean().default(true),
  command: z.string().optional(),
  args: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrikePreprocess$ {
  /** @deprecated use `InputCrowdstrikePreprocess$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrikePreprocess$inboundSchema;
  /** @deprecated use `InputCrowdstrikePreprocess$outboundSchema` instead. */
  export const outboundSchema = InputCrowdstrikePreprocess$outboundSchema;
  /** @deprecated use `InputCrowdstrikePreprocess$Outbound` instead. */
  export type Outbound = InputCrowdstrikePreprocess$Outbound;
}

export function inputCrowdstrikePreprocessToJSON(
  inputCrowdstrikePreprocess: InputCrowdstrikePreprocess,
): string {
  return JSON.stringify(
    InputCrowdstrikePreprocess$outboundSchema.parse(inputCrowdstrikePreprocess),
  );
}

export function inputCrowdstrikePreprocessFromJSON(
  jsonString: string,
): SafeParseResult<InputCrowdstrikePreprocess, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCrowdstrikePreprocess$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCrowdstrikePreprocess' from JSON`,
  );
}

/** @internal */
export const InputCrowdstrikeMetadatum$inboundSchema: z.ZodType<
  InputCrowdstrikeMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputCrowdstrikeMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputCrowdstrikeMetadatum$outboundSchema: z.ZodType<
  InputCrowdstrikeMetadatum$Outbound,
  z.ZodTypeDef,
  InputCrowdstrikeMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrikeMetadatum$ {
  /** @deprecated use `InputCrowdstrikeMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrikeMetadatum$inboundSchema;
  /** @deprecated use `InputCrowdstrikeMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputCrowdstrikeMetadatum$outboundSchema;
  /** @deprecated use `InputCrowdstrikeMetadatum$Outbound` instead. */
  export type Outbound = InputCrowdstrikeMetadatum$Outbound;
}

export function inputCrowdstrikeMetadatumToJSON(
  inputCrowdstrikeMetadatum: InputCrowdstrikeMetadatum,
): string {
  return JSON.stringify(
    InputCrowdstrikeMetadatum$outboundSchema.parse(inputCrowdstrikeMetadatum),
  );
}

export function inputCrowdstrikeMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputCrowdstrikeMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCrowdstrikeMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCrowdstrikeMetadatum' from JSON`,
  );
}

/** @internal */
export const InputCrowdstrikeCheckpointing$inboundSchema: z.ZodType<
  InputCrowdstrikeCheckpointing,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/** @internal */
export type InputCrowdstrikeCheckpointing$Outbound = {
  enabled: boolean;
  retries: number;
};

/** @internal */
export const InputCrowdstrikeCheckpointing$outboundSchema: z.ZodType<
  InputCrowdstrikeCheckpointing$Outbound,
  z.ZodTypeDef,
  InputCrowdstrikeCheckpointing
> = z.object({
  enabled: z.boolean().default(false),
  retries: z.number().default(5),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrikeCheckpointing$ {
  /** @deprecated use `InputCrowdstrikeCheckpointing$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrikeCheckpointing$inboundSchema;
  /** @deprecated use `InputCrowdstrikeCheckpointing$outboundSchema` instead. */
  export const outboundSchema = InputCrowdstrikeCheckpointing$outboundSchema;
  /** @deprecated use `InputCrowdstrikeCheckpointing$Outbound` instead. */
  export type Outbound = InputCrowdstrikeCheckpointing$Outbound;
}

export function inputCrowdstrikeCheckpointingToJSON(
  inputCrowdstrikeCheckpointing: InputCrowdstrikeCheckpointing,
): string {
  return JSON.stringify(
    InputCrowdstrikeCheckpointing$outboundSchema.parse(
      inputCrowdstrikeCheckpointing,
    ),
  );
}

export function inputCrowdstrikeCheckpointingFromJSON(
  jsonString: string,
): SafeParseResult<InputCrowdstrikeCheckpointing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCrowdstrikeCheckpointing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCrowdstrikeCheckpointing' from JSON`,
  );
}

/** @internal */
export const InputCrowdstrikeTagAfterProcessing$inboundSchema: z.ZodType<
  InputCrowdstrikeTagAfterProcessing,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCrowdstrikeTagAfterProcessing),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCrowdstrikeTagAfterProcessing$outboundSchema: z.ZodType<
  InputCrowdstrikeTagAfterProcessing,
  z.ZodTypeDef,
  InputCrowdstrikeTagAfterProcessing
> = z.union([
  z.nativeEnum(InputCrowdstrikeTagAfterProcessing),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrikeTagAfterProcessing$ {
  /** @deprecated use `InputCrowdstrikeTagAfterProcessing$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrikeTagAfterProcessing$inboundSchema;
  /** @deprecated use `InputCrowdstrikeTagAfterProcessing$outboundSchema` instead. */
  export const outboundSchema =
    InputCrowdstrikeTagAfterProcessing$outboundSchema;
}

/** @internal */
export const InputCrowdstrike$inboundSchema: z.ZodType<
  InputCrowdstrike,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputCrowdstrikeType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputCrowdstrikeConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputCrowdstrikePq$inboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: InputCrowdstrikeAuthenticationMethod$inboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputCrowdstrikeSignatureVersion$inboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(21600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => InputCrowdstrikePreprocess$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputCrowdstrikeMetadatum$inboundSchema))
    .optional(),
  checkpointing: z.lazy(() => InputCrowdstrikeCheckpointing$inboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  encoding: z.string().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: InputCrowdstrikeTagAfterProcessing$inboundSchema
    .optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/** @internal */
export type InputCrowdstrike$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputCrowdstrikeConnection$Outbound> | undefined;
  pq?: InputCrowdstrikePq$Outbound | undefined;
  queueName: string;
  fileFilter: string;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  maxMessages: number;
  visibilityTimeout: number;
  numReceivers: number;
  socketTimeout: number;
  skipOnError: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  enableSQSAssumeRole: boolean;
  preprocess?: InputCrowdstrikePreprocess$Outbound | undefined;
  metadata?: Array<InputCrowdstrikeMetadatum$Outbound> | undefined;
  checkpointing?: InputCrowdstrikeCheckpointing$Outbound | undefined;
  pollTimeout: number;
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputCrowdstrike$outboundSchema: z.ZodType<
  InputCrowdstrike$Outbound,
  z.ZodTypeDef,
  InputCrowdstrike
> = z.object({
  id: z.string(),
  type: InputCrowdstrikeType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputCrowdstrikeConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputCrowdstrikePq$outboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: InputCrowdstrikeAuthenticationMethod$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputCrowdstrikeSignatureVersion$outboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  maxMessages: z.number().default(1),
  visibilityTimeout: z.number().default(21600),
  numReceivers: z.number().default(1),
  socketTimeout: z.number().default(300),
  skipOnError: z.boolean().default(false),
  enableAssumeRole: z.boolean().default(true),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  enableSQSAssumeRole: z.boolean().default(false),
  preprocess: z.lazy(() => InputCrowdstrikePreprocess$outboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => InputCrowdstrikeMetadatum$outboundSchema))
    .optional(),
  checkpointing: z.lazy(() => InputCrowdstrikeCheckpointing$outboundSchema)
    .optional(),
  pollTimeout: z.number().default(10),
  encoding: z.string().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: InputCrowdstrikeTagAfterProcessing$outboundSchema
    .optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCrowdstrike$ {
  /** @deprecated use `InputCrowdstrike$inboundSchema` instead. */
  export const inboundSchema = InputCrowdstrike$inboundSchema;
  /** @deprecated use `InputCrowdstrike$outboundSchema` instead. */
  export const outboundSchema = InputCrowdstrike$outboundSchema;
  /** @deprecated use `InputCrowdstrike$Outbound` instead. */
  export type Outbound = InputCrowdstrike$Outbound;
}

export function inputCrowdstrikeToJSON(
  inputCrowdstrike: InputCrowdstrike,
): string {
  return JSON.stringify(
    InputCrowdstrike$outboundSchema.parse(inputCrowdstrike),
  );
}

export function inputCrowdstrikeFromJSON(
  jsonString: string,
): SafeParseResult<InputCrowdstrike, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCrowdstrike$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCrowdstrike' from JSON`,
  );
}

/** @internal */
export const InputTcpjsonType$inboundSchema: z.ZodType<
  InputTcpjsonType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpjsonType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpjsonType$outboundSchema: z.ZodType<
  InputTcpjsonType,
  z.ZodTypeDef,
  InputTcpjsonType
> = z.union([
  z.nativeEnum(InputTcpjsonType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjsonType$ {
  /** @deprecated use `InputTcpjsonType$inboundSchema` instead. */
  export const inboundSchema = InputTcpjsonType$inboundSchema;
  /** @deprecated use `InputTcpjsonType$outboundSchema` instead. */
  export const outboundSchema = InputTcpjsonType$outboundSchema;
}

/** @internal */
export const InputTcpjsonConnection$inboundSchema: z.ZodType<
  InputTcpjsonConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputTcpjsonConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputTcpjsonConnection$outboundSchema: z.ZodType<
  InputTcpjsonConnection$Outbound,
  z.ZodTypeDef,
  InputTcpjsonConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjsonConnection$ {
  /** @deprecated use `InputTcpjsonConnection$inboundSchema` instead. */
  export const inboundSchema = InputTcpjsonConnection$inboundSchema;
  /** @deprecated use `InputTcpjsonConnection$outboundSchema` instead. */
  export const outboundSchema = InputTcpjsonConnection$outboundSchema;
  /** @deprecated use `InputTcpjsonConnection$Outbound` instead. */
  export type Outbound = InputTcpjsonConnection$Outbound;
}

export function inputTcpjsonConnectionToJSON(
  inputTcpjsonConnection: InputTcpjsonConnection,
): string {
  return JSON.stringify(
    InputTcpjsonConnection$outboundSchema.parse(inputTcpjsonConnection),
  );
}

export function inputTcpjsonConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputTcpjsonConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcpjsonConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcpjsonConnection' from JSON`,
  );
}

/** @internal */
export const InputTcpjsonMode$inboundSchema: z.ZodType<
  InputTcpjsonMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpjsonMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpjsonMode$outboundSchema: z.ZodType<
  InputTcpjsonMode,
  z.ZodTypeDef,
  InputTcpjsonMode
> = z.union([
  z.nativeEnum(InputTcpjsonMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjsonMode$ {
  /** @deprecated use `InputTcpjsonMode$inboundSchema` instead. */
  export const inboundSchema = InputTcpjsonMode$inboundSchema;
  /** @deprecated use `InputTcpjsonMode$outboundSchema` instead. */
  export const outboundSchema = InputTcpjsonMode$outboundSchema;
}

/** @internal */
export const InputTcpjsonCompression$inboundSchema: z.ZodType<
  InputTcpjsonCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpjsonCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpjsonCompression$outboundSchema: z.ZodType<
  InputTcpjsonCompression,
  z.ZodTypeDef,
  InputTcpjsonCompression
> = z.union([
  z.nativeEnum(InputTcpjsonCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjsonCompression$ {
  /** @deprecated use `InputTcpjsonCompression$inboundSchema` instead. */
  export const inboundSchema = InputTcpjsonCompression$inboundSchema;
  /** @deprecated use `InputTcpjsonCompression$outboundSchema` instead. */
  export const outboundSchema = InputTcpjsonCompression$outboundSchema;
}

/** @internal */
export const InputTcpjsonPq$inboundSchema: z.ZodType<
  InputTcpjsonPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputTcpjsonMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputTcpjsonCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputTcpjsonPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputTcpjsonPq$outboundSchema: z.ZodType<
  InputTcpjsonPq$Outbound,
  z.ZodTypeDef,
  InputTcpjsonPq
> = z.object({
  mode: InputTcpjsonMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputTcpjsonCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjsonPq$ {
  /** @deprecated use `InputTcpjsonPq$inboundSchema` instead. */
  export const inboundSchema = InputTcpjsonPq$inboundSchema;
  /** @deprecated use `InputTcpjsonPq$outboundSchema` instead. */
  export const outboundSchema = InputTcpjsonPq$outboundSchema;
  /** @deprecated use `InputTcpjsonPq$Outbound` instead. */
  export type Outbound = InputTcpjsonPq$Outbound;
}

export function inputTcpjsonPqToJSON(inputTcpjsonPq: InputTcpjsonPq): string {
  return JSON.stringify(InputTcpjsonPq$outboundSchema.parse(inputTcpjsonPq));
}

export function inputTcpjsonPqFromJSON(
  jsonString: string,
): SafeParseResult<InputTcpjsonPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcpjsonPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcpjsonPq' from JSON`,
  );
}

/** @internal */
export const InputTcpjsonMinimumTLSVersion$inboundSchema: z.ZodType<
  InputTcpjsonMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpjsonMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpjsonMinimumTLSVersion$outboundSchema: z.ZodType<
  InputTcpjsonMinimumTLSVersion,
  z.ZodTypeDef,
  InputTcpjsonMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputTcpjsonMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjsonMinimumTLSVersion$ {
  /** @deprecated use `InputTcpjsonMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputTcpjsonMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputTcpjsonMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputTcpjsonMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputTcpjsonMaximumTLSVersion$inboundSchema: z.ZodType<
  InputTcpjsonMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpjsonMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpjsonMaximumTLSVersion$outboundSchema: z.ZodType<
  InputTcpjsonMaximumTLSVersion,
  z.ZodTypeDef,
  InputTcpjsonMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputTcpjsonMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjsonMaximumTLSVersion$ {
  /** @deprecated use `InputTcpjsonMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputTcpjsonMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputTcpjsonMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputTcpjsonMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputTcpjsonTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputTcpjsonTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputTcpjsonMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputTcpjsonMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputTcpjsonTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputTcpjsonTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputTcpjsonTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputTcpjsonTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputTcpjsonMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputTcpjsonMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjsonTLSSettingsServerSide$ {
  /** @deprecated use `InputTcpjsonTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputTcpjsonTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputTcpjsonTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputTcpjsonTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputTcpjsonTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputTcpjsonTLSSettingsServerSide$Outbound;
}

export function inputTcpjsonTLSSettingsServerSideToJSON(
  inputTcpjsonTLSSettingsServerSide: InputTcpjsonTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputTcpjsonTLSSettingsServerSide$outboundSchema.parse(
      inputTcpjsonTLSSettingsServerSide,
    ),
  );
}

export function inputTcpjsonTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputTcpjsonTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcpjsonTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcpjsonTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputTcpjsonMetadatum$inboundSchema: z.ZodType<
  InputTcpjsonMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputTcpjsonMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputTcpjsonMetadatum$outboundSchema: z.ZodType<
  InputTcpjsonMetadatum$Outbound,
  z.ZodTypeDef,
  InputTcpjsonMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjsonMetadatum$ {
  /** @deprecated use `InputTcpjsonMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputTcpjsonMetadatum$inboundSchema;
  /** @deprecated use `InputTcpjsonMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputTcpjsonMetadatum$outboundSchema;
  /** @deprecated use `InputTcpjsonMetadatum$Outbound` instead. */
  export type Outbound = InputTcpjsonMetadatum$Outbound;
}

export function inputTcpjsonMetadatumToJSON(
  inputTcpjsonMetadatum: InputTcpjsonMetadatum,
): string {
  return JSON.stringify(
    InputTcpjsonMetadatum$outboundSchema.parse(inputTcpjsonMetadatum),
  );
}

export function inputTcpjsonMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputTcpjsonMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcpjsonMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcpjsonMetadatum' from JSON`,
  );
}

/** @internal */
export const InputTcpjsonAuthenticationMethod$inboundSchema: z.ZodType<
  InputTcpjsonAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputTcpjsonAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputTcpjsonAuthenticationMethod$outboundSchema: z.ZodType<
  InputTcpjsonAuthenticationMethod,
  z.ZodTypeDef,
  InputTcpjsonAuthenticationMethod
> = z.union([
  z.nativeEnum(InputTcpjsonAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjsonAuthenticationMethod$ {
  /** @deprecated use `InputTcpjsonAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputTcpjsonAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputTcpjsonAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = InputTcpjsonAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputTcpjson$inboundSchema: z.ZodType<
  InputTcpjson,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputTcpjsonType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputTcpjsonConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputTcpjsonPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputTcpjsonTLSSettingsServerSide$inboundSchema).optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputTcpjsonMetadatum$inboundSchema))
    .optional(),
  enableLoadBalancing: z.boolean().default(false),
  authType: InputTcpjsonAuthenticationMethod$inboundSchema.default("manual"),
  description: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/** @internal */
export type InputTcpjson$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputTcpjsonConnection$Outbound> | undefined;
  pq?: InputTcpjsonPq$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputTcpjsonTLSSettingsServerSide$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<InputTcpjsonMetadatum$Outbound> | undefined;
  enableLoadBalancing: boolean;
  authType: string;
  description?: string | undefined;
  authToken: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcpjson$outboundSchema: z.ZodType<
  InputTcpjson$Outbound,
  z.ZodTypeDef,
  InputTcpjson
> = z.object({
  id: z.string(),
  type: InputTcpjsonType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputTcpjsonConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputTcpjsonPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputTcpjsonTLSSettingsServerSide$outboundSchema)
    .optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputTcpjsonMetadatum$outboundSchema))
    .optional(),
  enableLoadBalancing: z.boolean().default(false),
  authType: InputTcpjsonAuthenticationMethod$outboundSchema.default("manual"),
  description: z.string().optional(),
  authToken: z.string().default(""),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputTcpjson$ {
  /** @deprecated use `InputTcpjson$inboundSchema` instead. */
  export const inboundSchema = InputTcpjson$inboundSchema;
  /** @deprecated use `InputTcpjson$outboundSchema` instead. */
  export const outboundSchema = InputTcpjson$outboundSchema;
  /** @deprecated use `InputTcpjson$Outbound` instead. */
  export type Outbound = InputTcpjson$Outbound;
}

export function inputTcpjsonToJSON(inputTcpjson: InputTcpjson): string {
  return JSON.stringify(InputTcpjson$outboundSchema.parse(inputTcpjson));
}

export function inputTcpjsonFromJSON(
  jsonString: string,
): SafeParseResult<InputTcpjson, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcpjson$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcpjson' from JSON`,
  );
}

/** @internal */
export const InputCriblLakeHttpType$inboundSchema: z.ZodType<
  InputCriblLakeHttpType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblLakeHttpType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblLakeHttpType$outboundSchema: z.ZodType<
  InputCriblLakeHttpType,
  z.ZodTypeDef,
  InputCriblLakeHttpType
> = z.union([
  z.nativeEnum(InputCriblLakeHttpType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblLakeHttpType$ {
  /** @deprecated use `InputCriblLakeHttpType$inboundSchema` instead. */
  export const inboundSchema = InputCriblLakeHttpType$inboundSchema;
  /** @deprecated use `InputCriblLakeHttpType$outboundSchema` instead. */
  export const outboundSchema = InputCriblLakeHttpType$outboundSchema;
}

/** @internal */
export const InputCriblLakeHttpConnection$inboundSchema: z.ZodType<
  InputCriblLakeHttpConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputCriblLakeHttpConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputCriblLakeHttpConnection$outboundSchema: z.ZodType<
  InputCriblLakeHttpConnection$Outbound,
  z.ZodTypeDef,
  InputCriblLakeHttpConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblLakeHttpConnection$ {
  /** @deprecated use `InputCriblLakeHttpConnection$inboundSchema` instead. */
  export const inboundSchema = InputCriblLakeHttpConnection$inboundSchema;
  /** @deprecated use `InputCriblLakeHttpConnection$outboundSchema` instead. */
  export const outboundSchema = InputCriblLakeHttpConnection$outboundSchema;
  /** @deprecated use `InputCriblLakeHttpConnection$Outbound` instead. */
  export type Outbound = InputCriblLakeHttpConnection$Outbound;
}

export function inputCriblLakeHttpConnectionToJSON(
  inputCriblLakeHttpConnection: InputCriblLakeHttpConnection,
): string {
  return JSON.stringify(
    InputCriblLakeHttpConnection$outboundSchema.parse(
      inputCriblLakeHttpConnection,
    ),
  );
}

export function inputCriblLakeHttpConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblLakeHttpConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblLakeHttpConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblLakeHttpConnection' from JSON`,
  );
}

/** @internal */
export const InputCriblLakeHttpMode$inboundSchema: z.ZodType<
  InputCriblLakeHttpMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblLakeHttpMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblLakeHttpMode$outboundSchema: z.ZodType<
  InputCriblLakeHttpMode,
  z.ZodTypeDef,
  InputCriblLakeHttpMode
> = z.union([
  z.nativeEnum(InputCriblLakeHttpMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblLakeHttpMode$ {
  /** @deprecated use `InputCriblLakeHttpMode$inboundSchema` instead. */
  export const inboundSchema = InputCriblLakeHttpMode$inboundSchema;
  /** @deprecated use `InputCriblLakeHttpMode$outboundSchema` instead. */
  export const outboundSchema = InputCriblLakeHttpMode$outboundSchema;
}

/** @internal */
export const InputCriblLakeHttpCompression$inboundSchema: z.ZodType<
  InputCriblLakeHttpCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblLakeHttpCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblLakeHttpCompression$outboundSchema: z.ZodType<
  InputCriblLakeHttpCompression,
  z.ZodTypeDef,
  InputCriblLakeHttpCompression
> = z.union([
  z.nativeEnum(InputCriblLakeHttpCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblLakeHttpCompression$ {
  /** @deprecated use `InputCriblLakeHttpCompression$inboundSchema` instead. */
  export const inboundSchema = InputCriblLakeHttpCompression$inboundSchema;
  /** @deprecated use `InputCriblLakeHttpCompression$outboundSchema` instead. */
  export const outboundSchema = InputCriblLakeHttpCompression$outboundSchema;
}

/** @internal */
export const InputCriblLakeHttpPq$inboundSchema: z.ZodType<
  InputCriblLakeHttpPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputCriblLakeHttpMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputCriblLakeHttpCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputCriblLakeHttpPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputCriblLakeHttpPq$outboundSchema: z.ZodType<
  InputCriblLakeHttpPq$Outbound,
  z.ZodTypeDef,
  InputCriblLakeHttpPq
> = z.object({
  mode: InputCriblLakeHttpMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputCriblLakeHttpCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblLakeHttpPq$ {
  /** @deprecated use `InputCriblLakeHttpPq$inboundSchema` instead. */
  export const inboundSchema = InputCriblLakeHttpPq$inboundSchema;
  /** @deprecated use `InputCriblLakeHttpPq$outboundSchema` instead. */
  export const outboundSchema = InputCriblLakeHttpPq$outboundSchema;
  /** @deprecated use `InputCriblLakeHttpPq$Outbound` instead. */
  export type Outbound = InputCriblLakeHttpPq$Outbound;
}

export function inputCriblLakeHttpPqToJSON(
  inputCriblLakeHttpPq: InputCriblLakeHttpPq,
): string {
  return JSON.stringify(
    InputCriblLakeHttpPq$outboundSchema.parse(inputCriblLakeHttpPq),
  );
}

export function inputCriblLakeHttpPqFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblLakeHttpPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblLakeHttpPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblLakeHttpPq' from JSON`,
  );
}

/** @internal */
export const InputCriblLakeHttpMinimumTLSVersion$inboundSchema: z.ZodType<
  InputCriblLakeHttpMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblLakeHttpMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblLakeHttpMinimumTLSVersion$outboundSchema: z.ZodType<
  InputCriblLakeHttpMinimumTLSVersion,
  z.ZodTypeDef,
  InputCriblLakeHttpMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputCriblLakeHttpMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblLakeHttpMinimumTLSVersion$ {
  /** @deprecated use `InputCriblLakeHttpMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputCriblLakeHttpMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputCriblLakeHttpMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputCriblLakeHttpMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputCriblLakeHttpMaximumTLSVersion$inboundSchema: z.ZodType<
  InputCriblLakeHttpMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblLakeHttpMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblLakeHttpMaximumTLSVersion$outboundSchema: z.ZodType<
  InputCriblLakeHttpMaximumTLSVersion,
  z.ZodTypeDef,
  InputCriblLakeHttpMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputCriblLakeHttpMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblLakeHttpMaximumTLSVersion$ {
  /** @deprecated use `InputCriblLakeHttpMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputCriblLakeHttpMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputCriblLakeHttpMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputCriblLakeHttpMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputCriblLakeHttpTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputCriblLakeHttpTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputCriblLakeHttpMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputCriblLakeHttpMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputCriblLakeHttpTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputCriblLakeHttpTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputCriblLakeHttpTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputCriblLakeHttpTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputCriblLakeHttpMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputCriblLakeHttpMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblLakeHttpTLSSettingsServerSide$ {
  /** @deprecated use `InputCriblLakeHttpTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema =
    InputCriblLakeHttpTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputCriblLakeHttpTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputCriblLakeHttpTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputCriblLakeHttpTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputCriblLakeHttpTLSSettingsServerSide$Outbound;
}

export function inputCriblLakeHttpTLSSettingsServerSideToJSON(
  inputCriblLakeHttpTLSSettingsServerSide:
    InputCriblLakeHttpTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputCriblLakeHttpTLSSettingsServerSide$outboundSchema.parse(
      inputCriblLakeHttpTLSSettingsServerSide,
    ),
  );
}

export function inputCriblLakeHttpTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<
  InputCriblLakeHttpTLSSettingsServerSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputCriblLakeHttpTLSSettingsServerSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputCriblLakeHttpTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputCriblLakeHttpMetadatum$inboundSchema: z.ZodType<
  InputCriblLakeHttpMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputCriblLakeHttpMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputCriblLakeHttpMetadatum$outboundSchema: z.ZodType<
  InputCriblLakeHttpMetadatum$Outbound,
  z.ZodTypeDef,
  InputCriblLakeHttpMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblLakeHttpMetadatum$ {
  /** @deprecated use `InputCriblLakeHttpMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputCriblLakeHttpMetadatum$inboundSchema;
  /** @deprecated use `InputCriblLakeHttpMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputCriblLakeHttpMetadatum$outboundSchema;
  /** @deprecated use `InputCriblLakeHttpMetadatum$Outbound` instead. */
  export type Outbound = InputCriblLakeHttpMetadatum$Outbound;
}

export function inputCriblLakeHttpMetadatumToJSON(
  inputCriblLakeHttpMetadatum: InputCriblLakeHttpMetadatum,
): string {
  return JSON.stringify(
    InputCriblLakeHttpMetadatum$outboundSchema.parse(
      inputCriblLakeHttpMetadatum,
    ),
  );
}

export function inputCriblLakeHttpMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblLakeHttpMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblLakeHttpMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblLakeHttpMetadatum' from JSON`,
  );
}

/** @internal */
export const InputCriblLakeHttp$inboundSchema: z.ZodType<
  InputCriblLakeHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputCriblLakeHttpType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputCriblLakeHttpConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputCriblLakeHttpPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => InputCriblLakeHttpTLSSettingsServerSide$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => InputCriblLakeHttpMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputCriblLakeHttp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputCriblLakeHttpConnection$Outbound> | undefined;
  pq?: InputCriblLakeHttpPq$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: InputCriblLakeHttpTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  metadata?: Array<InputCriblLakeHttpMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblLakeHttp$outboundSchema: z.ZodType<
  InputCriblLakeHttp$Outbound,
  z.ZodTypeDef,
  InputCriblLakeHttp
> = z.object({
  id: z.string(),
  type: InputCriblLakeHttpType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputCriblLakeHttpConnection$outboundSchema),
  ).optional(),
  pq: z.lazy(() => InputCriblLakeHttpPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => InputCriblLakeHttpTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => InputCriblLakeHttpMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblLakeHttp$ {
  /** @deprecated use `InputCriblLakeHttp$inboundSchema` instead. */
  export const inboundSchema = InputCriblLakeHttp$inboundSchema;
  /** @deprecated use `InputCriblLakeHttp$outboundSchema` instead. */
  export const outboundSchema = InputCriblLakeHttp$outboundSchema;
  /** @deprecated use `InputCriblLakeHttp$Outbound` instead. */
  export type Outbound = InputCriblLakeHttp$Outbound;
}

export function inputCriblLakeHttpToJSON(
  inputCriblLakeHttp: InputCriblLakeHttp,
): string {
  return JSON.stringify(
    InputCriblLakeHttp$outboundSchema.parse(inputCriblLakeHttp),
  );
}

export function inputCriblLakeHttpFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblLakeHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblLakeHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblLakeHttp' from JSON`,
  );
}

/** @internal */
export const InputCriblHttpType$inboundSchema: z.ZodType<
  InputCriblHttpType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblHttpType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblHttpType$outboundSchema: z.ZodType<
  InputCriblHttpType,
  z.ZodTypeDef,
  InputCriblHttpType
> = z.union([
  z.nativeEnum(InputCriblHttpType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblHttpType$ {
  /** @deprecated use `InputCriblHttpType$inboundSchema` instead. */
  export const inboundSchema = InputCriblHttpType$inboundSchema;
  /** @deprecated use `InputCriblHttpType$outboundSchema` instead. */
  export const outboundSchema = InputCriblHttpType$outboundSchema;
}

/** @internal */
export const InputCriblHttpConnection$inboundSchema: z.ZodType<
  InputCriblHttpConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputCriblHttpConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputCriblHttpConnection$outboundSchema: z.ZodType<
  InputCriblHttpConnection$Outbound,
  z.ZodTypeDef,
  InputCriblHttpConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblHttpConnection$ {
  /** @deprecated use `InputCriblHttpConnection$inboundSchema` instead. */
  export const inboundSchema = InputCriblHttpConnection$inboundSchema;
  /** @deprecated use `InputCriblHttpConnection$outboundSchema` instead. */
  export const outboundSchema = InputCriblHttpConnection$outboundSchema;
  /** @deprecated use `InputCriblHttpConnection$Outbound` instead. */
  export type Outbound = InputCriblHttpConnection$Outbound;
}

export function inputCriblHttpConnectionToJSON(
  inputCriblHttpConnection: InputCriblHttpConnection,
): string {
  return JSON.stringify(
    InputCriblHttpConnection$outboundSchema.parse(inputCriblHttpConnection),
  );
}

export function inputCriblHttpConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblHttpConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblHttpConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblHttpConnection' from JSON`,
  );
}

/** @internal */
export const InputCriblHttpMode$inboundSchema: z.ZodType<
  InputCriblHttpMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblHttpMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblHttpMode$outboundSchema: z.ZodType<
  InputCriblHttpMode,
  z.ZodTypeDef,
  InputCriblHttpMode
> = z.union([
  z.nativeEnum(InputCriblHttpMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblHttpMode$ {
  /** @deprecated use `InputCriblHttpMode$inboundSchema` instead. */
  export const inboundSchema = InputCriblHttpMode$inboundSchema;
  /** @deprecated use `InputCriblHttpMode$outboundSchema` instead. */
  export const outboundSchema = InputCriblHttpMode$outboundSchema;
}

/** @internal */
export const InputCriblHttpCompression$inboundSchema: z.ZodType<
  InputCriblHttpCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblHttpCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblHttpCompression$outboundSchema: z.ZodType<
  InputCriblHttpCompression,
  z.ZodTypeDef,
  InputCriblHttpCompression
> = z.union([
  z.nativeEnum(InputCriblHttpCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblHttpCompression$ {
  /** @deprecated use `InputCriblHttpCompression$inboundSchema` instead. */
  export const inboundSchema = InputCriblHttpCompression$inboundSchema;
  /** @deprecated use `InputCriblHttpCompression$outboundSchema` instead. */
  export const outboundSchema = InputCriblHttpCompression$outboundSchema;
}

/** @internal */
export const InputCriblHttpPq$inboundSchema: z.ZodType<
  InputCriblHttpPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputCriblHttpMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputCriblHttpCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputCriblHttpPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputCriblHttpPq$outboundSchema: z.ZodType<
  InputCriblHttpPq$Outbound,
  z.ZodTypeDef,
  InputCriblHttpPq
> = z.object({
  mode: InputCriblHttpMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputCriblHttpCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblHttpPq$ {
  /** @deprecated use `InputCriblHttpPq$inboundSchema` instead. */
  export const inboundSchema = InputCriblHttpPq$inboundSchema;
  /** @deprecated use `InputCriblHttpPq$outboundSchema` instead. */
  export const outboundSchema = InputCriblHttpPq$outboundSchema;
  /** @deprecated use `InputCriblHttpPq$Outbound` instead. */
  export type Outbound = InputCriblHttpPq$Outbound;
}

export function inputCriblHttpPqToJSON(
  inputCriblHttpPq: InputCriblHttpPq,
): string {
  return JSON.stringify(
    InputCriblHttpPq$outboundSchema.parse(inputCriblHttpPq),
  );
}

export function inputCriblHttpPqFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblHttpPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblHttpPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblHttpPq' from JSON`,
  );
}

/** @internal */
export const InputCriblHttpMinimumTLSVersion$inboundSchema: z.ZodType<
  InputCriblHttpMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblHttpMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblHttpMinimumTLSVersion$outboundSchema: z.ZodType<
  InputCriblHttpMinimumTLSVersion,
  z.ZodTypeDef,
  InputCriblHttpMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputCriblHttpMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblHttpMinimumTLSVersion$ {
  /** @deprecated use `InputCriblHttpMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputCriblHttpMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputCriblHttpMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputCriblHttpMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputCriblHttpMaximumTLSVersion$inboundSchema: z.ZodType<
  InputCriblHttpMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblHttpMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblHttpMaximumTLSVersion$outboundSchema: z.ZodType<
  InputCriblHttpMaximumTLSVersion,
  z.ZodTypeDef,
  InputCriblHttpMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputCriblHttpMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblHttpMaximumTLSVersion$ {
  /** @deprecated use `InputCriblHttpMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputCriblHttpMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputCriblHttpMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputCriblHttpMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputCriblHttpTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputCriblHttpTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputCriblHttpMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputCriblHttpMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputCriblHttpTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputCriblHttpTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputCriblHttpTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputCriblHttpTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputCriblHttpMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputCriblHttpMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblHttpTLSSettingsServerSide$ {
  /** @deprecated use `InputCriblHttpTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema =
    InputCriblHttpTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputCriblHttpTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputCriblHttpTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputCriblHttpTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputCriblHttpTLSSettingsServerSide$Outbound;
}

export function inputCriblHttpTLSSettingsServerSideToJSON(
  inputCriblHttpTLSSettingsServerSide: InputCriblHttpTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputCriblHttpTLSSettingsServerSide$outboundSchema.parse(
      inputCriblHttpTLSSettingsServerSide,
    ),
  );
}

export function inputCriblHttpTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblHttpTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputCriblHttpTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblHttpTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputCriblHttpMetadatum$inboundSchema: z.ZodType<
  InputCriblHttpMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputCriblHttpMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputCriblHttpMetadatum$outboundSchema: z.ZodType<
  InputCriblHttpMetadatum$Outbound,
  z.ZodTypeDef,
  InputCriblHttpMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblHttpMetadatum$ {
  /** @deprecated use `InputCriblHttpMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputCriblHttpMetadatum$inboundSchema;
  /** @deprecated use `InputCriblHttpMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputCriblHttpMetadatum$outboundSchema;
  /** @deprecated use `InputCriblHttpMetadatum$Outbound` instead. */
  export type Outbound = InputCriblHttpMetadatum$Outbound;
}

export function inputCriblHttpMetadatumToJSON(
  inputCriblHttpMetadatum: InputCriblHttpMetadatum,
): string {
  return JSON.stringify(
    InputCriblHttpMetadatum$outboundSchema.parse(inputCriblHttpMetadatum),
  );
}

export function inputCriblHttpMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblHttpMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblHttpMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblHttpMetadatum' from JSON`,
  );
}

/** @internal */
export const InputCriblHttp$inboundSchema: z.ZodType<
  InputCriblHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputCriblHttpType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputCriblHttpConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputCriblHttpPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => InputCriblHttpTLSSettingsServerSide$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => InputCriblHttpMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputCriblHttp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputCriblHttpConnection$Outbound> | undefined;
  pq?: InputCriblHttpPq$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: InputCriblHttpTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  metadata?: Array<InputCriblHttpMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblHttp$outboundSchema: z.ZodType<
  InputCriblHttp$Outbound,
  z.ZodTypeDef,
  InputCriblHttp
> = z.object({
  id: z.string(),
  type: InputCriblHttpType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputCriblHttpConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputCriblHttpPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => InputCriblHttpTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => InputCriblHttpMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblHttp$ {
  /** @deprecated use `InputCriblHttp$inboundSchema` instead. */
  export const inboundSchema = InputCriblHttp$inboundSchema;
  /** @deprecated use `InputCriblHttp$outboundSchema` instead. */
  export const outboundSchema = InputCriblHttp$outboundSchema;
  /** @deprecated use `InputCriblHttp$Outbound` instead. */
  export type Outbound = InputCriblHttp$Outbound;
}

export function inputCriblHttpToJSON(inputCriblHttp: InputCriblHttp): string {
  return JSON.stringify(InputCriblHttp$outboundSchema.parse(inputCriblHttp));
}

export function inputCriblHttpFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblHttp' from JSON`,
  );
}

/** @internal */
export const InputCriblTcpType$inboundSchema: z.ZodType<
  InputCriblTcpType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblTcpType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblTcpType$outboundSchema: z.ZodType<
  InputCriblTcpType,
  z.ZodTypeDef,
  InputCriblTcpType
> = z.union([
  z.nativeEnum(InputCriblTcpType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblTcpType$ {
  /** @deprecated use `InputCriblTcpType$inboundSchema` instead. */
  export const inboundSchema = InputCriblTcpType$inboundSchema;
  /** @deprecated use `InputCriblTcpType$outboundSchema` instead. */
  export const outboundSchema = InputCriblTcpType$outboundSchema;
}

/** @internal */
export const InputCriblTcpConnection$inboundSchema: z.ZodType<
  InputCriblTcpConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputCriblTcpConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputCriblTcpConnection$outboundSchema: z.ZodType<
  InputCriblTcpConnection$Outbound,
  z.ZodTypeDef,
  InputCriblTcpConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblTcpConnection$ {
  /** @deprecated use `InputCriblTcpConnection$inboundSchema` instead. */
  export const inboundSchema = InputCriblTcpConnection$inboundSchema;
  /** @deprecated use `InputCriblTcpConnection$outboundSchema` instead. */
  export const outboundSchema = InputCriblTcpConnection$outboundSchema;
  /** @deprecated use `InputCriblTcpConnection$Outbound` instead. */
  export type Outbound = InputCriblTcpConnection$Outbound;
}

export function inputCriblTcpConnectionToJSON(
  inputCriblTcpConnection: InputCriblTcpConnection,
): string {
  return JSON.stringify(
    InputCriblTcpConnection$outboundSchema.parse(inputCriblTcpConnection),
  );
}

export function inputCriblTcpConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblTcpConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblTcpConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblTcpConnection' from JSON`,
  );
}

/** @internal */
export const InputCriblTcpMode$inboundSchema: z.ZodType<
  InputCriblTcpMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblTcpMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblTcpMode$outboundSchema: z.ZodType<
  InputCriblTcpMode,
  z.ZodTypeDef,
  InputCriblTcpMode
> = z.union([
  z.nativeEnum(InputCriblTcpMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblTcpMode$ {
  /** @deprecated use `InputCriblTcpMode$inboundSchema` instead. */
  export const inboundSchema = InputCriblTcpMode$inboundSchema;
  /** @deprecated use `InputCriblTcpMode$outboundSchema` instead. */
  export const outboundSchema = InputCriblTcpMode$outboundSchema;
}

/** @internal */
export const InputCriblTcpCompression$inboundSchema: z.ZodType<
  InputCriblTcpCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblTcpCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblTcpCompression$outboundSchema: z.ZodType<
  InputCriblTcpCompression,
  z.ZodTypeDef,
  InputCriblTcpCompression
> = z.union([
  z.nativeEnum(InputCriblTcpCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblTcpCompression$ {
  /** @deprecated use `InputCriblTcpCompression$inboundSchema` instead. */
  export const inboundSchema = InputCriblTcpCompression$inboundSchema;
  /** @deprecated use `InputCriblTcpCompression$outboundSchema` instead. */
  export const outboundSchema = InputCriblTcpCompression$outboundSchema;
}

/** @internal */
export const InputCriblTcpPq$inboundSchema: z.ZodType<
  InputCriblTcpPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputCriblTcpMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputCriblTcpCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputCriblTcpPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputCriblTcpPq$outboundSchema: z.ZodType<
  InputCriblTcpPq$Outbound,
  z.ZodTypeDef,
  InputCriblTcpPq
> = z.object({
  mode: InputCriblTcpMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputCriblTcpCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblTcpPq$ {
  /** @deprecated use `InputCriblTcpPq$inboundSchema` instead. */
  export const inboundSchema = InputCriblTcpPq$inboundSchema;
  /** @deprecated use `InputCriblTcpPq$outboundSchema` instead. */
  export const outboundSchema = InputCriblTcpPq$outboundSchema;
  /** @deprecated use `InputCriblTcpPq$Outbound` instead. */
  export type Outbound = InputCriblTcpPq$Outbound;
}

export function inputCriblTcpPqToJSON(
  inputCriblTcpPq: InputCriblTcpPq,
): string {
  return JSON.stringify(InputCriblTcpPq$outboundSchema.parse(inputCriblTcpPq));
}

export function inputCriblTcpPqFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblTcpPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblTcpPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblTcpPq' from JSON`,
  );
}

/** @internal */
export const InputCriblTcpMinimumTLSVersion$inboundSchema: z.ZodType<
  InputCriblTcpMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblTcpMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblTcpMinimumTLSVersion$outboundSchema: z.ZodType<
  InputCriblTcpMinimumTLSVersion,
  z.ZodTypeDef,
  InputCriblTcpMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputCriblTcpMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblTcpMinimumTLSVersion$ {
  /** @deprecated use `InputCriblTcpMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputCriblTcpMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputCriblTcpMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputCriblTcpMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputCriblTcpMaximumTLSVersion$inboundSchema: z.ZodType<
  InputCriblTcpMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputCriblTcpMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputCriblTcpMaximumTLSVersion$outboundSchema: z.ZodType<
  InputCriblTcpMaximumTLSVersion,
  z.ZodTypeDef,
  InputCriblTcpMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputCriblTcpMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblTcpMaximumTLSVersion$ {
  /** @deprecated use `InputCriblTcpMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputCriblTcpMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputCriblTcpMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputCriblTcpMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputCriblTcpTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputCriblTcpTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputCriblTcpMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputCriblTcpMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputCriblTcpTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputCriblTcpTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputCriblTcpTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputCriblTcpTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputCriblTcpMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputCriblTcpMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblTcpTLSSettingsServerSide$ {
  /** @deprecated use `InputCriblTcpTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputCriblTcpTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputCriblTcpTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputCriblTcpTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputCriblTcpTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputCriblTcpTLSSettingsServerSide$Outbound;
}

export function inputCriblTcpTLSSettingsServerSideToJSON(
  inputCriblTcpTLSSettingsServerSide: InputCriblTcpTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputCriblTcpTLSSettingsServerSide$outboundSchema.parse(
      inputCriblTcpTLSSettingsServerSide,
    ),
  );
}

export function inputCriblTcpTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblTcpTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputCriblTcpTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblTcpTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputCriblTcpMetadatum$inboundSchema: z.ZodType<
  InputCriblTcpMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputCriblTcpMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputCriblTcpMetadatum$outboundSchema: z.ZodType<
  InputCriblTcpMetadatum$Outbound,
  z.ZodTypeDef,
  InputCriblTcpMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblTcpMetadatum$ {
  /** @deprecated use `InputCriblTcpMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputCriblTcpMetadatum$inboundSchema;
  /** @deprecated use `InputCriblTcpMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputCriblTcpMetadatum$outboundSchema;
  /** @deprecated use `InputCriblTcpMetadatum$Outbound` instead. */
  export type Outbound = InputCriblTcpMetadatum$Outbound;
}

export function inputCriblTcpMetadatumToJSON(
  inputCriblTcpMetadatum: InputCriblTcpMetadatum,
): string {
  return JSON.stringify(
    InputCriblTcpMetadatum$outboundSchema.parse(inputCriblTcpMetadatum),
  );
}

export function inputCriblTcpMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblTcpMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblTcpMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblTcpMetadatum' from JSON`,
  );
}

/** @internal */
export const InputCriblTcp$inboundSchema: z.ZodType<
  InputCriblTcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputCriblTcpType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputCriblTcpConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputCriblTcpPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputCriblTcpTLSSettingsServerSide$inboundSchema)
    .optional(),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputCriblTcpMetadatum$inboundSchema))
    .optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
});

/** @internal */
export type InputCriblTcp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputCriblTcpConnection$Outbound> | undefined;
  pq?: InputCriblTcpPq$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputCriblTcpTLSSettingsServerSide$Outbound | undefined;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<InputCriblTcpMetadatum$Outbound> | undefined;
  enableLoadBalancing: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputCriblTcp$outboundSchema: z.ZodType<
  InputCriblTcp$Outbound,
  z.ZodTypeDef,
  InputCriblTcp
> = z.object({
  id: z.string(),
  type: InputCriblTcpType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputCriblTcpConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputCriblTcpPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputCriblTcpTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputCriblTcpMetadatum$outboundSchema))
    .optional(),
  enableLoadBalancing: z.boolean().default(false),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputCriblTcp$ {
  /** @deprecated use `InputCriblTcp$inboundSchema` instead. */
  export const inboundSchema = InputCriblTcp$inboundSchema;
  /** @deprecated use `InputCriblTcp$outboundSchema` instead. */
  export const outboundSchema = InputCriblTcp$outboundSchema;
  /** @deprecated use `InputCriblTcp$Outbound` instead. */
  export type Outbound = InputCriblTcp$Outbound;
}

export function inputCriblTcpToJSON(inputCriblTcp: InputCriblTcp): string {
  return JSON.stringify(InputCriblTcp$outboundSchema.parse(inputCriblTcp));
}

export function inputCriblTcpFromJSON(
  jsonString: string,
): SafeParseResult<InputCriblTcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputCriblTcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputCriblTcp' from JSON`,
  );
}

/** @internal */
export const InputGooglePubsubType$inboundSchema: z.ZodType<
  InputGooglePubsubType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGooglePubsubType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGooglePubsubType$outboundSchema: z.ZodType<
  InputGooglePubsubType,
  z.ZodTypeDef,
  InputGooglePubsubType
> = z.union([
  z.nativeEnum(InputGooglePubsubType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGooglePubsubType$ {
  /** @deprecated use `InputGooglePubsubType$inboundSchema` instead. */
  export const inboundSchema = InputGooglePubsubType$inboundSchema;
  /** @deprecated use `InputGooglePubsubType$outboundSchema` instead. */
  export const outboundSchema = InputGooglePubsubType$outboundSchema;
}

/** @internal */
export const InputGooglePubsubConnection$inboundSchema: z.ZodType<
  InputGooglePubsubConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputGooglePubsubConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputGooglePubsubConnection$outboundSchema: z.ZodType<
  InputGooglePubsubConnection$Outbound,
  z.ZodTypeDef,
  InputGooglePubsubConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGooglePubsubConnection$ {
  /** @deprecated use `InputGooglePubsubConnection$inboundSchema` instead. */
  export const inboundSchema = InputGooglePubsubConnection$inboundSchema;
  /** @deprecated use `InputGooglePubsubConnection$outboundSchema` instead. */
  export const outboundSchema = InputGooglePubsubConnection$outboundSchema;
  /** @deprecated use `InputGooglePubsubConnection$Outbound` instead. */
  export type Outbound = InputGooglePubsubConnection$Outbound;
}

export function inputGooglePubsubConnectionToJSON(
  inputGooglePubsubConnection: InputGooglePubsubConnection,
): string {
  return JSON.stringify(
    InputGooglePubsubConnection$outboundSchema.parse(
      inputGooglePubsubConnection,
    ),
  );
}

export function inputGooglePubsubConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputGooglePubsubConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGooglePubsubConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGooglePubsubConnection' from JSON`,
  );
}

/** @internal */
export const InputGooglePubsubMode$inboundSchema: z.ZodType<
  InputGooglePubsubMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGooglePubsubMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGooglePubsubMode$outboundSchema: z.ZodType<
  InputGooglePubsubMode,
  z.ZodTypeDef,
  InputGooglePubsubMode
> = z.union([
  z.nativeEnum(InputGooglePubsubMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGooglePubsubMode$ {
  /** @deprecated use `InputGooglePubsubMode$inboundSchema` instead. */
  export const inboundSchema = InputGooglePubsubMode$inboundSchema;
  /** @deprecated use `InputGooglePubsubMode$outboundSchema` instead. */
  export const outboundSchema = InputGooglePubsubMode$outboundSchema;
}

/** @internal */
export const InputGooglePubsubCompression$inboundSchema: z.ZodType<
  InputGooglePubsubCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGooglePubsubCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGooglePubsubCompression$outboundSchema: z.ZodType<
  InputGooglePubsubCompression,
  z.ZodTypeDef,
  InputGooglePubsubCompression
> = z.union([
  z.nativeEnum(InputGooglePubsubCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGooglePubsubCompression$ {
  /** @deprecated use `InputGooglePubsubCompression$inboundSchema` instead. */
  export const inboundSchema = InputGooglePubsubCompression$inboundSchema;
  /** @deprecated use `InputGooglePubsubCompression$outboundSchema` instead. */
  export const outboundSchema = InputGooglePubsubCompression$outboundSchema;
}

/** @internal */
export const InputGooglePubsubPq$inboundSchema: z.ZodType<
  InputGooglePubsubPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputGooglePubsubMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGooglePubsubCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputGooglePubsubPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputGooglePubsubPq$outboundSchema: z.ZodType<
  InputGooglePubsubPq$Outbound,
  z.ZodTypeDef,
  InputGooglePubsubPq
> = z.object({
  mode: InputGooglePubsubMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGooglePubsubCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGooglePubsubPq$ {
  /** @deprecated use `InputGooglePubsubPq$inboundSchema` instead. */
  export const inboundSchema = InputGooglePubsubPq$inboundSchema;
  /** @deprecated use `InputGooglePubsubPq$outboundSchema` instead. */
  export const outboundSchema = InputGooglePubsubPq$outboundSchema;
  /** @deprecated use `InputGooglePubsubPq$Outbound` instead. */
  export type Outbound = InputGooglePubsubPq$Outbound;
}

export function inputGooglePubsubPqToJSON(
  inputGooglePubsubPq: InputGooglePubsubPq,
): string {
  return JSON.stringify(
    InputGooglePubsubPq$outboundSchema.parse(inputGooglePubsubPq),
  );
}

export function inputGooglePubsubPqFromJSON(
  jsonString: string,
): SafeParseResult<InputGooglePubsubPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGooglePubsubPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGooglePubsubPq' from JSON`,
  );
}

/** @internal */
export const CreateInputGoogleAuthenticationMethod$inboundSchema: z.ZodType<
  CreateInputGoogleAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CreateInputGoogleAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CreateInputGoogleAuthenticationMethod$outboundSchema: z.ZodType<
  CreateInputGoogleAuthenticationMethod,
  z.ZodTypeDef,
  CreateInputGoogleAuthenticationMethod
> = z.union([
  z.nativeEnum(CreateInputGoogleAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputGoogleAuthenticationMethod$ {
  /** @deprecated use `CreateInputGoogleAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    CreateInputGoogleAuthenticationMethod$inboundSchema;
  /** @deprecated use `CreateInputGoogleAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    CreateInputGoogleAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputGooglePubsubMetadatum$inboundSchema: z.ZodType<
  InputGooglePubsubMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputGooglePubsubMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputGooglePubsubMetadatum$outboundSchema: z.ZodType<
  InputGooglePubsubMetadatum$Outbound,
  z.ZodTypeDef,
  InputGooglePubsubMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGooglePubsubMetadatum$ {
  /** @deprecated use `InputGooglePubsubMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputGooglePubsubMetadatum$inboundSchema;
  /** @deprecated use `InputGooglePubsubMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputGooglePubsubMetadatum$outboundSchema;
  /** @deprecated use `InputGooglePubsubMetadatum$Outbound` instead. */
  export type Outbound = InputGooglePubsubMetadatum$Outbound;
}

export function inputGooglePubsubMetadatumToJSON(
  inputGooglePubsubMetadatum: InputGooglePubsubMetadatum,
): string {
  return JSON.stringify(
    InputGooglePubsubMetadatum$outboundSchema.parse(inputGooglePubsubMetadatum),
  );
}

export function inputGooglePubsubMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputGooglePubsubMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGooglePubsubMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGooglePubsubMetadatum' from JSON`,
  );
}

/** @internal */
export const InputGooglePubsub$inboundSchema: z.ZodType<
  InputGooglePubsub,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputGooglePubsubType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGooglePubsubConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputGooglePubsubPq$inboundSchema).optional(),
  topicName: z.string(),
  subscriptionName: z.string(),
  createTopic: z.boolean().default(false),
  createSubscription: z.boolean().default(true),
  region: z.string().optional(),
  googleAuthMethod: CreateInputGoogleAuthenticationMethod$inboundSchema.default(
    "manual",
  ),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  maxBacklog: z.number().default(1000),
  concurrency: z.number().default(5),
  requestTimeout: z.number().default(60000),
  metadata: z.array(z.lazy(() => InputGooglePubsubMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
  orderedDelivery: z.boolean().default(false),
});

/** @internal */
export type InputGooglePubsub$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputGooglePubsubConnection$Outbound> | undefined;
  pq?: InputGooglePubsubPq$Outbound | undefined;
  topicName: string;
  subscriptionName: string;
  createTopic: boolean;
  createSubscription: boolean;
  region?: string | undefined;
  googleAuthMethod: string;
  serviceAccountCredentials?: string | undefined;
  secret?: string | undefined;
  maxBacklog: number;
  concurrency: number;
  requestTimeout: number;
  metadata?: Array<InputGooglePubsubMetadatum$Outbound> | undefined;
  description?: string | undefined;
  orderedDelivery: boolean;
};

/** @internal */
export const InputGooglePubsub$outboundSchema: z.ZodType<
  InputGooglePubsub$Outbound,
  z.ZodTypeDef,
  InputGooglePubsub
> = z.object({
  id: z.string(),
  type: InputGooglePubsubType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGooglePubsubConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputGooglePubsubPq$outboundSchema).optional(),
  topicName: z.string(),
  subscriptionName: z.string(),
  createTopic: z.boolean().default(false),
  createSubscription: z.boolean().default(true),
  region: z.string().optional(),
  googleAuthMethod: CreateInputGoogleAuthenticationMethod$outboundSchema
    .default("manual"),
  serviceAccountCredentials: z.string().optional(),
  secret: z.string().optional(),
  maxBacklog: z.number().default(1000),
  concurrency: z.number().default(5),
  requestTimeout: z.number().default(60000),
  metadata: z.array(z.lazy(() => InputGooglePubsubMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
  orderedDelivery: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGooglePubsub$ {
  /** @deprecated use `InputGooglePubsub$inboundSchema` instead. */
  export const inboundSchema = InputGooglePubsub$inboundSchema;
  /** @deprecated use `InputGooglePubsub$outboundSchema` instead. */
  export const outboundSchema = InputGooglePubsub$outboundSchema;
  /** @deprecated use `InputGooglePubsub$Outbound` instead. */
  export type Outbound = InputGooglePubsub$Outbound;
}

export function inputGooglePubsubToJSON(
  inputGooglePubsub: InputGooglePubsub,
): string {
  return JSON.stringify(
    InputGooglePubsub$outboundSchema.parse(inputGooglePubsub),
  );
}

export function inputGooglePubsubFromJSON(
  jsonString: string,
): SafeParseResult<InputGooglePubsub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGooglePubsub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGooglePubsub' from JSON`,
  );
}

/** @internal */
export const InputFirehoseType$inboundSchema: z.ZodType<
  InputFirehoseType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputFirehoseType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputFirehoseType$outboundSchema: z.ZodType<
  InputFirehoseType,
  z.ZodTypeDef,
  InputFirehoseType
> = z.union([
  z.nativeEnum(InputFirehoseType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputFirehoseType$ {
  /** @deprecated use `InputFirehoseType$inboundSchema` instead. */
  export const inboundSchema = InputFirehoseType$inboundSchema;
  /** @deprecated use `InputFirehoseType$outboundSchema` instead. */
  export const outboundSchema = InputFirehoseType$outboundSchema;
}

/** @internal */
export const InputFirehoseConnection$inboundSchema: z.ZodType<
  InputFirehoseConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputFirehoseConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputFirehoseConnection$outboundSchema: z.ZodType<
  InputFirehoseConnection$Outbound,
  z.ZodTypeDef,
  InputFirehoseConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputFirehoseConnection$ {
  /** @deprecated use `InputFirehoseConnection$inboundSchema` instead. */
  export const inboundSchema = InputFirehoseConnection$inboundSchema;
  /** @deprecated use `InputFirehoseConnection$outboundSchema` instead. */
  export const outboundSchema = InputFirehoseConnection$outboundSchema;
  /** @deprecated use `InputFirehoseConnection$Outbound` instead. */
  export type Outbound = InputFirehoseConnection$Outbound;
}

export function inputFirehoseConnectionToJSON(
  inputFirehoseConnection: InputFirehoseConnection,
): string {
  return JSON.stringify(
    InputFirehoseConnection$outboundSchema.parse(inputFirehoseConnection),
  );
}

export function inputFirehoseConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputFirehoseConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputFirehoseConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputFirehoseConnection' from JSON`,
  );
}

/** @internal */
export const InputFirehoseMode$inboundSchema: z.ZodType<
  InputFirehoseMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputFirehoseMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputFirehoseMode$outboundSchema: z.ZodType<
  InputFirehoseMode,
  z.ZodTypeDef,
  InputFirehoseMode
> = z.union([
  z.nativeEnum(InputFirehoseMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputFirehoseMode$ {
  /** @deprecated use `InputFirehoseMode$inboundSchema` instead. */
  export const inboundSchema = InputFirehoseMode$inboundSchema;
  /** @deprecated use `InputFirehoseMode$outboundSchema` instead. */
  export const outboundSchema = InputFirehoseMode$outboundSchema;
}

/** @internal */
export const InputFirehoseCompression$inboundSchema: z.ZodType<
  InputFirehoseCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputFirehoseCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputFirehoseCompression$outboundSchema: z.ZodType<
  InputFirehoseCompression,
  z.ZodTypeDef,
  InputFirehoseCompression
> = z.union([
  z.nativeEnum(InputFirehoseCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputFirehoseCompression$ {
  /** @deprecated use `InputFirehoseCompression$inboundSchema` instead. */
  export const inboundSchema = InputFirehoseCompression$inboundSchema;
  /** @deprecated use `InputFirehoseCompression$outboundSchema` instead. */
  export const outboundSchema = InputFirehoseCompression$outboundSchema;
}

/** @internal */
export const InputFirehosePq$inboundSchema: z.ZodType<
  InputFirehosePq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputFirehoseMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputFirehoseCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputFirehosePq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputFirehosePq$outboundSchema: z.ZodType<
  InputFirehosePq$Outbound,
  z.ZodTypeDef,
  InputFirehosePq
> = z.object({
  mode: InputFirehoseMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputFirehoseCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputFirehosePq$ {
  /** @deprecated use `InputFirehosePq$inboundSchema` instead. */
  export const inboundSchema = InputFirehosePq$inboundSchema;
  /** @deprecated use `InputFirehosePq$outboundSchema` instead. */
  export const outboundSchema = InputFirehosePq$outboundSchema;
  /** @deprecated use `InputFirehosePq$Outbound` instead. */
  export type Outbound = InputFirehosePq$Outbound;
}

export function inputFirehosePqToJSON(
  inputFirehosePq: InputFirehosePq,
): string {
  return JSON.stringify(InputFirehosePq$outboundSchema.parse(inputFirehosePq));
}

export function inputFirehosePqFromJSON(
  jsonString: string,
): SafeParseResult<InputFirehosePq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputFirehosePq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputFirehosePq' from JSON`,
  );
}

/** @internal */
export const InputFirehoseMinimumTLSVersion$inboundSchema: z.ZodType<
  InputFirehoseMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputFirehoseMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputFirehoseMinimumTLSVersion$outboundSchema: z.ZodType<
  InputFirehoseMinimumTLSVersion,
  z.ZodTypeDef,
  InputFirehoseMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputFirehoseMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputFirehoseMinimumTLSVersion$ {
  /** @deprecated use `InputFirehoseMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputFirehoseMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputFirehoseMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputFirehoseMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputFirehoseMaximumTLSVersion$inboundSchema: z.ZodType<
  InputFirehoseMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputFirehoseMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputFirehoseMaximumTLSVersion$outboundSchema: z.ZodType<
  InputFirehoseMaximumTLSVersion,
  z.ZodTypeDef,
  InputFirehoseMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputFirehoseMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputFirehoseMaximumTLSVersion$ {
  /** @deprecated use `InputFirehoseMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputFirehoseMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputFirehoseMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputFirehoseMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputFirehoseTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputFirehoseTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputFirehoseMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputFirehoseMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputFirehoseTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputFirehoseTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputFirehoseTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputFirehoseTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputFirehoseMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputFirehoseMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputFirehoseTLSSettingsServerSide$ {
  /** @deprecated use `InputFirehoseTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputFirehoseTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputFirehoseTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputFirehoseTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputFirehoseTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputFirehoseTLSSettingsServerSide$Outbound;
}

export function inputFirehoseTLSSettingsServerSideToJSON(
  inputFirehoseTLSSettingsServerSide: InputFirehoseTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputFirehoseTLSSettingsServerSide$outboundSchema.parse(
      inputFirehoseTLSSettingsServerSide,
    ),
  );
}

export function inputFirehoseTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputFirehoseTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputFirehoseTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputFirehoseTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputFirehoseMetadatum$inboundSchema: z.ZodType<
  InputFirehoseMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputFirehoseMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputFirehoseMetadatum$outboundSchema: z.ZodType<
  InputFirehoseMetadatum$Outbound,
  z.ZodTypeDef,
  InputFirehoseMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputFirehoseMetadatum$ {
  /** @deprecated use `InputFirehoseMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputFirehoseMetadatum$inboundSchema;
  /** @deprecated use `InputFirehoseMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputFirehoseMetadatum$outboundSchema;
  /** @deprecated use `InputFirehoseMetadatum$Outbound` instead. */
  export type Outbound = InputFirehoseMetadatum$Outbound;
}

export function inputFirehoseMetadatumToJSON(
  inputFirehoseMetadatum: InputFirehoseMetadatum,
): string {
  return JSON.stringify(
    InputFirehoseMetadatum$outboundSchema.parse(inputFirehoseMetadatum),
  );
}

export function inputFirehoseMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputFirehoseMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputFirehoseMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputFirehoseMetadatum' from JSON`,
  );
}

/** @internal */
export const InputFirehose$inboundSchema: z.ZodType<
  InputFirehose,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputFirehoseType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputFirehoseConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputFirehosePq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => InputFirehoseTLSSettingsServerSide$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => InputFirehoseMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputFirehose$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputFirehoseConnection$Outbound> | undefined;
  pq?: InputFirehosePq$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: InputFirehoseTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  metadata?: Array<InputFirehoseMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputFirehose$outboundSchema: z.ZodType<
  InputFirehose$Outbound,
  z.ZodTypeDef,
  InputFirehose
> = z.object({
  id: z.string(),
  type: InputFirehoseType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputFirehoseConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputFirehosePq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => InputFirehoseTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  metadata: z.array(z.lazy(() => InputFirehoseMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputFirehose$ {
  /** @deprecated use `InputFirehose$inboundSchema` instead. */
  export const inboundSchema = InputFirehose$inboundSchema;
  /** @deprecated use `InputFirehose$outboundSchema` instead. */
  export const outboundSchema = InputFirehose$outboundSchema;
  /** @deprecated use `InputFirehose$Outbound` instead. */
  export type Outbound = InputFirehose$Outbound;
}

export function inputFirehoseToJSON(inputFirehose: InputFirehose): string {
  return JSON.stringify(InputFirehose$outboundSchema.parse(inputFirehose));
}

export function inputFirehoseFromJSON(
  jsonString: string,
): SafeParseResult<InputFirehose, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputFirehose$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputFirehose' from JSON`,
  );
}

/** @internal */
export const InputExecType$inboundSchema: z.ZodType<
  InputExecType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputExecType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputExecType$outboundSchema: z.ZodType<
  InputExecType,
  z.ZodTypeDef,
  InputExecType
> = z.union([
  z.nativeEnum(InputExecType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecType$ {
  /** @deprecated use `InputExecType$inboundSchema` instead. */
  export const inboundSchema = InputExecType$inboundSchema;
  /** @deprecated use `InputExecType$outboundSchema` instead. */
  export const outboundSchema = InputExecType$outboundSchema;
}

/** @internal */
export const InputExecConnection$inboundSchema: z.ZodType<
  InputExecConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputExecConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputExecConnection$outboundSchema: z.ZodType<
  InputExecConnection$Outbound,
  z.ZodTypeDef,
  InputExecConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecConnection$ {
  /** @deprecated use `InputExecConnection$inboundSchema` instead. */
  export const inboundSchema = InputExecConnection$inboundSchema;
  /** @deprecated use `InputExecConnection$outboundSchema` instead. */
  export const outboundSchema = InputExecConnection$outboundSchema;
  /** @deprecated use `InputExecConnection$Outbound` instead. */
  export type Outbound = InputExecConnection$Outbound;
}

export function inputExecConnectionToJSON(
  inputExecConnection: InputExecConnection,
): string {
  return JSON.stringify(
    InputExecConnection$outboundSchema.parse(inputExecConnection),
  );
}

export function inputExecConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputExecConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExecConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExecConnection' from JSON`,
  );
}

/** @internal */
export const InputExecMode$inboundSchema: z.ZodType<
  InputExecMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputExecMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputExecMode$outboundSchema: z.ZodType<
  InputExecMode,
  z.ZodTypeDef,
  InputExecMode
> = z.union([
  z.nativeEnum(InputExecMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecMode$ {
  /** @deprecated use `InputExecMode$inboundSchema` instead. */
  export const inboundSchema = InputExecMode$inboundSchema;
  /** @deprecated use `InputExecMode$outboundSchema` instead. */
  export const outboundSchema = InputExecMode$outboundSchema;
}

/** @internal */
export const InputExecCompression$inboundSchema: z.ZodType<
  InputExecCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputExecCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputExecCompression$outboundSchema: z.ZodType<
  InputExecCompression,
  z.ZodTypeDef,
  InputExecCompression
> = z.union([
  z.nativeEnum(InputExecCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecCompression$ {
  /** @deprecated use `InputExecCompression$inboundSchema` instead. */
  export const inboundSchema = InputExecCompression$inboundSchema;
  /** @deprecated use `InputExecCompression$outboundSchema` instead. */
  export const outboundSchema = InputExecCompression$outboundSchema;
}

/** @internal */
export const InputExecPq$inboundSchema: z.ZodType<
  InputExecPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputExecMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputExecCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputExecPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputExecPq$outboundSchema: z.ZodType<
  InputExecPq$Outbound,
  z.ZodTypeDef,
  InputExecPq
> = z.object({
  mode: InputExecMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputExecCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecPq$ {
  /** @deprecated use `InputExecPq$inboundSchema` instead. */
  export const inboundSchema = InputExecPq$inboundSchema;
  /** @deprecated use `InputExecPq$outboundSchema` instead. */
  export const outboundSchema = InputExecPq$outboundSchema;
  /** @deprecated use `InputExecPq$Outbound` instead. */
  export type Outbound = InputExecPq$Outbound;
}

export function inputExecPqToJSON(inputExecPq: InputExecPq): string {
  return JSON.stringify(InputExecPq$outboundSchema.parse(inputExecPq));
}

export function inputExecPqFromJSON(
  jsonString: string,
): SafeParseResult<InputExecPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExecPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExecPq' from JSON`,
  );
}

/** @internal */
export const ScheduleType$inboundSchema: z.ZodType<
  ScheduleType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ScheduleType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ScheduleType$outboundSchema: z.ZodType<
  ScheduleType,
  z.ZodTypeDef,
  ScheduleType
> = z.union([
  z.nativeEnum(ScheduleType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ScheduleType$ {
  /** @deprecated use `ScheduleType$inboundSchema` instead. */
  export const inboundSchema = ScheduleType$inboundSchema;
  /** @deprecated use `ScheduleType$outboundSchema` instead. */
  export const outboundSchema = ScheduleType$outboundSchema;
}

/** @internal */
export const InputExecMetadatum$inboundSchema: z.ZodType<
  InputExecMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputExecMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputExecMetadatum$outboundSchema: z.ZodType<
  InputExecMetadatum$Outbound,
  z.ZodTypeDef,
  InputExecMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExecMetadatum$ {
  /** @deprecated use `InputExecMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputExecMetadatum$inboundSchema;
  /** @deprecated use `InputExecMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputExecMetadatum$outboundSchema;
  /** @deprecated use `InputExecMetadatum$Outbound` instead. */
  export type Outbound = InputExecMetadatum$Outbound;
}

export function inputExecMetadatumToJSON(
  inputExecMetadatum: InputExecMetadatum,
): string {
  return JSON.stringify(
    InputExecMetadatum$outboundSchema.parse(inputExecMetadatum),
  );
}

export function inputExecMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputExecMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExecMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExecMetadatum' from JSON`,
  );
}

/** @internal */
export const InputExec$inboundSchema: z.ZodType<
  InputExec,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputExecType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputExecConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputExecPq$inboundSchema).optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleType$inboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(z.lazy(() => InputExecMetadatum$inboundSchema)).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

/** @internal */
export type InputExec$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputExecConnection$Outbound> | undefined;
  pq?: InputExecPq$Outbound | undefined;
  command: string;
  retries: number;
  scheduleType: string;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  metadata?: Array<InputExecMetadatum$Outbound> | undefined;
  description?: string | undefined;
  interval: number;
  cronSchedule: string;
};

/** @internal */
export const InputExec$outboundSchema: z.ZodType<
  InputExec$Outbound,
  z.ZodTypeDef,
  InputExec
> = z.object({
  id: z.string(),
  type: InputExecType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputExecConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputExecPq$outboundSchema).optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleType$outboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(z.lazy(() => InputExecMetadatum$outboundSchema)).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputExec$ {
  /** @deprecated use `InputExec$inboundSchema` instead. */
  export const inboundSchema = InputExec$inboundSchema;
  /** @deprecated use `InputExec$outboundSchema` instead. */
  export const outboundSchema = InputExec$outboundSchema;
  /** @deprecated use `InputExec$Outbound` instead. */
  export type Outbound = InputExec$Outbound;
}

export function inputExecToJSON(inputExec: InputExec): string {
  return JSON.stringify(InputExec$outboundSchema.parse(inputExec));
}

export function inputExecFromJSON(
  jsonString: string,
): SafeParseResult<InputExec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExec' from JSON`,
  );
}

/** @internal */
export const InputEventhubType$inboundSchema: z.ZodType<
  InputEventhubType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputEventhubType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputEventhubType$outboundSchema: z.ZodType<
  InputEventhubType,
  z.ZodTypeDef,
  InputEventhubType
> = z.union([
  z.nativeEnum(InputEventhubType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEventhubType$ {
  /** @deprecated use `InputEventhubType$inboundSchema` instead. */
  export const inboundSchema = InputEventhubType$inboundSchema;
  /** @deprecated use `InputEventhubType$outboundSchema` instead. */
  export const outboundSchema = InputEventhubType$outboundSchema;
}

/** @internal */
export const InputEventhubConnection$inboundSchema: z.ZodType<
  InputEventhubConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputEventhubConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputEventhubConnection$outboundSchema: z.ZodType<
  InputEventhubConnection$Outbound,
  z.ZodTypeDef,
  InputEventhubConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEventhubConnection$ {
  /** @deprecated use `InputEventhubConnection$inboundSchema` instead. */
  export const inboundSchema = InputEventhubConnection$inboundSchema;
  /** @deprecated use `InputEventhubConnection$outboundSchema` instead. */
  export const outboundSchema = InputEventhubConnection$outboundSchema;
  /** @deprecated use `InputEventhubConnection$Outbound` instead. */
  export type Outbound = InputEventhubConnection$Outbound;
}

export function inputEventhubConnectionToJSON(
  inputEventhubConnection: InputEventhubConnection,
): string {
  return JSON.stringify(
    InputEventhubConnection$outboundSchema.parse(inputEventhubConnection),
  );
}

export function inputEventhubConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputEventhubConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEventhubConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEventhubConnection' from JSON`,
  );
}

/** @internal */
export const InputEventhubMode$inboundSchema: z.ZodType<
  InputEventhubMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputEventhubMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputEventhubMode$outboundSchema: z.ZodType<
  InputEventhubMode,
  z.ZodTypeDef,
  InputEventhubMode
> = z.union([
  z.nativeEnum(InputEventhubMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEventhubMode$ {
  /** @deprecated use `InputEventhubMode$inboundSchema` instead. */
  export const inboundSchema = InputEventhubMode$inboundSchema;
  /** @deprecated use `InputEventhubMode$outboundSchema` instead. */
  export const outboundSchema = InputEventhubMode$outboundSchema;
}

/** @internal */
export const InputEventhubCompression$inboundSchema: z.ZodType<
  InputEventhubCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputEventhubCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputEventhubCompression$outboundSchema: z.ZodType<
  InputEventhubCompression,
  z.ZodTypeDef,
  InputEventhubCompression
> = z.union([
  z.nativeEnum(InputEventhubCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEventhubCompression$ {
  /** @deprecated use `InputEventhubCompression$inboundSchema` instead. */
  export const inboundSchema = InputEventhubCompression$inboundSchema;
  /** @deprecated use `InputEventhubCompression$outboundSchema` instead. */
  export const outboundSchema = InputEventhubCompression$outboundSchema;
}

/** @internal */
export const InputEventhubPq$inboundSchema: z.ZodType<
  InputEventhubPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputEventhubMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputEventhubCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputEventhubPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputEventhubPq$outboundSchema: z.ZodType<
  InputEventhubPq$Outbound,
  z.ZodTypeDef,
  InputEventhubPq
> = z.object({
  mode: InputEventhubMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputEventhubCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEventhubPq$ {
  /** @deprecated use `InputEventhubPq$inboundSchema` instead. */
  export const inboundSchema = InputEventhubPq$inboundSchema;
  /** @deprecated use `InputEventhubPq$outboundSchema` instead. */
  export const outboundSchema = InputEventhubPq$outboundSchema;
  /** @deprecated use `InputEventhubPq$Outbound` instead. */
  export type Outbound = InputEventhubPq$Outbound;
}

export function inputEventhubPqToJSON(
  inputEventhubPq: InputEventhubPq,
): string {
  return JSON.stringify(InputEventhubPq$outboundSchema.parse(inputEventhubPq));
}

export function inputEventhubPqFromJSON(
  jsonString: string,
): SafeParseResult<InputEventhubPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEventhubPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEventhubPq' from JSON`,
  );
}

/** @internal */
export const InputEventhubSASLMechanism$inboundSchema: z.ZodType<
  InputEventhubSASLMechanism,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputEventhubSASLMechanism),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputEventhubSASLMechanism$outboundSchema: z.ZodType<
  InputEventhubSASLMechanism,
  z.ZodTypeDef,
  InputEventhubSASLMechanism
> = z.union([
  z.nativeEnum(InputEventhubSASLMechanism),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEventhubSASLMechanism$ {
  /** @deprecated use `InputEventhubSASLMechanism$inboundSchema` instead. */
  export const inboundSchema = InputEventhubSASLMechanism$inboundSchema;
  /** @deprecated use `InputEventhubSASLMechanism$outboundSchema` instead. */
  export const outboundSchema = InputEventhubSASLMechanism$outboundSchema;
}

/** @internal */
export const InputEventhubAuthentication$inboundSchema: z.ZodType<
  InputEventhubAuthentication,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  mechanism: InputEventhubSASLMechanism$inboundSchema.default("plain"),
});

/** @internal */
export type InputEventhubAuthentication$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const InputEventhubAuthentication$outboundSchema: z.ZodType<
  InputEventhubAuthentication$Outbound,
  z.ZodTypeDef,
  InputEventhubAuthentication
> = z.object({
  disabled: z.boolean().default(false),
  mechanism: InputEventhubSASLMechanism$outboundSchema.default("plain"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEventhubAuthentication$ {
  /** @deprecated use `InputEventhubAuthentication$inboundSchema` instead. */
  export const inboundSchema = InputEventhubAuthentication$inboundSchema;
  /** @deprecated use `InputEventhubAuthentication$outboundSchema` instead. */
  export const outboundSchema = InputEventhubAuthentication$outboundSchema;
  /** @deprecated use `InputEventhubAuthentication$Outbound` instead. */
  export type Outbound = InputEventhubAuthentication$Outbound;
}

export function inputEventhubAuthenticationToJSON(
  inputEventhubAuthentication: InputEventhubAuthentication,
): string {
  return JSON.stringify(
    InputEventhubAuthentication$outboundSchema.parse(
      inputEventhubAuthentication,
    ),
  );
}

export function inputEventhubAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<InputEventhubAuthentication, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEventhubAuthentication$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEventhubAuthentication' from JSON`,
  );
}

/** @internal */
export const InputEventhubTLSSettingsClientSide$inboundSchema: z.ZodType<
  InputEventhubTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/** @internal */
export type InputEventhubTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
};

/** @internal */
export const InputEventhubTLSSettingsClientSide$outboundSchema: z.ZodType<
  InputEventhubTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  InputEventhubTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEventhubTLSSettingsClientSide$ {
  /** @deprecated use `InputEventhubTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema = InputEventhubTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `InputEventhubTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    InputEventhubTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `InputEventhubTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = InputEventhubTLSSettingsClientSide$Outbound;
}

export function inputEventhubTLSSettingsClientSideToJSON(
  inputEventhubTLSSettingsClientSide: InputEventhubTLSSettingsClientSide,
): string {
  return JSON.stringify(
    InputEventhubTLSSettingsClientSide$outboundSchema.parse(
      inputEventhubTLSSettingsClientSide,
    ),
  );
}

export function inputEventhubTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<InputEventhubTLSSettingsClientSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputEventhubTLSSettingsClientSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEventhubTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const InputEventhubMetadatum$inboundSchema: z.ZodType<
  InputEventhubMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputEventhubMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputEventhubMetadatum$outboundSchema: z.ZodType<
  InputEventhubMetadatum$Outbound,
  z.ZodTypeDef,
  InputEventhubMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEventhubMetadatum$ {
  /** @deprecated use `InputEventhubMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputEventhubMetadatum$inboundSchema;
  /** @deprecated use `InputEventhubMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputEventhubMetadatum$outboundSchema;
  /** @deprecated use `InputEventhubMetadatum$Outbound` instead. */
  export type Outbound = InputEventhubMetadatum$Outbound;
}

export function inputEventhubMetadatumToJSON(
  inputEventhubMetadatum: InputEventhubMetadatum,
): string {
  return JSON.stringify(
    InputEventhubMetadatum$outboundSchema.parse(inputEventhubMetadatum),
  );
}

export function inputEventhubMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputEventhubMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEventhubMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEventhubMetadatum' from JSON`,
  );
}

/** @internal */
export const InputEventhub$inboundSchema: z.ZodType<
  InputEventhub,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputEventhubType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputEventhubConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputEventhubPq$inboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => InputEventhubAuthentication$inboundSchema).optional(),
  tls: z.lazy(() => InputEventhubTLSSettingsClientSide$inboundSchema)
    .optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  minimizeDuplicates: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputEventhubMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputEventhub$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputEventhubConnection$Outbound> | undefined;
  pq?: InputEventhubPq$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId: string;
  fromBeginning: boolean;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: InputEventhubAuthentication$Outbound | undefined;
  tls?: InputEventhubTLSSettingsClientSide$Outbound | undefined;
  sessionTimeout: number;
  rebalanceTimeout: number;
  heartbeatInterval: number;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition: number;
  maxBytes: number;
  maxSocketErrors: number;
  minimizeDuplicates: boolean;
  metadata?: Array<InputEventhubMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputEventhub$outboundSchema: z.ZodType<
  InputEventhub$Outbound,
  z.ZodTypeDef,
  InputEventhub
> = z.object({
  id: z.string(),
  type: InputEventhubType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputEventhubConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputEventhubPq$outboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => InputEventhubAuthentication$outboundSchema).optional(),
  tls: z.lazy(() => InputEventhubTLSSettingsClientSide$outboundSchema)
    .optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  minimizeDuplicates: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputEventhubMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEventhub$ {
  /** @deprecated use `InputEventhub$inboundSchema` instead. */
  export const inboundSchema = InputEventhub$inboundSchema;
  /** @deprecated use `InputEventhub$outboundSchema` instead. */
  export const outboundSchema = InputEventhub$outboundSchema;
  /** @deprecated use `InputEventhub$Outbound` instead. */
  export type Outbound = InputEventhub$Outbound;
}

export function inputEventhubToJSON(inputEventhub: InputEventhub): string {
  return JSON.stringify(InputEventhub$outboundSchema.parse(inputEventhub));
}

export function inputEventhubFromJSON(
  jsonString: string,
): SafeParseResult<InputEventhub, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEventhub$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEventhub' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTraceType$inboundSchema: z.ZodType<
  InputOffice365MsgTraceType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceType$outboundSchema: z.ZodType<
  InputOffice365MsgTraceType,
  z.ZodTypeDef,
  InputOffice365MsgTraceType
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceType$ {
  /** @deprecated use `InputOffice365MsgTraceType$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceType$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceType$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceType$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTraceConnection$inboundSchema: z.ZodType<
  InputOffice365MsgTraceConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputOffice365MsgTraceConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputOffice365MsgTraceConnection$outboundSchema: z.ZodType<
  InputOffice365MsgTraceConnection$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTraceConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceConnection$ {
  /** @deprecated use `InputOffice365MsgTraceConnection$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceConnection$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceConnection$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceConnection$outboundSchema;
  /** @deprecated use `InputOffice365MsgTraceConnection$Outbound` instead. */
  export type Outbound = InputOffice365MsgTraceConnection$Outbound;
}

export function inputOffice365MsgTraceConnectionToJSON(
  inputOffice365MsgTraceConnection: InputOffice365MsgTraceConnection,
): string {
  return JSON.stringify(
    InputOffice365MsgTraceConnection$outboundSchema.parse(
      inputOffice365MsgTraceConnection,
    ),
  );
}

export function inputOffice365MsgTraceConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MsgTraceConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MsgTraceConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MsgTraceConnection' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTraceMode$inboundSchema: z.ZodType<
  InputOffice365MsgTraceMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceMode$outboundSchema: z.ZodType<
  InputOffice365MsgTraceMode,
  z.ZodTypeDef,
  InputOffice365MsgTraceMode
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceMode$ {
  /** @deprecated use `InputOffice365MsgTraceMode$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceMode$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceMode$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceMode$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTraceCompression$inboundSchema: z.ZodType<
  InputOffice365MsgTraceCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceCompression$outboundSchema: z.ZodType<
  InputOffice365MsgTraceCompression,
  z.ZodTypeDef,
  InputOffice365MsgTraceCompression
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceCompression$ {
  /** @deprecated use `InputOffice365MsgTraceCompression$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceCompression$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceCompression$outboundSchema` instead. */
  export const outboundSchema =
    InputOffice365MsgTraceCompression$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTracePq$inboundSchema: z.ZodType<
  InputOffice365MsgTracePq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputOffice365MsgTraceMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputOffice365MsgTraceCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputOffice365MsgTracePq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputOffice365MsgTracePq$outboundSchema: z.ZodType<
  InputOffice365MsgTracePq$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTracePq
> = z.object({
  mode: InputOffice365MsgTraceMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputOffice365MsgTraceCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTracePq$ {
  /** @deprecated use `InputOffice365MsgTracePq$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTracePq$inboundSchema;
  /** @deprecated use `InputOffice365MsgTracePq$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTracePq$outboundSchema;
  /** @deprecated use `InputOffice365MsgTracePq$Outbound` instead. */
  export type Outbound = InputOffice365MsgTracePq$Outbound;
}

export function inputOffice365MsgTracePqToJSON(
  inputOffice365MsgTracePq: InputOffice365MsgTracePq,
): string {
  return JSON.stringify(
    InputOffice365MsgTracePq$outboundSchema.parse(inputOffice365MsgTracePq),
  );
}

export function inputOffice365MsgTracePqFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MsgTracePq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MsgTracePq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MsgTracePq' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTraceAuthenticationMethod$inboundSchema:
  z.ZodType<InputOffice365MsgTraceAuthenticationMethod, z.ZodTypeDef, unknown> =
    z
      .union([
        z.nativeEnum(InputOffice365MsgTraceAuthenticationMethod),
        z.string().transform(catchUnrecognizedEnum),
      ]);

/** @internal */
export const InputOffice365MsgTraceAuthenticationMethod$outboundSchema:
  z.ZodType<
    InputOffice365MsgTraceAuthenticationMethod,
    z.ZodTypeDef,
    InputOffice365MsgTraceAuthenticationMethod
  > = z.union([
    z.nativeEnum(InputOffice365MsgTraceAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceAuthenticationMethod$ {
  /** @deprecated use `InputOffice365MsgTraceAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputOffice365MsgTraceAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputOffice365MsgTraceAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTraceLogLevel$inboundSchema: z.ZodType<
  InputOffice365MsgTraceLogLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceLogLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceLogLevel$outboundSchema: z.ZodType<
  InputOffice365MsgTraceLogLevel,
  z.ZodTypeDef,
  InputOffice365MsgTraceLogLevel
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceLogLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceLogLevel$ {
  /** @deprecated use `InputOffice365MsgTraceLogLevel$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceLogLevel$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceLogLevel$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceLogLevel$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTraceMetadatum$inboundSchema: z.ZodType<
  InputOffice365MsgTraceMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputOffice365MsgTraceMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputOffice365MsgTraceMetadatum$outboundSchema: z.ZodType<
  InputOffice365MsgTraceMetadatum$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTraceMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceMetadatum$ {
  /** @deprecated use `InputOffice365MsgTraceMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceMetadatum$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceMetadatum$outboundSchema;
  /** @deprecated use `InputOffice365MsgTraceMetadatum$Outbound` instead. */
  export type Outbound = InputOffice365MsgTraceMetadatum$Outbound;
}

export function inputOffice365MsgTraceMetadatumToJSON(
  inputOffice365MsgTraceMetadatum: InputOffice365MsgTraceMetadatum,
): string {
  return JSON.stringify(
    InputOffice365MsgTraceMetadatum$outboundSchema.parse(
      inputOffice365MsgTraceMetadatum,
    ),
  );
}

export function inputOffice365MsgTraceMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MsgTraceMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MsgTraceMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MsgTraceMetadatum' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTraceRetryType$inboundSchema: z.ZodType<
  InputOffice365MsgTraceRetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceRetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceRetryType$outboundSchema: z.ZodType<
  InputOffice365MsgTraceRetryType,
  z.ZodTypeDef,
  InputOffice365MsgTraceRetryType
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceRetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceRetryType$ {
  /** @deprecated use `InputOffice365MsgTraceRetryType$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceRetryType$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceRetryType$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceRetryType$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTraceRetryRules$inboundSchema: z.ZodType<
  InputOffice365MsgTraceRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InputOffice365MsgTraceRetryType$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type InputOffice365MsgTraceRetryRules$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const InputOffice365MsgTraceRetryRules$outboundSchema: z.ZodType<
  InputOffice365MsgTraceRetryRules$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTraceRetryRules
> = z.object({
  type: InputOffice365MsgTraceRetryType$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceRetryRules$ {
  /** @deprecated use `InputOffice365MsgTraceRetryRules$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceRetryRules$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceRetryRules$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceRetryRules$outboundSchema;
  /** @deprecated use `InputOffice365MsgTraceRetryRules$Outbound` instead. */
  export type Outbound = InputOffice365MsgTraceRetryRules$Outbound;
}

export function inputOffice365MsgTraceRetryRulesToJSON(
  inputOffice365MsgTraceRetryRules: InputOffice365MsgTraceRetryRules,
): string {
  return JSON.stringify(
    InputOffice365MsgTraceRetryRules$outboundSchema.parse(
      inputOffice365MsgTraceRetryRules,
    ),
  );
}

export function inputOffice365MsgTraceRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MsgTraceRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MsgTraceRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MsgTraceRetryRules' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTraceSubscriptionPlan$inboundSchema: z.ZodType<
  InputOffice365MsgTraceSubscriptionPlan,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceSubscriptionPlan),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceSubscriptionPlan$outboundSchema: z.ZodType<
  InputOffice365MsgTraceSubscriptionPlan,
  z.ZodTypeDef,
  InputOffice365MsgTraceSubscriptionPlan
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceSubscriptionPlan),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceSubscriptionPlan$ {
  /** @deprecated use `InputOffice365MsgTraceSubscriptionPlan$inboundSchema` instead. */
  export const inboundSchema =
    InputOffice365MsgTraceSubscriptionPlan$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceSubscriptionPlan$outboundSchema` instead. */
  export const outboundSchema =
    InputOffice365MsgTraceSubscriptionPlan$outboundSchema;
}

/** @internal */
export const CertOptions$inboundSchema: z.ZodType<
  CertOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
});

/** @internal */
export type CertOptions$Outbound = {
  certificateName?: string | undefined;
  privKeyPath: string;
  passphrase?: string | undefined;
  certPath: string;
};

/** @internal */
export const CertOptions$outboundSchema: z.ZodType<
  CertOptions$Outbound,
  z.ZodTypeDef,
  CertOptions
> = z.object({
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CertOptions$ {
  /** @deprecated use `CertOptions$inboundSchema` instead. */
  export const inboundSchema = CertOptions$inboundSchema;
  /** @deprecated use `CertOptions$outboundSchema` instead. */
  export const outboundSchema = CertOptions$outboundSchema;
  /** @deprecated use `CertOptions$Outbound` instead. */
  export type Outbound = CertOptions$Outbound;
}

export function certOptionsToJSON(certOptions: CertOptions): string {
  return JSON.stringify(CertOptions$outboundSchema.parse(certOptions));
}

export function certOptionsFromJSON(
  jsonString: string,
): SafeParseResult<CertOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CertOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CertOptions' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTrace$inboundSchema: z.ZodType<
  InputOffice365MsgTrace,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputOffice365MsgTraceType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputOffice365MsgTraceConnection$inboundSchema),
  ).optional(),
  pq: z.lazy(() => InputOffice365MsgTracePq$inboundSchema).optional(),
  url: z.string().default(
    "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace",
  ),
  interval: z.number().default(60),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  timeout: z.number().default(300),
  disableTimeFilter: z.boolean().default(true),
  authType: InputOffice365MsgTraceAuthenticationMethod$inboundSchema.default(
    "oauth",
  ),
  rescheduleDroppedTasks: z.boolean().default(true),
  maxTaskReschedule: z.number().default(1),
  logLevel: InputOffice365MsgTraceLogLevel$inboundSchema.default("info"),
  jobTimeout: z.string().default("0"),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputOffice365MsgTraceMetadatum$inboundSchema))
    .optional(),
  retryRules: z.lazy(() => InputOffice365MsgTraceRetryRules$inboundSchema)
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  clientSecret: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  resource: z.string().default("https://outlook.office365.com"),
  planType: InputOffice365MsgTraceSubscriptionPlan$inboundSchema.default(
    "enterprise_gcc",
  ),
  textSecret: z.string().optional(),
  certOptions: z.lazy(() => CertOptions$inboundSchema).optional(),
});

/** @internal */
export type InputOffice365MsgTrace$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputOffice365MsgTraceConnection$Outbound> | undefined;
  pq?: InputOffice365MsgTracePq$Outbound | undefined;
  url: string;
  interval: number;
  startDate?: string | undefined;
  endDate?: string | undefined;
  timeout: number;
  disableTimeFilter: boolean;
  authType: string;
  rescheduleDroppedTasks: boolean;
  maxTaskReschedule: number;
  logLevel: string;
  jobTimeout: string;
  keepAliveTime: number;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<InputOffice365MsgTraceMetadatum$Outbound> | undefined;
  retryRules?: InputOffice365MsgTraceRetryRules$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  clientSecret?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  resource: string;
  planType: string;
  textSecret?: string | undefined;
  certOptions?: CertOptions$Outbound | undefined;
};

/** @internal */
export const InputOffice365MsgTrace$outboundSchema: z.ZodType<
  InputOffice365MsgTrace$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTrace
> = z.object({
  id: z.string(),
  type: InputOffice365MsgTraceType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputOffice365MsgTraceConnection$outboundSchema),
  ).optional(),
  pq: z.lazy(() => InputOffice365MsgTracePq$outboundSchema).optional(),
  url: z.string().default(
    "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace",
  ),
  interval: z.number().default(60),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  timeout: z.number().default(300),
  disableTimeFilter: z.boolean().default(true),
  authType: InputOffice365MsgTraceAuthenticationMethod$outboundSchema.default(
    "oauth",
  ),
  rescheduleDroppedTasks: z.boolean().default(true),
  maxTaskReschedule: z.number().default(1),
  logLevel: InputOffice365MsgTraceLogLevel$outboundSchema.default("info"),
  jobTimeout: z.string().default("0"),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(
    z.lazy(() => InputOffice365MsgTraceMetadatum$outboundSchema),
  ).optional(),
  retryRules: z.lazy(() => InputOffice365MsgTraceRetryRules$outboundSchema)
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  clientSecret: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  resource: z.string().default("https://outlook.office365.com"),
  planType: InputOffice365MsgTraceSubscriptionPlan$outboundSchema.default(
    "enterprise_gcc",
  ),
  textSecret: z.string().optional(),
  certOptions: z.lazy(() => CertOptions$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTrace$ {
  /** @deprecated use `InputOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTrace$inboundSchema;
  /** @deprecated use `InputOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTrace$outboundSchema;
  /** @deprecated use `InputOffice365MsgTrace$Outbound` instead. */
  export type Outbound = InputOffice365MsgTrace$Outbound;
}

export function inputOffice365MsgTraceToJSON(
  inputOffice365MsgTrace: InputOffice365MsgTrace,
): string {
  return JSON.stringify(
    InputOffice365MsgTrace$outboundSchema.parse(inputOffice365MsgTrace),
  );
}

export function inputOffice365MsgTraceFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MsgTrace, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MsgTrace$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MsgTrace' from JSON`,
  );
}

/** @internal */
export const InputOffice365ServiceType$inboundSchema: z.ZodType<
  InputOffice365ServiceType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365ServiceType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365ServiceType$outboundSchema: z.ZodType<
  InputOffice365ServiceType,
  z.ZodTypeDef,
  InputOffice365ServiceType
> = z.union([
  z.nativeEnum(InputOffice365ServiceType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServiceType$ {
  /** @deprecated use `InputOffice365ServiceType$inboundSchema` instead. */
  export const inboundSchema = InputOffice365ServiceType$inboundSchema;
  /** @deprecated use `InputOffice365ServiceType$outboundSchema` instead. */
  export const outboundSchema = InputOffice365ServiceType$outboundSchema;
}

/** @internal */
export const InputOffice365ServiceConnection$inboundSchema: z.ZodType<
  InputOffice365ServiceConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputOffice365ServiceConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputOffice365ServiceConnection$outboundSchema: z.ZodType<
  InputOffice365ServiceConnection$Outbound,
  z.ZodTypeDef,
  InputOffice365ServiceConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServiceConnection$ {
  /** @deprecated use `InputOffice365ServiceConnection$inboundSchema` instead. */
  export const inboundSchema = InputOffice365ServiceConnection$inboundSchema;
  /** @deprecated use `InputOffice365ServiceConnection$outboundSchema` instead. */
  export const outboundSchema = InputOffice365ServiceConnection$outboundSchema;
  /** @deprecated use `InputOffice365ServiceConnection$Outbound` instead. */
  export type Outbound = InputOffice365ServiceConnection$Outbound;
}

export function inputOffice365ServiceConnectionToJSON(
  inputOffice365ServiceConnection: InputOffice365ServiceConnection,
): string {
  return JSON.stringify(
    InputOffice365ServiceConnection$outboundSchema.parse(
      inputOffice365ServiceConnection,
    ),
  );
}

export function inputOffice365ServiceConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365ServiceConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365ServiceConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365ServiceConnection' from JSON`,
  );
}

/** @internal */
export const InputOffice365ServiceMode$inboundSchema: z.ZodType<
  InputOffice365ServiceMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365ServiceMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365ServiceMode$outboundSchema: z.ZodType<
  InputOffice365ServiceMode,
  z.ZodTypeDef,
  InputOffice365ServiceMode
> = z.union([
  z.nativeEnum(InputOffice365ServiceMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServiceMode$ {
  /** @deprecated use `InputOffice365ServiceMode$inboundSchema` instead. */
  export const inboundSchema = InputOffice365ServiceMode$inboundSchema;
  /** @deprecated use `InputOffice365ServiceMode$outboundSchema` instead. */
  export const outboundSchema = InputOffice365ServiceMode$outboundSchema;
}

/** @internal */
export const InputOffice365ServiceCompression$inboundSchema: z.ZodType<
  InputOffice365ServiceCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365ServiceCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365ServiceCompression$outboundSchema: z.ZodType<
  InputOffice365ServiceCompression,
  z.ZodTypeDef,
  InputOffice365ServiceCompression
> = z.union([
  z.nativeEnum(InputOffice365ServiceCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServiceCompression$ {
  /** @deprecated use `InputOffice365ServiceCompression$inboundSchema` instead. */
  export const inboundSchema = InputOffice365ServiceCompression$inboundSchema;
  /** @deprecated use `InputOffice365ServiceCompression$outboundSchema` instead. */
  export const outboundSchema = InputOffice365ServiceCompression$outboundSchema;
}

/** @internal */
export const InputOffice365ServicePq$inboundSchema: z.ZodType<
  InputOffice365ServicePq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputOffice365ServiceMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputOffice365ServiceCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputOffice365ServicePq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputOffice365ServicePq$outboundSchema: z.ZodType<
  InputOffice365ServicePq$Outbound,
  z.ZodTypeDef,
  InputOffice365ServicePq
> = z.object({
  mode: InputOffice365ServiceMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputOffice365ServiceCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServicePq$ {
  /** @deprecated use `InputOffice365ServicePq$inboundSchema` instead. */
  export const inboundSchema = InputOffice365ServicePq$inboundSchema;
  /** @deprecated use `InputOffice365ServicePq$outboundSchema` instead. */
  export const outboundSchema = InputOffice365ServicePq$outboundSchema;
  /** @deprecated use `InputOffice365ServicePq$Outbound` instead. */
  export type Outbound = InputOffice365ServicePq$Outbound;
}

export function inputOffice365ServicePqToJSON(
  inputOffice365ServicePq: InputOffice365ServicePq,
): string {
  return JSON.stringify(
    InputOffice365ServicePq$outboundSchema.parse(inputOffice365ServicePq),
  );
}

export function inputOffice365ServicePqFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365ServicePq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365ServicePq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365ServicePq' from JSON`,
  );
}

/** @internal */
export const InputOffice365ServiceSubscriptionPlan$inboundSchema: z.ZodType<
  InputOffice365ServiceSubscriptionPlan,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365ServiceSubscriptionPlan),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365ServiceSubscriptionPlan$outboundSchema: z.ZodType<
  InputOffice365ServiceSubscriptionPlan,
  z.ZodTypeDef,
  InputOffice365ServiceSubscriptionPlan
> = z.union([
  z.nativeEnum(InputOffice365ServiceSubscriptionPlan),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServiceSubscriptionPlan$ {
  /** @deprecated use `InputOffice365ServiceSubscriptionPlan$inboundSchema` instead. */
  export const inboundSchema =
    InputOffice365ServiceSubscriptionPlan$inboundSchema;
  /** @deprecated use `InputOffice365ServiceSubscriptionPlan$outboundSchema` instead. */
  export const outboundSchema =
    InputOffice365ServiceSubscriptionPlan$outboundSchema;
}

/** @internal */
export const InputOffice365ServiceMetadatum$inboundSchema: z.ZodType<
  InputOffice365ServiceMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputOffice365ServiceMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputOffice365ServiceMetadatum$outboundSchema: z.ZodType<
  InputOffice365ServiceMetadatum$Outbound,
  z.ZodTypeDef,
  InputOffice365ServiceMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServiceMetadatum$ {
  /** @deprecated use `InputOffice365ServiceMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputOffice365ServiceMetadatum$inboundSchema;
  /** @deprecated use `InputOffice365ServiceMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputOffice365ServiceMetadatum$outboundSchema;
  /** @deprecated use `InputOffice365ServiceMetadatum$Outbound` instead. */
  export type Outbound = InputOffice365ServiceMetadatum$Outbound;
}

export function inputOffice365ServiceMetadatumToJSON(
  inputOffice365ServiceMetadatum: InputOffice365ServiceMetadatum,
): string {
  return JSON.stringify(
    InputOffice365ServiceMetadatum$outboundSchema.parse(
      inputOffice365ServiceMetadatum,
    ),
  );
}

export function inputOffice365ServiceMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365ServiceMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365ServiceMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365ServiceMetadatum' from JSON`,
  );
}

/** @internal */
export const InputOffice365ServiceLogLevel$inboundSchema: z.ZodType<
  InputOffice365ServiceLogLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365ServiceLogLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365ServiceLogLevel$outboundSchema: z.ZodType<
  InputOffice365ServiceLogLevel,
  z.ZodTypeDef,
  InputOffice365ServiceLogLevel
> = z.union([
  z.nativeEnum(InputOffice365ServiceLogLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServiceLogLevel$ {
  /** @deprecated use `InputOffice365ServiceLogLevel$inboundSchema` instead. */
  export const inboundSchema = InputOffice365ServiceLogLevel$inboundSchema;
  /** @deprecated use `InputOffice365ServiceLogLevel$outboundSchema` instead. */
  export const outboundSchema = InputOffice365ServiceLogLevel$outboundSchema;
}

/** @internal */
export const InputOffice365ServiceContentConfig$inboundSchema: z.ZodType<
  InputOffice365ServiceContentConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  contentType: z.string().optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  logLevel: InputOffice365ServiceLogLevel$inboundSchema.optional(),
  enabled: z.boolean().optional(),
});

/** @internal */
export type InputOffice365ServiceContentConfig$Outbound = {
  contentType?: string | undefined;
  description?: string | undefined;
  interval?: number | undefined;
  logLevel?: string | undefined;
  enabled?: boolean | undefined;
};

/** @internal */
export const InputOffice365ServiceContentConfig$outboundSchema: z.ZodType<
  InputOffice365ServiceContentConfig$Outbound,
  z.ZodTypeDef,
  InputOffice365ServiceContentConfig
> = z.object({
  contentType: z.string().optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  logLevel: InputOffice365ServiceLogLevel$outboundSchema.optional(),
  enabled: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServiceContentConfig$ {
  /** @deprecated use `InputOffice365ServiceContentConfig$inboundSchema` instead. */
  export const inboundSchema = InputOffice365ServiceContentConfig$inboundSchema;
  /** @deprecated use `InputOffice365ServiceContentConfig$outboundSchema` instead. */
  export const outboundSchema =
    InputOffice365ServiceContentConfig$outboundSchema;
  /** @deprecated use `InputOffice365ServiceContentConfig$Outbound` instead. */
  export type Outbound = InputOffice365ServiceContentConfig$Outbound;
}

export function inputOffice365ServiceContentConfigToJSON(
  inputOffice365ServiceContentConfig: InputOffice365ServiceContentConfig,
): string {
  return JSON.stringify(
    InputOffice365ServiceContentConfig$outboundSchema.parse(
      inputOffice365ServiceContentConfig,
    ),
  );
}

export function inputOffice365ServiceContentConfigFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365ServiceContentConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputOffice365ServiceContentConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365ServiceContentConfig' from JSON`,
  );
}

/** @internal */
export const InputOffice365ServiceRetryType$inboundSchema: z.ZodType<
  InputOffice365ServiceRetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365ServiceRetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365ServiceRetryType$outboundSchema: z.ZodType<
  InputOffice365ServiceRetryType,
  z.ZodTypeDef,
  InputOffice365ServiceRetryType
> = z.union([
  z.nativeEnum(InputOffice365ServiceRetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServiceRetryType$ {
  /** @deprecated use `InputOffice365ServiceRetryType$inboundSchema` instead. */
  export const inboundSchema = InputOffice365ServiceRetryType$inboundSchema;
  /** @deprecated use `InputOffice365ServiceRetryType$outboundSchema` instead. */
  export const outboundSchema = InputOffice365ServiceRetryType$outboundSchema;
}

/** @internal */
export const InputOffice365ServiceRetryRules$inboundSchema: z.ZodType<
  InputOffice365ServiceRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InputOffice365ServiceRetryType$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type InputOffice365ServiceRetryRules$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const InputOffice365ServiceRetryRules$outboundSchema: z.ZodType<
  InputOffice365ServiceRetryRules$Outbound,
  z.ZodTypeDef,
  InputOffice365ServiceRetryRules
> = z.object({
  type: InputOffice365ServiceRetryType$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServiceRetryRules$ {
  /** @deprecated use `InputOffice365ServiceRetryRules$inboundSchema` instead. */
  export const inboundSchema = InputOffice365ServiceRetryRules$inboundSchema;
  /** @deprecated use `InputOffice365ServiceRetryRules$outboundSchema` instead. */
  export const outboundSchema = InputOffice365ServiceRetryRules$outboundSchema;
  /** @deprecated use `InputOffice365ServiceRetryRules$Outbound` instead. */
  export type Outbound = InputOffice365ServiceRetryRules$Outbound;
}

export function inputOffice365ServiceRetryRulesToJSON(
  inputOffice365ServiceRetryRules: InputOffice365ServiceRetryRules,
): string {
  return JSON.stringify(
    InputOffice365ServiceRetryRules$outboundSchema.parse(
      inputOffice365ServiceRetryRules,
    ),
  );
}

export function inputOffice365ServiceRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365ServiceRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365ServiceRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365ServiceRetryRules' from JSON`,
  );
}

/** @internal */
export const InputOffice365ServiceAuthenticationMethod$inboundSchema: z.ZodType<
  InputOffice365ServiceAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365ServiceAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365ServiceAuthenticationMethod$outboundSchema:
  z.ZodType<
    InputOffice365ServiceAuthenticationMethod,
    z.ZodTypeDef,
    InputOffice365ServiceAuthenticationMethod
  > = z.union([
    z.nativeEnum(InputOffice365ServiceAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365ServiceAuthenticationMethod$ {
  /** @deprecated use `InputOffice365ServiceAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputOffice365ServiceAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputOffice365ServiceAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputOffice365ServiceAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputOffice365Service$inboundSchema: z.ZodType<
  InputOffice365Service,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputOffice365ServiceType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputOffice365ServiceConnection$inboundSchema),
  ).optional(),
  pq: z.lazy(() => InputOffice365ServicePq$inboundSchema).optional(),
  planType: InputOffice365ServiceSubscriptionPlan$inboundSchema.default(
    "enterprise_gcc",
  ),
  tenantId: z.string(),
  appId: z.string(),
  timeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputOffice365ServiceMetadatum$inboundSchema))
    .optional(),
  contentConfig: z.array(
    z.lazy(() => InputOffice365ServiceContentConfig$inboundSchema),
  ).optional(),
  retryRules: z.lazy(() => InputOffice365ServiceRetryRules$inboundSchema)
    .optional(),
  authType: InputOffice365ServiceAuthenticationMethod$inboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/** @internal */
export type InputOffice365Service$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputOffice365ServiceConnection$Outbound> | undefined;
  pq?: InputOffice365ServicePq$Outbound | undefined;
  planType: string;
  tenantId: string;
  appId: string;
  timeout: number;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<InputOffice365ServiceMetadatum$Outbound> | undefined;
  contentConfig?:
    | Array<InputOffice365ServiceContentConfig$Outbound>
    | undefined;
  retryRules?: InputOffice365ServiceRetryRules$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputOffice365Service$outboundSchema: z.ZodType<
  InputOffice365Service$Outbound,
  z.ZodTypeDef,
  InputOffice365Service
> = z.object({
  id: z.string(),
  type: InputOffice365ServiceType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputOffice365ServiceConnection$outboundSchema),
  ).optional(),
  pq: z.lazy(() => InputOffice365ServicePq$outboundSchema).optional(),
  planType: InputOffice365ServiceSubscriptionPlan$outboundSchema.default(
    "enterprise_gcc",
  ),
  tenantId: z.string(),
  appId: z.string(),
  timeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputOffice365ServiceMetadatum$outboundSchema))
    .optional(),
  contentConfig: z.array(
    z.lazy(() => InputOffice365ServiceContentConfig$outboundSchema),
  ).optional(),
  retryRules: z.lazy(() => InputOffice365ServiceRetryRules$outboundSchema)
    .optional(),
  authType: InputOffice365ServiceAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365Service$ {
  /** @deprecated use `InputOffice365Service$inboundSchema` instead. */
  export const inboundSchema = InputOffice365Service$inboundSchema;
  /** @deprecated use `InputOffice365Service$outboundSchema` instead. */
  export const outboundSchema = InputOffice365Service$outboundSchema;
  /** @deprecated use `InputOffice365Service$Outbound` instead. */
  export type Outbound = InputOffice365Service$Outbound;
}

export function inputOffice365ServiceToJSON(
  inputOffice365Service: InputOffice365Service,
): string {
  return JSON.stringify(
    InputOffice365Service$outboundSchema.parse(inputOffice365Service),
  );
}

export function inputOffice365ServiceFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365Service, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365Service$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365Service' from JSON`,
  );
}

/** @internal */
export const InputOffice365MgmtType$inboundSchema: z.ZodType<
  InputOffice365MgmtType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MgmtType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MgmtType$outboundSchema: z.ZodType<
  InputOffice365MgmtType,
  z.ZodTypeDef,
  InputOffice365MgmtType
> = z.union([
  z.nativeEnum(InputOffice365MgmtType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtType$ {
  /** @deprecated use `InputOffice365MgmtType$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MgmtType$inboundSchema;
  /** @deprecated use `InputOffice365MgmtType$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MgmtType$outboundSchema;
}

/** @internal */
export const InputOffice365MgmtConnection$inboundSchema: z.ZodType<
  InputOffice365MgmtConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputOffice365MgmtConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputOffice365MgmtConnection$outboundSchema: z.ZodType<
  InputOffice365MgmtConnection$Outbound,
  z.ZodTypeDef,
  InputOffice365MgmtConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtConnection$ {
  /** @deprecated use `InputOffice365MgmtConnection$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MgmtConnection$inboundSchema;
  /** @deprecated use `InputOffice365MgmtConnection$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MgmtConnection$outboundSchema;
  /** @deprecated use `InputOffice365MgmtConnection$Outbound` instead. */
  export type Outbound = InputOffice365MgmtConnection$Outbound;
}

export function inputOffice365MgmtConnectionToJSON(
  inputOffice365MgmtConnection: InputOffice365MgmtConnection,
): string {
  return JSON.stringify(
    InputOffice365MgmtConnection$outboundSchema.parse(
      inputOffice365MgmtConnection,
    ),
  );
}

export function inputOffice365MgmtConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MgmtConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MgmtConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MgmtConnection' from JSON`,
  );
}

/** @internal */
export const InputOffice365MgmtMode$inboundSchema: z.ZodType<
  InputOffice365MgmtMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MgmtMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MgmtMode$outboundSchema: z.ZodType<
  InputOffice365MgmtMode,
  z.ZodTypeDef,
  InputOffice365MgmtMode
> = z.union([
  z.nativeEnum(InputOffice365MgmtMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtMode$ {
  /** @deprecated use `InputOffice365MgmtMode$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MgmtMode$inboundSchema;
  /** @deprecated use `InputOffice365MgmtMode$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MgmtMode$outboundSchema;
}

/** @internal */
export const InputOffice365MgmtCompression$inboundSchema: z.ZodType<
  InputOffice365MgmtCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MgmtCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MgmtCompression$outboundSchema: z.ZodType<
  InputOffice365MgmtCompression,
  z.ZodTypeDef,
  InputOffice365MgmtCompression
> = z.union([
  z.nativeEnum(InputOffice365MgmtCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtCompression$ {
  /** @deprecated use `InputOffice365MgmtCompression$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MgmtCompression$inboundSchema;
  /** @deprecated use `InputOffice365MgmtCompression$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MgmtCompression$outboundSchema;
}

/** @internal */
export const InputOffice365MgmtPq$inboundSchema: z.ZodType<
  InputOffice365MgmtPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputOffice365MgmtMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputOffice365MgmtCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputOffice365MgmtPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputOffice365MgmtPq$outboundSchema: z.ZodType<
  InputOffice365MgmtPq$Outbound,
  z.ZodTypeDef,
  InputOffice365MgmtPq
> = z.object({
  mode: InputOffice365MgmtMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputOffice365MgmtCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtPq$ {
  /** @deprecated use `InputOffice365MgmtPq$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MgmtPq$inboundSchema;
  /** @deprecated use `InputOffice365MgmtPq$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MgmtPq$outboundSchema;
  /** @deprecated use `InputOffice365MgmtPq$Outbound` instead. */
  export type Outbound = InputOffice365MgmtPq$Outbound;
}

export function inputOffice365MgmtPqToJSON(
  inputOffice365MgmtPq: InputOffice365MgmtPq,
): string {
  return JSON.stringify(
    InputOffice365MgmtPq$outboundSchema.parse(inputOffice365MgmtPq),
  );
}

export function inputOffice365MgmtPqFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MgmtPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MgmtPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MgmtPq' from JSON`,
  );
}

/** @internal */
export const InputOffice365MgmtSubscriptionPlan$inboundSchema: z.ZodType<
  InputOffice365MgmtSubscriptionPlan,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MgmtSubscriptionPlan),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MgmtSubscriptionPlan$outboundSchema: z.ZodType<
  InputOffice365MgmtSubscriptionPlan,
  z.ZodTypeDef,
  InputOffice365MgmtSubscriptionPlan
> = z.union([
  z.nativeEnum(InputOffice365MgmtSubscriptionPlan),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtSubscriptionPlan$ {
  /** @deprecated use `InputOffice365MgmtSubscriptionPlan$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MgmtSubscriptionPlan$inboundSchema;
  /** @deprecated use `InputOffice365MgmtSubscriptionPlan$outboundSchema` instead. */
  export const outboundSchema =
    InputOffice365MgmtSubscriptionPlan$outboundSchema;
}

/** @internal */
export const InputOffice365MgmtMetadatum$inboundSchema: z.ZodType<
  InputOffice365MgmtMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputOffice365MgmtMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputOffice365MgmtMetadatum$outboundSchema: z.ZodType<
  InputOffice365MgmtMetadatum$Outbound,
  z.ZodTypeDef,
  InputOffice365MgmtMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtMetadatum$ {
  /** @deprecated use `InputOffice365MgmtMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MgmtMetadatum$inboundSchema;
  /** @deprecated use `InputOffice365MgmtMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MgmtMetadatum$outboundSchema;
  /** @deprecated use `InputOffice365MgmtMetadatum$Outbound` instead. */
  export type Outbound = InputOffice365MgmtMetadatum$Outbound;
}

export function inputOffice365MgmtMetadatumToJSON(
  inputOffice365MgmtMetadatum: InputOffice365MgmtMetadatum,
): string {
  return JSON.stringify(
    InputOffice365MgmtMetadatum$outboundSchema.parse(
      inputOffice365MgmtMetadatum,
    ),
  );
}

export function inputOffice365MgmtMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MgmtMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MgmtMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MgmtMetadatum' from JSON`,
  );
}

/** @internal */
export const InputOffice365MgmtLogLevel$inboundSchema: z.ZodType<
  InputOffice365MgmtLogLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MgmtLogLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MgmtLogLevel$outboundSchema: z.ZodType<
  InputOffice365MgmtLogLevel,
  z.ZodTypeDef,
  InputOffice365MgmtLogLevel
> = z.union([
  z.nativeEnum(InputOffice365MgmtLogLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtLogLevel$ {
  /** @deprecated use `InputOffice365MgmtLogLevel$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MgmtLogLevel$inboundSchema;
  /** @deprecated use `InputOffice365MgmtLogLevel$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MgmtLogLevel$outboundSchema;
}

/** @internal */
export const InputOffice365MgmtContentConfig$inboundSchema: z.ZodType<
  InputOffice365MgmtContentConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  contentType: z.string().optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  logLevel: InputOffice365MgmtLogLevel$inboundSchema.optional(),
  enabled: z.boolean().optional(),
});

/** @internal */
export type InputOffice365MgmtContentConfig$Outbound = {
  contentType?: string | undefined;
  description?: string | undefined;
  interval?: number | undefined;
  logLevel?: string | undefined;
  enabled?: boolean | undefined;
};

/** @internal */
export const InputOffice365MgmtContentConfig$outboundSchema: z.ZodType<
  InputOffice365MgmtContentConfig$Outbound,
  z.ZodTypeDef,
  InputOffice365MgmtContentConfig
> = z.object({
  contentType: z.string().optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  logLevel: InputOffice365MgmtLogLevel$outboundSchema.optional(),
  enabled: z.boolean().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtContentConfig$ {
  /** @deprecated use `InputOffice365MgmtContentConfig$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MgmtContentConfig$inboundSchema;
  /** @deprecated use `InputOffice365MgmtContentConfig$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MgmtContentConfig$outboundSchema;
  /** @deprecated use `InputOffice365MgmtContentConfig$Outbound` instead. */
  export type Outbound = InputOffice365MgmtContentConfig$Outbound;
}

export function inputOffice365MgmtContentConfigToJSON(
  inputOffice365MgmtContentConfig: InputOffice365MgmtContentConfig,
): string {
  return JSON.stringify(
    InputOffice365MgmtContentConfig$outboundSchema.parse(
      inputOffice365MgmtContentConfig,
    ),
  );
}

export function inputOffice365MgmtContentConfigFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MgmtContentConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MgmtContentConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MgmtContentConfig' from JSON`,
  );
}

/** @internal */
export const InputOffice365MgmtRetryType$inboundSchema: z.ZodType<
  InputOffice365MgmtRetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MgmtRetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MgmtRetryType$outboundSchema: z.ZodType<
  InputOffice365MgmtRetryType,
  z.ZodTypeDef,
  InputOffice365MgmtRetryType
> = z.union([
  z.nativeEnum(InputOffice365MgmtRetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtRetryType$ {
  /** @deprecated use `InputOffice365MgmtRetryType$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MgmtRetryType$inboundSchema;
  /** @deprecated use `InputOffice365MgmtRetryType$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MgmtRetryType$outboundSchema;
}

/** @internal */
export const InputOffice365MgmtRetryRules$inboundSchema: z.ZodType<
  InputOffice365MgmtRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InputOffice365MgmtRetryType$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type InputOffice365MgmtRetryRules$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const InputOffice365MgmtRetryRules$outboundSchema: z.ZodType<
  InputOffice365MgmtRetryRules$Outbound,
  z.ZodTypeDef,
  InputOffice365MgmtRetryRules
> = z.object({
  type: InputOffice365MgmtRetryType$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtRetryRules$ {
  /** @deprecated use `InputOffice365MgmtRetryRules$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MgmtRetryRules$inboundSchema;
  /** @deprecated use `InputOffice365MgmtRetryRules$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MgmtRetryRules$outboundSchema;
  /** @deprecated use `InputOffice365MgmtRetryRules$Outbound` instead. */
  export type Outbound = InputOffice365MgmtRetryRules$Outbound;
}

export function inputOffice365MgmtRetryRulesToJSON(
  inputOffice365MgmtRetryRules: InputOffice365MgmtRetryRules,
): string {
  return JSON.stringify(
    InputOffice365MgmtRetryRules$outboundSchema.parse(
      inputOffice365MgmtRetryRules,
    ),
  );
}

export function inputOffice365MgmtRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MgmtRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MgmtRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MgmtRetryRules' from JSON`,
  );
}

/** @internal */
export const InputOffice365MgmtAuthenticationMethod$inboundSchema: z.ZodType<
  InputOffice365MgmtAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MgmtAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MgmtAuthenticationMethod$outboundSchema: z.ZodType<
  InputOffice365MgmtAuthenticationMethod,
  z.ZodTypeDef,
  InputOffice365MgmtAuthenticationMethod
> = z.union([
  z.nativeEnum(InputOffice365MgmtAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MgmtAuthenticationMethod$ {
  /** @deprecated use `InputOffice365MgmtAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputOffice365MgmtAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputOffice365MgmtAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputOffice365MgmtAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputOffice365Mgmt$inboundSchema: z.ZodType<
  InputOffice365Mgmt,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputOffice365MgmtType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputOffice365MgmtConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputOffice365MgmtPq$inboundSchema).optional(),
  planType: InputOffice365MgmtSubscriptionPlan$inboundSchema.default(
    "enterprise_gcc",
  ),
  tenantId: z.string(),
  appId: z.string(),
  timeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputOffice365MgmtMetadatum$inboundSchema))
    .optional(),
  publisherIdentifier: z.string().optional(),
  contentConfig: z.array(
    z.lazy(() => InputOffice365MgmtContentConfig$inboundSchema),
  ).optional(),
  ingestionLag: z.number().default(0),
  retryRules: z.lazy(() => InputOffice365MgmtRetryRules$inboundSchema)
    .optional(),
  authType: InputOffice365MgmtAuthenticationMethod$inboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/** @internal */
export type InputOffice365Mgmt$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputOffice365MgmtConnection$Outbound> | undefined;
  pq?: InputOffice365MgmtPq$Outbound | undefined;
  planType: string;
  tenantId: string;
  appId: string;
  timeout: number;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<InputOffice365MgmtMetadatum$Outbound> | undefined;
  publisherIdentifier?: string | undefined;
  contentConfig?: Array<InputOffice365MgmtContentConfig$Outbound> | undefined;
  ingestionLag: number;
  retryRules?: InputOffice365MgmtRetryRules$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputOffice365Mgmt$outboundSchema: z.ZodType<
  InputOffice365Mgmt$Outbound,
  z.ZodTypeDef,
  InputOffice365Mgmt
> = z.object({
  id: z.string(),
  type: InputOffice365MgmtType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputOffice365MgmtConnection$outboundSchema),
  ).optional(),
  pq: z.lazy(() => InputOffice365MgmtPq$outboundSchema).optional(),
  planType: InputOffice365MgmtSubscriptionPlan$outboundSchema.default(
    "enterprise_gcc",
  ),
  tenantId: z.string(),
  appId: z.string(),
  timeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputOffice365MgmtMetadatum$outboundSchema))
    .optional(),
  publisherIdentifier: z.string().optional(),
  contentConfig: z.array(
    z.lazy(() => InputOffice365MgmtContentConfig$outboundSchema),
  ).optional(),
  ingestionLag: z.number().default(0),
  retryRules: z.lazy(() => InputOffice365MgmtRetryRules$outboundSchema)
    .optional(),
  authType: InputOffice365MgmtAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365Mgmt$ {
  /** @deprecated use `InputOffice365Mgmt$inboundSchema` instead. */
  export const inboundSchema = InputOffice365Mgmt$inboundSchema;
  /** @deprecated use `InputOffice365Mgmt$outboundSchema` instead. */
  export const outboundSchema = InputOffice365Mgmt$outboundSchema;
  /** @deprecated use `InputOffice365Mgmt$Outbound` instead. */
  export type Outbound = InputOffice365Mgmt$Outbound;
}

export function inputOffice365MgmtToJSON(
  inputOffice365Mgmt: InputOffice365Mgmt,
): string {
  return JSON.stringify(
    InputOffice365Mgmt$outboundSchema.parse(inputOffice365Mgmt),
  );
}

export function inputOffice365MgmtFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365Mgmt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365Mgmt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365Mgmt' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheusType$inboundSchema: z.ZodType<
  InputEdgePrometheusType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputEdgePrometheusType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputEdgePrometheusType$outboundSchema: z.ZodType<
  InputEdgePrometheusType,
  z.ZodTypeDef,
  InputEdgePrometheusType
> = z.union([
  z.nativeEnum(InputEdgePrometheusType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusType$ {
  /** @deprecated use `InputEdgePrometheusType$inboundSchema` instead. */
  export const inboundSchema = InputEdgePrometheusType$inboundSchema;
  /** @deprecated use `InputEdgePrometheusType$outboundSchema` instead. */
  export const outboundSchema = InputEdgePrometheusType$outboundSchema;
}

/** @internal */
export const InputEdgePrometheusConnection$inboundSchema: z.ZodType<
  InputEdgePrometheusConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputEdgePrometheusConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputEdgePrometheusConnection$outboundSchema: z.ZodType<
  InputEdgePrometheusConnection$Outbound,
  z.ZodTypeDef,
  InputEdgePrometheusConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusConnection$ {
  /** @deprecated use `InputEdgePrometheusConnection$inboundSchema` instead. */
  export const inboundSchema = InputEdgePrometheusConnection$inboundSchema;
  /** @deprecated use `InputEdgePrometheusConnection$outboundSchema` instead. */
  export const outboundSchema = InputEdgePrometheusConnection$outboundSchema;
  /** @deprecated use `InputEdgePrometheusConnection$Outbound` instead. */
  export type Outbound = InputEdgePrometheusConnection$Outbound;
}

export function inputEdgePrometheusConnectionToJSON(
  inputEdgePrometheusConnection: InputEdgePrometheusConnection,
): string {
  return JSON.stringify(
    InputEdgePrometheusConnection$outboundSchema.parse(
      inputEdgePrometheusConnection,
    ),
  );
}

export function inputEdgePrometheusConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputEdgePrometheusConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEdgePrometheusConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEdgePrometheusConnection' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheusMode$inboundSchema: z.ZodType<
  InputEdgePrometheusMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputEdgePrometheusMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputEdgePrometheusMode$outboundSchema: z.ZodType<
  InputEdgePrometheusMode,
  z.ZodTypeDef,
  InputEdgePrometheusMode
> = z.union([
  z.nativeEnum(InputEdgePrometheusMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusMode$ {
  /** @deprecated use `InputEdgePrometheusMode$inboundSchema` instead. */
  export const inboundSchema = InputEdgePrometheusMode$inboundSchema;
  /** @deprecated use `InputEdgePrometheusMode$outboundSchema` instead. */
  export const outboundSchema = InputEdgePrometheusMode$outboundSchema;
}

/** @internal */
export const InputEdgePrometheusPqCompression$inboundSchema: z.ZodType<
  InputEdgePrometheusPqCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputEdgePrometheusPqCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputEdgePrometheusPqCompression$outboundSchema: z.ZodType<
  InputEdgePrometheusPqCompression,
  z.ZodTypeDef,
  InputEdgePrometheusPqCompression
> = z.union([
  z.nativeEnum(InputEdgePrometheusPqCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusPqCompression$ {
  /** @deprecated use `InputEdgePrometheusPqCompression$inboundSchema` instead. */
  export const inboundSchema = InputEdgePrometheusPqCompression$inboundSchema;
  /** @deprecated use `InputEdgePrometheusPqCompression$outboundSchema` instead. */
  export const outboundSchema = InputEdgePrometheusPqCompression$outboundSchema;
}

/** @internal */
export const InputEdgePrometheusPq$inboundSchema: z.ZodType<
  InputEdgePrometheusPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputEdgePrometheusMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputEdgePrometheusPqCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputEdgePrometheusPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputEdgePrometheusPq$outboundSchema: z.ZodType<
  InputEdgePrometheusPq$Outbound,
  z.ZodTypeDef,
  InputEdgePrometheusPq
> = z.object({
  mode: InputEdgePrometheusMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputEdgePrometheusPqCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusPq$ {
  /** @deprecated use `InputEdgePrometheusPq$inboundSchema` instead. */
  export const inboundSchema = InputEdgePrometheusPq$inboundSchema;
  /** @deprecated use `InputEdgePrometheusPq$outboundSchema` instead. */
  export const outboundSchema = InputEdgePrometheusPq$outboundSchema;
  /** @deprecated use `InputEdgePrometheusPq$Outbound` instead. */
  export type Outbound = InputEdgePrometheusPq$Outbound;
}

export function inputEdgePrometheusPqToJSON(
  inputEdgePrometheusPq: InputEdgePrometheusPq,
): string {
  return JSON.stringify(
    InputEdgePrometheusPq$outboundSchema.parse(inputEdgePrometheusPq),
  );
}

export function inputEdgePrometheusPqFromJSON(
  jsonString: string,
): SafeParseResult<InputEdgePrometheusPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEdgePrometheusPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEdgePrometheusPq' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheusDiscoveryType$inboundSchema: z.ZodType<
  InputEdgePrometheusDiscoveryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputEdgePrometheusDiscoveryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputEdgePrometheusDiscoveryType$outboundSchema: z.ZodType<
  InputEdgePrometheusDiscoveryType,
  z.ZodTypeDef,
  InputEdgePrometheusDiscoveryType
> = z.union([
  z.nativeEnum(InputEdgePrometheusDiscoveryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusDiscoveryType$ {
  /** @deprecated use `InputEdgePrometheusDiscoveryType$inboundSchema` instead. */
  export const inboundSchema = InputEdgePrometheusDiscoveryType$inboundSchema;
  /** @deprecated use `InputEdgePrometheusDiscoveryType$outboundSchema` instead. */
  export const outboundSchema = InputEdgePrometheusDiscoveryType$outboundSchema;
}

/** @internal */
export const PersistenceCompression$inboundSchema: z.ZodType<
  PersistenceCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PersistenceCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const PersistenceCompression$outboundSchema: z.ZodType<
  PersistenceCompression,
  z.ZodTypeDef,
  PersistenceCompression
> = z.union([
  z.nativeEnum(PersistenceCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PersistenceCompression$ {
  /** @deprecated use `PersistenceCompression$inboundSchema` instead. */
  export const inboundSchema = PersistenceCompression$inboundSchema;
  /** @deprecated use `PersistenceCompression$outboundSchema` instead. */
  export const outboundSchema = PersistenceCompression$outboundSchema;
}

/** @internal */
export const DiskSpooling$inboundSchema: z.ZodType<
  DiskSpooling,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: PersistenceCompression$inboundSchema.default("gzip"),
});

/** @internal */
export type DiskSpooling$Outbound = {
  enable: boolean;
  timeWindow: string;
  maxDataSize: string;
  maxDataTime: string;
  compress: string;
};

/** @internal */
export const DiskSpooling$outboundSchema: z.ZodType<
  DiskSpooling$Outbound,
  z.ZodTypeDef,
  DiskSpooling
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: PersistenceCompression$outboundSchema.default("gzip"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DiskSpooling$ {
  /** @deprecated use `DiskSpooling$inboundSchema` instead. */
  export const inboundSchema = DiskSpooling$inboundSchema;
  /** @deprecated use `DiskSpooling$outboundSchema` instead. */
  export const outboundSchema = DiskSpooling$outboundSchema;
  /** @deprecated use `DiskSpooling$Outbound` instead. */
  export type Outbound = DiskSpooling$Outbound;
}

export function diskSpoolingToJSON(diskSpooling: DiskSpooling): string {
  return JSON.stringify(DiskSpooling$outboundSchema.parse(diskSpooling));
}

export function diskSpoolingFromJSON(
  jsonString: string,
): SafeParseResult<DiskSpooling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DiskSpooling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DiskSpooling' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheusMetadatum$inboundSchema: z.ZodType<
  InputEdgePrometheusMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputEdgePrometheusMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputEdgePrometheusMetadatum$outboundSchema: z.ZodType<
  InputEdgePrometheusMetadatum$Outbound,
  z.ZodTypeDef,
  InputEdgePrometheusMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusMetadatum$ {
  /** @deprecated use `InputEdgePrometheusMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputEdgePrometheusMetadatum$inboundSchema;
  /** @deprecated use `InputEdgePrometheusMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputEdgePrometheusMetadatum$outboundSchema;
  /** @deprecated use `InputEdgePrometheusMetadatum$Outbound` instead. */
  export type Outbound = InputEdgePrometheusMetadatum$Outbound;
}

export function inputEdgePrometheusMetadatumToJSON(
  inputEdgePrometheusMetadatum: InputEdgePrometheusMetadatum,
): string {
  return JSON.stringify(
    InputEdgePrometheusMetadatum$outboundSchema.parse(
      inputEdgePrometheusMetadatum,
    ),
  );
}

export function inputEdgePrometheusMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputEdgePrometheusMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEdgePrometheusMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEdgePrometheusMetadatum' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheusAuthTypeAuthenticationMethod$inboundSchema:
  z.ZodType<
    InputEdgePrometheusAuthTypeAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(InputEdgePrometheusAuthTypeAuthenticationMethod),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const InputEdgePrometheusAuthTypeAuthenticationMethod$outboundSchema:
  z.ZodType<
    InputEdgePrometheusAuthTypeAuthenticationMethod,
    z.ZodTypeDef,
    InputEdgePrometheusAuthTypeAuthenticationMethod
  > = z.union([
    z.nativeEnum(InputEdgePrometheusAuthTypeAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusAuthTypeAuthenticationMethod$ {
  /** @deprecated use `InputEdgePrometheusAuthTypeAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputEdgePrometheusAuthTypeAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputEdgePrometheusAuthTypeAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputEdgePrometheusAuthTypeAuthenticationMethod$outboundSchema;
}

/** @internal */
export const TargetProtocol$inboundSchema: z.ZodType<
  TargetProtocol,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(TargetProtocol),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const TargetProtocol$outboundSchema: z.ZodType<
  TargetProtocol,
  z.ZodTypeDef,
  TargetProtocol
> = z.union([
  z.nativeEnum(TargetProtocol),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TargetProtocol$ {
  /** @deprecated use `TargetProtocol$inboundSchema` instead. */
  export const inboundSchema = TargetProtocol$inboundSchema;
  /** @deprecated use `TargetProtocol$outboundSchema` instead. */
  export const outboundSchema = TargetProtocol$outboundSchema;
}

/** @internal */
export const Target$inboundSchema: z.ZodType<Target, z.ZodTypeDef, unknown> = z
  .object({
    protocol: TargetProtocol$inboundSchema.default("http"),
    host: z.string(),
    port: z.number().default(9090),
    path: z.string().default("/metrics"),
  });

/** @internal */
export type Target$Outbound = {
  protocol: string;
  host: string;
  port: number;
  path: string;
};

/** @internal */
export const Target$outboundSchema: z.ZodType<
  Target$Outbound,
  z.ZodTypeDef,
  Target
> = z.object({
  protocol: TargetProtocol$outboundSchema.default("http"),
  host: z.string(),
  port: z.number().default(9090),
  path: z.string().default("/metrics"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Target$ {
  /** @deprecated use `Target$inboundSchema` instead. */
  export const inboundSchema = Target$inboundSchema;
  /** @deprecated use `Target$outboundSchema` instead. */
  export const outboundSchema = Target$outboundSchema;
  /** @deprecated use `Target$Outbound` instead. */
  export type Outbound = Target$Outbound;
}

export function targetToJSON(target: Target): string {
  return JSON.stringify(Target$outboundSchema.parse(target));
}

export function targetFromJSON(
  jsonString: string,
): SafeParseResult<Target, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Target$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Target' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheusRecordType$inboundSchema: z.ZodType<
  InputEdgePrometheusRecordType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputEdgePrometheusRecordType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputEdgePrometheusRecordType$outboundSchema: z.ZodType<
  InputEdgePrometheusRecordType,
  z.ZodTypeDef,
  InputEdgePrometheusRecordType
> = z.union([
  z.nativeEnum(InputEdgePrometheusRecordType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusRecordType$ {
  /** @deprecated use `InputEdgePrometheusRecordType$inboundSchema` instead. */
  export const inboundSchema = InputEdgePrometheusRecordType$inboundSchema;
  /** @deprecated use `InputEdgePrometheusRecordType$outboundSchema` instead. */
  export const outboundSchema = InputEdgePrometheusRecordType$outboundSchema;
}

/** @internal */
export const ScrapeProtocolProtocol$inboundSchema: z.ZodType<
  ScrapeProtocolProtocol,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ScrapeProtocolProtocol),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ScrapeProtocolProtocol$outboundSchema: z.ZodType<
  ScrapeProtocolProtocol,
  z.ZodTypeDef,
  ScrapeProtocolProtocol
> = z.union([
  z.nativeEnum(ScrapeProtocolProtocol),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ScrapeProtocolProtocol$ {
  /** @deprecated use `ScrapeProtocolProtocol$inboundSchema` instead. */
  export const inboundSchema = ScrapeProtocolProtocol$inboundSchema;
  /** @deprecated use `ScrapeProtocolProtocol$outboundSchema` instead. */
  export const outboundSchema = ScrapeProtocolProtocol$outboundSchema;
}

/** @internal */
export const InputEdgePrometheusSearchFilter$inboundSchema: z.ZodType<
  InputEdgePrometheusSearchFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  Name: z.string(),
  Values: z.array(z.string()),
}).transform((v) => {
  return remap$(v, {
    "Name": "name",
    "Values": "values",
  });
});

/** @internal */
export type InputEdgePrometheusSearchFilter$Outbound = {
  Name: string;
  Values: Array<string>;
};

/** @internal */
export const InputEdgePrometheusSearchFilter$outboundSchema: z.ZodType<
  InputEdgePrometheusSearchFilter$Outbound,
  z.ZodTypeDef,
  InputEdgePrometheusSearchFilter
> = z.object({
  name: z.string(),
  values: z.array(z.string()),
}).transform((v) => {
  return remap$(v, {
    name: "Name",
    values: "Values",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusSearchFilter$ {
  /** @deprecated use `InputEdgePrometheusSearchFilter$inboundSchema` instead. */
  export const inboundSchema = InputEdgePrometheusSearchFilter$inboundSchema;
  /** @deprecated use `InputEdgePrometheusSearchFilter$outboundSchema` instead. */
  export const outboundSchema = InputEdgePrometheusSearchFilter$outboundSchema;
  /** @deprecated use `InputEdgePrometheusSearchFilter$Outbound` instead. */
  export type Outbound = InputEdgePrometheusSearchFilter$Outbound;
}

export function inputEdgePrometheusSearchFilterToJSON(
  inputEdgePrometheusSearchFilter: InputEdgePrometheusSearchFilter,
): string {
  return JSON.stringify(
    InputEdgePrometheusSearchFilter$outboundSchema.parse(
      inputEdgePrometheusSearchFilter,
    ),
  );
}

export function inputEdgePrometheusSearchFilterFromJSON(
  jsonString: string,
): SafeParseResult<InputEdgePrometheusSearchFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEdgePrometheusSearchFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEdgePrometheusSearchFilter' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod$inboundSchema:
  z.ZodType<
    InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(
        InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod,
      ),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod$outboundSchema:
  z.ZodType<
    InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod,
    z.ZodTypeDef,
    InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod
  > = z.union([
    z.nativeEnum(
      InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod,
    ),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod$ {
  /** @deprecated use `InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputEdgePrometheusSignatureVersion$inboundSchema: z.ZodType<
  InputEdgePrometheusSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputEdgePrometheusSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputEdgePrometheusSignatureVersion$outboundSchema: z.ZodType<
  InputEdgePrometheusSignatureVersion,
  z.ZodTypeDef,
  InputEdgePrometheusSignatureVersion
> = z.union([
  z.nativeEnum(InputEdgePrometheusSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheusSignatureVersion$ {
  /** @deprecated use `InputEdgePrometheusSignatureVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputEdgePrometheusSignatureVersion$inboundSchema;
  /** @deprecated use `InputEdgePrometheusSignatureVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputEdgePrometheusSignatureVersion$outboundSchema;
}

/** @internal */
export const PodFilter$inboundSchema: z.ZodType<
  PodFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

/** @internal */
export type PodFilter$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const PodFilter$outboundSchema: z.ZodType<
  PodFilter$Outbound,
  z.ZodTypeDef,
  PodFilter
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PodFilter$ {
  /** @deprecated use `PodFilter$inboundSchema` instead. */
  export const inboundSchema = PodFilter$inboundSchema;
  /** @deprecated use `PodFilter$outboundSchema` instead. */
  export const outboundSchema = PodFilter$outboundSchema;
  /** @deprecated use `PodFilter$Outbound` instead. */
  export type Outbound = PodFilter$Outbound;
}

export function podFilterToJSON(podFilter: PodFilter): string {
  return JSON.stringify(PodFilter$outboundSchema.parse(podFilter));
}

export function podFilterFromJSON(
  jsonString: string,
): SafeParseResult<PodFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PodFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PodFilter' from JSON`,
  );
}

/** @internal */
export const InputEdgePrometheus$inboundSchema: z.ZodType<
  InputEdgePrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputEdgePrometheusType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputEdgePrometheusConnection$inboundSchema),
  ).optional(),
  pq: z.lazy(() => InputEdgePrometheusPq$inboundSchema).optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputEdgePrometheusDiscoveryType$inboundSchema.default(
    "static",
  ),
  interval: z.number().default(15),
  timeout: z.number().default(5000),
  persistence: z.lazy(() => DiskSpooling$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputEdgePrometheusMetadatum$inboundSchema))
    .optional(),
  authType: InputEdgePrometheusAuthTypeAuthenticationMethod$inboundSchema
    .default("manual"),
  description: z.string().optional(),
  targets: z.array(z.lazy(() => Target$inboundSchema)).optional(),
  nameList: z.array(z.string()).optional(),
  recordType: InputEdgePrometheusRecordType$inboundSchema.default("SRV"),
  scrapeProtocol: ScrapeProtocolProtocol$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  usePublicIp: z.boolean().default(true),
  scrapePort: z.number().default(9090),
  searchFilter: z.array(
    z.lazy(() => InputEdgePrometheusSearchFilter$inboundSchema),
  ).optional(),
  awsAuthenticationMethod:
    InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod$inboundSchema
      .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputEdgePrometheusSignatureVersion$inboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  scrapeProtocolExpr: z.string().default(
    "metadata.annotations['prometheus.io/scheme'] || 'http'",
  ),
  scrapePortExpr: z.string().default(
    "metadata.annotations['prometheus.io/port'] || 9090",
  ),
  scrapePathExpr: z.string().default(
    "metadata.annotations['prometheus.io/path'] || '/metrics'",
  ),
  podFilter: z.array(z.lazy(() => PodFilter$inboundSchema)).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type InputEdgePrometheus$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputEdgePrometheusConnection$Outbound> | undefined;
  pq?: InputEdgePrometheusPq$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  timeout: number;
  persistence?: DiskSpooling$Outbound | undefined;
  metadata?: Array<InputEdgePrometheusMetadatum$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targets?: Array<Target$Outbound> | undefined;
  nameList?: Array<string> | undefined;
  recordType: string;
  scrapeProtocol: string;
  scrapePath: string;
  usePublicIp: boolean;
  scrapePort: number;
  searchFilter?: Array<InputEdgePrometheusSearchFilter$Outbound> | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  scrapeProtocolExpr: string;
  scrapePortExpr: string;
  scrapePathExpr: string;
  podFilter?: Array<PodFilter$Outbound> | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputEdgePrometheus$outboundSchema: z.ZodType<
  InputEdgePrometheus$Outbound,
  z.ZodTypeDef,
  InputEdgePrometheus
> = z.object({
  id: z.string(),
  type: InputEdgePrometheusType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputEdgePrometheusConnection$outboundSchema),
  ).optional(),
  pq: z.lazy(() => InputEdgePrometheusPq$outboundSchema).optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputEdgePrometheusDiscoveryType$outboundSchema.default(
    "static",
  ),
  interval: z.number().default(15),
  timeout: z.number().default(5000),
  persistence: z.lazy(() => DiskSpooling$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputEdgePrometheusMetadatum$outboundSchema))
    .optional(),
  authType: InputEdgePrometheusAuthTypeAuthenticationMethod$outboundSchema
    .default("manual"),
  description: z.string().optional(),
  targets: z.array(z.lazy(() => Target$outboundSchema)).optional(),
  nameList: z.array(z.string()).optional(),
  recordType: InputEdgePrometheusRecordType$outboundSchema.default("SRV"),
  scrapeProtocol: ScrapeProtocolProtocol$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  usePublicIp: z.boolean().default(true),
  scrapePort: z.number().default(9090),
  searchFilter: z.array(
    z.lazy(() => InputEdgePrometheusSearchFilter$outboundSchema),
  ).optional(),
  awsAuthenticationMethod:
    InputEdgePrometheusAwsAuthenticationMethodAuthenticationMethod$outboundSchema
      .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputEdgePrometheusSignatureVersion$outboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  scrapeProtocolExpr: z.string().default(
    "metadata.annotations['prometheus.io/scheme'] || 'http'",
  ),
  scrapePortExpr: z.string().default(
    "metadata.annotations['prometheus.io/port'] || 9090",
  ),
  scrapePathExpr: z.string().default(
    "metadata.annotations['prometheus.io/path'] || '/metrics'",
  ),
  podFilter: z.array(z.lazy(() => PodFilter$outboundSchema)).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputEdgePrometheus$ {
  /** @deprecated use `InputEdgePrometheus$inboundSchema` instead. */
  export const inboundSchema = InputEdgePrometheus$inboundSchema;
  /** @deprecated use `InputEdgePrometheus$outboundSchema` instead. */
  export const outboundSchema = InputEdgePrometheus$outboundSchema;
  /** @deprecated use `InputEdgePrometheus$Outbound` instead. */
  export type Outbound = InputEdgePrometheus$Outbound;
}

export function inputEdgePrometheusToJSON(
  inputEdgePrometheus: InputEdgePrometheus,
): string {
  return JSON.stringify(
    InputEdgePrometheus$outboundSchema.parse(inputEdgePrometheus),
  );
}

export function inputEdgePrometheusFromJSON(
  jsonString: string,
): SafeParseResult<InputEdgePrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputEdgePrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputEdgePrometheus' from JSON`,
  );
}

/** @internal */
export const InputPrometheusType$inboundSchema: z.ZodType<
  InputPrometheusType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusType$outboundSchema: z.ZodType<
  InputPrometheusType,
  z.ZodTypeDef,
  InputPrometheusType
> = z.union([
  z.nativeEnum(InputPrometheusType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusType$ {
  /** @deprecated use `InputPrometheusType$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusType$inboundSchema;
  /** @deprecated use `InputPrometheusType$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusType$outboundSchema;
}

/** @internal */
export const InputPrometheusConnection$inboundSchema: z.ZodType<
  InputPrometheusConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputPrometheusConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputPrometheusConnection$outboundSchema: z.ZodType<
  InputPrometheusConnection$Outbound,
  z.ZodTypeDef,
  InputPrometheusConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusConnection$ {
  /** @deprecated use `InputPrometheusConnection$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusConnection$inboundSchema;
  /** @deprecated use `InputPrometheusConnection$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusConnection$outboundSchema;
  /** @deprecated use `InputPrometheusConnection$Outbound` instead. */
  export type Outbound = InputPrometheusConnection$Outbound;
}

export function inputPrometheusConnectionToJSON(
  inputPrometheusConnection: InputPrometheusConnection,
): string {
  return JSON.stringify(
    InputPrometheusConnection$outboundSchema.parse(inputPrometheusConnection),
  );
}

export function inputPrometheusConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusConnection' from JSON`,
  );
}

/** @internal */
export const InputPrometheusMode$inboundSchema: z.ZodType<
  InputPrometheusMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusMode$outboundSchema: z.ZodType<
  InputPrometheusMode,
  z.ZodTypeDef,
  InputPrometheusMode
> = z.union([
  z.nativeEnum(InputPrometheusMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusMode$ {
  /** @deprecated use `InputPrometheusMode$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusMode$inboundSchema;
  /** @deprecated use `InputPrometheusMode$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusMode$outboundSchema;
}

/** @internal */
export const InputPrometheusCompression$inboundSchema: z.ZodType<
  InputPrometheusCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusCompression$outboundSchema: z.ZodType<
  InputPrometheusCompression,
  z.ZodTypeDef,
  InputPrometheusCompression
> = z.union([
  z.nativeEnum(InputPrometheusCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusCompression$ {
  /** @deprecated use `InputPrometheusCompression$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusCompression$inboundSchema;
  /** @deprecated use `InputPrometheusCompression$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusCompression$outboundSchema;
}

/** @internal */
export const InputPrometheusPq$inboundSchema: z.ZodType<
  InputPrometheusPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputPrometheusMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputPrometheusCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputPrometheusPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputPrometheusPq$outboundSchema: z.ZodType<
  InputPrometheusPq$Outbound,
  z.ZodTypeDef,
  InputPrometheusPq
> = z.object({
  mode: InputPrometheusMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputPrometheusCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusPq$ {
  /** @deprecated use `InputPrometheusPq$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusPq$inboundSchema;
  /** @deprecated use `InputPrometheusPq$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusPq$outboundSchema;
  /** @deprecated use `InputPrometheusPq$Outbound` instead. */
  export type Outbound = InputPrometheusPq$Outbound;
}

export function inputPrometheusPqToJSON(
  inputPrometheusPq: InputPrometheusPq,
): string {
  return JSON.stringify(
    InputPrometheusPq$outboundSchema.parse(inputPrometheusPq),
  );
}

export function inputPrometheusPqFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusPq' from JSON`,
  );
}

/** @internal */
export const InputPrometheusDiscoveryType$inboundSchema: z.ZodType<
  InputPrometheusDiscoveryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusDiscoveryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusDiscoveryType$outboundSchema: z.ZodType<
  InputPrometheusDiscoveryType,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType
> = z.union([
  z.nativeEnum(InputPrometheusDiscoveryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusDiscoveryType$ {
  /** @deprecated use `InputPrometheusDiscoveryType$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusDiscoveryType$inboundSchema;
  /** @deprecated use `InputPrometheusDiscoveryType$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusDiscoveryType$outboundSchema;
}

/** @internal */
export const InputPrometheusLogLevel$inboundSchema: z.ZodType<
  InputPrometheusLogLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusLogLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusLogLevel$outboundSchema: z.ZodType<
  InputPrometheusLogLevel,
  z.ZodTypeDef,
  InputPrometheusLogLevel
> = z.union([
  z.nativeEnum(InputPrometheusLogLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusLogLevel$ {
  /** @deprecated use `InputPrometheusLogLevel$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusLogLevel$inboundSchema;
  /** @deprecated use `InputPrometheusLogLevel$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusLogLevel$outboundSchema;
}

/** @internal */
export const InputPrometheusMetadatum$inboundSchema: z.ZodType<
  InputPrometheusMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputPrometheusMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputPrometheusMetadatum$outboundSchema: z.ZodType<
  InputPrometheusMetadatum$Outbound,
  z.ZodTypeDef,
  InputPrometheusMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusMetadatum$ {
  /** @deprecated use `InputPrometheusMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusMetadatum$inboundSchema;
  /** @deprecated use `InputPrometheusMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusMetadatum$outboundSchema;
  /** @deprecated use `InputPrometheusMetadatum$Outbound` instead. */
  export type Outbound = InputPrometheusMetadatum$Outbound;
}

export function inputPrometheusMetadatumToJSON(
  inputPrometheusMetadatum: InputPrometheusMetadatum,
): string {
  return JSON.stringify(
    InputPrometheusMetadatum$outboundSchema.parse(inputPrometheusMetadatum),
  );
}

export function inputPrometheusMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusMetadatum' from JSON`,
  );
}

/** @internal */
export const InputPrometheusAuthTypeAuthenticationMethod$inboundSchema:
  z.ZodType<
    InputPrometheusAuthTypeAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(InputPrometheusAuthTypeAuthenticationMethod),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const InputPrometheusAuthTypeAuthenticationMethod$outboundSchema:
  z.ZodType<
    InputPrometheusAuthTypeAuthenticationMethod,
    z.ZodTypeDef,
    InputPrometheusAuthTypeAuthenticationMethod
  > = z.union([
    z.nativeEnum(InputPrometheusAuthTypeAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusAuthTypeAuthenticationMethod$ {
  /** @deprecated use `InputPrometheusAuthTypeAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputPrometheusAuthTypeAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputPrometheusAuthTypeAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputPrometheusAuthTypeAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputPrometheusRecordType$inboundSchema: z.ZodType<
  InputPrometheusRecordType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusRecordType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusRecordType$outboundSchema: z.ZodType<
  InputPrometheusRecordType,
  z.ZodTypeDef,
  InputPrometheusRecordType
> = z.union([
  z.nativeEnum(InputPrometheusRecordType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRecordType$ {
  /** @deprecated use `InputPrometheusRecordType$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRecordType$inboundSchema;
  /** @deprecated use `InputPrometheusRecordType$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusRecordType$outboundSchema;
}

/** @internal */
export const MetricsProtocol$inboundSchema: z.ZodType<
  MetricsProtocol,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(MetricsProtocol),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const MetricsProtocol$outboundSchema: z.ZodType<
  MetricsProtocol,
  z.ZodTypeDef,
  MetricsProtocol
> = z.union([
  z.nativeEnum(MetricsProtocol),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MetricsProtocol$ {
  /** @deprecated use `MetricsProtocol$inboundSchema` instead. */
  export const inboundSchema = MetricsProtocol$inboundSchema;
  /** @deprecated use `MetricsProtocol$outboundSchema` instead. */
  export const outboundSchema = MetricsProtocol$outboundSchema;
}

/** @internal */
export const InputPrometheusSearchFilter$inboundSchema: z.ZodType<
  InputPrometheusSearchFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  Name: z.string(),
  Values: z.array(z.string()),
}).transform((v) => {
  return remap$(v, {
    "Name": "name",
    "Values": "values",
  });
});

/** @internal */
export type InputPrometheusSearchFilter$Outbound = {
  Name: string;
  Values: Array<string>;
};

/** @internal */
export const InputPrometheusSearchFilter$outboundSchema: z.ZodType<
  InputPrometheusSearchFilter$Outbound,
  z.ZodTypeDef,
  InputPrometheusSearchFilter
> = z.object({
  name: z.string(),
  values: z.array(z.string()),
}).transform((v) => {
  return remap$(v, {
    name: "Name",
    values: "Values",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusSearchFilter$ {
  /** @deprecated use `InputPrometheusSearchFilter$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusSearchFilter$inboundSchema;
  /** @deprecated use `InputPrometheusSearchFilter$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusSearchFilter$outboundSchema;
  /** @deprecated use `InputPrometheusSearchFilter$Outbound` instead. */
  export type Outbound = InputPrometheusSearchFilter$Outbound;
}

export function inputPrometheusSearchFilterToJSON(
  inputPrometheusSearchFilter: InputPrometheusSearchFilter,
): string {
  return JSON.stringify(
    InputPrometheusSearchFilter$outboundSchema.parse(
      inputPrometheusSearchFilter,
    ),
  );
}

export function inputPrometheusSearchFilterFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusSearchFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusSearchFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusSearchFilter' from JSON`,
  );
}

/** @internal */
export const InputPrometheusAwsAuthenticationMethodAuthenticationMethod$inboundSchema:
  z.ZodType<
    InputPrometheusAwsAuthenticationMethodAuthenticationMethod,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(InputPrometheusAwsAuthenticationMethodAuthenticationMethod),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const InputPrometheusAwsAuthenticationMethodAuthenticationMethod$outboundSchema:
  z.ZodType<
    InputPrometheusAwsAuthenticationMethodAuthenticationMethod,
    z.ZodTypeDef,
    InputPrometheusAwsAuthenticationMethodAuthenticationMethod
  > = z.union([
    z.nativeEnum(InputPrometheusAwsAuthenticationMethodAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusAwsAuthenticationMethodAuthenticationMethod$ {
  /** @deprecated use `InputPrometheusAwsAuthenticationMethodAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputPrometheusAwsAuthenticationMethodAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputPrometheusAwsAuthenticationMethodAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputPrometheusAwsAuthenticationMethodAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputPrometheusSignatureVersion$inboundSchema: z.ZodType<
  InputPrometheusSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusSignatureVersion$outboundSchema: z.ZodType<
  InputPrometheusSignatureVersion,
  z.ZodTypeDef,
  InputPrometheusSignatureVersion
> = z.union([
  z.nativeEnum(InputPrometheusSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusSignatureVersion$ {
  /** @deprecated use `InputPrometheusSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusSignatureVersion$inboundSchema;
  /** @deprecated use `InputPrometheusSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusSignatureVersion$outboundSchema;
}

/** @internal */
export const InputPrometheus$inboundSchema: z.ZodType<
  InputPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputPrometheusType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputPrometheusConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputPrometheusPq$inboundSchema).optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType$inboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: InputPrometheusLogLevel$inboundSchema.default("info"),
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputPrometheusMetadatum$inboundSchema))
    .optional(),
  authType: InputPrometheusAuthTypeAuthenticationMethod$inboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  nameList: z.array(z.string()).optional(),
  recordType: InputPrometheusRecordType$inboundSchema.default("SRV"),
  scrapeProtocol: MetricsProtocol$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  usePublicIp: z.boolean().default(true),
  scrapePort: z.number().default(9090),
  searchFilter: z.array(z.lazy(() => InputPrometheusSearchFilter$inboundSchema))
    .optional(),
  awsAuthenticationMethod:
    InputPrometheusAwsAuthenticationMethodAuthenticationMethod$inboundSchema
      .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputPrometheusSignatureVersion$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type InputPrometheus$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputPrometheusConnection$Outbound> | undefined;
  pq?: InputPrometheusPq$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  logLevel: string;
  rejectUnauthorized: boolean;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<InputPrometheusMetadatum$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  nameList?: Array<string> | undefined;
  recordType: string;
  scrapeProtocol: string;
  scrapePath: string;
  usePublicIp: boolean;
  scrapePort: number;
  searchFilter?: Array<InputPrometheusSearchFilter$Outbound> | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheus$outboundSchema: z.ZodType<
  InputPrometheus$Outbound,
  z.ZodTypeDef,
  InputPrometheus
> = z.object({
  id: z.string(),
  type: InputPrometheusType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputPrometheusConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputPrometheusPq$outboundSchema).optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType$outboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: InputPrometheusLogLevel$outboundSchema.default("info"),
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputPrometheusMetadatum$outboundSchema))
    .optional(),
  authType: InputPrometheusAuthTypeAuthenticationMethod$outboundSchema.default(
    "manual",
  ),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  nameList: z.array(z.string()).optional(),
  recordType: InputPrometheusRecordType$outboundSchema.default("SRV"),
  scrapeProtocol: MetricsProtocol$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  usePublicIp: z.boolean().default(true),
  scrapePort: z.number().default(9090),
  searchFilter: z.array(
    z.lazy(() => InputPrometheusSearchFilter$outboundSchema),
  ).optional(),
  awsAuthenticationMethod:
    InputPrometheusAwsAuthenticationMethodAuthenticationMethod$outboundSchema
      .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: InputPrometheusSignatureVersion$outboundSchema.default(
    "v4",
  ),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheus$ {
  /** @deprecated use `InputPrometheus$inboundSchema` instead. */
  export const inboundSchema = InputPrometheus$inboundSchema;
  /** @deprecated use `InputPrometheus$outboundSchema` instead. */
  export const outboundSchema = InputPrometheus$outboundSchema;
  /** @deprecated use `InputPrometheus$Outbound` instead. */
  export type Outbound = InputPrometheus$Outbound;
}

export function inputPrometheusToJSON(
  inputPrometheus: InputPrometheus,
): string {
  return JSON.stringify(InputPrometheus$outboundSchema.parse(inputPrometheus));
}

export function inputPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheus' from JSON`,
  );
}

/** @internal */
export const InputPrometheusRwType$inboundSchema: z.ZodType<
  InputPrometheusRwType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusRwType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusRwType$outboundSchema: z.ZodType<
  InputPrometheusRwType,
  z.ZodTypeDef,
  InputPrometheusRwType
> = z.union([
  z.nativeEnum(InputPrometheusRwType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwType$ {
  /** @deprecated use `InputPrometheusRwType$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRwType$inboundSchema;
  /** @deprecated use `InputPrometheusRwType$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusRwType$outboundSchema;
}

/** @internal */
export const InputPrometheusRwConnection$inboundSchema: z.ZodType<
  InputPrometheusRwConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputPrometheusRwConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputPrometheusRwConnection$outboundSchema: z.ZodType<
  InputPrometheusRwConnection$Outbound,
  z.ZodTypeDef,
  InputPrometheusRwConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwConnection$ {
  /** @deprecated use `InputPrometheusRwConnection$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRwConnection$inboundSchema;
  /** @deprecated use `InputPrometheusRwConnection$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusRwConnection$outboundSchema;
  /** @deprecated use `InputPrometheusRwConnection$Outbound` instead. */
  export type Outbound = InputPrometheusRwConnection$Outbound;
}

export function inputPrometheusRwConnectionToJSON(
  inputPrometheusRwConnection: InputPrometheusRwConnection,
): string {
  return JSON.stringify(
    InputPrometheusRwConnection$outboundSchema.parse(
      inputPrometheusRwConnection,
    ),
  );
}

export function inputPrometheusRwConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusRwConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusRwConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusRwConnection' from JSON`,
  );
}

/** @internal */
export const InputPrometheusRwMode$inboundSchema: z.ZodType<
  InputPrometheusRwMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusRwMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusRwMode$outboundSchema: z.ZodType<
  InputPrometheusRwMode,
  z.ZodTypeDef,
  InputPrometheusRwMode
> = z.union([
  z.nativeEnum(InputPrometheusRwMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwMode$ {
  /** @deprecated use `InputPrometheusRwMode$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRwMode$inboundSchema;
  /** @deprecated use `InputPrometheusRwMode$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusRwMode$outboundSchema;
}

/** @internal */
export const InputPrometheusRwCompression$inboundSchema: z.ZodType<
  InputPrometheusRwCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusRwCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusRwCompression$outboundSchema: z.ZodType<
  InputPrometheusRwCompression,
  z.ZodTypeDef,
  InputPrometheusRwCompression
> = z.union([
  z.nativeEnum(InputPrometheusRwCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwCompression$ {
  /** @deprecated use `InputPrometheusRwCompression$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRwCompression$inboundSchema;
  /** @deprecated use `InputPrometheusRwCompression$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusRwCompression$outboundSchema;
}

/** @internal */
export const InputPrometheusRwPq$inboundSchema: z.ZodType<
  InputPrometheusRwPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputPrometheusRwMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputPrometheusRwCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputPrometheusRwPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputPrometheusRwPq$outboundSchema: z.ZodType<
  InputPrometheusRwPq$Outbound,
  z.ZodTypeDef,
  InputPrometheusRwPq
> = z.object({
  mode: InputPrometheusRwMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputPrometheusRwCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwPq$ {
  /** @deprecated use `InputPrometheusRwPq$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRwPq$inboundSchema;
  /** @deprecated use `InputPrometheusRwPq$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusRwPq$outboundSchema;
  /** @deprecated use `InputPrometheusRwPq$Outbound` instead. */
  export type Outbound = InputPrometheusRwPq$Outbound;
}

export function inputPrometheusRwPqToJSON(
  inputPrometheusRwPq: InputPrometheusRwPq,
): string {
  return JSON.stringify(
    InputPrometheusRwPq$outboundSchema.parse(inputPrometheusRwPq),
  );
}

export function inputPrometheusRwPqFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusRwPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusRwPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusRwPq' from JSON`,
  );
}

/** @internal */
export const InputPrometheusRwMinimumTLSVersion$inboundSchema: z.ZodType<
  InputPrometheusRwMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusRwMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusRwMinimumTLSVersion$outboundSchema: z.ZodType<
  InputPrometheusRwMinimumTLSVersion,
  z.ZodTypeDef,
  InputPrometheusRwMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputPrometheusRwMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwMinimumTLSVersion$ {
  /** @deprecated use `InputPrometheusRwMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRwMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputPrometheusRwMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputPrometheusRwMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputPrometheusRwMaximumTLSVersion$inboundSchema: z.ZodType<
  InputPrometheusRwMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusRwMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusRwMaximumTLSVersion$outboundSchema: z.ZodType<
  InputPrometheusRwMaximumTLSVersion,
  z.ZodTypeDef,
  InputPrometheusRwMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputPrometheusRwMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwMaximumTLSVersion$ {
  /** @deprecated use `InputPrometheusRwMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRwMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputPrometheusRwMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputPrometheusRwMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputPrometheusRwTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputPrometheusRwTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputPrometheusRwMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputPrometheusRwMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputPrometheusRwTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputPrometheusRwTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputPrometheusRwTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputPrometheusRwTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputPrometheusRwMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputPrometheusRwMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwTLSSettingsServerSide$ {
  /** @deprecated use `InputPrometheusRwTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema =
    InputPrometheusRwTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputPrometheusRwTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputPrometheusRwTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputPrometheusRwTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputPrometheusRwTLSSettingsServerSide$Outbound;
}

export function inputPrometheusRwTLSSettingsServerSideToJSON(
  inputPrometheusRwTLSSettingsServerSide:
    InputPrometheusRwTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputPrometheusRwTLSSettingsServerSide$outboundSchema.parse(
      inputPrometheusRwTLSSettingsServerSide,
    ),
  );
}

export function inputPrometheusRwTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusRwTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputPrometheusRwTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusRwTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputPrometheusRwAuthenticationType$inboundSchema: z.ZodType<
  InputPrometheusRwAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusRwAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputPrometheusRwAuthenticationType$outboundSchema: z.ZodType<
  InputPrometheusRwAuthenticationType,
  z.ZodTypeDef,
  InputPrometheusRwAuthenticationType
> = z.union([
  z.nativeEnum(InputPrometheusRwAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwAuthenticationType$ {
  /** @deprecated use `InputPrometheusRwAuthenticationType$inboundSchema` instead. */
  export const inboundSchema =
    InputPrometheusRwAuthenticationType$inboundSchema;
  /** @deprecated use `InputPrometheusRwAuthenticationType$outboundSchema` instead. */
  export const outboundSchema =
    InputPrometheusRwAuthenticationType$outboundSchema;
}

/** @internal */
export const InputPrometheusRwMetadatum$inboundSchema: z.ZodType<
  InputPrometheusRwMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputPrometheusRwMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputPrometheusRwMetadatum$outboundSchema: z.ZodType<
  InputPrometheusRwMetadatum$Outbound,
  z.ZodTypeDef,
  InputPrometheusRwMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwMetadatum$ {
  /** @deprecated use `InputPrometheusRwMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRwMetadatum$inboundSchema;
  /** @deprecated use `InputPrometheusRwMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusRwMetadatum$outboundSchema;
  /** @deprecated use `InputPrometheusRwMetadatum$Outbound` instead. */
  export type Outbound = InputPrometheusRwMetadatum$Outbound;
}

export function inputPrometheusRwMetadatumToJSON(
  inputPrometheusRwMetadatum: InputPrometheusRwMetadatum,
): string {
  return JSON.stringify(
    InputPrometheusRwMetadatum$outboundSchema.parse(inputPrometheusRwMetadatum),
  );
}

export function inputPrometheusRwMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusRwMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusRwMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusRwMetadatum' from JSON`,
  );
}

/** @internal */
export const InputPrometheusRwOauthParam$inboundSchema: z.ZodType<
  InputPrometheusRwOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputPrometheusRwOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputPrometheusRwOauthParam$outboundSchema: z.ZodType<
  InputPrometheusRwOauthParam$Outbound,
  z.ZodTypeDef,
  InputPrometheusRwOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwOauthParam$ {
  /** @deprecated use `InputPrometheusRwOauthParam$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRwOauthParam$inboundSchema;
  /** @deprecated use `InputPrometheusRwOauthParam$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusRwOauthParam$outboundSchema;
  /** @deprecated use `InputPrometheusRwOauthParam$Outbound` instead. */
  export type Outbound = InputPrometheusRwOauthParam$Outbound;
}

export function inputPrometheusRwOauthParamToJSON(
  inputPrometheusRwOauthParam: InputPrometheusRwOauthParam,
): string {
  return JSON.stringify(
    InputPrometheusRwOauthParam$outboundSchema.parse(
      inputPrometheusRwOauthParam,
    ),
  );
}

export function inputPrometheusRwOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusRwOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusRwOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusRwOauthParam' from JSON`,
  );
}

/** @internal */
export const InputPrometheusRwOauthHeader$inboundSchema: z.ZodType<
  InputPrometheusRwOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputPrometheusRwOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputPrometheusRwOauthHeader$outboundSchema: z.ZodType<
  InputPrometheusRwOauthHeader$Outbound,
  z.ZodTypeDef,
  InputPrometheusRwOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRwOauthHeader$ {
  /** @deprecated use `InputPrometheusRwOauthHeader$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRwOauthHeader$inboundSchema;
  /** @deprecated use `InputPrometheusRwOauthHeader$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusRwOauthHeader$outboundSchema;
  /** @deprecated use `InputPrometheusRwOauthHeader$Outbound` instead. */
  export type Outbound = InputPrometheusRwOauthHeader$Outbound;
}

export function inputPrometheusRwOauthHeaderToJSON(
  inputPrometheusRwOauthHeader: InputPrometheusRwOauthHeader,
): string {
  return JSON.stringify(
    InputPrometheusRwOauthHeader$outboundSchema.parse(
      inputPrometheusRwOauthHeader,
    ),
  );
}

export function inputPrometheusRwOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusRwOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusRwOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusRwOauthHeader' from JSON`,
  );
}

/** @internal */
export const InputPrometheusRw$inboundSchema: z.ZodType<
  InputPrometheusRw,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputPrometheusRwType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputPrometheusRwConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputPrometheusRwPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputPrometheusRwTLSSettingsServerSide$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/write"),
  authType: InputPrometheusRwAuthenticationType$inboundSchema.default("none"),
  metadata: z.array(z.lazy(() => InputPrometheusRwMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => InputPrometheusRwOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(
    z.lazy(() => InputPrometheusRwOauthHeader$inboundSchema),
  ).optional(),
});

/** @internal */
export type InputPrometheusRw$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputPrometheusRwConnection$Outbound> | undefined;
  pq?: InputPrometheusRwPq$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputPrometheusRwTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  prometheusAPI: string;
  authType: string;
  metadata?: Array<InputPrometheusRwMetadatum$Outbound> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<InputPrometheusRwOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<InputPrometheusRwOauthHeader$Outbound> | undefined;
};

/** @internal */
export const InputPrometheusRw$outboundSchema: z.ZodType<
  InputPrometheusRw$Outbound,
  z.ZodTypeDef,
  InputPrometheusRw
> = z.object({
  id: z.string(),
  type: InputPrometheusRwType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputPrometheusRwConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputPrometheusRwPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputPrometheusRwTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/write"),
  authType: InputPrometheusRwAuthenticationType$outboundSchema.default("none"),
  metadata: z.array(z.lazy(() => InputPrometheusRwMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => InputPrometheusRwOauthParam$outboundSchema))
    .optional(),
  oauthHeaders: z.array(
    z.lazy(() => InputPrometheusRwOauthHeader$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputPrometheusRw$ {
  /** @deprecated use `InputPrometheusRw$inboundSchema` instead. */
  export const inboundSchema = InputPrometheusRw$inboundSchema;
  /** @deprecated use `InputPrometheusRw$outboundSchema` instead. */
  export const outboundSchema = InputPrometheusRw$outboundSchema;
  /** @deprecated use `InputPrometheusRw$Outbound` instead. */
  export type Outbound = InputPrometheusRw$Outbound;
}

export function inputPrometheusRwToJSON(
  inputPrometheusRw: InputPrometheusRw,
): string {
  return JSON.stringify(
    InputPrometheusRw$outboundSchema.parse(inputPrometheusRw),
  );
}

export function inputPrometheusRwFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusRw, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusRw$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusRw' from JSON`,
  );
}

/** @internal */
export const InputLokiType$inboundSchema: z.ZodType<
  InputLokiType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputLokiType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputLokiType$outboundSchema: z.ZodType<
  InputLokiType,
  z.ZodTypeDef,
  InputLokiType
> = z.union([
  z.nativeEnum(InputLokiType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiType$ {
  /** @deprecated use `InputLokiType$inboundSchema` instead. */
  export const inboundSchema = InputLokiType$inboundSchema;
  /** @deprecated use `InputLokiType$outboundSchema` instead. */
  export const outboundSchema = InputLokiType$outboundSchema;
}

/** @internal */
export const InputLokiConnection$inboundSchema: z.ZodType<
  InputLokiConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputLokiConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputLokiConnection$outboundSchema: z.ZodType<
  InputLokiConnection$Outbound,
  z.ZodTypeDef,
  InputLokiConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiConnection$ {
  /** @deprecated use `InputLokiConnection$inboundSchema` instead. */
  export const inboundSchema = InputLokiConnection$inboundSchema;
  /** @deprecated use `InputLokiConnection$outboundSchema` instead. */
  export const outboundSchema = InputLokiConnection$outboundSchema;
  /** @deprecated use `InputLokiConnection$Outbound` instead. */
  export type Outbound = InputLokiConnection$Outbound;
}

export function inputLokiConnectionToJSON(
  inputLokiConnection: InputLokiConnection,
): string {
  return JSON.stringify(
    InputLokiConnection$outboundSchema.parse(inputLokiConnection),
  );
}

export function inputLokiConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputLokiConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputLokiConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputLokiConnection' from JSON`,
  );
}

/** @internal */
export const InputLokiMode$inboundSchema: z.ZodType<
  InputLokiMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputLokiMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputLokiMode$outboundSchema: z.ZodType<
  InputLokiMode,
  z.ZodTypeDef,
  InputLokiMode
> = z.union([
  z.nativeEnum(InputLokiMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiMode$ {
  /** @deprecated use `InputLokiMode$inboundSchema` instead. */
  export const inboundSchema = InputLokiMode$inboundSchema;
  /** @deprecated use `InputLokiMode$outboundSchema` instead. */
  export const outboundSchema = InputLokiMode$outboundSchema;
}

/** @internal */
export const InputLokiCompression$inboundSchema: z.ZodType<
  InputLokiCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputLokiCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputLokiCompression$outboundSchema: z.ZodType<
  InputLokiCompression,
  z.ZodTypeDef,
  InputLokiCompression
> = z.union([
  z.nativeEnum(InputLokiCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiCompression$ {
  /** @deprecated use `InputLokiCompression$inboundSchema` instead. */
  export const inboundSchema = InputLokiCompression$inboundSchema;
  /** @deprecated use `InputLokiCompression$outboundSchema` instead. */
  export const outboundSchema = InputLokiCompression$outboundSchema;
}

/** @internal */
export const InputLokiPq$inboundSchema: z.ZodType<
  InputLokiPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputLokiMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputLokiCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputLokiPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputLokiPq$outboundSchema: z.ZodType<
  InputLokiPq$Outbound,
  z.ZodTypeDef,
  InputLokiPq
> = z.object({
  mode: InputLokiMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputLokiCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiPq$ {
  /** @deprecated use `InputLokiPq$inboundSchema` instead. */
  export const inboundSchema = InputLokiPq$inboundSchema;
  /** @deprecated use `InputLokiPq$outboundSchema` instead. */
  export const outboundSchema = InputLokiPq$outboundSchema;
  /** @deprecated use `InputLokiPq$Outbound` instead. */
  export type Outbound = InputLokiPq$Outbound;
}

export function inputLokiPqToJSON(inputLokiPq: InputLokiPq): string {
  return JSON.stringify(InputLokiPq$outboundSchema.parse(inputLokiPq));
}

export function inputLokiPqFromJSON(
  jsonString: string,
): SafeParseResult<InputLokiPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputLokiPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputLokiPq' from JSON`,
  );
}

/** @internal */
export const InputLokiMinimumTLSVersion$inboundSchema: z.ZodType<
  InputLokiMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputLokiMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputLokiMinimumTLSVersion$outboundSchema: z.ZodType<
  InputLokiMinimumTLSVersion,
  z.ZodTypeDef,
  InputLokiMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputLokiMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiMinimumTLSVersion$ {
  /** @deprecated use `InputLokiMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputLokiMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputLokiMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputLokiMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputLokiMaximumTLSVersion$inboundSchema: z.ZodType<
  InputLokiMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputLokiMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputLokiMaximumTLSVersion$outboundSchema: z.ZodType<
  InputLokiMaximumTLSVersion,
  z.ZodTypeDef,
  InputLokiMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputLokiMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiMaximumTLSVersion$ {
  /** @deprecated use `InputLokiMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputLokiMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputLokiMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputLokiMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputLokiTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputLokiTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputLokiMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputLokiMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputLokiTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputLokiTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputLokiTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputLokiTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputLokiMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputLokiMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiTLSSettingsServerSide$ {
  /** @deprecated use `InputLokiTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputLokiTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputLokiTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema = InputLokiTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputLokiTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputLokiTLSSettingsServerSide$Outbound;
}

export function inputLokiTLSSettingsServerSideToJSON(
  inputLokiTLSSettingsServerSide: InputLokiTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputLokiTLSSettingsServerSide$outboundSchema.parse(
      inputLokiTLSSettingsServerSide,
    ),
  );
}

export function inputLokiTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputLokiTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputLokiTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputLokiTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputLokiAuthenticationType$inboundSchema: z.ZodType<
  InputLokiAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputLokiAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputLokiAuthenticationType$outboundSchema: z.ZodType<
  InputLokiAuthenticationType,
  z.ZodTypeDef,
  InputLokiAuthenticationType
> = z.union([
  z.nativeEnum(InputLokiAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiAuthenticationType$ {
  /** @deprecated use `InputLokiAuthenticationType$inboundSchema` instead. */
  export const inboundSchema = InputLokiAuthenticationType$inboundSchema;
  /** @deprecated use `InputLokiAuthenticationType$outboundSchema` instead. */
  export const outboundSchema = InputLokiAuthenticationType$outboundSchema;
}

/** @internal */
export const InputLokiMetadatum$inboundSchema: z.ZodType<
  InputLokiMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputLokiMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputLokiMetadatum$outboundSchema: z.ZodType<
  InputLokiMetadatum$Outbound,
  z.ZodTypeDef,
  InputLokiMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiMetadatum$ {
  /** @deprecated use `InputLokiMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputLokiMetadatum$inboundSchema;
  /** @deprecated use `InputLokiMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputLokiMetadatum$outboundSchema;
  /** @deprecated use `InputLokiMetadatum$Outbound` instead. */
  export type Outbound = InputLokiMetadatum$Outbound;
}

export function inputLokiMetadatumToJSON(
  inputLokiMetadatum: InputLokiMetadatum,
): string {
  return JSON.stringify(
    InputLokiMetadatum$outboundSchema.parse(inputLokiMetadatum),
  );
}

export function inputLokiMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputLokiMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputLokiMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputLokiMetadatum' from JSON`,
  );
}

/** @internal */
export const InputLokiOauthParam$inboundSchema: z.ZodType<
  InputLokiOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputLokiOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputLokiOauthParam$outboundSchema: z.ZodType<
  InputLokiOauthParam$Outbound,
  z.ZodTypeDef,
  InputLokiOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiOauthParam$ {
  /** @deprecated use `InputLokiOauthParam$inboundSchema` instead. */
  export const inboundSchema = InputLokiOauthParam$inboundSchema;
  /** @deprecated use `InputLokiOauthParam$outboundSchema` instead. */
  export const outboundSchema = InputLokiOauthParam$outboundSchema;
  /** @deprecated use `InputLokiOauthParam$Outbound` instead. */
  export type Outbound = InputLokiOauthParam$Outbound;
}

export function inputLokiOauthParamToJSON(
  inputLokiOauthParam: InputLokiOauthParam,
): string {
  return JSON.stringify(
    InputLokiOauthParam$outboundSchema.parse(inputLokiOauthParam),
  );
}

export function inputLokiOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<InputLokiOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputLokiOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputLokiOauthParam' from JSON`,
  );
}

/** @internal */
export const InputLokiOauthHeader$inboundSchema: z.ZodType<
  InputLokiOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputLokiOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputLokiOauthHeader$outboundSchema: z.ZodType<
  InputLokiOauthHeader$Outbound,
  z.ZodTypeDef,
  InputLokiOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLokiOauthHeader$ {
  /** @deprecated use `InputLokiOauthHeader$inboundSchema` instead. */
  export const inboundSchema = InputLokiOauthHeader$inboundSchema;
  /** @deprecated use `InputLokiOauthHeader$outboundSchema` instead. */
  export const outboundSchema = InputLokiOauthHeader$outboundSchema;
  /** @deprecated use `InputLokiOauthHeader$Outbound` instead. */
  export type Outbound = InputLokiOauthHeader$Outbound;
}

export function inputLokiOauthHeaderToJSON(
  inputLokiOauthHeader: InputLokiOauthHeader,
): string {
  return JSON.stringify(
    InputLokiOauthHeader$outboundSchema.parse(inputLokiOauthHeader),
  );
}

export function inputLokiOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<InputLokiOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputLokiOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputLokiOauthHeader' from JSON`,
  );
}

/** @internal */
export const InputLoki$inboundSchema: z.ZodType<
  InputLoki,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputLokiType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputLokiConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputLokiPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputLokiTLSSettingsServerSide$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  authType: InputLokiAuthenticationType$inboundSchema.default("none"),
  metadata: z.array(z.lazy(() => InputLokiMetadatum$inboundSchema)).optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => InputLokiOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => InputLokiOauthHeader$inboundSchema))
    .optional(),
});

/** @internal */
export type InputLoki$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputLokiConnection$Outbound> | undefined;
  pq?: InputLokiPq$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputLokiTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  lokiAPI: string;
  authType: string;
  metadata?: Array<InputLokiMetadatum$Outbound> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<InputLokiOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<InputLokiOauthHeader$Outbound> | undefined;
};

/** @internal */
export const InputLoki$outboundSchema: z.ZodType<
  InputLoki$Outbound,
  z.ZodTypeDef,
  InputLoki
> = z.object({
  id: z.string(),
  type: InputLokiType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputLokiConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputLokiPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputLokiTLSSettingsServerSide$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  authType: InputLokiAuthenticationType$outboundSchema.default("none"),
  metadata: z.array(z.lazy(() => InputLokiMetadatum$outboundSchema)).optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => InputLokiOauthParam$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => InputLokiOauthHeader$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputLoki$ {
  /** @deprecated use `InputLoki$inboundSchema` instead. */
  export const inboundSchema = InputLoki$inboundSchema;
  /** @deprecated use `InputLoki$outboundSchema` instead. */
  export const outboundSchema = InputLoki$outboundSchema;
  /** @deprecated use `InputLoki$Outbound` instead. */
  export type Outbound = InputLoki$Outbound;
}

export function inputLokiToJSON(inputLoki: InputLoki): string {
  return JSON.stringify(InputLoki$outboundSchema.parse(inputLoki));
}

export function inputLokiFromJSON(
  jsonString: string,
): SafeParseResult<InputLoki, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputLoki$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputLoki' from JSON`,
  );
}

/** @internal */
export const InputGrafanaType2$inboundSchema: z.ZodType<
  InputGrafanaType2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGrafanaType2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGrafanaType2$outboundSchema: z.ZodType<
  InputGrafanaType2,
  z.ZodTypeDef,
  InputGrafanaType2
> = z.union([
  z.nativeEnum(InputGrafanaType2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaType2$ {
  /** @deprecated use `InputGrafanaType2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaType2$inboundSchema;
  /** @deprecated use `InputGrafanaType2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaType2$outboundSchema;
}

/** @internal */
export const InputGrafanaConnection2$inboundSchema: z.ZodType<
  InputGrafanaConnection2,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputGrafanaConnection2$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputGrafanaConnection2$outboundSchema: z.ZodType<
  InputGrafanaConnection2$Outbound,
  z.ZodTypeDef,
  InputGrafanaConnection2
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaConnection2$ {
  /** @deprecated use `InputGrafanaConnection2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaConnection2$inboundSchema;
  /** @deprecated use `InputGrafanaConnection2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaConnection2$outboundSchema;
  /** @deprecated use `InputGrafanaConnection2$Outbound` instead. */
  export type Outbound = InputGrafanaConnection2$Outbound;
}

export function inputGrafanaConnection2ToJSON(
  inputGrafanaConnection2: InputGrafanaConnection2,
): string {
  return JSON.stringify(
    InputGrafanaConnection2$outboundSchema.parse(inputGrafanaConnection2),
  );
}

export function inputGrafanaConnection2FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaConnection2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaConnection2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaConnection2' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMode2$inboundSchema: z.ZodType<
  InputGrafanaMode2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGrafanaMode2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGrafanaMode2$outboundSchema: z.ZodType<
  InputGrafanaMode2,
  z.ZodTypeDef,
  InputGrafanaMode2
> = z.union([
  z.nativeEnum(InputGrafanaMode2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMode2$ {
  /** @deprecated use `InputGrafanaMode2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMode2$inboundSchema;
  /** @deprecated use `InputGrafanaMode2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMode2$outboundSchema;
}

/** @internal */
export const InputGrafanaCompression2$inboundSchema: z.ZodType<
  InputGrafanaCompression2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGrafanaCompression2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGrafanaCompression2$outboundSchema: z.ZodType<
  InputGrafanaCompression2,
  z.ZodTypeDef,
  InputGrafanaCompression2
> = z.union([
  z.nativeEnum(InputGrafanaCompression2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaCompression2$ {
  /** @deprecated use `InputGrafanaCompression2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaCompression2$inboundSchema;
  /** @deprecated use `InputGrafanaCompression2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaCompression2$outboundSchema;
}

/** @internal */
export const InputGrafanaPq2$inboundSchema: z.ZodType<
  InputGrafanaPq2,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputGrafanaMode2$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGrafanaCompression2$inboundSchema.default("none"),
});

/** @internal */
export type InputGrafanaPq2$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputGrafanaPq2$outboundSchema: z.ZodType<
  InputGrafanaPq2$Outbound,
  z.ZodTypeDef,
  InputGrafanaPq2
> = z.object({
  mode: InputGrafanaMode2$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGrafanaCompression2$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaPq2$ {
  /** @deprecated use `InputGrafanaPq2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaPq2$inboundSchema;
  /** @deprecated use `InputGrafanaPq2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaPq2$outboundSchema;
  /** @deprecated use `InputGrafanaPq2$Outbound` instead. */
  export type Outbound = InputGrafanaPq2$Outbound;
}

export function inputGrafanaPq2ToJSON(
  inputGrafanaPq2: InputGrafanaPq2,
): string {
  return JSON.stringify(InputGrafanaPq2$outboundSchema.parse(inputGrafanaPq2));
}

export function inputGrafanaPq2FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaPq2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaPq2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaPq2' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMinimumTLSVersion2$inboundSchema: z.ZodType<
  InputGrafanaMinimumTLSVersion2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGrafanaMinimumTLSVersion2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGrafanaMinimumTLSVersion2$outboundSchema: z.ZodType<
  InputGrafanaMinimumTLSVersion2,
  z.ZodTypeDef,
  InputGrafanaMinimumTLSVersion2
> = z.union([
  z.nativeEnum(InputGrafanaMinimumTLSVersion2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMinimumTLSVersion2$ {
  /** @deprecated use `InputGrafanaMinimumTLSVersion2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMinimumTLSVersion2$inboundSchema;
  /** @deprecated use `InputGrafanaMinimumTLSVersion2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMinimumTLSVersion2$outboundSchema;
}

/** @internal */
export const InputGrafanaMaximumTLSVersion2$inboundSchema: z.ZodType<
  InputGrafanaMaximumTLSVersion2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGrafanaMaximumTLSVersion2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGrafanaMaximumTLSVersion2$outboundSchema: z.ZodType<
  InputGrafanaMaximumTLSVersion2,
  z.ZodTypeDef,
  InputGrafanaMaximumTLSVersion2
> = z.union([
  z.nativeEnum(InputGrafanaMaximumTLSVersion2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMaximumTLSVersion2$ {
  /** @deprecated use `InputGrafanaMaximumTLSVersion2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMaximumTLSVersion2$inboundSchema;
  /** @deprecated use `InputGrafanaMaximumTLSVersion2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMaximumTLSVersion2$outboundSchema;
}

/** @internal */
export const InputGrafanaTLSSettingsServerSide2$inboundSchema: z.ZodType<
  InputGrafanaTLSSettingsServerSide2,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputGrafanaMinimumTLSVersion2$inboundSchema.optional(),
  maxVersion: InputGrafanaMaximumTLSVersion2$inboundSchema.optional(),
});

/** @internal */
export type InputGrafanaTLSSettingsServerSide2$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputGrafanaTLSSettingsServerSide2$outboundSchema: z.ZodType<
  InputGrafanaTLSSettingsServerSide2$Outbound,
  z.ZodTypeDef,
  InputGrafanaTLSSettingsServerSide2
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputGrafanaMinimumTLSVersion2$outboundSchema.optional(),
  maxVersion: InputGrafanaMaximumTLSVersion2$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaTLSSettingsServerSide2$ {
  /** @deprecated use `InputGrafanaTLSSettingsServerSide2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaTLSSettingsServerSide2$inboundSchema;
  /** @deprecated use `InputGrafanaTLSSettingsServerSide2$outboundSchema` instead. */
  export const outboundSchema =
    InputGrafanaTLSSettingsServerSide2$outboundSchema;
  /** @deprecated use `InputGrafanaTLSSettingsServerSide2$Outbound` instead. */
  export type Outbound = InputGrafanaTLSSettingsServerSide2$Outbound;
}

export function inputGrafanaTLSSettingsServerSide2ToJSON(
  inputGrafanaTLSSettingsServerSide2: InputGrafanaTLSSettingsServerSide2,
): string {
  return JSON.stringify(
    InputGrafanaTLSSettingsServerSide2$outboundSchema.parse(
      inputGrafanaTLSSettingsServerSide2,
    ),
  );
}

export function inputGrafanaTLSSettingsServerSide2FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaTLSSettingsServerSide2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputGrafanaTLSSettingsServerSide2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaTLSSettingsServerSide2' from JSON`,
  );
}

/** @internal */
export const PrometheusAuthAuthenticationType2$inboundSchema: z.ZodType<
  PrometheusAuthAuthenticationType2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PrometheusAuthAuthenticationType2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const PrometheusAuthAuthenticationType2$outboundSchema: z.ZodType<
  PrometheusAuthAuthenticationType2,
  z.ZodTypeDef,
  PrometheusAuthAuthenticationType2
> = z.union([
  z.nativeEnum(PrometheusAuthAuthenticationType2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthAuthenticationType2$ {
  /** @deprecated use `PrometheusAuthAuthenticationType2$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthAuthenticationType2$inboundSchema;
  /** @deprecated use `PrometheusAuthAuthenticationType2$outboundSchema` instead. */
  export const outboundSchema =
    PrometheusAuthAuthenticationType2$outboundSchema;
}

/** @internal */
export const PrometheusAuthOauthParam2$inboundSchema: z.ZodType<
  PrometheusAuthOauthParam2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type PrometheusAuthOauthParam2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const PrometheusAuthOauthParam2$outboundSchema: z.ZodType<
  PrometheusAuthOauthParam2$Outbound,
  z.ZodTypeDef,
  PrometheusAuthOauthParam2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthOauthParam2$ {
  /** @deprecated use `PrometheusAuthOauthParam2$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthOauthParam2$inboundSchema;
  /** @deprecated use `PrometheusAuthOauthParam2$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuthOauthParam2$outboundSchema;
  /** @deprecated use `PrometheusAuthOauthParam2$Outbound` instead. */
  export type Outbound = PrometheusAuthOauthParam2$Outbound;
}

export function prometheusAuthOauthParam2ToJSON(
  prometheusAuthOauthParam2: PrometheusAuthOauthParam2,
): string {
  return JSON.stringify(
    PrometheusAuthOauthParam2$outboundSchema.parse(prometheusAuthOauthParam2),
  );
}

export function prometheusAuthOauthParam2FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthOauthParam2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthOauthParam2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthOauthParam2' from JSON`,
  );
}

/** @internal */
export const PrometheusAuthOauthHeader2$inboundSchema: z.ZodType<
  PrometheusAuthOauthHeader2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type PrometheusAuthOauthHeader2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const PrometheusAuthOauthHeader2$outboundSchema: z.ZodType<
  PrometheusAuthOauthHeader2$Outbound,
  z.ZodTypeDef,
  PrometheusAuthOauthHeader2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthOauthHeader2$ {
  /** @deprecated use `PrometheusAuthOauthHeader2$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthOauthHeader2$inboundSchema;
  /** @deprecated use `PrometheusAuthOauthHeader2$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuthOauthHeader2$outboundSchema;
  /** @deprecated use `PrometheusAuthOauthHeader2$Outbound` instead. */
  export type Outbound = PrometheusAuthOauthHeader2$Outbound;
}

export function prometheusAuthOauthHeader2ToJSON(
  prometheusAuthOauthHeader2: PrometheusAuthOauthHeader2,
): string {
  return JSON.stringify(
    PrometheusAuthOauthHeader2$outboundSchema.parse(prometheusAuthOauthHeader2),
  );
}

export function prometheusAuthOauthHeader2FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthOauthHeader2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthOauthHeader2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthOauthHeader2' from JSON`,
  );
}

/** @internal */
export const PrometheusAuth2$inboundSchema: z.ZodType<
  PrometheusAuth2,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: PrometheusAuthAuthenticationType2$inboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => PrometheusAuthOauthParam2$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => PrometheusAuthOauthHeader2$inboundSchema))
    .optional(),
});

/** @internal */
export type PrometheusAuth2$Outbound = {
  authType: string;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<PrometheusAuthOauthParam2$Outbound> | undefined;
  oauthHeaders?: Array<PrometheusAuthOauthHeader2$Outbound> | undefined;
};

/** @internal */
export const PrometheusAuth2$outboundSchema: z.ZodType<
  PrometheusAuth2$Outbound,
  z.ZodTypeDef,
  PrometheusAuth2
> = z.object({
  authType: PrometheusAuthAuthenticationType2$outboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => PrometheusAuthOauthParam2$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => PrometheusAuthOauthHeader2$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuth2$ {
  /** @deprecated use `PrometheusAuth2$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuth2$inboundSchema;
  /** @deprecated use `PrometheusAuth2$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuth2$outboundSchema;
  /** @deprecated use `PrometheusAuth2$Outbound` instead. */
  export type Outbound = PrometheusAuth2$Outbound;
}

export function prometheusAuth2ToJSON(
  prometheusAuth2: PrometheusAuth2,
): string {
  return JSON.stringify(PrometheusAuth2$outboundSchema.parse(prometheusAuth2));
}

export function prometheusAuth2FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuth2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuth2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuth2' from JSON`,
  );
}

/** @internal */
export const LokiAuthAuthenticationType2$inboundSchema: z.ZodType<
  LokiAuthAuthenticationType2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(LokiAuthAuthenticationType2),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const LokiAuthAuthenticationType2$outboundSchema: z.ZodType<
  LokiAuthAuthenticationType2,
  z.ZodTypeDef,
  LokiAuthAuthenticationType2
> = z.union([
  z.nativeEnum(LokiAuthAuthenticationType2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthAuthenticationType2$ {
  /** @deprecated use `LokiAuthAuthenticationType2$inboundSchema` instead. */
  export const inboundSchema = LokiAuthAuthenticationType2$inboundSchema;
  /** @deprecated use `LokiAuthAuthenticationType2$outboundSchema` instead. */
  export const outboundSchema = LokiAuthAuthenticationType2$outboundSchema;
}

/** @internal */
export const LokiAuthOauthParam2$inboundSchema: z.ZodType<
  LokiAuthOauthParam2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type LokiAuthOauthParam2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const LokiAuthOauthParam2$outboundSchema: z.ZodType<
  LokiAuthOauthParam2$Outbound,
  z.ZodTypeDef,
  LokiAuthOauthParam2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthOauthParam2$ {
  /** @deprecated use `LokiAuthOauthParam2$inboundSchema` instead. */
  export const inboundSchema = LokiAuthOauthParam2$inboundSchema;
  /** @deprecated use `LokiAuthOauthParam2$outboundSchema` instead. */
  export const outboundSchema = LokiAuthOauthParam2$outboundSchema;
  /** @deprecated use `LokiAuthOauthParam2$Outbound` instead. */
  export type Outbound = LokiAuthOauthParam2$Outbound;
}

export function lokiAuthOauthParam2ToJSON(
  lokiAuthOauthParam2: LokiAuthOauthParam2,
): string {
  return JSON.stringify(
    LokiAuthOauthParam2$outboundSchema.parse(lokiAuthOauthParam2),
  );
}

export function lokiAuthOauthParam2FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuthOauthParam2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuthOauthParam2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuthOauthParam2' from JSON`,
  );
}

/** @internal */
export const LokiAuthOauthHeader2$inboundSchema: z.ZodType<
  LokiAuthOauthHeader2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type LokiAuthOauthHeader2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const LokiAuthOauthHeader2$outboundSchema: z.ZodType<
  LokiAuthOauthHeader2$Outbound,
  z.ZodTypeDef,
  LokiAuthOauthHeader2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthOauthHeader2$ {
  /** @deprecated use `LokiAuthOauthHeader2$inboundSchema` instead. */
  export const inboundSchema = LokiAuthOauthHeader2$inboundSchema;
  /** @deprecated use `LokiAuthOauthHeader2$outboundSchema` instead. */
  export const outboundSchema = LokiAuthOauthHeader2$outboundSchema;
  /** @deprecated use `LokiAuthOauthHeader2$Outbound` instead. */
  export type Outbound = LokiAuthOauthHeader2$Outbound;
}

export function lokiAuthOauthHeader2ToJSON(
  lokiAuthOauthHeader2: LokiAuthOauthHeader2,
): string {
  return JSON.stringify(
    LokiAuthOauthHeader2$outboundSchema.parse(lokiAuthOauthHeader2),
  );
}

export function lokiAuthOauthHeader2FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuthOauthHeader2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuthOauthHeader2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuthOauthHeader2' from JSON`,
  );
}

/** @internal */
export const LokiAuth2$inboundSchema: z.ZodType<
  LokiAuth2,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: LokiAuthAuthenticationType2$inboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => LokiAuthOauthParam2$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => LokiAuthOauthHeader2$inboundSchema))
    .optional(),
});

/** @internal */
export type LokiAuth2$Outbound = {
  authType: string;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<LokiAuthOauthParam2$Outbound> | undefined;
  oauthHeaders?: Array<LokiAuthOauthHeader2$Outbound> | undefined;
};

/** @internal */
export const LokiAuth2$outboundSchema: z.ZodType<
  LokiAuth2$Outbound,
  z.ZodTypeDef,
  LokiAuth2
> = z.object({
  authType: LokiAuthAuthenticationType2$outboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => LokiAuthOauthParam2$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => LokiAuthOauthHeader2$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuth2$ {
  /** @deprecated use `LokiAuth2$inboundSchema` instead. */
  export const inboundSchema = LokiAuth2$inboundSchema;
  /** @deprecated use `LokiAuth2$outboundSchema` instead. */
  export const outboundSchema = LokiAuth2$outboundSchema;
  /** @deprecated use `LokiAuth2$Outbound` instead. */
  export type Outbound = LokiAuth2$Outbound;
}

export function lokiAuth2ToJSON(lokiAuth2: LokiAuth2): string {
  return JSON.stringify(LokiAuth2$outboundSchema.parse(lokiAuth2));
}

export function lokiAuth2FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuth2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuth2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuth2' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMetadatum2$inboundSchema: z.ZodType<
  InputGrafanaMetadatum2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputGrafanaMetadatum2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputGrafanaMetadatum2$outboundSchema: z.ZodType<
  InputGrafanaMetadatum2$Outbound,
  z.ZodTypeDef,
  InputGrafanaMetadatum2
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMetadatum2$ {
  /** @deprecated use `InputGrafanaMetadatum2$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMetadatum2$inboundSchema;
  /** @deprecated use `InputGrafanaMetadatum2$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMetadatum2$outboundSchema;
  /** @deprecated use `InputGrafanaMetadatum2$Outbound` instead. */
  export type Outbound = InputGrafanaMetadatum2$Outbound;
}

export function inputGrafanaMetadatum2ToJSON(
  inputGrafanaMetadatum2: InputGrafanaMetadatum2,
): string {
  return JSON.stringify(
    InputGrafanaMetadatum2$outboundSchema.parse(inputGrafanaMetadatum2),
  );
}

export function inputGrafanaMetadatum2FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaMetadatum2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaMetadatum2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaMetadatum2' from JSON`,
  );
}

/** @internal */
export const InputGrafana2$inboundSchema: z.ZodType<
  InputGrafana2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputGrafanaType2$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGrafanaConnection2$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputGrafanaPq2$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputGrafanaTLSSettingsServerSide2$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/api/prom/push"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  prometheusAuth: z.lazy(() => PrometheusAuth2$inboundSchema).optional(),
  lokiAuth: z.lazy(() => LokiAuth2$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputGrafanaMetadatum2$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputGrafana2$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputGrafanaConnection2$Outbound> | undefined;
  pq?: InputGrafanaPq2$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputGrafanaTLSSettingsServerSide2$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  prometheusAPI: string;
  lokiAPI: string;
  prometheusAuth?: PrometheusAuth2$Outbound | undefined;
  lokiAuth?: LokiAuth2$Outbound | undefined;
  metadata?: Array<InputGrafanaMetadatum2$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputGrafana2$outboundSchema: z.ZodType<
  InputGrafana2$Outbound,
  z.ZodTypeDef,
  InputGrafana2
> = z.object({
  id: z.string(),
  type: InputGrafanaType2$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGrafanaConnection2$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputGrafanaPq2$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputGrafanaTLSSettingsServerSide2$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/api/prom/push"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  prometheusAuth: z.lazy(() => PrometheusAuth2$outboundSchema).optional(),
  lokiAuth: z.lazy(() => LokiAuth2$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputGrafanaMetadatum2$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafana2$ {
  /** @deprecated use `InputGrafana2$inboundSchema` instead. */
  export const inboundSchema = InputGrafana2$inboundSchema;
  /** @deprecated use `InputGrafana2$outboundSchema` instead. */
  export const outboundSchema = InputGrafana2$outboundSchema;
  /** @deprecated use `InputGrafana2$Outbound` instead. */
  export type Outbound = InputGrafana2$Outbound;
}

export function inputGrafana2ToJSON(inputGrafana2: InputGrafana2): string {
  return JSON.stringify(InputGrafana2$outboundSchema.parse(inputGrafana2));
}

export function inputGrafana2FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafana2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafana2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafana2' from JSON`,
  );
}

/** @internal */
export const InputGrafanaType1$inboundSchema: z.ZodType<
  InputGrafanaType1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGrafanaType1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGrafanaType1$outboundSchema: z.ZodType<
  InputGrafanaType1,
  z.ZodTypeDef,
  InputGrafanaType1
> = z.union([
  z.nativeEnum(InputGrafanaType1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaType1$ {
  /** @deprecated use `InputGrafanaType1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaType1$inboundSchema;
  /** @deprecated use `InputGrafanaType1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaType1$outboundSchema;
}

/** @internal */
export const InputGrafanaConnection1$inboundSchema: z.ZodType<
  InputGrafanaConnection1,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputGrafanaConnection1$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputGrafanaConnection1$outboundSchema: z.ZodType<
  InputGrafanaConnection1$Outbound,
  z.ZodTypeDef,
  InputGrafanaConnection1
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaConnection1$ {
  /** @deprecated use `InputGrafanaConnection1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaConnection1$inboundSchema;
  /** @deprecated use `InputGrafanaConnection1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaConnection1$outboundSchema;
  /** @deprecated use `InputGrafanaConnection1$Outbound` instead. */
  export type Outbound = InputGrafanaConnection1$Outbound;
}

export function inputGrafanaConnection1ToJSON(
  inputGrafanaConnection1: InputGrafanaConnection1,
): string {
  return JSON.stringify(
    InputGrafanaConnection1$outboundSchema.parse(inputGrafanaConnection1),
  );
}

export function inputGrafanaConnection1FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaConnection1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaConnection1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaConnection1' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMode1$inboundSchema: z.ZodType<
  InputGrafanaMode1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGrafanaMode1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGrafanaMode1$outboundSchema: z.ZodType<
  InputGrafanaMode1,
  z.ZodTypeDef,
  InputGrafanaMode1
> = z.union([
  z.nativeEnum(InputGrafanaMode1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMode1$ {
  /** @deprecated use `InputGrafanaMode1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMode1$inboundSchema;
  /** @deprecated use `InputGrafanaMode1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMode1$outboundSchema;
}

/** @internal */
export const InputGrafanaCompression1$inboundSchema: z.ZodType<
  InputGrafanaCompression1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGrafanaCompression1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGrafanaCompression1$outboundSchema: z.ZodType<
  InputGrafanaCompression1,
  z.ZodTypeDef,
  InputGrafanaCompression1
> = z.union([
  z.nativeEnum(InputGrafanaCompression1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaCompression1$ {
  /** @deprecated use `InputGrafanaCompression1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaCompression1$inboundSchema;
  /** @deprecated use `InputGrafanaCompression1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaCompression1$outboundSchema;
}

/** @internal */
export const InputGrafanaPq1$inboundSchema: z.ZodType<
  InputGrafanaPq1,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputGrafanaMode1$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGrafanaCompression1$inboundSchema.default("none"),
});

/** @internal */
export type InputGrafanaPq1$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputGrafanaPq1$outboundSchema: z.ZodType<
  InputGrafanaPq1$Outbound,
  z.ZodTypeDef,
  InputGrafanaPq1
> = z.object({
  mode: InputGrafanaMode1$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGrafanaCompression1$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaPq1$ {
  /** @deprecated use `InputGrafanaPq1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaPq1$inboundSchema;
  /** @deprecated use `InputGrafanaPq1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaPq1$outboundSchema;
  /** @deprecated use `InputGrafanaPq1$Outbound` instead. */
  export type Outbound = InputGrafanaPq1$Outbound;
}

export function inputGrafanaPq1ToJSON(
  inputGrafanaPq1: InputGrafanaPq1,
): string {
  return JSON.stringify(InputGrafanaPq1$outboundSchema.parse(inputGrafanaPq1));
}

export function inputGrafanaPq1FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaPq1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaPq1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaPq1' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMinimumTLSVersion1$inboundSchema: z.ZodType<
  InputGrafanaMinimumTLSVersion1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGrafanaMinimumTLSVersion1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGrafanaMinimumTLSVersion1$outboundSchema: z.ZodType<
  InputGrafanaMinimumTLSVersion1,
  z.ZodTypeDef,
  InputGrafanaMinimumTLSVersion1
> = z.union([
  z.nativeEnum(InputGrafanaMinimumTLSVersion1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMinimumTLSVersion1$ {
  /** @deprecated use `InputGrafanaMinimumTLSVersion1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMinimumTLSVersion1$inboundSchema;
  /** @deprecated use `InputGrafanaMinimumTLSVersion1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMinimumTLSVersion1$outboundSchema;
}

/** @internal */
export const InputGrafanaMaximumTLSVersion1$inboundSchema: z.ZodType<
  InputGrafanaMaximumTLSVersion1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputGrafanaMaximumTLSVersion1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputGrafanaMaximumTLSVersion1$outboundSchema: z.ZodType<
  InputGrafanaMaximumTLSVersion1,
  z.ZodTypeDef,
  InputGrafanaMaximumTLSVersion1
> = z.union([
  z.nativeEnum(InputGrafanaMaximumTLSVersion1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMaximumTLSVersion1$ {
  /** @deprecated use `InputGrafanaMaximumTLSVersion1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMaximumTLSVersion1$inboundSchema;
  /** @deprecated use `InputGrafanaMaximumTLSVersion1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMaximumTLSVersion1$outboundSchema;
}

/** @internal */
export const InputGrafanaTLSSettingsServerSide1$inboundSchema: z.ZodType<
  InputGrafanaTLSSettingsServerSide1,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputGrafanaMinimumTLSVersion1$inboundSchema.optional(),
  maxVersion: InputGrafanaMaximumTLSVersion1$inboundSchema.optional(),
});

/** @internal */
export type InputGrafanaTLSSettingsServerSide1$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputGrafanaTLSSettingsServerSide1$outboundSchema: z.ZodType<
  InputGrafanaTLSSettingsServerSide1$Outbound,
  z.ZodTypeDef,
  InputGrafanaTLSSettingsServerSide1
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputGrafanaMinimumTLSVersion1$outboundSchema.optional(),
  maxVersion: InputGrafanaMaximumTLSVersion1$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaTLSSettingsServerSide1$ {
  /** @deprecated use `InputGrafanaTLSSettingsServerSide1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaTLSSettingsServerSide1$inboundSchema;
  /** @deprecated use `InputGrafanaTLSSettingsServerSide1$outboundSchema` instead. */
  export const outboundSchema =
    InputGrafanaTLSSettingsServerSide1$outboundSchema;
  /** @deprecated use `InputGrafanaTLSSettingsServerSide1$Outbound` instead. */
  export type Outbound = InputGrafanaTLSSettingsServerSide1$Outbound;
}

export function inputGrafanaTLSSettingsServerSide1ToJSON(
  inputGrafanaTLSSettingsServerSide1: InputGrafanaTLSSettingsServerSide1,
): string {
  return JSON.stringify(
    InputGrafanaTLSSettingsServerSide1$outboundSchema.parse(
      inputGrafanaTLSSettingsServerSide1,
    ),
  );
}

export function inputGrafanaTLSSettingsServerSide1FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaTLSSettingsServerSide1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputGrafanaTLSSettingsServerSide1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaTLSSettingsServerSide1' from JSON`,
  );
}

/** @internal */
export const PrometheusAuthAuthenticationType1$inboundSchema: z.ZodType<
  PrometheusAuthAuthenticationType1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PrometheusAuthAuthenticationType1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const PrometheusAuthAuthenticationType1$outboundSchema: z.ZodType<
  PrometheusAuthAuthenticationType1,
  z.ZodTypeDef,
  PrometheusAuthAuthenticationType1
> = z.union([
  z.nativeEnum(PrometheusAuthAuthenticationType1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthAuthenticationType1$ {
  /** @deprecated use `PrometheusAuthAuthenticationType1$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthAuthenticationType1$inboundSchema;
  /** @deprecated use `PrometheusAuthAuthenticationType1$outboundSchema` instead. */
  export const outboundSchema =
    PrometheusAuthAuthenticationType1$outboundSchema;
}

/** @internal */
export const PrometheusAuthOauthParam1$inboundSchema: z.ZodType<
  PrometheusAuthOauthParam1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type PrometheusAuthOauthParam1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const PrometheusAuthOauthParam1$outboundSchema: z.ZodType<
  PrometheusAuthOauthParam1$Outbound,
  z.ZodTypeDef,
  PrometheusAuthOauthParam1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthOauthParam1$ {
  /** @deprecated use `PrometheusAuthOauthParam1$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthOauthParam1$inboundSchema;
  /** @deprecated use `PrometheusAuthOauthParam1$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuthOauthParam1$outboundSchema;
  /** @deprecated use `PrometheusAuthOauthParam1$Outbound` instead. */
  export type Outbound = PrometheusAuthOauthParam1$Outbound;
}

export function prometheusAuthOauthParam1ToJSON(
  prometheusAuthOauthParam1: PrometheusAuthOauthParam1,
): string {
  return JSON.stringify(
    PrometheusAuthOauthParam1$outboundSchema.parse(prometheusAuthOauthParam1),
  );
}

export function prometheusAuthOauthParam1FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthOauthParam1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthOauthParam1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthOauthParam1' from JSON`,
  );
}

/** @internal */
export const PrometheusAuthOauthHeader1$inboundSchema: z.ZodType<
  PrometheusAuthOauthHeader1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type PrometheusAuthOauthHeader1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const PrometheusAuthOauthHeader1$outboundSchema: z.ZodType<
  PrometheusAuthOauthHeader1$Outbound,
  z.ZodTypeDef,
  PrometheusAuthOauthHeader1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthOauthHeader1$ {
  /** @deprecated use `PrometheusAuthOauthHeader1$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthOauthHeader1$inboundSchema;
  /** @deprecated use `PrometheusAuthOauthHeader1$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuthOauthHeader1$outboundSchema;
  /** @deprecated use `PrometheusAuthOauthHeader1$Outbound` instead. */
  export type Outbound = PrometheusAuthOauthHeader1$Outbound;
}

export function prometheusAuthOauthHeader1ToJSON(
  prometheusAuthOauthHeader1: PrometheusAuthOauthHeader1,
): string {
  return JSON.stringify(
    PrometheusAuthOauthHeader1$outboundSchema.parse(prometheusAuthOauthHeader1),
  );
}

export function prometheusAuthOauthHeader1FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthOauthHeader1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthOauthHeader1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthOauthHeader1' from JSON`,
  );
}

/** @internal */
export const PrometheusAuth1$inboundSchema: z.ZodType<
  PrometheusAuth1,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: PrometheusAuthAuthenticationType1$inboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => PrometheusAuthOauthParam1$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => PrometheusAuthOauthHeader1$inboundSchema))
    .optional(),
});

/** @internal */
export type PrometheusAuth1$Outbound = {
  authType: string;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<PrometheusAuthOauthParam1$Outbound> | undefined;
  oauthHeaders?: Array<PrometheusAuthOauthHeader1$Outbound> | undefined;
};

/** @internal */
export const PrometheusAuth1$outboundSchema: z.ZodType<
  PrometheusAuth1$Outbound,
  z.ZodTypeDef,
  PrometheusAuth1
> = z.object({
  authType: PrometheusAuthAuthenticationType1$outboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => PrometheusAuthOauthParam1$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => PrometheusAuthOauthHeader1$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuth1$ {
  /** @deprecated use `PrometheusAuth1$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuth1$inboundSchema;
  /** @deprecated use `PrometheusAuth1$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuth1$outboundSchema;
  /** @deprecated use `PrometheusAuth1$Outbound` instead. */
  export type Outbound = PrometheusAuth1$Outbound;
}

export function prometheusAuth1ToJSON(
  prometheusAuth1: PrometheusAuth1,
): string {
  return JSON.stringify(PrometheusAuth1$outboundSchema.parse(prometheusAuth1));
}

export function prometheusAuth1FromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuth1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuth1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuth1' from JSON`,
  );
}

/** @internal */
export const LokiAuthAuthenticationType1$inboundSchema: z.ZodType<
  LokiAuthAuthenticationType1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(LokiAuthAuthenticationType1),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const LokiAuthAuthenticationType1$outboundSchema: z.ZodType<
  LokiAuthAuthenticationType1,
  z.ZodTypeDef,
  LokiAuthAuthenticationType1
> = z.union([
  z.nativeEnum(LokiAuthAuthenticationType1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthAuthenticationType1$ {
  /** @deprecated use `LokiAuthAuthenticationType1$inboundSchema` instead. */
  export const inboundSchema = LokiAuthAuthenticationType1$inboundSchema;
  /** @deprecated use `LokiAuthAuthenticationType1$outboundSchema` instead. */
  export const outboundSchema = LokiAuthAuthenticationType1$outboundSchema;
}

/** @internal */
export const LokiAuthOauthParam1$inboundSchema: z.ZodType<
  LokiAuthOauthParam1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type LokiAuthOauthParam1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const LokiAuthOauthParam1$outboundSchema: z.ZodType<
  LokiAuthOauthParam1$Outbound,
  z.ZodTypeDef,
  LokiAuthOauthParam1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthOauthParam1$ {
  /** @deprecated use `LokiAuthOauthParam1$inboundSchema` instead. */
  export const inboundSchema = LokiAuthOauthParam1$inboundSchema;
  /** @deprecated use `LokiAuthOauthParam1$outboundSchema` instead. */
  export const outboundSchema = LokiAuthOauthParam1$outboundSchema;
  /** @deprecated use `LokiAuthOauthParam1$Outbound` instead. */
  export type Outbound = LokiAuthOauthParam1$Outbound;
}

export function lokiAuthOauthParam1ToJSON(
  lokiAuthOauthParam1: LokiAuthOauthParam1,
): string {
  return JSON.stringify(
    LokiAuthOauthParam1$outboundSchema.parse(lokiAuthOauthParam1),
  );
}

export function lokiAuthOauthParam1FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuthOauthParam1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuthOauthParam1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuthOauthParam1' from JSON`,
  );
}

/** @internal */
export const LokiAuthOauthHeader1$inboundSchema: z.ZodType<
  LokiAuthOauthHeader1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type LokiAuthOauthHeader1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const LokiAuthOauthHeader1$outboundSchema: z.ZodType<
  LokiAuthOauthHeader1$Outbound,
  z.ZodTypeDef,
  LokiAuthOauthHeader1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthOauthHeader1$ {
  /** @deprecated use `LokiAuthOauthHeader1$inboundSchema` instead. */
  export const inboundSchema = LokiAuthOauthHeader1$inboundSchema;
  /** @deprecated use `LokiAuthOauthHeader1$outboundSchema` instead. */
  export const outboundSchema = LokiAuthOauthHeader1$outboundSchema;
  /** @deprecated use `LokiAuthOauthHeader1$Outbound` instead. */
  export type Outbound = LokiAuthOauthHeader1$Outbound;
}

export function lokiAuthOauthHeader1ToJSON(
  lokiAuthOauthHeader1: LokiAuthOauthHeader1,
): string {
  return JSON.stringify(
    LokiAuthOauthHeader1$outboundSchema.parse(lokiAuthOauthHeader1),
  );
}

export function lokiAuthOauthHeader1FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuthOauthHeader1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuthOauthHeader1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuthOauthHeader1' from JSON`,
  );
}

/** @internal */
export const LokiAuth1$inboundSchema: z.ZodType<
  LokiAuth1,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: LokiAuthAuthenticationType1$inboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => LokiAuthOauthParam1$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => LokiAuthOauthHeader1$inboundSchema))
    .optional(),
});

/** @internal */
export type LokiAuth1$Outbound = {
  authType: string;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<LokiAuthOauthParam1$Outbound> | undefined;
  oauthHeaders?: Array<LokiAuthOauthHeader1$Outbound> | undefined;
};

/** @internal */
export const LokiAuth1$outboundSchema: z.ZodType<
  LokiAuth1$Outbound,
  z.ZodTypeDef,
  LokiAuth1
> = z.object({
  authType: LokiAuthAuthenticationType1$outboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => LokiAuthOauthParam1$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => LokiAuthOauthHeader1$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuth1$ {
  /** @deprecated use `LokiAuth1$inboundSchema` instead. */
  export const inboundSchema = LokiAuth1$inboundSchema;
  /** @deprecated use `LokiAuth1$outboundSchema` instead. */
  export const outboundSchema = LokiAuth1$outboundSchema;
  /** @deprecated use `LokiAuth1$Outbound` instead. */
  export type Outbound = LokiAuth1$Outbound;
}

export function lokiAuth1ToJSON(lokiAuth1: LokiAuth1): string {
  return JSON.stringify(LokiAuth1$outboundSchema.parse(lokiAuth1));
}

export function lokiAuth1FromJSON(
  jsonString: string,
): SafeParseResult<LokiAuth1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuth1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuth1' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMetadatum1$inboundSchema: z.ZodType<
  InputGrafanaMetadatum1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputGrafanaMetadatum1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputGrafanaMetadatum1$outboundSchema: z.ZodType<
  InputGrafanaMetadatum1$Outbound,
  z.ZodTypeDef,
  InputGrafanaMetadatum1
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMetadatum1$ {
  /** @deprecated use `InputGrafanaMetadatum1$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMetadatum1$inboundSchema;
  /** @deprecated use `InputGrafanaMetadatum1$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMetadatum1$outboundSchema;
  /** @deprecated use `InputGrafanaMetadatum1$Outbound` instead. */
  export type Outbound = InputGrafanaMetadatum1$Outbound;
}

export function inputGrafanaMetadatum1ToJSON(
  inputGrafanaMetadatum1: InputGrafanaMetadatum1,
): string {
  return JSON.stringify(
    InputGrafanaMetadatum1$outboundSchema.parse(inputGrafanaMetadatum1),
  );
}

export function inputGrafanaMetadatum1FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaMetadatum1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaMetadatum1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaMetadatum1' from JSON`,
  );
}

/** @internal */
export const InputGrafana1$inboundSchema: z.ZodType<
  InputGrafana1,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputGrafanaType1$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGrafanaConnection1$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputGrafanaPq1$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputGrafanaTLSSettingsServerSide1$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/api/prom/push"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  prometheusAuth: z.lazy(() => PrometheusAuth1$inboundSchema).optional(),
  lokiAuth: z.lazy(() => LokiAuth1$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputGrafanaMetadatum1$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputGrafana1$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputGrafanaConnection1$Outbound> | undefined;
  pq?: InputGrafanaPq1$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputGrafanaTLSSettingsServerSide1$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  prometheusAPI: string;
  lokiAPI: string;
  prometheusAuth?: PrometheusAuth1$Outbound | undefined;
  lokiAuth?: LokiAuth1$Outbound | undefined;
  metadata?: Array<InputGrafanaMetadatum1$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputGrafana1$outboundSchema: z.ZodType<
  InputGrafana1$Outbound,
  z.ZodTypeDef,
  InputGrafana1
> = z.object({
  id: z.string(),
  type: InputGrafanaType1$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGrafanaConnection1$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputGrafanaPq1$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputGrafanaTLSSettingsServerSide1$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/api/prom/push"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  prometheusAuth: z.lazy(() => PrometheusAuth1$outboundSchema).optional(),
  lokiAuth: z.lazy(() => LokiAuth1$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputGrafanaMetadatum1$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafana1$ {
  /** @deprecated use `InputGrafana1$inboundSchema` instead. */
  export const inboundSchema = InputGrafana1$inboundSchema;
  /** @deprecated use `InputGrafana1$outboundSchema` instead. */
  export const outboundSchema = InputGrafana1$outboundSchema;
  /** @deprecated use `InputGrafana1$Outbound` instead. */
  export type Outbound = InputGrafana1$Outbound;
}

export function inputGrafana1ToJSON(inputGrafana1: InputGrafana1): string {
  return JSON.stringify(InputGrafana1$outboundSchema.parse(inputGrafana1));
}

export function inputGrafana1FromJSON(
  jsonString: string,
): SafeParseResult<InputGrafana1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafana1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafana1' from JSON`,
  );
}

/** @internal */
export const InputGrafanaUnion$inboundSchema: z.ZodType<
  InputGrafanaUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputGrafana1$inboundSchema),
  z.lazy(() => InputGrafana2$inboundSchema),
]);

/** @internal */
export type InputGrafanaUnion$Outbound =
  | InputGrafana1$Outbound
  | InputGrafana2$Outbound;

/** @internal */
export const InputGrafanaUnion$outboundSchema: z.ZodType<
  InputGrafanaUnion$Outbound,
  z.ZodTypeDef,
  InputGrafanaUnion
> = z.union([
  z.lazy(() => InputGrafana1$outboundSchema),
  z.lazy(() => InputGrafana2$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaUnion$ {
  /** @deprecated use `InputGrafanaUnion$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaUnion$inboundSchema;
  /** @deprecated use `InputGrafanaUnion$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaUnion$outboundSchema;
  /** @deprecated use `InputGrafanaUnion$Outbound` instead. */
  export type Outbound = InputGrafanaUnion$Outbound;
}

export function inputGrafanaUnionToJSON(
  inputGrafanaUnion: InputGrafanaUnion,
): string {
  return JSON.stringify(
    InputGrafanaUnion$outboundSchema.parse(inputGrafanaUnion),
  );
}

export function inputGrafanaUnionFromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaUnion' from JSON`,
  );
}

/** @internal */
export const InputConfluentCloudType$inboundSchema: z.ZodType<
  InputConfluentCloudType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputConfluentCloudType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputConfluentCloudType$outboundSchema: z.ZodType<
  InputConfluentCloudType,
  z.ZodTypeDef,
  InputConfluentCloudType
> = z.union([
  z.nativeEnum(InputConfluentCloudType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudType$ {
  /** @deprecated use `InputConfluentCloudType$inboundSchema` instead. */
  export const inboundSchema = InputConfluentCloudType$inboundSchema;
  /** @deprecated use `InputConfluentCloudType$outboundSchema` instead. */
  export const outboundSchema = InputConfluentCloudType$outboundSchema;
}

/** @internal */
export const InputConfluentCloudConnection$inboundSchema: z.ZodType<
  InputConfluentCloudConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputConfluentCloudConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputConfluentCloudConnection$outboundSchema: z.ZodType<
  InputConfluentCloudConnection$Outbound,
  z.ZodTypeDef,
  InputConfluentCloudConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudConnection$ {
  /** @deprecated use `InputConfluentCloudConnection$inboundSchema` instead. */
  export const inboundSchema = InputConfluentCloudConnection$inboundSchema;
  /** @deprecated use `InputConfluentCloudConnection$outboundSchema` instead. */
  export const outboundSchema = InputConfluentCloudConnection$outboundSchema;
  /** @deprecated use `InputConfluentCloudConnection$Outbound` instead. */
  export type Outbound = InputConfluentCloudConnection$Outbound;
}

export function inputConfluentCloudConnectionToJSON(
  inputConfluentCloudConnection: InputConfluentCloudConnection,
): string {
  return JSON.stringify(
    InputConfluentCloudConnection$outboundSchema.parse(
      inputConfluentCloudConnection,
    ),
  );
}

export function inputConfluentCloudConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputConfluentCloudConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputConfluentCloudConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputConfluentCloudConnection' from JSON`,
  );
}

/** @internal */
export const InputConfluentCloudMode$inboundSchema: z.ZodType<
  InputConfluentCloudMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputConfluentCloudMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputConfluentCloudMode$outboundSchema: z.ZodType<
  InputConfluentCloudMode,
  z.ZodTypeDef,
  InputConfluentCloudMode
> = z.union([
  z.nativeEnum(InputConfluentCloudMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudMode$ {
  /** @deprecated use `InputConfluentCloudMode$inboundSchema` instead. */
  export const inboundSchema = InputConfluentCloudMode$inboundSchema;
  /** @deprecated use `InputConfluentCloudMode$outboundSchema` instead. */
  export const outboundSchema = InputConfluentCloudMode$outboundSchema;
}

/** @internal */
export const InputConfluentCloudCompression$inboundSchema: z.ZodType<
  InputConfluentCloudCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputConfluentCloudCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputConfluentCloudCompression$outboundSchema: z.ZodType<
  InputConfluentCloudCompression,
  z.ZodTypeDef,
  InputConfluentCloudCompression
> = z.union([
  z.nativeEnum(InputConfluentCloudCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudCompression$ {
  /** @deprecated use `InputConfluentCloudCompression$inboundSchema` instead. */
  export const inboundSchema = InputConfluentCloudCompression$inboundSchema;
  /** @deprecated use `InputConfluentCloudCompression$outboundSchema` instead. */
  export const outboundSchema = InputConfluentCloudCompression$outboundSchema;
}

/** @internal */
export const InputConfluentCloudPq$inboundSchema: z.ZodType<
  InputConfluentCloudPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputConfluentCloudMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputConfluentCloudCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputConfluentCloudPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputConfluentCloudPq$outboundSchema: z.ZodType<
  InputConfluentCloudPq$Outbound,
  z.ZodTypeDef,
  InputConfluentCloudPq
> = z.object({
  mode: InputConfluentCloudMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputConfluentCloudCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudPq$ {
  /** @deprecated use `InputConfluentCloudPq$inboundSchema` instead. */
  export const inboundSchema = InputConfluentCloudPq$inboundSchema;
  /** @deprecated use `InputConfluentCloudPq$outboundSchema` instead. */
  export const outboundSchema = InputConfluentCloudPq$outboundSchema;
  /** @deprecated use `InputConfluentCloudPq$Outbound` instead. */
  export type Outbound = InputConfluentCloudPq$Outbound;
}

export function inputConfluentCloudPqToJSON(
  inputConfluentCloudPq: InputConfluentCloudPq,
): string {
  return JSON.stringify(
    InputConfluentCloudPq$outboundSchema.parse(inputConfluentCloudPq),
  );
}

export function inputConfluentCloudPqFromJSON(
  jsonString: string,
): SafeParseResult<InputConfluentCloudPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputConfluentCloudPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputConfluentCloudPq' from JSON`,
  );
}

/** @internal */
export const InputConfluentCloudMinimumTLSVersion$inboundSchema: z.ZodType<
  InputConfluentCloudMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputConfluentCloudMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputConfluentCloudMinimumTLSVersion$outboundSchema: z.ZodType<
  InputConfluentCloudMinimumTLSVersion,
  z.ZodTypeDef,
  InputConfluentCloudMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputConfluentCloudMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudMinimumTLSVersion$ {
  /** @deprecated use `InputConfluentCloudMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputConfluentCloudMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputConfluentCloudMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputConfluentCloudMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputConfluentCloudMaximumTLSVersion$inboundSchema: z.ZodType<
  InputConfluentCloudMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputConfluentCloudMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputConfluentCloudMaximumTLSVersion$outboundSchema: z.ZodType<
  InputConfluentCloudMaximumTLSVersion,
  z.ZodTypeDef,
  InputConfluentCloudMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputConfluentCloudMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudMaximumTLSVersion$ {
  /** @deprecated use `InputConfluentCloudMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputConfluentCloudMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputConfluentCloudMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputConfluentCloudMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputConfluentCloudTLSSettingsClientSide$inboundSchema: z.ZodType<
  InputConfluentCloudTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: InputConfluentCloudMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputConfluentCloudMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputConfluentCloudTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputConfluentCloudTLSSettingsClientSide$outboundSchema: z.ZodType<
  InputConfluentCloudTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  InputConfluentCloudTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: InputConfluentCloudMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputConfluentCloudMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudTLSSettingsClientSide$ {
  /** @deprecated use `InputConfluentCloudTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    InputConfluentCloudTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `InputConfluentCloudTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    InputConfluentCloudTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `InputConfluentCloudTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = InputConfluentCloudTLSSettingsClientSide$Outbound;
}

export function inputConfluentCloudTLSSettingsClientSideToJSON(
  inputConfluentCloudTLSSettingsClientSide:
    InputConfluentCloudTLSSettingsClientSide,
): string {
  return JSON.stringify(
    InputConfluentCloudTLSSettingsClientSide$outboundSchema.parse(
      inputConfluentCloudTLSSettingsClientSide,
    ),
  );
}

export function inputConfluentCloudTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  InputConfluentCloudTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputConfluentCloudTLSSettingsClientSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputConfluentCloudTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const InputConfluentCloudAuth$inboundSchema: z.ZodType<
  InputConfluentCloudAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type InputConfluentCloudAuth$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputConfluentCloudAuth$outboundSchema: z.ZodType<
  InputConfluentCloudAuth$Outbound,
  z.ZodTypeDef,
  InputConfluentCloudAuth
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudAuth$ {
  /** @deprecated use `InputConfluentCloudAuth$inboundSchema` instead. */
  export const inboundSchema = InputConfluentCloudAuth$inboundSchema;
  /** @deprecated use `InputConfluentCloudAuth$outboundSchema` instead. */
  export const outboundSchema = InputConfluentCloudAuth$outboundSchema;
  /** @deprecated use `InputConfluentCloudAuth$Outbound` instead. */
  export type Outbound = InputConfluentCloudAuth$Outbound;
}

export function inputConfluentCloudAuthToJSON(
  inputConfluentCloudAuth: InputConfluentCloudAuth,
): string {
  return JSON.stringify(
    InputConfluentCloudAuth$outboundSchema.parse(inputConfluentCloudAuth),
  );
}

export function inputConfluentCloudAuthFromJSON(
  jsonString: string,
): SafeParseResult<InputConfluentCloudAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputConfluentCloudAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputConfluentCloudAuth' from JSON`,
  );
}

/** @internal */
export const InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$inboundSchema:
  z.ZodType<
    InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$outboundSchema:
  z.ZodType<
    InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion
  > = z.union([
    z.nativeEnum(InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$ {
  /** @deprecated use `InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$inboundSchema:
  z.ZodType<
    InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$outboundSchema:
  z.ZodType<
    InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion
  > = z.union([
    z.nativeEnum(InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$ {
  /** @deprecated use `InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema:
  z.ZodType<
    InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$inboundSchema
        .optional(),
    maxVersion:
      InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$inboundSchema
        .optional(),
  });

/** @internal */
export type InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$Outbound =
  {
    disabled: boolean;
    rejectUnauthorized: boolean;
    servername?: string | undefined;
    certificateName?: string | undefined;
    caPath?: string | undefined;
    privKeyPath?: string | undefined;
    certPath?: string | undefined;
    passphrase?: string | undefined;
    minVersion?: string | undefined;
    maxVersion?: string | undefined;
  };

/** @internal */
export const InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema:
  z.ZodType<
    InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$Outbound,
    z.ZodTypeDef,
    InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion:
      InputConfluentCloudKafkaSchemaRegistryMinimumTLSVersion$outboundSchema
        .optional(),
    maxVersion:
      InputConfluentCloudKafkaSchemaRegistryMaximumTLSVersion$outboundSchema
        .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$ {
  /** @deprecated use `InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$Outbound` instead. */
  export type Outbound =
    InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$Outbound;
}

export function inputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSideToJSON(
  inputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide:
    InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide,
): string {
  return JSON.stringify(
    InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema
      .parse(inputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide),
  );
}

export function inputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const InputConfluentCloudKafkaSchemaRegistryAuthentication$inboundSchema:
  z.ZodType<
    InputConfluentCloudKafkaSchemaRegistryAuthentication,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => InputConfluentCloudAuth$inboundSchema).optional(),
    tls: z.lazy(() =>
      InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema
    ).optional(),
  });

/** @internal */
export type InputConfluentCloudKafkaSchemaRegistryAuthentication$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: InputConfluentCloudAuth$Outbound | undefined;
  tls?:
    | InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$Outbound
    | undefined;
};

/** @internal */
export const InputConfluentCloudKafkaSchemaRegistryAuthentication$outboundSchema:
  z.ZodType<
    InputConfluentCloudKafkaSchemaRegistryAuthentication$Outbound,
    z.ZodTypeDef,
    InputConfluentCloudKafkaSchemaRegistryAuthentication
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => InputConfluentCloudAuth$outboundSchema).optional(),
    tls: z.lazy(() =>
      InputConfluentCloudKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema
    ).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudKafkaSchemaRegistryAuthentication$ {
  /** @deprecated use `InputConfluentCloudKafkaSchemaRegistryAuthentication$inboundSchema` instead. */
  export const inboundSchema =
    InputConfluentCloudKafkaSchemaRegistryAuthentication$inboundSchema;
  /** @deprecated use `InputConfluentCloudKafkaSchemaRegistryAuthentication$outboundSchema` instead. */
  export const outboundSchema =
    InputConfluentCloudKafkaSchemaRegistryAuthentication$outboundSchema;
  /** @deprecated use `InputConfluentCloudKafkaSchemaRegistryAuthentication$Outbound` instead. */
  export type Outbound =
    InputConfluentCloudKafkaSchemaRegistryAuthentication$Outbound;
}

export function inputConfluentCloudKafkaSchemaRegistryAuthenticationToJSON(
  inputConfluentCloudKafkaSchemaRegistryAuthentication:
    InputConfluentCloudKafkaSchemaRegistryAuthentication,
): string {
  return JSON.stringify(
    InputConfluentCloudKafkaSchemaRegistryAuthentication$outboundSchema.parse(
      inputConfluentCloudKafkaSchemaRegistryAuthentication,
    ),
  );
}

export function inputConfluentCloudKafkaSchemaRegistryAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<
  InputConfluentCloudKafkaSchemaRegistryAuthentication,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputConfluentCloudKafkaSchemaRegistryAuthentication$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputConfluentCloudKafkaSchemaRegistryAuthentication' from JSON`,
  );
}

/** @internal */
export const InputConfluentCloudSASLMechanism$inboundSchema: z.ZodType<
  InputConfluentCloudSASLMechanism,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputConfluentCloudSASLMechanism),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputConfluentCloudSASLMechanism$outboundSchema: z.ZodType<
  InputConfluentCloudSASLMechanism,
  z.ZodTypeDef,
  InputConfluentCloudSASLMechanism
> = z.union([
  z.nativeEnum(InputConfluentCloudSASLMechanism),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudSASLMechanism$ {
  /** @deprecated use `InputConfluentCloudSASLMechanism$inboundSchema` instead. */
  export const inboundSchema = InputConfluentCloudSASLMechanism$inboundSchema;
  /** @deprecated use `InputConfluentCloudSASLMechanism$outboundSchema` instead. */
  export const outboundSchema = InputConfluentCloudSASLMechanism$outboundSchema;
}

/** @internal */
export const InputConfluentCloudAuthentication$inboundSchema: z.ZodType<
  InputConfluentCloudAuthentication,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: InputConfluentCloudSASLMechanism$inboundSchema.default("plain"),
});

/** @internal */
export type InputConfluentCloudAuthentication$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const InputConfluentCloudAuthentication$outboundSchema: z.ZodType<
  InputConfluentCloudAuthentication$Outbound,
  z.ZodTypeDef,
  InputConfluentCloudAuthentication
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: InputConfluentCloudSASLMechanism$outboundSchema.default("plain"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudAuthentication$ {
  /** @deprecated use `InputConfluentCloudAuthentication$inboundSchema` instead. */
  export const inboundSchema = InputConfluentCloudAuthentication$inboundSchema;
  /** @deprecated use `InputConfluentCloudAuthentication$outboundSchema` instead. */
  export const outboundSchema =
    InputConfluentCloudAuthentication$outboundSchema;
  /** @deprecated use `InputConfluentCloudAuthentication$Outbound` instead. */
  export type Outbound = InputConfluentCloudAuthentication$Outbound;
}

export function inputConfluentCloudAuthenticationToJSON(
  inputConfluentCloudAuthentication: InputConfluentCloudAuthentication,
): string {
  return JSON.stringify(
    InputConfluentCloudAuthentication$outboundSchema.parse(
      inputConfluentCloudAuthentication,
    ),
  );
}

export function inputConfluentCloudAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<InputConfluentCloudAuthentication, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputConfluentCloudAuthentication$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputConfluentCloudAuthentication' from JSON`,
  );
}

/** @internal */
export const InputConfluentCloudMetadatum$inboundSchema: z.ZodType<
  InputConfluentCloudMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputConfluentCloudMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputConfluentCloudMetadatum$outboundSchema: z.ZodType<
  InputConfluentCloudMetadatum$Outbound,
  z.ZodTypeDef,
  InputConfluentCloudMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloudMetadatum$ {
  /** @deprecated use `InputConfluentCloudMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputConfluentCloudMetadatum$inboundSchema;
  /** @deprecated use `InputConfluentCloudMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputConfluentCloudMetadatum$outboundSchema;
  /** @deprecated use `InputConfluentCloudMetadatum$Outbound` instead. */
  export type Outbound = InputConfluentCloudMetadatum$Outbound;
}

export function inputConfluentCloudMetadatumToJSON(
  inputConfluentCloudMetadatum: InputConfluentCloudMetadatum,
): string {
  return JSON.stringify(
    InputConfluentCloudMetadatum$outboundSchema.parse(
      inputConfluentCloudMetadatum,
    ),
  );
}

export function inputConfluentCloudMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputConfluentCloudMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputConfluentCloudMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputConfluentCloudMetadatum' from JSON`,
  );
}

/** @internal */
export const InputConfluentCloud$inboundSchema: z.ZodType<
  InputConfluentCloud,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputConfluentCloudType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputConfluentCloudConnection$inboundSchema),
  ).optional(),
  pq: z.lazy(() => InputConfluentCloudPq$inboundSchema).optional(),
  brokers: z.array(z.string()),
  tls: z.lazy(() => InputConfluentCloudTLSSettingsClientSide$inboundSchema)
    .optional(),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  kafkaSchemaRegistry: z.lazy(() =>
    InputConfluentCloudKafkaSchemaRegistryAuthentication$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => InputConfluentCloudAuthentication$inboundSchema)
    .optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  metadata: z.array(z.lazy(() => InputConfluentCloudMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputConfluentCloud$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputConfluentCloudConnection$Outbound> | undefined;
  pq?: InputConfluentCloudPq$Outbound | undefined;
  brokers: Array<string>;
  tls?: InputConfluentCloudTLSSettingsClientSide$Outbound | undefined;
  topics: Array<string>;
  groupId: string;
  fromBeginning: boolean;
  kafkaSchemaRegistry?:
    | InputConfluentCloudKafkaSchemaRegistryAuthentication$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: InputConfluentCloudAuthentication$Outbound | undefined;
  sessionTimeout: number;
  rebalanceTimeout: number;
  heartbeatInterval: number;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition: number;
  maxBytes: number;
  maxSocketErrors: number;
  metadata?: Array<InputConfluentCloudMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputConfluentCloud$outboundSchema: z.ZodType<
  InputConfluentCloud$Outbound,
  z.ZodTypeDef,
  InputConfluentCloud
> = z.object({
  id: z.string(),
  type: InputConfluentCloudType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputConfluentCloudConnection$outboundSchema),
  ).optional(),
  pq: z.lazy(() => InputConfluentCloudPq$outboundSchema).optional(),
  brokers: z.array(z.string()),
  tls: z.lazy(() => InputConfluentCloudTLSSettingsClientSide$outboundSchema)
    .optional(),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  kafkaSchemaRegistry: z.lazy(() =>
    InputConfluentCloudKafkaSchemaRegistryAuthentication$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => InputConfluentCloudAuthentication$outboundSchema)
    .optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  metadata: z.array(z.lazy(() => InputConfluentCloudMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputConfluentCloud$ {
  /** @deprecated use `InputConfluentCloud$inboundSchema` instead. */
  export const inboundSchema = InputConfluentCloud$inboundSchema;
  /** @deprecated use `InputConfluentCloud$outboundSchema` instead. */
  export const outboundSchema = InputConfluentCloud$outboundSchema;
  /** @deprecated use `InputConfluentCloud$Outbound` instead. */
  export type Outbound = InputConfluentCloud$Outbound;
}

export function inputConfluentCloudToJSON(
  inputConfluentCloud: InputConfluentCloud,
): string {
  return JSON.stringify(
    InputConfluentCloud$outboundSchema.parse(inputConfluentCloud),
  );
}

export function inputConfluentCloudFromJSON(
  jsonString: string,
): SafeParseResult<InputConfluentCloud, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputConfluentCloud$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputConfluentCloud' from JSON`,
  );
}

/** @internal */
export const InputElasticType$inboundSchema: z.ZodType<
  InputElasticType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputElasticType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputElasticType$outboundSchema: z.ZodType<
  InputElasticType,
  z.ZodTypeDef,
  InputElasticType
> = z.union([
  z.nativeEnum(InputElasticType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticType$ {
  /** @deprecated use `InputElasticType$inboundSchema` instead. */
  export const inboundSchema = InputElasticType$inboundSchema;
  /** @deprecated use `InputElasticType$outboundSchema` instead. */
  export const outboundSchema = InputElasticType$outboundSchema;
}

/** @internal */
export const InputElasticConnection$inboundSchema: z.ZodType<
  InputElasticConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputElasticConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputElasticConnection$outboundSchema: z.ZodType<
  InputElasticConnection$Outbound,
  z.ZodTypeDef,
  InputElasticConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticConnection$ {
  /** @deprecated use `InputElasticConnection$inboundSchema` instead. */
  export const inboundSchema = InputElasticConnection$inboundSchema;
  /** @deprecated use `InputElasticConnection$outboundSchema` instead. */
  export const outboundSchema = InputElasticConnection$outboundSchema;
  /** @deprecated use `InputElasticConnection$Outbound` instead. */
  export type Outbound = InputElasticConnection$Outbound;
}

export function inputElasticConnectionToJSON(
  inputElasticConnection: InputElasticConnection,
): string {
  return JSON.stringify(
    InputElasticConnection$outboundSchema.parse(inputElasticConnection),
  );
}

export function inputElasticConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputElasticConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputElasticConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputElasticConnection' from JSON`,
  );
}

/** @internal */
export const InputElasticMode$inboundSchema: z.ZodType<
  InputElasticMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputElasticMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputElasticMode$outboundSchema: z.ZodType<
  InputElasticMode,
  z.ZodTypeDef,
  InputElasticMode
> = z.union([
  z.nativeEnum(InputElasticMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticMode$ {
  /** @deprecated use `InputElasticMode$inboundSchema` instead. */
  export const inboundSchema = InputElasticMode$inboundSchema;
  /** @deprecated use `InputElasticMode$outboundSchema` instead. */
  export const outboundSchema = InputElasticMode$outboundSchema;
}

/** @internal */
export const InputElasticCompression$inboundSchema: z.ZodType<
  InputElasticCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputElasticCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputElasticCompression$outboundSchema: z.ZodType<
  InputElasticCompression,
  z.ZodTypeDef,
  InputElasticCompression
> = z.union([
  z.nativeEnum(InputElasticCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticCompression$ {
  /** @deprecated use `InputElasticCompression$inboundSchema` instead. */
  export const inboundSchema = InputElasticCompression$inboundSchema;
  /** @deprecated use `InputElasticCompression$outboundSchema` instead. */
  export const outboundSchema = InputElasticCompression$outboundSchema;
}

/** @internal */
export const InputElasticPq$inboundSchema: z.ZodType<
  InputElasticPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputElasticMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputElasticCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputElasticPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputElasticPq$outboundSchema: z.ZodType<
  InputElasticPq$Outbound,
  z.ZodTypeDef,
  InputElasticPq
> = z.object({
  mode: InputElasticMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputElasticCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticPq$ {
  /** @deprecated use `InputElasticPq$inboundSchema` instead. */
  export const inboundSchema = InputElasticPq$inboundSchema;
  /** @deprecated use `InputElasticPq$outboundSchema` instead. */
  export const outboundSchema = InputElasticPq$outboundSchema;
  /** @deprecated use `InputElasticPq$Outbound` instead. */
  export type Outbound = InputElasticPq$Outbound;
}

export function inputElasticPqToJSON(inputElasticPq: InputElasticPq): string {
  return JSON.stringify(InputElasticPq$outboundSchema.parse(inputElasticPq));
}

export function inputElasticPqFromJSON(
  jsonString: string,
): SafeParseResult<InputElasticPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputElasticPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputElasticPq' from JSON`,
  );
}

/** @internal */
export const InputElasticMinimumTLSVersion$inboundSchema: z.ZodType<
  InputElasticMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputElasticMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputElasticMinimumTLSVersion$outboundSchema: z.ZodType<
  InputElasticMinimumTLSVersion,
  z.ZodTypeDef,
  InputElasticMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputElasticMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticMinimumTLSVersion$ {
  /** @deprecated use `InputElasticMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputElasticMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputElasticMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputElasticMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputElasticMaximumTLSVersion$inboundSchema: z.ZodType<
  InputElasticMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputElasticMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputElasticMaximumTLSVersion$outboundSchema: z.ZodType<
  InputElasticMaximumTLSVersion,
  z.ZodTypeDef,
  InputElasticMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputElasticMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticMaximumTLSVersion$ {
  /** @deprecated use `InputElasticMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputElasticMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputElasticMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputElasticMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputElasticTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputElasticTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputElasticMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputElasticMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputElasticTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputElasticTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputElasticTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputElasticTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputElasticMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputElasticMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticTLSSettingsServerSide$ {
  /** @deprecated use `InputElasticTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputElasticTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputElasticTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputElasticTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputElasticTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputElasticTLSSettingsServerSide$Outbound;
}

export function inputElasticTLSSettingsServerSideToJSON(
  inputElasticTLSSettingsServerSide: InputElasticTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputElasticTLSSettingsServerSide$outboundSchema.parse(
      inputElasticTLSSettingsServerSide,
    ),
  );
}

export function inputElasticTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputElasticTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputElasticTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputElasticTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputElasticAuthenticationType$inboundSchema: z.ZodType<
  InputElasticAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputElasticAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputElasticAuthenticationType$outboundSchema: z.ZodType<
  InputElasticAuthenticationType,
  z.ZodTypeDef,
  InputElasticAuthenticationType
> = z.union([
  z.nativeEnum(InputElasticAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticAuthenticationType$ {
  /** @deprecated use `InputElasticAuthenticationType$inboundSchema` instead. */
  export const inboundSchema = InputElasticAuthenticationType$inboundSchema;
  /** @deprecated use `InputElasticAuthenticationType$outboundSchema` instead. */
  export const outboundSchema = InputElasticAuthenticationType$outboundSchema;
}

/** @internal */
export const CreateInputAPIVersion$inboundSchema: z.ZodType<
  CreateInputAPIVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CreateInputAPIVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CreateInputAPIVersion$outboundSchema: z.ZodType<
  CreateInputAPIVersion,
  z.ZodTypeDef,
  CreateInputAPIVersion
> = z.union([
  z.nativeEnum(CreateInputAPIVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputAPIVersion$ {
  /** @deprecated use `CreateInputAPIVersion$inboundSchema` instead. */
  export const inboundSchema = CreateInputAPIVersion$inboundSchema;
  /** @deprecated use `CreateInputAPIVersion$outboundSchema` instead. */
  export const outboundSchema = CreateInputAPIVersion$outboundSchema;
}

/** @internal */
export const CreateInputExtraHttpHeader$inboundSchema: z.ZodType<
  CreateInputExtraHttpHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/** @internal */
export type CreateInputExtraHttpHeader$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const CreateInputExtraHttpHeader$outboundSchema: z.ZodType<
  CreateInputExtraHttpHeader$Outbound,
  z.ZodTypeDef,
  CreateInputExtraHttpHeader
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputExtraHttpHeader$ {
  /** @deprecated use `CreateInputExtraHttpHeader$inboundSchema` instead. */
  export const inboundSchema = CreateInputExtraHttpHeader$inboundSchema;
  /** @deprecated use `CreateInputExtraHttpHeader$outboundSchema` instead. */
  export const outboundSchema = CreateInputExtraHttpHeader$outboundSchema;
  /** @deprecated use `CreateInputExtraHttpHeader$Outbound` instead. */
  export type Outbound = CreateInputExtraHttpHeader$Outbound;
}

export function createInputExtraHttpHeaderToJSON(
  createInputExtraHttpHeader: CreateInputExtraHttpHeader,
): string {
  return JSON.stringify(
    CreateInputExtraHttpHeader$outboundSchema.parse(createInputExtraHttpHeader),
  );
}

export function createInputExtraHttpHeaderFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputExtraHttpHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputExtraHttpHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputExtraHttpHeader' from JSON`,
  );
}

/** @internal */
export const InputElasticMetadatum$inboundSchema: z.ZodType<
  InputElasticMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputElasticMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputElasticMetadatum$outboundSchema: z.ZodType<
  InputElasticMetadatum$Outbound,
  z.ZodTypeDef,
  InputElasticMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticMetadatum$ {
  /** @deprecated use `InputElasticMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputElasticMetadatum$inboundSchema;
  /** @deprecated use `InputElasticMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputElasticMetadatum$outboundSchema;
  /** @deprecated use `InputElasticMetadatum$Outbound` instead. */
  export type Outbound = InputElasticMetadatum$Outbound;
}

export function inputElasticMetadatumToJSON(
  inputElasticMetadatum: InputElasticMetadatum,
): string {
  return JSON.stringify(
    InputElasticMetadatum$outboundSchema.parse(inputElasticMetadatum),
  );
}

export function inputElasticMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputElasticMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputElasticMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputElasticMetadatum' from JSON`,
  );
}

/** @internal */
export const InputElasticAuthenticationMethod$inboundSchema: z.ZodType<
  InputElasticAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputElasticAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputElasticAuthenticationMethod$outboundSchema: z.ZodType<
  InputElasticAuthenticationMethod,
  z.ZodTypeDef,
  InputElasticAuthenticationMethod
> = z.union([
  z.nativeEnum(InputElasticAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticAuthenticationMethod$ {
  /** @deprecated use `InputElasticAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputElasticAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputElasticAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = InputElasticAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputElasticProxyMode$inboundSchema: z.ZodType<
  InputElasticProxyMode,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().default(false),
  url: z.string().optional(),
  rejectUnauthorized: z.boolean().default(false),
  removeHeaders: z.array(z.string()).optional(),
  timeoutSec: z.number().default(60),
  authType: InputElasticAuthenticationMethod$inboundSchema.default("none"),
});

/** @internal */
export type InputElasticProxyMode$Outbound = {
  enabled: boolean;
  url?: string | undefined;
  rejectUnauthorized: boolean;
  removeHeaders?: Array<string> | undefined;
  timeoutSec: number;
  authType: string;
};

/** @internal */
export const InputElasticProxyMode$outboundSchema: z.ZodType<
  InputElasticProxyMode$Outbound,
  z.ZodTypeDef,
  InputElasticProxyMode
> = z.object({
  enabled: z.boolean().default(false),
  url: z.string().optional(),
  rejectUnauthorized: z.boolean().default(false),
  removeHeaders: z.array(z.string()).optional(),
  timeoutSec: z.number().default(60),
  authType: InputElasticAuthenticationMethod$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElasticProxyMode$ {
  /** @deprecated use `InputElasticProxyMode$inboundSchema` instead. */
  export const inboundSchema = InputElasticProxyMode$inboundSchema;
  /** @deprecated use `InputElasticProxyMode$outboundSchema` instead. */
  export const outboundSchema = InputElasticProxyMode$outboundSchema;
  /** @deprecated use `InputElasticProxyMode$Outbound` instead. */
  export type Outbound = InputElasticProxyMode$Outbound;
}

export function inputElasticProxyModeToJSON(
  inputElasticProxyMode: InputElasticProxyMode,
): string {
  return JSON.stringify(
    InputElasticProxyMode$outboundSchema.parse(inputElasticProxyMode),
  );
}

export function inputElasticProxyModeFromJSON(
  jsonString: string,
): SafeParseResult<InputElasticProxyMode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputElasticProxyMode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputElasticProxyMode' from JSON`,
  );
}

/** @internal */
export const InputElastic$inboundSchema: z.ZodType<
  InputElastic,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputElasticType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputElasticConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputElasticPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputElasticTLSSettingsServerSide$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  elasticAPI: z.string().default("/"),
  authType: InputElasticAuthenticationType$inboundSchema.default("none"),
  apiVersion: CreateInputAPIVersion$inboundSchema.default("8.3.2"),
  extraHttpHeaders: z.array(
    z.lazy(() => CreateInputExtraHttpHeader$inboundSchema),
  ).optional(),
  metadata: z.array(z.lazy(() => InputElasticMetadatum$inboundSchema))
    .optional(),
  proxyMode: z.lazy(() => InputElasticProxyMode$inboundSchema).optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  authTokens: z.array(z.string()).optional(),
  customAPIVersion: z.string().default(
    "{\n    \"name\": \"AzU84iL\",\n    \"cluster_name\": \"cribl\",\n    \"cluster_uuid\": \"Js6_Z2VKS3KbfRSxPmPbaw\",\n    \"version\": {\n        \"number\": \"8.3.2\",\n        \"build_type\": \"tar\",\n        \"build_hash\": \"bca0c8d\",\n        \"build_date\": \"2019-10-16T06:19:49.319352Z\",\n        \"build_snapshot\": false,\n        \"lucene_version\": \"9.7.2\",\n        \"minimum_wire_compatibility_version\": \"7.17.0\",\n        \"minimum_index_compatibility_version\": \"7.0.0\"\n    },\n    \"tagline\": \"You Know, for Search\"\n}",
  ),
});

/** @internal */
export type InputElastic$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputElasticConnection$Outbound> | undefined;
  pq?: InputElasticPq$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputElasticTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  elasticAPI: string;
  authType: string;
  apiVersion: string;
  extraHttpHeaders?: Array<CreateInputExtraHttpHeader$Outbound> | undefined;
  metadata?: Array<InputElasticMetadatum$Outbound> | undefined;
  proxyMode?: InputElasticProxyMode$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  authTokens?: Array<string> | undefined;
  customAPIVersion: string;
};

/** @internal */
export const InputElastic$outboundSchema: z.ZodType<
  InputElastic$Outbound,
  z.ZodTypeDef,
  InputElastic
> = z.object({
  id: z.string(),
  type: InputElasticType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputElasticConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputElasticPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputElasticTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  elasticAPI: z.string().default("/"),
  authType: InputElasticAuthenticationType$outboundSchema.default("none"),
  apiVersion: CreateInputAPIVersion$outboundSchema.default("8.3.2"),
  extraHttpHeaders: z.array(
    z.lazy(() => CreateInputExtraHttpHeader$outboundSchema),
  ).optional(),
  metadata: z.array(z.lazy(() => InputElasticMetadatum$outboundSchema))
    .optional(),
  proxyMode: z.lazy(() => InputElasticProxyMode$outboundSchema).optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  authTokens: z.array(z.string()).optional(),
  customAPIVersion: z.string().default(
    "{\n    \"name\": \"AzU84iL\",\n    \"cluster_name\": \"cribl\",\n    \"cluster_uuid\": \"Js6_Z2VKS3KbfRSxPmPbaw\",\n    \"version\": {\n        \"number\": \"8.3.2\",\n        \"build_type\": \"tar\",\n        \"build_hash\": \"bca0c8d\",\n        \"build_date\": \"2019-10-16T06:19:49.319352Z\",\n        \"build_snapshot\": false,\n        \"lucene_version\": \"9.7.2\",\n        \"minimum_wire_compatibility_version\": \"7.17.0\",\n        \"minimum_index_compatibility_version\": \"7.0.0\"\n    },\n    \"tagline\": \"You Know, for Search\"\n}",
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputElastic$ {
  /** @deprecated use `InputElastic$inboundSchema` instead. */
  export const inboundSchema = InputElastic$inboundSchema;
  /** @deprecated use `InputElastic$outboundSchema` instead. */
  export const outboundSchema = InputElastic$outboundSchema;
  /** @deprecated use `InputElastic$Outbound` instead. */
  export type Outbound = InputElastic$Outbound;
}

export function inputElasticToJSON(inputElastic: InputElastic): string {
  return JSON.stringify(InputElastic$outboundSchema.parse(inputElastic));
}

export function inputElasticFromJSON(
  jsonString: string,
): SafeParseResult<InputElastic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputElastic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputElastic' from JSON`,
  );
}

/** @internal */
export const InputAzureBlobType$inboundSchema: z.ZodType<
  InputAzureBlobType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputAzureBlobType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputAzureBlobType$outboundSchema: z.ZodType<
  InputAzureBlobType,
  z.ZodTypeDef,
  InputAzureBlobType
> = z.union([
  z.nativeEnum(InputAzureBlobType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputAzureBlobType$ {
  /** @deprecated use `InputAzureBlobType$inboundSchema` instead. */
  export const inboundSchema = InputAzureBlobType$inboundSchema;
  /** @deprecated use `InputAzureBlobType$outboundSchema` instead. */
  export const outboundSchema = InputAzureBlobType$outboundSchema;
}

/** @internal */
export const InputAzureBlobConnection$inboundSchema: z.ZodType<
  InputAzureBlobConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputAzureBlobConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputAzureBlobConnection$outboundSchema: z.ZodType<
  InputAzureBlobConnection$Outbound,
  z.ZodTypeDef,
  InputAzureBlobConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputAzureBlobConnection$ {
  /** @deprecated use `InputAzureBlobConnection$inboundSchema` instead. */
  export const inboundSchema = InputAzureBlobConnection$inboundSchema;
  /** @deprecated use `InputAzureBlobConnection$outboundSchema` instead. */
  export const outboundSchema = InputAzureBlobConnection$outboundSchema;
  /** @deprecated use `InputAzureBlobConnection$Outbound` instead. */
  export type Outbound = InputAzureBlobConnection$Outbound;
}

export function inputAzureBlobConnectionToJSON(
  inputAzureBlobConnection: InputAzureBlobConnection,
): string {
  return JSON.stringify(
    InputAzureBlobConnection$outboundSchema.parse(inputAzureBlobConnection),
  );
}

export function inputAzureBlobConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputAzureBlobConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAzureBlobConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAzureBlobConnection' from JSON`,
  );
}

/** @internal */
export const InputAzureBlobMode$inboundSchema: z.ZodType<
  InputAzureBlobMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputAzureBlobMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputAzureBlobMode$outboundSchema: z.ZodType<
  InputAzureBlobMode,
  z.ZodTypeDef,
  InputAzureBlobMode
> = z.union([
  z.nativeEnum(InputAzureBlobMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputAzureBlobMode$ {
  /** @deprecated use `InputAzureBlobMode$inboundSchema` instead. */
  export const inboundSchema = InputAzureBlobMode$inboundSchema;
  /** @deprecated use `InputAzureBlobMode$outboundSchema` instead. */
  export const outboundSchema = InputAzureBlobMode$outboundSchema;
}

/** @internal */
export const InputAzureBlobCompression$inboundSchema: z.ZodType<
  InputAzureBlobCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputAzureBlobCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputAzureBlobCompression$outboundSchema: z.ZodType<
  InputAzureBlobCompression,
  z.ZodTypeDef,
  InputAzureBlobCompression
> = z.union([
  z.nativeEnum(InputAzureBlobCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputAzureBlobCompression$ {
  /** @deprecated use `InputAzureBlobCompression$inboundSchema` instead. */
  export const inboundSchema = InputAzureBlobCompression$inboundSchema;
  /** @deprecated use `InputAzureBlobCompression$outboundSchema` instead. */
  export const outboundSchema = InputAzureBlobCompression$outboundSchema;
}

/** @internal */
export const InputAzureBlobPq$inboundSchema: z.ZodType<
  InputAzureBlobPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputAzureBlobMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputAzureBlobCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputAzureBlobPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputAzureBlobPq$outboundSchema: z.ZodType<
  InputAzureBlobPq$Outbound,
  z.ZodTypeDef,
  InputAzureBlobPq
> = z.object({
  mode: InputAzureBlobMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputAzureBlobCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputAzureBlobPq$ {
  /** @deprecated use `InputAzureBlobPq$inboundSchema` instead. */
  export const inboundSchema = InputAzureBlobPq$inboundSchema;
  /** @deprecated use `InputAzureBlobPq$outboundSchema` instead. */
  export const outboundSchema = InputAzureBlobPq$outboundSchema;
  /** @deprecated use `InputAzureBlobPq$Outbound` instead. */
  export type Outbound = InputAzureBlobPq$Outbound;
}

export function inputAzureBlobPqToJSON(
  inputAzureBlobPq: InputAzureBlobPq,
): string {
  return JSON.stringify(
    InputAzureBlobPq$outboundSchema.parse(inputAzureBlobPq),
  );
}

export function inputAzureBlobPqFromJSON(
  jsonString: string,
): SafeParseResult<InputAzureBlobPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAzureBlobPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAzureBlobPq' from JSON`,
  );
}

/** @internal */
export const InputAzureBlobMetadatum$inboundSchema: z.ZodType<
  InputAzureBlobMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputAzureBlobMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputAzureBlobMetadatum$outboundSchema: z.ZodType<
  InputAzureBlobMetadatum$Outbound,
  z.ZodTypeDef,
  InputAzureBlobMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputAzureBlobMetadatum$ {
  /** @deprecated use `InputAzureBlobMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputAzureBlobMetadatum$inboundSchema;
  /** @deprecated use `InputAzureBlobMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputAzureBlobMetadatum$outboundSchema;
  /** @deprecated use `InputAzureBlobMetadatum$Outbound` instead. */
  export type Outbound = InputAzureBlobMetadatum$Outbound;
}

export function inputAzureBlobMetadatumToJSON(
  inputAzureBlobMetadatum: InputAzureBlobMetadatum,
): string {
  return JSON.stringify(
    InputAzureBlobMetadatum$outboundSchema.parse(inputAzureBlobMetadatum),
  );
}

export function inputAzureBlobMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputAzureBlobMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAzureBlobMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAzureBlobMetadatum' from JSON`,
  );
}

/** @internal */
export const InputAzureBlobAuthenticationMethod$inboundSchema: z.ZodType<
  InputAzureBlobAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputAzureBlobAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputAzureBlobAuthenticationMethod$outboundSchema: z.ZodType<
  InputAzureBlobAuthenticationMethod,
  z.ZodTypeDef,
  InputAzureBlobAuthenticationMethod
> = z.union([
  z.nativeEnum(InputAzureBlobAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputAzureBlobAuthenticationMethod$ {
  /** @deprecated use `InputAzureBlobAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputAzureBlobAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputAzureBlobAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputAzureBlobAuthenticationMethod$outboundSchema;
}

/** @internal */
export const CreateInputCertificate$inboundSchema: z.ZodType<
  CreateInputCertificate,
  z.ZodTypeDef,
  unknown
> = z.object({
  certificateName: z.string(),
});

/** @internal */
export type CreateInputCertificate$Outbound = {
  certificateName: string;
};

/** @internal */
export const CreateInputCertificate$outboundSchema: z.ZodType<
  CreateInputCertificate$Outbound,
  z.ZodTypeDef,
  CreateInputCertificate
> = z.object({
  certificateName: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputCertificate$ {
  /** @deprecated use `CreateInputCertificate$inboundSchema` instead. */
  export const inboundSchema = CreateInputCertificate$inboundSchema;
  /** @deprecated use `CreateInputCertificate$outboundSchema` instead. */
  export const outboundSchema = CreateInputCertificate$outboundSchema;
  /** @deprecated use `CreateInputCertificate$Outbound` instead. */
  export type Outbound = CreateInputCertificate$Outbound;
}

export function createInputCertificateToJSON(
  createInputCertificate: CreateInputCertificate,
): string {
  return JSON.stringify(
    CreateInputCertificate$outboundSchema.parse(createInputCertificate),
  );
}

export function createInputCertificateFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputCertificate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputCertificate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputCertificate' from JSON`,
  );
}

/** @internal */
export const InputAzureBlob$inboundSchema: z.ZodType<
  InputAzureBlob,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputAzureBlobType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputAzureBlobConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputAzureBlobPq$inboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  maxMessages: z.number().default(1),
  servicePeriodSecs: z.number().default(5),
  skipOnError: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputAzureBlobMetadatum$inboundSchema))
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  authType: InputAzureBlobAuthenticationMethod$inboundSchema.default("manual"),
  description: z.string().optional(),
  connectionString: z.string().optional(),
  textSecret: z.string().optional(),
  storageAccountName: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  clientTextSecret: z.string().optional(),
  certificate: z.lazy(() => CreateInputCertificate$inboundSchema).optional(),
});

/** @internal */
export type InputAzureBlob$Outbound = {
  id: string;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputAzureBlobConnection$Outbound> | undefined;
  pq?: InputAzureBlobPq$Outbound | undefined;
  queueName: string;
  fileFilter: string;
  visibilityTimeout: number;
  numReceivers: number;
  maxMessages: number;
  servicePeriodSecs: number;
  skipOnError: boolean;
  metadata?: Array<InputAzureBlobMetadatum$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  parquetChunkSizeMB: number;
  parquetChunkDownloadTimeout: number;
  authType: string;
  description?: string | undefined;
  connectionString?: string | undefined;
  textSecret?: string | undefined;
  storageAccountName?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  azureCloud?: string | undefined;
  endpointSuffix?: string | undefined;
  clientTextSecret?: string | undefined;
  certificate?: CreateInputCertificate$Outbound | undefined;
};

/** @internal */
export const InputAzureBlob$outboundSchema: z.ZodType<
  InputAzureBlob$Outbound,
  z.ZodTypeDef,
  InputAzureBlob
> = z.object({
  id: z.string(),
  type: InputAzureBlobType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputAzureBlobConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputAzureBlobPq$outboundSchema).optional(),
  queueName: z.string(),
  fileFilter: z.string().default("/.*/"),
  visibilityTimeout: z.number().default(600),
  numReceivers: z.number().default(1),
  maxMessages: z.number().default(1),
  servicePeriodSecs: z.number().default(5),
  skipOnError: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputAzureBlobMetadatum$outboundSchema))
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  parquetChunkSizeMB: z.number().default(5),
  parquetChunkDownloadTimeout: z.number().default(600),
  authType: InputAzureBlobAuthenticationMethod$outboundSchema.default("manual"),
  description: z.string().optional(),
  connectionString: z.string().optional(),
  textSecret: z.string().optional(),
  storageAccountName: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  clientTextSecret: z.string().optional(),
  certificate: z.lazy(() => CreateInputCertificate$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputAzureBlob$ {
  /** @deprecated use `InputAzureBlob$inboundSchema` instead. */
  export const inboundSchema = InputAzureBlob$inboundSchema;
  /** @deprecated use `InputAzureBlob$outboundSchema` instead. */
  export const outboundSchema = InputAzureBlob$outboundSchema;
  /** @deprecated use `InputAzureBlob$Outbound` instead. */
  export type Outbound = InputAzureBlob$Outbound;
}

export function inputAzureBlobToJSON(inputAzureBlob: InputAzureBlob): string {
  return JSON.stringify(InputAzureBlob$outboundSchema.parse(inputAzureBlob));
}

export function inputAzureBlobFromJSON(
  jsonString: string,
): SafeParseResult<InputAzureBlob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAzureBlob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAzureBlob' from JSON`,
  );
}

/** @internal */
export const InputSplunkHecType$inboundSchema: z.ZodType<
  InputSplunkHecType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkHecType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkHecType$outboundSchema: z.ZodType<
  InputSplunkHecType,
  z.ZodTypeDef,
  InputSplunkHecType
> = z.union([
  z.nativeEnum(InputSplunkHecType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecType$ {
  /** @deprecated use `InputSplunkHecType$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHecType$inboundSchema;
  /** @deprecated use `InputSplunkHecType$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHecType$outboundSchema;
}

/** @internal */
export const InputSplunkHecConnection$inboundSchema: z.ZodType<
  InputSplunkHecConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputSplunkHecConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSplunkHecConnection$outboundSchema: z.ZodType<
  InputSplunkHecConnection$Outbound,
  z.ZodTypeDef,
  InputSplunkHecConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecConnection$ {
  /** @deprecated use `InputSplunkHecConnection$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHecConnection$inboundSchema;
  /** @deprecated use `InputSplunkHecConnection$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHecConnection$outboundSchema;
  /** @deprecated use `InputSplunkHecConnection$Outbound` instead. */
  export type Outbound = InputSplunkHecConnection$Outbound;
}

export function inputSplunkHecConnectionToJSON(
  inputSplunkHecConnection: InputSplunkHecConnection,
): string {
  return JSON.stringify(
    InputSplunkHecConnection$outboundSchema.parse(inputSplunkHecConnection),
  );
}

export function inputSplunkHecConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkHecConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkHecConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkHecConnection' from JSON`,
  );
}

/** @internal */
export const InputSplunkHecMode$inboundSchema: z.ZodType<
  InputSplunkHecMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkHecMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkHecMode$outboundSchema: z.ZodType<
  InputSplunkHecMode,
  z.ZodTypeDef,
  InputSplunkHecMode
> = z.union([
  z.nativeEnum(InputSplunkHecMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecMode$ {
  /** @deprecated use `InputSplunkHecMode$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHecMode$inboundSchema;
  /** @deprecated use `InputSplunkHecMode$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHecMode$outboundSchema;
}

/** @internal */
export const InputSplunkHecCompression$inboundSchema: z.ZodType<
  InputSplunkHecCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkHecCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkHecCompression$outboundSchema: z.ZodType<
  InputSplunkHecCompression,
  z.ZodTypeDef,
  InputSplunkHecCompression
> = z.union([
  z.nativeEnum(InputSplunkHecCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecCompression$ {
  /** @deprecated use `InputSplunkHecCompression$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHecCompression$inboundSchema;
  /** @deprecated use `InputSplunkHecCompression$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHecCompression$outboundSchema;
}

/** @internal */
export const InputSplunkHecPq$inboundSchema: z.ZodType<
  InputSplunkHecPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSplunkHecMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSplunkHecCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputSplunkHecPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputSplunkHecPq$outboundSchema: z.ZodType<
  InputSplunkHecPq$Outbound,
  z.ZodTypeDef,
  InputSplunkHecPq
> = z.object({
  mode: InputSplunkHecMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSplunkHecCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecPq$ {
  /** @deprecated use `InputSplunkHecPq$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHecPq$inboundSchema;
  /** @deprecated use `InputSplunkHecPq$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHecPq$outboundSchema;
  /** @deprecated use `InputSplunkHecPq$Outbound` instead. */
  export type Outbound = InputSplunkHecPq$Outbound;
}

export function inputSplunkHecPqToJSON(
  inputSplunkHecPq: InputSplunkHecPq,
): string {
  return JSON.stringify(
    InputSplunkHecPq$outboundSchema.parse(inputSplunkHecPq),
  );
}

export function inputSplunkHecPqFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkHecPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkHecPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkHecPq' from JSON`,
  );
}

/** @internal */
export const InputSplunkHecAuthenticationMethod$inboundSchema: z.ZodType<
  InputSplunkHecAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkHecAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkHecAuthenticationMethod$outboundSchema: z.ZodType<
  InputSplunkHecAuthenticationMethod,
  z.ZodTypeDef,
  InputSplunkHecAuthenticationMethod
> = z.union([
  z.nativeEnum(InputSplunkHecAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecAuthenticationMethod$ {
  /** @deprecated use `InputSplunkHecAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHecAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputSplunkHecAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputSplunkHecAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputSplunkHecAuthTokenMetadatum$inboundSchema: z.ZodType<
  InputSplunkHecAuthTokenMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSplunkHecAuthTokenMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkHecAuthTokenMetadatum$outboundSchema: z.ZodType<
  InputSplunkHecAuthTokenMetadatum$Outbound,
  z.ZodTypeDef,
  InputSplunkHecAuthTokenMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecAuthTokenMetadatum$ {
  /** @deprecated use `InputSplunkHecAuthTokenMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHecAuthTokenMetadatum$inboundSchema;
  /** @deprecated use `InputSplunkHecAuthTokenMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHecAuthTokenMetadatum$outboundSchema;
  /** @deprecated use `InputSplunkHecAuthTokenMetadatum$Outbound` instead. */
  export type Outbound = InputSplunkHecAuthTokenMetadatum$Outbound;
}

export function inputSplunkHecAuthTokenMetadatumToJSON(
  inputSplunkHecAuthTokenMetadatum: InputSplunkHecAuthTokenMetadatum,
): string {
  return JSON.stringify(
    InputSplunkHecAuthTokenMetadatum$outboundSchema.parse(
      inputSplunkHecAuthTokenMetadatum,
    ),
  );
}

export function inputSplunkHecAuthTokenMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkHecAuthTokenMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkHecAuthTokenMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkHecAuthTokenMetadatum' from JSON`,
  );
}

/** @internal */
export const InputSplunkHecAuthToken$inboundSchema: z.ZodType<
  InputSplunkHecAuthToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: InputSplunkHecAuthenticationMethod$inboundSchema.default("manual"),
  tokenSecret: z.any().optional(),
  token: z.any().optional(),
  enabled: z.boolean().default(true),
  description: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
  metadata: z.array(
    z.lazy(() => InputSplunkHecAuthTokenMetadatum$inboundSchema),
  ).optional(),
});

/** @internal */
export type InputSplunkHecAuthToken$Outbound = {
  authType: string;
  tokenSecret?: any | undefined;
  token?: any | undefined;
  enabled: boolean;
  description?: string | undefined;
  allowedIndexesAtToken?: Array<string> | undefined;
  metadata?: Array<InputSplunkHecAuthTokenMetadatum$Outbound> | undefined;
};

/** @internal */
export const InputSplunkHecAuthToken$outboundSchema: z.ZodType<
  InputSplunkHecAuthToken$Outbound,
  z.ZodTypeDef,
  InputSplunkHecAuthToken
> = z.object({
  authType: InputSplunkHecAuthenticationMethod$outboundSchema.default("manual"),
  tokenSecret: z.any().optional(),
  token: z.any().optional(),
  enabled: z.boolean().default(true),
  description: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
  metadata: z.array(
    z.lazy(() => InputSplunkHecAuthTokenMetadatum$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecAuthToken$ {
  /** @deprecated use `InputSplunkHecAuthToken$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHecAuthToken$inboundSchema;
  /** @deprecated use `InputSplunkHecAuthToken$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHecAuthToken$outboundSchema;
  /** @deprecated use `InputSplunkHecAuthToken$Outbound` instead. */
  export type Outbound = InputSplunkHecAuthToken$Outbound;
}

export function inputSplunkHecAuthTokenToJSON(
  inputSplunkHecAuthToken: InputSplunkHecAuthToken,
): string {
  return JSON.stringify(
    InputSplunkHecAuthToken$outboundSchema.parse(inputSplunkHecAuthToken),
  );
}

export function inputSplunkHecAuthTokenFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkHecAuthToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkHecAuthToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkHecAuthToken' from JSON`,
  );
}

/** @internal */
export const InputSplunkHecMinimumTLSVersion$inboundSchema: z.ZodType<
  InputSplunkHecMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkHecMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkHecMinimumTLSVersion$outboundSchema: z.ZodType<
  InputSplunkHecMinimumTLSVersion,
  z.ZodTypeDef,
  InputSplunkHecMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputSplunkHecMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecMinimumTLSVersion$ {
  /** @deprecated use `InputSplunkHecMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHecMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputSplunkHecMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHecMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputSplunkHecMaximumTLSVersion$inboundSchema: z.ZodType<
  InputSplunkHecMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkHecMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkHecMaximumTLSVersion$outboundSchema: z.ZodType<
  InputSplunkHecMaximumTLSVersion,
  z.ZodTypeDef,
  InputSplunkHecMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputSplunkHecMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecMaximumTLSVersion$ {
  /** @deprecated use `InputSplunkHecMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHecMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputSplunkHecMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHecMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputSplunkHecTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputSplunkHecTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSplunkHecMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputSplunkHecMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputSplunkHecTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputSplunkHecTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputSplunkHecTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputSplunkHecTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSplunkHecMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputSplunkHecMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecTLSSettingsServerSide$ {
  /** @deprecated use `InputSplunkHecTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema =
    InputSplunkHecTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputSplunkHecTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputSplunkHecTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputSplunkHecTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputSplunkHecTLSSettingsServerSide$Outbound;
}

export function inputSplunkHecTLSSettingsServerSideToJSON(
  inputSplunkHecTLSSettingsServerSide: InputSplunkHecTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputSplunkHecTLSSettingsServerSide$outboundSchema.parse(
      inputSplunkHecTLSSettingsServerSide,
    ),
  );
}

export function inputSplunkHecTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkHecTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InputSplunkHecTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkHecTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputSplunkHecMetadatum$inboundSchema: z.ZodType<
  InputSplunkHecMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSplunkHecMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkHecMetadatum$outboundSchema: z.ZodType<
  InputSplunkHecMetadatum$Outbound,
  z.ZodTypeDef,
  InputSplunkHecMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHecMetadatum$ {
  /** @deprecated use `InputSplunkHecMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHecMetadatum$inboundSchema;
  /** @deprecated use `InputSplunkHecMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHecMetadatum$outboundSchema;
  /** @deprecated use `InputSplunkHecMetadatum$Outbound` instead. */
  export type Outbound = InputSplunkHecMetadatum$Outbound;
}

export function inputSplunkHecMetadatumToJSON(
  inputSplunkHecMetadatum: InputSplunkHecMetadatum,
): string {
  return JSON.stringify(
    InputSplunkHecMetadatum$outboundSchema.parse(inputSplunkHecMetadatum),
  );
}

export function inputSplunkHecMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkHecMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkHecMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkHecMetadatum' from JSON`,
  );
}

/** @internal */
export const InputSplunkHec$inboundSchema: z.ZodType<
  InputSplunkHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputSplunkHecType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSplunkHecConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSplunkHecPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.lazy(() => InputSplunkHecAuthToken$inboundSchema))
    .optional(),
  tls: z.lazy(() => InputSplunkHecTLSSettingsServerSide$inboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.any().optional(),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  splunkHecAPI: z.string().default("/services/collector"),
  metadata: z.array(z.lazy(() => InputSplunkHecMetadatum$inboundSchema))
    .optional(),
  allowedIndexes: z.array(z.string()).optional(),
  splunkHecAcks: z.boolean().default(false),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  useFwdTimezone: z.boolean().default(true),
  dropControlFields: z.boolean().default(true),
  extractMetrics: z.boolean().default(false),
  accessControlAllowOrigin: z.array(z.string()).optional(),
  accessControlAllowHeaders: z.array(z.string()).optional(),
  emitTokenMetrics: z.boolean().default(false),
  description: z.string().optional(),
});

/** @internal */
export type InputSplunkHec$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSplunkHecConnection$Outbound> | undefined;
  pq?: InputSplunkHecPq$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<InputSplunkHecAuthToken$Outbound> | undefined;
  tls?: InputSplunkHecTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  splunkHecAPI: string;
  metadata?: Array<InputSplunkHecMetadatum$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  splunkHecAcks: boolean;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  useFwdTimezone: boolean;
  dropControlFields: boolean;
  extractMetrics: boolean;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputSplunkHec$outboundSchema: z.ZodType<
  InputSplunkHec$Outbound,
  z.ZodTypeDef,
  InputSplunkHec
> = z.object({
  id: z.string(),
  type: InputSplunkHecType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSplunkHecConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSplunkHecPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.lazy(() => InputSplunkHecAuthToken$outboundSchema))
    .optional(),
  tls: z.lazy(() => InputSplunkHecTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.any().optional(),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  splunkHecAPI: z.string().default("/services/collector"),
  metadata: z.array(z.lazy(() => InputSplunkHecMetadatum$outboundSchema))
    .optional(),
  allowedIndexes: z.array(z.string()).optional(),
  splunkHecAcks: z.boolean().default(false),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  useFwdTimezone: z.boolean().default(true),
  dropControlFields: z.boolean().default(true),
  extractMetrics: z.boolean().default(false),
  accessControlAllowOrigin: z.array(z.string()).optional(),
  accessControlAllowHeaders: z.array(z.string()).optional(),
  emitTokenMetrics: z.boolean().default(false),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkHec$ {
  /** @deprecated use `InputSplunkHec$inboundSchema` instead. */
  export const inboundSchema = InputSplunkHec$inboundSchema;
  /** @deprecated use `InputSplunkHec$outboundSchema` instead. */
  export const outboundSchema = InputSplunkHec$outboundSchema;
  /** @deprecated use `InputSplunkHec$Outbound` instead. */
  export type Outbound = InputSplunkHec$Outbound;
}

export function inputSplunkHecToJSON(inputSplunkHec: InputSplunkHec): string {
  return JSON.stringify(InputSplunkHec$outboundSchema.parse(inputSplunkHec));
}

export function inputSplunkHecFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkHec' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchType$inboundSchema: z.ZodType<
  InputSplunkSearchType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkSearchType$outboundSchema: z.ZodType<
  InputSplunkSearchType,
  z.ZodTypeDef,
  InputSplunkSearchType
> = z.union([
  z.nativeEnum(InputSplunkSearchType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchType$ {
  /** @deprecated use `InputSplunkSearchType$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchType$inboundSchema;
  /** @deprecated use `InputSplunkSearchType$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchType$outboundSchema;
}

/** @internal */
export const InputSplunkSearchConnection$inboundSchema: z.ZodType<
  InputSplunkSearchConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputSplunkSearchConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSplunkSearchConnection$outboundSchema: z.ZodType<
  InputSplunkSearchConnection$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchConnection$ {
  /** @deprecated use `InputSplunkSearchConnection$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchConnection$inboundSchema;
  /** @deprecated use `InputSplunkSearchConnection$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchConnection$outboundSchema;
  /** @deprecated use `InputSplunkSearchConnection$Outbound` instead. */
  export type Outbound = InputSplunkSearchConnection$Outbound;
}

export function inputSplunkSearchConnectionToJSON(
  inputSplunkSearchConnection: InputSplunkSearchConnection,
): string {
  return JSON.stringify(
    InputSplunkSearchConnection$outboundSchema.parse(
      inputSplunkSearchConnection,
    ),
  );
}

export function inputSplunkSearchConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchConnection' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchMode$inboundSchema: z.ZodType<
  InputSplunkSearchMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkSearchMode$outboundSchema: z.ZodType<
  InputSplunkSearchMode,
  z.ZodTypeDef,
  InputSplunkSearchMode
> = z.union([
  z.nativeEnum(InputSplunkSearchMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchMode$ {
  /** @deprecated use `InputSplunkSearchMode$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchMode$inboundSchema;
  /** @deprecated use `InputSplunkSearchMode$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchMode$outboundSchema;
}

/** @internal */
export const InputSplunkSearchCompression$inboundSchema: z.ZodType<
  InputSplunkSearchCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkSearchCompression$outboundSchema: z.ZodType<
  InputSplunkSearchCompression,
  z.ZodTypeDef,
  InputSplunkSearchCompression
> = z.union([
  z.nativeEnum(InputSplunkSearchCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchCompression$ {
  /** @deprecated use `InputSplunkSearchCompression$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchCompression$inboundSchema;
  /** @deprecated use `InputSplunkSearchCompression$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchCompression$outboundSchema;
}

/** @internal */
export const InputSplunkSearchPq$inboundSchema: z.ZodType<
  InputSplunkSearchPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSplunkSearchMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSplunkSearchCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputSplunkSearchPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputSplunkSearchPq$outboundSchema: z.ZodType<
  InputSplunkSearchPq$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchPq
> = z.object({
  mode: InputSplunkSearchMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSplunkSearchCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchPq$ {
  /** @deprecated use `InputSplunkSearchPq$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchPq$inboundSchema;
  /** @deprecated use `InputSplunkSearchPq$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchPq$outboundSchema;
  /** @deprecated use `InputSplunkSearchPq$Outbound` instead. */
  export type Outbound = InputSplunkSearchPq$Outbound;
}

export function inputSplunkSearchPqToJSON(
  inputSplunkSearchPq: InputSplunkSearchPq,
): string {
  return JSON.stringify(
    InputSplunkSearchPq$outboundSchema.parse(inputSplunkSearchPq),
  );
}

export function inputSplunkSearchPqFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchPq' from JSON`,
  );
}

/** @internal */
export const OutputMode$inboundSchema: z.ZodType<
  OutputMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(OutputMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const OutputMode$outboundSchema: z.ZodType<
  OutputMode,
  z.ZodTypeDef,
  OutputMode
> = z.union([
  z.nativeEnum(OutputMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OutputMode$ {
  /** @deprecated use `OutputMode$inboundSchema` instead. */
  export const inboundSchema = OutputMode$inboundSchema;
  /** @deprecated use `OutputMode$outboundSchema` instead. */
  export const outboundSchema = OutputMode$outboundSchema;
}

/** @internal */
export const EndpointParam$inboundSchema: z.ZodType<
  EndpointParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type EndpointParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const EndpointParam$outboundSchema: z.ZodType<
  EndpointParam$Outbound,
  z.ZodTypeDef,
  EndpointParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EndpointParam$ {
  /** @deprecated use `EndpointParam$inboundSchema` instead. */
  export const inboundSchema = EndpointParam$inboundSchema;
  /** @deprecated use `EndpointParam$outboundSchema` instead. */
  export const outboundSchema = EndpointParam$outboundSchema;
  /** @deprecated use `EndpointParam$Outbound` instead. */
  export type Outbound = EndpointParam$Outbound;
}

export function endpointParamToJSON(endpointParam: EndpointParam): string {
  return JSON.stringify(EndpointParam$outboundSchema.parse(endpointParam));
}

export function endpointParamFromJSON(
  jsonString: string,
): SafeParseResult<EndpointParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EndpointParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EndpointParam' from JSON`,
  );
}

/** @internal */
export const EndpointHeader$inboundSchema: z.ZodType<
  EndpointHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type EndpointHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const EndpointHeader$outboundSchema: z.ZodType<
  EndpointHeader$Outbound,
  z.ZodTypeDef,
  EndpointHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EndpointHeader$ {
  /** @deprecated use `EndpointHeader$inboundSchema` instead. */
  export const inboundSchema = EndpointHeader$inboundSchema;
  /** @deprecated use `EndpointHeader$outboundSchema` instead. */
  export const outboundSchema = EndpointHeader$outboundSchema;
  /** @deprecated use `EndpointHeader$Outbound` instead. */
  export type Outbound = EndpointHeader$Outbound;
}

export function endpointHeaderToJSON(endpointHeader: EndpointHeader): string {
  return JSON.stringify(EndpointHeader$outboundSchema.parse(endpointHeader));
}

export function endpointHeaderFromJSON(
  jsonString: string,
): SafeParseResult<EndpointHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EndpointHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EndpointHeader' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchLogLevel$inboundSchema: z.ZodType<
  InputSplunkSearchLogLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchLogLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkSearchLogLevel$outboundSchema: z.ZodType<
  InputSplunkSearchLogLevel,
  z.ZodTypeDef,
  InputSplunkSearchLogLevel
> = z.union([
  z.nativeEnum(InputSplunkSearchLogLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchLogLevel$ {
  /** @deprecated use `InputSplunkSearchLogLevel$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchLogLevel$inboundSchema;
  /** @deprecated use `InputSplunkSearchLogLevel$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchLogLevel$outboundSchema;
}

/** @internal */
export const InputSplunkSearchMetadatum$inboundSchema: z.ZodType<
  InputSplunkSearchMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSplunkSearchMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkSearchMetadatum$outboundSchema: z.ZodType<
  InputSplunkSearchMetadatum$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchMetadatum$ {
  /** @deprecated use `InputSplunkSearchMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchMetadatum$inboundSchema;
  /** @deprecated use `InputSplunkSearchMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchMetadatum$outboundSchema;
  /** @deprecated use `InputSplunkSearchMetadatum$Outbound` instead. */
  export type Outbound = InputSplunkSearchMetadatum$Outbound;
}

export function inputSplunkSearchMetadatumToJSON(
  inputSplunkSearchMetadatum: InputSplunkSearchMetadatum,
): string {
  return JSON.stringify(
    InputSplunkSearchMetadatum$outboundSchema.parse(inputSplunkSearchMetadatum),
  );
}

export function inputSplunkSearchMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchMetadatum' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchRetryType$inboundSchema: z.ZodType<
  InputSplunkSearchRetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchRetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkSearchRetryType$outboundSchema: z.ZodType<
  InputSplunkSearchRetryType,
  z.ZodTypeDef,
  InputSplunkSearchRetryType
> = z.union([
  z.nativeEnum(InputSplunkSearchRetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchRetryType$ {
  /** @deprecated use `InputSplunkSearchRetryType$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchRetryType$inboundSchema;
  /** @deprecated use `InputSplunkSearchRetryType$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchRetryType$outboundSchema;
}

/** @internal */
export const InputSplunkSearchRetryRules$inboundSchema: z.ZodType<
  InputSplunkSearchRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InputSplunkSearchRetryType$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type InputSplunkSearchRetryRules$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const InputSplunkSearchRetryRules$outboundSchema: z.ZodType<
  InputSplunkSearchRetryRules$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchRetryRules
> = z.object({
  type: InputSplunkSearchRetryType$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchRetryRules$ {
  /** @deprecated use `InputSplunkSearchRetryRules$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchRetryRules$inboundSchema;
  /** @deprecated use `InputSplunkSearchRetryRules$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchRetryRules$outboundSchema;
  /** @deprecated use `InputSplunkSearchRetryRules$Outbound` instead. */
  export type Outbound = InputSplunkSearchRetryRules$Outbound;
}

export function inputSplunkSearchRetryRulesToJSON(
  inputSplunkSearchRetryRules: InputSplunkSearchRetryRules,
): string {
  return JSON.stringify(
    InputSplunkSearchRetryRules$outboundSchema.parse(
      inputSplunkSearchRetryRules,
    ),
  );
}

export function inputSplunkSearchRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchRetryRules' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchAuthenticationType$inboundSchema: z.ZodType<
  InputSplunkSearchAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkSearchAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkSearchAuthenticationType$outboundSchema: z.ZodType<
  InputSplunkSearchAuthenticationType,
  z.ZodTypeDef,
  InputSplunkSearchAuthenticationType
> = z.union([
  z.nativeEnum(InputSplunkSearchAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchAuthenticationType$ {
  /** @deprecated use `InputSplunkSearchAuthenticationType$inboundSchema` instead. */
  export const inboundSchema =
    InputSplunkSearchAuthenticationType$inboundSchema;
  /** @deprecated use `InputSplunkSearchAuthenticationType$outboundSchema` instead. */
  export const outboundSchema =
    InputSplunkSearchAuthenticationType$outboundSchema;
}

/** @internal */
export const InputSplunkSearchOauthParam$inboundSchema: z.ZodType<
  InputSplunkSearchOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSplunkSearchOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkSearchOauthParam$outboundSchema: z.ZodType<
  InputSplunkSearchOauthParam$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchOauthParam$ {
  /** @deprecated use `InputSplunkSearchOauthParam$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchOauthParam$inboundSchema;
  /** @deprecated use `InputSplunkSearchOauthParam$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchOauthParam$outboundSchema;
  /** @deprecated use `InputSplunkSearchOauthParam$Outbound` instead. */
  export type Outbound = InputSplunkSearchOauthParam$Outbound;
}

export function inputSplunkSearchOauthParamToJSON(
  inputSplunkSearchOauthParam: InputSplunkSearchOauthParam,
): string {
  return JSON.stringify(
    InputSplunkSearchOauthParam$outboundSchema.parse(
      inputSplunkSearchOauthParam,
    ),
  );
}

export function inputSplunkSearchOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchOauthParam' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearchOauthHeader$inboundSchema: z.ZodType<
  InputSplunkSearchOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSplunkSearchOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkSearchOauthHeader$outboundSchema: z.ZodType<
  InputSplunkSearchOauthHeader$Outbound,
  z.ZodTypeDef,
  InputSplunkSearchOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearchOauthHeader$ {
  /** @deprecated use `InputSplunkSearchOauthHeader$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearchOauthHeader$inboundSchema;
  /** @deprecated use `InputSplunkSearchOauthHeader$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearchOauthHeader$outboundSchema;
  /** @deprecated use `InputSplunkSearchOauthHeader$Outbound` instead. */
  export type Outbound = InputSplunkSearchOauthHeader$Outbound;
}

export function inputSplunkSearchOauthHeaderToJSON(
  inputSplunkSearchOauthHeader: InputSplunkSearchOauthHeader,
): string {
  return JSON.stringify(
    InputSplunkSearchOauthHeader$outboundSchema.parse(
      inputSplunkSearchOauthHeader,
    ),
  );
}

export function inputSplunkSearchOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearchOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearchOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearchOauthHeader' from JSON`,
  );
}

/** @internal */
export const InputSplunkSearch$inboundSchema: z.ZodType<
  InputSplunkSearch,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputSplunkSearchType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSplunkSearchConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSplunkSearchPq$inboundSchema).optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode$inboundSchema.default("json"),
  endpointParams: z.array(z.lazy(() => EndpointParam$inboundSchema)).optional(),
  endpointHeaders: z.array(z.lazy(() => EndpointHeader$inboundSchema))
    .optional(),
  logLevel: InputSplunkSearchLogLevel$inboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputSplunkSearchMetadatum$inboundSchema))
    .optional(),
  retryRules: z.lazy(() => InputSplunkSearchRetryRules$inboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: InputSplunkSearchAuthenticationType$inboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => InputSplunkSearchOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(
    z.lazy(() => InputSplunkSearchOauthHeader$inboundSchema),
  ).optional(),
});

/** @internal */
export type InputSplunkSearch$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSplunkSearchConnection$Outbound> | undefined;
  pq?: InputSplunkSearchPq$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest: string;
  latest: string;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<EndpointParam$Outbound> | undefined;
  endpointHeaders?: Array<EndpointHeader$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout: number;
  useRoundRobinDns: boolean;
  rejectUnauthorized: boolean;
  encoding?: string | undefined;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<InputSplunkSearchMetadatum$Outbound> | undefined;
  retryRules?: InputSplunkSearchRetryRules$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  authType: string;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<InputSplunkSearchOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<InputSplunkSearchOauthHeader$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearch$outboundSchema: z.ZodType<
  InputSplunkSearch$Outbound,
  z.ZodTypeDef,
  InputSplunkSearch
> = z.object({
  id: z.string(),
  type: InputSplunkSearchType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSplunkSearchConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSplunkSearchPq$outboundSchema).optional(),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().default("-16m@m"),
  latest: z.string().default("-1m@m"),
  cronSchedule: z.string().default("*/15 * * * *"),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputMode$outboundSchema.default("json"),
  endpointParams: z.array(z.lazy(() => EndpointParam$outboundSchema))
    .optional(),
  endpointHeaders: z.array(z.lazy(() => EndpointHeader$outboundSchema))
    .optional(),
  logLevel: InputSplunkSearchLogLevel$outboundSchema.optional(),
  requestTimeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(false),
  encoding: z.string().optional(),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputSplunkSearchMetadatum$outboundSchema))
    .optional(),
  retryRules: z.lazy(() => InputSplunkSearchRetryRules$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authType: InputSplunkSearchAuthenticationType$outboundSchema.default("basic"),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => InputSplunkSearchOauthParam$outboundSchema))
    .optional(),
  oauthHeaders: z.array(
    z.lazy(() => InputSplunkSearchOauthHeader$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkSearch$ {
  /** @deprecated use `InputSplunkSearch$inboundSchema` instead. */
  export const inboundSchema = InputSplunkSearch$inboundSchema;
  /** @deprecated use `InputSplunkSearch$outboundSchema` instead. */
  export const outboundSchema = InputSplunkSearch$outboundSchema;
  /** @deprecated use `InputSplunkSearch$Outbound` instead. */
  export type Outbound = InputSplunkSearch$Outbound;
}

export function inputSplunkSearchToJSON(
  inputSplunkSearch: InputSplunkSearch,
): string {
  return JSON.stringify(
    InputSplunkSearch$outboundSchema.parse(inputSplunkSearch),
  );
}

export function inputSplunkSearchFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkSearch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkSearch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkSearch' from JSON`,
  );
}

/** @internal */
export const InputSplunkType$inboundSchema: z.ZodType<
  InputSplunkType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkType$outboundSchema: z.ZodType<
  InputSplunkType,
  z.ZodTypeDef,
  InputSplunkType
> = z.union([
  z.nativeEnum(InputSplunkType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkType$ {
  /** @deprecated use `InputSplunkType$inboundSchema` instead. */
  export const inboundSchema = InputSplunkType$inboundSchema;
  /** @deprecated use `InputSplunkType$outboundSchema` instead. */
  export const outboundSchema = InputSplunkType$outboundSchema;
}

/** @internal */
export const InputSplunkConnection$inboundSchema: z.ZodType<
  InputSplunkConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputSplunkConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputSplunkConnection$outboundSchema: z.ZodType<
  InputSplunkConnection$Outbound,
  z.ZodTypeDef,
  InputSplunkConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkConnection$ {
  /** @deprecated use `InputSplunkConnection$inboundSchema` instead. */
  export const inboundSchema = InputSplunkConnection$inboundSchema;
  /** @deprecated use `InputSplunkConnection$outboundSchema` instead. */
  export const outboundSchema = InputSplunkConnection$outboundSchema;
  /** @deprecated use `InputSplunkConnection$Outbound` instead. */
  export type Outbound = InputSplunkConnection$Outbound;
}

export function inputSplunkConnectionToJSON(
  inputSplunkConnection: InputSplunkConnection,
): string {
  return JSON.stringify(
    InputSplunkConnection$outboundSchema.parse(inputSplunkConnection),
  );
}

export function inputSplunkConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkConnection' from JSON`,
  );
}

/** @internal */
export const InputSplunkMode$inboundSchema: z.ZodType<
  InputSplunkMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkMode$outboundSchema: z.ZodType<
  InputSplunkMode,
  z.ZodTypeDef,
  InputSplunkMode
> = z.union([
  z.nativeEnum(InputSplunkMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkMode$ {
  /** @deprecated use `InputSplunkMode$inboundSchema` instead. */
  export const inboundSchema = InputSplunkMode$inboundSchema;
  /** @deprecated use `InputSplunkMode$outboundSchema` instead. */
  export const outboundSchema = InputSplunkMode$outboundSchema;
}

/** @internal */
export const InputSplunkPqCompression$inboundSchema: z.ZodType<
  InputSplunkPqCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkPqCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkPqCompression$outboundSchema: z.ZodType<
  InputSplunkPqCompression,
  z.ZodTypeDef,
  InputSplunkPqCompression
> = z.union([
  z.nativeEnum(InputSplunkPqCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkPqCompression$ {
  /** @deprecated use `InputSplunkPqCompression$inboundSchema` instead. */
  export const inboundSchema = InputSplunkPqCompression$inboundSchema;
  /** @deprecated use `InputSplunkPqCompression$outboundSchema` instead. */
  export const outboundSchema = InputSplunkPqCompression$outboundSchema;
}

/** @internal */
export const InputSplunkPq$inboundSchema: z.ZodType<
  InputSplunkPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSplunkMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSplunkPqCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputSplunkPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputSplunkPq$outboundSchema: z.ZodType<
  InputSplunkPq$Outbound,
  z.ZodTypeDef,
  InputSplunkPq
> = z.object({
  mode: InputSplunkMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputSplunkPqCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkPq$ {
  /** @deprecated use `InputSplunkPq$inboundSchema` instead. */
  export const inboundSchema = InputSplunkPq$inboundSchema;
  /** @deprecated use `InputSplunkPq$outboundSchema` instead. */
  export const outboundSchema = InputSplunkPq$outboundSchema;
  /** @deprecated use `InputSplunkPq$Outbound` instead. */
  export type Outbound = InputSplunkPq$Outbound;
}

export function inputSplunkPqToJSON(inputSplunkPq: InputSplunkPq): string {
  return JSON.stringify(InputSplunkPq$outboundSchema.parse(inputSplunkPq));
}

export function inputSplunkPqFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkPq' from JSON`,
  );
}

/** @internal */
export const InputSplunkMinimumTLSVersion$inboundSchema: z.ZodType<
  InputSplunkMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkMinimumTLSVersion$outboundSchema: z.ZodType<
  InputSplunkMinimumTLSVersion,
  z.ZodTypeDef,
  InputSplunkMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputSplunkMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkMinimumTLSVersion$ {
  /** @deprecated use `InputSplunkMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputSplunkMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputSplunkMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputSplunkMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputSplunkMaximumTLSVersion$inboundSchema: z.ZodType<
  InputSplunkMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkMaximumTLSVersion$outboundSchema: z.ZodType<
  InputSplunkMaximumTLSVersion,
  z.ZodTypeDef,
  InputSplunkMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputSplunkMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkMaximumTLSVersion$ {
  /** @deprecated use `InputSplunkMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputSplunkMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputSplunkMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputSplunkMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputSplunkTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputSplunkTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSplunkMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputSplunkMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputSplunkTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputSplunkTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputSplunkTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputSplunkTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputSplunkMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputSplunkMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkTLSSettingsServerSide$ {
  /** @deprecated use `InputSplunkTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputSplunkTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputSplunkTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema = InputSplunkTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputSplunkTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputSplunkTLSSettingsServerSide$Outbound;
}

export function inputSplunkTLSSettingsServerSideToJSON(
  inputSplunkTLSSettingsServerSide: InputSplunkTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputSplunkTLSSettingsServerSide$outboundSchema.parse(
      inputSplunkTLSSettingsServerSide,
    ),
  );
}

export function inputSplunkTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputSplunkMetadatum$inboundSchema: z.ZodType<
  InputSplunkMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputSplunkMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputSplunkMetadatum$outboundSchema: z.ZodType<
  InputSplunkMetadatum$Outbound,
  z.ZodTypeDef,
  InputSplunkMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkMetadatum$ {
  /** @deprecated use `InputSplunkMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputSplunkMetadatum$inboundSchema;
  /** @deprecated use `InputSplunkMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputSplunkMetadatum$outboundSchema;
  /** @deprecated use `InputSplunkMetadatum$Outbound` instead. */
  export type Outbound = InputSplunkMetadatum$Outbound;
}

export function inputSplunkMetadatumToJSON(
  inputSplunkMetadatum: InputSplunkMetadatum,
): string {
  return JSON.stringify(
    InputSplunkMetadatum$outboundSchema.parse(inputSplunkMetadatum),
  );
}

export function inputSplunkMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkMetadatum' from JSON`,
  );
}

/** @internal */
export const InputSplunkAuthToken$inboundSchema: z.ZodType<
  InputSplunkAuthToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  description: z.string().optional(),
});

/** @internal */
export type InputSplunkAuthToken$Outbound = {
  token: string;
  description?: string | undefined;
};

/** @internal */
export const InputSplunkAuthToken$outboundSchema: z.ZodType<
  InputSplunkAuthToken$Outbound,
  z.ZodTypeDef,
  InputSplunkAuthToken
> = z.object({
  token: z.string(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkAuthToken$ {
  /** @deprecated use `InputSplunkAuthToken$inboundSchema` instead. */
  export const inboundSchema = InputSplunkAuthToken$inboundSchema;
  /** @deprecated use `InputSplunkAuthToken$outboundSchema` instead. */
  export const outboundSchema = InputSplunkAuthToken$outboundSchema;
  /** @deprecated use `InputSplunkAuthToken$Outbound` instead. */
  export type Outbound = InputSplunkAuthToken$Outbound;
}

export function inputSplunkAuthTokenToJSON(
  inputSplunkAuthToken: InputSplunkAuthToken,
): string {
  return JSON.stringify(
    InputSplunkAuthToken$outboundSchema.parse(inputSplunkAuthToken),
  );
}

export function inputSplunkAuthTokenFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunkAuthToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunkAuthToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunkAuthToken' from JSON`,
  );
}

/** @internal */
export const CreateInputMaxS2SVersion$inboundSchema: z.ZodType<
  CreateInputMaxS2SVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(CreateInputMaxS2SVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const CreateInputMaxS2SVersion$outboundSchema: z.ZodType<
  CreateInputMaxS2SVersion,
  z.ZodTypeDef,
  CreateInputMaxS2SVersion
> = z.union([
  z.nativeEnum(CreateInputMaxS2SVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputMaxS2SVersion$ {
  /** @deprecated use `CreateInputMaxS2SVersion$inboundSchema` instead. */
  export const inboundSchema = CreateInputMaxS2SVersion$inboundSchema;
  /** @deprecated use `CreateInputMaxS2SVersion$outboundSchema` instead. */
  export const outboundSchema = CreateInputMaxS2SVersion$outboundSchema;
}

/** @internal */
export const InputSplunkCompression$inboundSchema: z.ZodType<
  InputSplunkCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputSplunkCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputSplunkCompression$outboundSchema: z.ZodType<
  InputSplunkCompression,
  z.ZodTypeDef,
  InputSplunkCompression
> = z.union([
  z.nativeEnum(InputSplunkCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunkCompression$ {
  /** @deprecated use `InputSplunkCompression$inboundSchema` instead. */
  export const inboundSchema = InputSplunkCompression$inboundSchema;
  /** @deprecated use `InputSplunkCompression$outboundSchema` instead. */
  export const outboundSchema = InputSplunkCompression$outboundSchema;
}

/** @internal */
export const InputSplunk$inboundSchema: z.ZodType<
  InputSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputSplunkType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSplunkConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputSplunkPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputSplunkTLSSettingsServerSide$inboundSchema).optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputSplunkMetadatum$inboundSchema))
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authTokens: z.array(z.lazy(() => InputSplunkAuthToken$inboundSchema))
    .optional(),
  maxS2Sversion: CreateInputMaxS2SVersion$inboundSchema.default("v3"),
  description: z.string().optional(),
  useFwdTimezone: z.boolean().default(true),
  dropControlFields: z.boolean().default(true),
  extractMetrics: z.boolean().default(false),
  compress: InputSplunkCompression$inboundSchema.default("disabled"),
});

/** @internal */
export type InputSplunk$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputSplunkConnection$Outbound> | undefined;
  pq?: InputSplunkPq$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputSplunkTLSSettingsServerSide$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<InputSplunkMetadatum$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  authTokens?: Array<InputSplunkAuthToken$Outbound> | undefined;
  maxS2Sversion: string;
  description?: string | undefined;
  useFwdTimezone: boolean;
  dropControlFields: boolean;
  extractMetrics: boolean;
  compress: string;
};

/** @internal */
export const InputSplunk$outboundSchema: z.ZodType<
  InputSplunk$Outbound,
  z.ZodTypeDef,
  InputSplunk
> = z.object({
  id: z.string(),
  type: InputSplunkType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputSplunkConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputSplunkPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputSplunkTLSSettingsServerSide$outboundSchema).optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputSplunkMetadatum$outboundSchema))
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  authTokens: z.array(z.lazy(() => InputSplunkAuthToken$outboundSchema))
    .optional(),
  maxS2Sversion: CreateInputMaxS2SVersion$outboundSchema.default("v3"),
  description: z.string().optional(),
  useFwdTimezone: z.boolean().default(true),
  dropControlFields: z.boolean().default(true),
  extractMetrics: z.boolean().default(false),
  compress: InputSplunkCompression$outboundSchema.default("disabled"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSplunk$ {
  /** @deprecated use `InputSplunk$inboundSchema` instead. */
  export const inboundSchema = InputSplunk$inboundSchema;
  /** @deprecated use `InputSplunk$outboundSchema` instead. */
  export const outboundSchema = InputSplunk$outboundSchema;
  /** @deprecated use `InputSplunk$Outbound` instead. */
  export type Outbound = InputSplunk$Outbound;
}

export function inputSplunkToJSON(inputSplunk: InputSplunk): string {
  return JSON.stringify(InputSplunk$outboundSchema.parse(inputSplunk));
}

export function inputSplunkFromJSON(
  jsonString: string,
): SafeParseResult<InputSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSplunk' from JSON`,
  );
}

/** @internal */
export const InputHttpType$inboundSchema: z.ZodType<
  InputHttpType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputHttpType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputHttpType$outboundSchema: z.ZodType<
  InputHttpType,
  z.ZodTypeDef,
  InputHttpType
> = z.union([
  z.nativeEnum(InputHttpType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpType$ {
  /** @deprecated use `InputHttpType$inboundSchema` instead. */
  export const inboundSchema = InputHttpType$inboundSchema;
  /** @deprecated use `InputHttpType$outboundSchema` instead. */
  export const outboundSchema = InputHttpType$outboundSchema;
}

/** @internal */
export const InputHttpConnection$inboundSchema: z.ZodType<
  InputHttpConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputHttpConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputHttpConnection$outboundSchema: z.ZodType<
  InputHttpConnection$Outbound,
  z.ZodTypeDef,
  InputHttpConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpConnection$ {
  /** @deprecated use `InputHttpConnection$inboundSchema` instead. */
  export const inboundSchema = InputHttpConnection$inboundSchema;
  /** @deprecated use `InputHttpConnection$outboundSchema` instead. */
  export const outboundSchema = InputHttpConnection$outboundSchema;
  /** @deprecated use `InputHttpConnection$Outbound` instead. */
  export type Outbound = InputHttpConnection$Outbound;
}

export function inputHttpConnectionToJSON(
  inputHttpConnection: InputHttpConnection,
): string {
  return JSON.stringify(
    InputHttpConnection$outboundSchema.parse(inputHttpConnection),
  );
}

export function inputHttpConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpConnection' from JSON`,
  );
}

/** @internal */
export const InputHttpMode$inboundSchema: z.ZodType<
  InputHttpMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputHttpMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputHttpMode$outboundSchema: z.ZodType<
  InputHttpMode,
  z.ZodTypeDef,
  InputHttpMode
> = z.union([
  z.nativeEnum(InputHttpMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpMode$ {
  /** @deprecated use `InputHttpMode$inboundSchema` instead. */
  export const inboundSchema = InputHttpMode$inboundSchema;
  /** @deprecated use `InputHttpMode$outboundSchema` instead. */
  export const outboundSchema = InputHttpMode$outboundSchema;
}

/** @internal */
export const InputHttpCompression$inboundSchema: z.ZodType<
  InputHttpCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputHttpCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputHttpCompression$outboundSchema: z.ZodType<
  InputHttpCompression,
  z.ZodTypeDef,
  InputHttpCompression
> = z.union([
  z.nativeEnum(InputHttpCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpCompression$ {
  /** @deprecated use `InputHttpCompression$inboundSchema` instead. */
  export const inboundSchema = InputHttpCompression$inboundSchema;
  /** @deprecated use `InputHttpCompression$outboundSchema` instead. */
  export const outboundSchema = InputHttpCompression$outboundSchema;
}

/** @internal */
export const InputHttpPq$inboundSchema: z.ZodType<
  InputHttpPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputHttpMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputHttpCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputHttpPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputHttpPq$outboundSchema: z.ZodType<
  InputHttpPq$Outbound,
  z.ZodTypeDef,
  InputHttpPq
> = z.object({
  mode: InputHttpMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputHttpCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpPq$ {
  /** @deprecated use `InputHttpPq$inboundSchema` instead. */
  export const inboundSchema = InputHttpPq$inboundSchema;
  /** @deprecated use `InputHttpPq$outboundSchema` instead. */
  export const outboundSchema = InputHttpPq$outboundSchema;
  /** @deprecated use `InputHttpPq$Outbound` instead. */
  export type Outbound = InputHttpPq$Outbound;
}

export function inputHttpPqToJSON(inputHttpPq: InputHttpPq): string {
  return JSON.stringify(InputHttpPq$outboundSchema.parse(inputHttpPq));
}

export function inputHttpPqFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpPq' from JSON`,
  );
}

/** @internal */
export const InputHttpMinimumTLSVersion$inboundSchema: z.ZodType<
  InputHttpMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputHttpMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputHttpMinimumTLSVersion$outboundSchema: z.ZodType<
  InputHttpMinimumTLSVersion,
  z.ZodTypeDef,
  InputHttpMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputHttpMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpMinimumTLSVersion$ {
  /** @deprecated use `InputHttpMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputHttpMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputHttpMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputHttpMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputHttpMaximumTLSVersion$inboundSchema: z.ZodType<
  InputHttpMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputHttpMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputHttpMaximumTLSVersion$outboundSchema: z.ZodType<
  InputHttpMaximumTLSVersion,
  z.ZodTypeDef,
  InputHttpMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputHttpMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpMaximumTLSVersion$ {
  /** @deprecated use `InputHttpMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputHttpMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputHttpMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputHttpMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputHttpTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputHttpTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputHttpMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputHttpMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputHttpTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputHttpTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputHttpTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputHttpTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputHttpMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputHttpMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpTLSSettingsServerSide$ {
  /** @deprecated use `InputHttpTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputHttpTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputHttpTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema = InputHttpTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputHttpTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputHttpTLSSettingsServerSide$Outbound;
}

export function inputHttpTLSSettingsServerSideToJSON(
  inputHttpTLSSettingsServerSide: InputHttpTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputHttpTLSSettingsServerSide$outboundSchema.parse(
      inputHttpTLSSettingsServerSide,
    ),
  );
}

export function inputHttpTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputHttpMetadatum$inboundSchema: z.ZodType<
  InputHttpMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputHttpMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputHttpMetadatum$outboundSchema: z.ZodType<
  InputHttpMetadatum$Outbound,
  z.ZodTypeDef,
  InputHttpMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpMetadatum$ {
  /** @deprecated use `InputHttpMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputHttpMetadatum$inboundSchema;
  /** @deprecated use `InputHttpMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputHttpMetadatum$outboundSchema;
  /** @deprecated use `InputHttpMetadatum$Outbound` instead. */
  export type Outbound = InputHttpMetadatum$Outbound;
}

export function inputHttpMetadatumToJSON(
  inputHttpMetadatum: InputHttpMetadatum,
): string {
  return JSON.stringify(
    InputHttpMetadatum$outboundSchema.parse(inputHttpMetadatum),
  );
}

export function inputHttpMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpMetadatum' from JSON`,
  );
}

/** @internal */
export const InputHttpAuthTokensExtMetadatum$inboundSchema: z.ZodType<
  InputHttpAuthTokensExtMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputHttpAuthTokensExtMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputHttpAuthTokensExtMetadatum$outboundSchema: z.ZodType<
  InputHttpAuthTokensExtMetadatum$Outbound,
  z.ZodTypeDef,
  InputHttpAuthTokensExtMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpAuthTokensExtMetadatum$ {
  /** @deprecated use `InputHttpAuthTokensExtMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputHttpAuthTokensExtMetadatum$inboundSchema;
  /** @deprecated use `InputHttpAuthTokensExtMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputHttpAuthTokensExtMetadatum$outboundSchema;
  /** @deprecated use `InputHttpAuthTokensExtMetadatum$Outbound` instead. */
  export type Outbound = InputHttpAuthTokensExtMetadatum$Outbound;
}

export function inputHttpAuthTokensExtMetadatumToJSON(
  inputHttpAuthTokensExtMetadatum: InputHttpAuthTokensExtMetadatum,
): string {
  return JSON.stringify(
    InputHttpAuthTokensExtMetadatum$outboundSchema.parse(
      inputHttpAuthTokensExtMetadatum,
    ),
  );
}

export function inputHttpAuthTokensExtMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpAuthTokensExtMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpAuthTokensExtMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpAuthTokensExtMetadatum' from JSON`,
  );
}

/** @internal */
export const InputHttpAuthTokensExt$inboundSchema: z.ZodType<
  InputHttpAuthTokensExt,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  description: z.string().optional(),
  metadata: z.array(z.lazy(() => InputHttpAuthTokensExtMetadatum$inboundSchema))
    .optional(),
});

/** @internal */
export type InputHttpAuthTokensExt$Outbound = {
  token: string;
  description?: string | undefined;
  metadata?: Array<InputHttpAuthTokensExtMetadatum$Outbound> | undefined;
};

/** @internal */
export const InputHttpAuthTokensExt$outboundSchema: z.ZodType<
  InputHttpAuthTokensExt$Outbound,
  z.ZodTypeDef,
  InputHttpAuthTokensExt
> = z.object({
  token: z.string(),
  description: z.string().optional(),
  metadata: z.array(
    z.lazy(() => InputHttpAuthTokensExtMetadatum$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttpAuthTokensExt$ {
  /** @deprecated use `InputHttpAuthTokensExt$inboundSchema` instead. */
  export const inboundSchema = InputHttpAuthTokensExt$inboundSchema;
  /** @deprecated use `InputHttpAuthTokensExt$outboundSchema` instead. */
  export const outboundSchema = InputHttpAuthTokensExt$outboundSchema;
  /** @deprecated use `InputHttpAuthTokensExt$Outbound` instead. */
  export type Outbound = InputHttpAuthTokensExt$Outbound;
}

export function inputHttpAuthTokensExtToJSON(
  inputHttpAuthTokensExt: InputHttpAuthTokensExt,
): string {
  return JSON.stringify(
    InputHttpAuthTokensExt$outboundSchema.parse(inputHttpAuthTokensExt),
  );
}

export function inputHttpAuthTokensExtFromJSON(
  jsonString: string,
): SafeParseResult<InputHttpAuthTokensExt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttpAuthTokensExt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttpAuthTokensExt' from JSON`,
  );
}

/** @internal */
export const InputHttp$inboundSchema: z.ZodType<
  InputHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputHttpType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputHttpConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputHttpPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => InputHttpTLSSettingsServerSide$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  criblAPI: z.string().default("/cribl"),
  elasticAPI: z.string().default("/elastic"),
  splunkHecAPI: z.string().default("/services/collector"),
  splunkHecAcks: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputHttpMetadatum$inboundSchema)).optional(),
  authTokensExt: z.array(z.lazy(() => InputHttpAuthTokensExt$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputHttp$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputHttpConnection$Outbound> | undefined;
  pq?: InputHttpPq$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: InputHttpTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  criblAPI: string;
  elasticAPI: string;
  splunkHecAPI: string;
  splunkHecAcks: boolean;
  metadata?: Array<InputHttpMetadatum$Outbound> | undefined;
  authTokensExt?: Array<InputHttpAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttp$outboundSchema: z.ZodType<
  InputHttp$Outbound,
  z.ZodTypeDef,
  InputHttp
> = z.object({
  id: z.string(),
  type: InputHttpType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputHttpConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputHttpPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: z.lazy(() => InputHttpTLSSettingsServerSide$outboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  criblAPI: z.string().default("/cribl"),
  elasticAPI: z.string().default("/elastic"),
  splunkHecAPI: z.string().default("/services/collector"),
  splunkHecAcks: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputHttpMetadatum$outboundSchema)).optional(),
  authTokensExt: z.array(z.lazy(() => InputHttpAuthTokensExt$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputHttp$ {
  /** @deprecated use `InputHttp$inboundSchema` instead. */
  export const inboundSchema = InputHttp$inboundSchema;
  /** @deprecated use `InputHttp$outboundSchema` instead. */
  export const outboundSchema = InputHttp$outboundSchema;
  /** @deprecated use `InputHttp$Outbound` instead. */
  export type Outbound = InputHttp$Outbound;
}

export function inputHttpToJSON(inputHttp: InputHttp): string {
  return JSON.stringify(InputHttp$outboundSchema.parse(inputHttp));
}

export function inputHttpFromJSON(
  jsonString: string,
): SafeParseResult<InputHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputHttp' from JSON`,
  );
}

/** @internal */
export const InputMskType$inboundSchema: z.ZodType<
  InputMskType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMskType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMskType$outboundSchema: z.ZodType<
  InputMskType,
  z.ZodTypeDef,
  InputMskType
> = z.union([
  z.nativeEnum(InputMskType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskType$ {
  /** @deprecated use `InputMskType$inboundSchema` instead. */
  export const inboundSchema = InputMskType$inboundSchema;
  /** @deprecated use `InputMskType$outboundSchema` instead. */
  export const outboundSchema = InputMskType$outboundSchema;
}

/** @internal */
export const InputMskConnection$inboundSchema: z.ZodType<
  InputMskConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputMskConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputMskConnection$outboundSchema: z.ZodType<
  InputMskConnection$Outbound,
  z.ZodTypeDef,
  InputMskConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskConnection$ {
  /** @deprecated use `InputMskConnection$inboundSchema` instead. */
  export const inboundSchema = InputMskConnection$inboundSchema;
  /** @deprecated use `InputMskConnection$outboundSchema` instead. */
  export const outboundSchema = InputMskConnection$outboundSchema;
  /** @deprecated use `InputMskConnection$Outbound` instead. */
  export type Outbound = InputMskConnection$Outbound;
}

export function inputMskConnectionToJSON(
  inputMskConnection: InputMskConnection,
): string {
  return JSON.stringify(
    InputMskConnection$outboundSchema.parse(inputMskConnection),
  );
}

export function inputMskConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputMskConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMskConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMskConnection' from JSON`,
  );
}

/** @internal */
export const InputMskMode$inboundSchema: z.ZodType<
  InputMskMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMskMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMskMode$outboundSchema: z.ZodType<
  InputMskMode,
  z.ZodTypeDef,
  InputMskMode
> = z.union([
  z.nativeEnum(InputMskMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskMode$ {
  /** @deprecated use `InputMskMode$inboundSchema` instead. */
  export const inboundSchema = InputMskMode$inboundSchema;
  /** @deprecated use `InputMskMode$outboundSchema` instead. */
  export const outboundSchema = InputMskMode$outboundSchema;
}

/** @internal */
export const InputMskCompression$inboundSchema: z.ZodType<
  InputMskCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMskCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMskCompression$outboundSchema: z.ZodType<
  InputMskCompression,
  z.ZodTypeDef,
  InputMskCompression
> = z.union([
  z.nativeEnum(InputMskCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskCompression$ {
  /** @deprecated use `InputMskCompression$inboundSchema` instead. */
  export const inboundSchema = InputMskCompression$inboundSchema;
  /** @deprecated use `InputMskCompression$outboundSchema` instead. */
  export const outboundSchema = InputMskCompression$outboundSchema;
}

/** @internal */
export const InputMskPq$inboundSchema: z.ZodType<
  InputMskPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputMskMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputMskCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputMskPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputMskPq$outboundSchema: z.ZodType<
  InputMskPq$Outbound,
  z.ZodTypeDef,
  InputMskPq
> = z.object({
  mode: InputMskMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputMskCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskPq$ {
  /** @deprecated use `InputMskPq$inboundSchema` instead. */
  export const inboundSchema = InputMskPq$inboundSchema;
  /** @deprecated use `InputMskPq$outboundSchema` instead. */
  export const outboundSchema = InputMskPq$outboundSchema;
  /** @deprecated use `InputMskPq$Outbound` instead. */
  export type Outbound = InputMskPq$Outbound;
}

export function inputMskPqToJSON(inputMskPq: InputMskPq): string {
  return JSON.stringify(InputMskPq$outboundSchema.parse(inputMskPq));
}

export function inputMskPqFromJSON(
  jsonString: string,
): SafeParseResult<InputMskPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMskPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMskPq' from JSON`,
  );
}

/** @internal */
export const InputMskMetadatum$inboundSchema: z.ZodType<
  InputMskMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputMskMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputMskMetadatum$outboundSchema: z.ZodType<
  InputMskMetadatum$Outbound,
  z.ZodTypeDef,
  InputMskMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskMetadatum$ {
  /** @deprecated use `InputMskMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputMskMetadatum$inboundSchema;
  /** @deprecated use `InputMskMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputMskMetadatum$outboundSchema;
  /** @deprecated use `InputMskMetadatum$Outbound` instead. */
  export type Outbound = InputMskMetadatum$Outbound;
}

export function inputMskMetadatumToJSON(
  inputMskMetadatum: InputMskMetadatum,
): string {
  return JSON.stringify(
    InputMskMetadatum$outboundSchema.parse(inputMskMetadatum),
  );
}

export function inputMskMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputMskMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMskMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMskMetadatum' from JSON`,
  );
}

/** @internal */
export const InputMskAuth$inboundSchema: z.ZodType<
  InputMskAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type InputMskAuth$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputMskAuth$outboundSchema: z.ZodType<
  InputMskAuth$Outbound,
  z.ZodTypeDef,
  InputMskAuth
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskAuth$ {
  /** @deprecated use `InputMskAuth$inboundSchema` instead. */
  export const inboundSchema = InputMskAuth$inboundSchema;
  /** @deprecated use `InputMskAuth$outboundSchema` instead. */
  export const outboundSchema = InputMskAuth$outboundSchema;
  /** @deprecated use `InputMskAuth$Outbound` instead. */
  export type Outbound = InputMskAuth$Outbound;
}

export function inputMskAuthToJSON(inputMskAuth: InputMskAuth): string {
  return JSON.stringify(InputMskAuth$outboundSchema.parse(inputMskAuth));
}

export function inputMskAuthFromJSON(
  jsonString: string,
): SafeParseResult<InputMskAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMskAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMskAuth' from JSON`,
  );
}

/** @internal */
export const InputMskKafkaSchemaRegistryMinimumTLSVersion$inboundSchema:
  z.ZodType<
    InputMskKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(InputMskKafkaSchemaRegistryMinimumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const InputMskKafkaSchemaRegistryMinimumTLSVersion$outboundSchema:
  z.ZodType<
    InputMskKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    InputMskKafkaSchemaRegistryMinimumTLSVersion
  > = z.union([
    z.nativeEnum(InputMskKafkaSchemaRegistryMinimumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskKafkaSchemaRegistryMinimumTLSVersion$ {
  /** @deprecated use `InputMskKafkaSchemaRegistryMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputMskKafkaSchemaRegistryMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputMskKafkaSchemaRegistryMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputMskKafkaSchemaRegistryMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputMskKafkaSchemaRegistryMaximumTLSVersion$inboundSchema:
  z.ZodType<
    InputMskKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(InputMskKafkaSchemaRegistryMaximumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const InputMskKafkaSchemaRegistryMaximumTLSVersion$outboundSchema:
  z.ZodType<
    InputMskKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    InputMskKafkaSchemaRegistryMaximumTLSVersion
  > = z.union([
    z.nativeEnum(InputMskKafkaSchemaRegistryMaximumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskKafkaSchemaRegistryMaximumTLSVersion$ {
  /** @deprecated use `InputMskKafkaSchemaRegistryMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputMskKafkaSchemaRegistryMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputMskKafkaSchemaRegistryMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputMskKafkaSchemaRegistryMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputMskKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema:
  z.ZodType<
    InputMskKafkaSchemaRegistryTLSSettingsClientSide,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: InputMskKafkaSchemaRegistryMinimumTLSVersion$inboundSchema
      .optional(),
    maxVersion: InputMskKafkaSchemaRegistryMaximumTLSVersion$inboundSchema
      .optional(),
  });

/** @internal */
export type InputMskKafkaSchemaRegistryTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputMskKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema:
  z.ZodType<
    InputMskKafkaSchemaRegistryTLSSettingsClientSide$Outbound,
    z.ZodTypeDef,
    InputMskKafkaSchemaRegistryTLSSettingsClientSide
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: InputMskKafkaSchemaRegistryMinimumTLSVersion$outboundSchema
      .optional(),
    maxVersion: InputMskKafkaSchemaRegistryMaximumTLSVersion$outboundSchema
      .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskKafkaSchemaRegistryTLSSettingsClientSide$ {
  /** @deprecated use `InputMskKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    InputMskKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `InputMskKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    InputMskKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `InputMskKafkaSchemaRegistryTLSSettingsClientSide$Outbound` instead. */
  export type Outbound =
    InputMskKafkaSchemaRegistryTLSSettingsClientSide$Outbound;
}

export function inputMskKafkaSchemaRegistryTLSSettingsClientSideToJSON(
  inputMskKafkaSchemaRegistryTLSSettingsClientSide:
    InputMskKafkaSchemaRegistryTLSSettingsClientSide,
): string {
  return JSON.stringify(
    InputMskKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema.parse(
      inputMskKafkaSchemaRegistryTLSSettingsClientSide,
    ),
  );
}

export function inputMskKafkaSchemaRegistryTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  InputMskKafkaSchemaRegistryTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputMskKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputMskKafkaSchemaRegistryTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const InputMskKafkaSchemaRegistryAuthentication$inboundSchema: z.ZodType<
  InputMskKafkaSchemaRegistryAuthentication,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  schemaRegistryURL: z.string().default("http://localhost:8081"),
  connectionTimeout: z.number().default(30000),
  requestTimeout: z.number().default(30000),
  maxRetries: z.number().default(1),
  auth: z.lazy(() => InputMskAuth$inboundSchema).optional(),
  tls: z.lazy(() =>
    InputMskKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema
  ).optional(),
});

/** @internal */
export type InputMskKafkaSchemaRegistryAuthentication$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: InputMskAuth$Outbound | undefined;
  tls?: InputMskKafkaSchemaRegistryTLSSettingsClientSide$Outbound | undefined;
};

/** @internal */
export const InputMskKafkaSchemaRegistryAuthentication$outboundSchema:
  z.ZodType<
    InputMskKafkaSchemaRegistryAuthentication$Outbound,
    z.ZodTypeDef,
    InputMskKafkaSchemaRegistryAuthentication
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => InputMskAuth$outboundSchema).optional(),
    tls: z.lazy(() =>
      InputMskKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema
    ).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskKafkaSchemaRegistryAuthentication$ {
  /** @deprecated use `InputMskKafkaSchemaRegistryAuthentication$inboundSchema` instead. */
  export const inboundSchema =
    InputMskKafkaSchemaRegistryAuthentication$inboundSchema;
  /** @deprecated use `InputMskKafkaSchemaRegistryAuthentication$outboundSchema` instead. */
  export const outboundSchema =
    InputMskKafkaSchemaRegistryAuthentication$outboundSchema;
  /** @deprecated use `InputMskKafkaSchemaRegistryAuthentication$Outbound` instead. */
  export type Outbound = InputMskKafkaSchemaRegistryAuthentication$Outbound;
}

export function inputMskKafkaSchemaRegistryAuthenticationToJSON(
  inputMskKafkaSchemaRegistryAuthentication:
    InputMskKafkaSchemaRegistryAuthentication,
): string {
  return JSON.stringify(
    InputMskKafkaSchemaRegistryAuthentication$outboundSchema.parse(
      inputMskKafkaSchemaRegistryAuthentication,
    ),
  );
}

export function inputMskKafkaSchemaRegistryAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<
  InputMskKafkaSchemaRegistryAuthentication,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputMskKafkaSchemaRegistryAuthentication$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputMskKafkaSchemaRegistryAuthentication' from JSON`,
  );
}

/** @internal */
export const InputMskAuthenticationMethod$inboundSchema: z.ZodType<
  InputMskAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMskAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMskAuthenticationMethod$outboundSchema: z.ZodType<
  InputMskAuthenticationMethod,
  z.ZodTypeDef,
  InputMskAuthenticationMethod
> = z.union([
  z.nativeEnum(InputMskAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskAuthenticationMethod$ {
  /** @deprecated use `InputMskAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputMskAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputMskAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = InputMskAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputMskSignatureVersion$inboundSchema: z.ZodType<
  InputMskSignatureVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMskSignatureVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMskSignatureVersion$outboundSchema: z.ZodType<
  InputMskSignatureVersion,
  z.ZodTypeDef,
  InputMskSignatureVersion
> = z.union([
  z.nativeEnum(InputMskSignatureVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskSignatureVersion$ {
  /** @deprecated use `InputMskSignatureVersion$inboundSchema` instead. */
  export const inboundSchema = InputMskSignatureVersion$inboundSchema;
  /** @deprecated use `InputMskSignatureVersion$outboundSchema` instead. */
  export const outboundSchema = InputMskSignatureVersion$outboundSchema;
}

/** @internal */
export const InputMskMinimumTLSVersion$inboundSchema: z.ZodType<
  InputMskMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMskMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMskMinimumTLSVersion$outboundSchema: z.ZodType<
  InputMskMinimumTLSVersion,
  z.ZodTypeDef,
  InputMskMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputMskMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskMinimumTLSVersion$ {
  /** @deprecated use `InputMskMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputMskMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputMskMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputMskMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputMskMaximumTLSVersion$inboundSchema: z.ZodType<
  InputMskMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMskMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMskMaximumTLSVersion$outboundSchema: z.ZodType<
  InputMskMaximumTLSVersion,
  z.ZodTypeDef,
  InputMskMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputMskMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskMaximumTLSVersion$ {
  /** @deprecated use `InputMskMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputMskMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputMskMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputMskMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputMskTLSSettingsClientSide$inboundSchema: z.ZodType<
  InputMskTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: InputMskMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputMskMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputMskTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputMskTLSSettingsClientSide$outboundSchema: z.ZodType<
  InputMskTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  InputMskTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(false),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: InputMskMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputMskMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMskTLSSettingsClientSide$ {
  /** @deprecated use `InputMskTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema = InputMskTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `InputMskTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema = InputMskTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `InputMskTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = InputMskTLSSettingsClientSide$Outbound;
}

export function inputMskTLSSettingsClientSideToJSON(
  inputMskTLSSettingsClientSide: InputMskTLSSettingsClientSide,
): string {
  return JSON.stringify(
    InputMskTLSSettingsClientSide$outboundSchema.parse(
      inputMskTLSSettingsClientSide,
    ),
  );
}

export function inputMskTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<InputMskTLSSettingsClientSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMskTLSSettingsClientSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMskTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const InputMsk$inboundSchema: z.ZodType<
  InputMsk,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputMskType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputMskConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputMskPq$inboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  metadata: z.array(z.lazy(() => InputMskMetadatum$inboundSchema)).optional(),
  kafkaSchemaRegistry: z.lazy(() =>
    InputMskKafkaSchemaRegistryAuthentication$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  awsAuthenticationMethod: InputMskAuthenticationMethod$inboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: InputMskSignatureVersion$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  tls: z.lazy(() => InputMskTLSSettingsClientSide$inboundSchema).optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/** @internal */
export type InputMsk$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputMskConnection$Outbound> | undefined;
  pq?: InputMskPq$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId: string;
  fromBeginning: boolean;
  sessionTimeout: number;
  rebalanceTimeout: number;
  heartbeatInterval: number;
  metadata?: Array<InputMskMetadatum$Outbound> | undefined;
  kafkaSchemaRegistry?:
    | InputMskKafkaSchemaRegistryAuthentication$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  tls?: InputMskTLSSettingsClientSide$Outbound | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition: number;
  maxBytes: number;
  maxSocketErrors: number;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputMsk$outboundSchema: z.ZodType<
  InputMsk$Outbound,
  z.ZodTypeDef,
  InputMsk
> = z.object({
  id: z.string(),
  type: InputMskType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputMskConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputMskPq$outboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  metadata: z.array(z.lazy(() => InputMskMetadatum$outboundSchema)).optional(),
  kafkaSchemaRegistry: z.lazy(() =>
    InputMskKafkaSchemaRegistryAuthentication$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  awsAuthenticationMethod: InputMskAuthenticationMethod$outboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: InputMskSignatureVersion$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  tls: z.lazy(() => InputMskTLSSettingsClientSide$outboundSchema).optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMsk$ {
  /** @deprecated use `InputMsk$inboundSchema` instead. */
  export const inboundSchema = InputMsk$inboundSchema;
  /** @deprecated use `InputMsk$outboundSchema` instead. */
  export const outboundSchema = InputMsk$outboundSchema;
  /** @deprecated use `InputMsk$Outbound` instead. */
  export type Outbound = InputMsk$Outbound;
}

export function inputMskToJSON(inputMsk: InputMsk): string {
  return JSON.stringify(InputMsk$outboundSchema.parse(inputMsk));
}

export function inputMskFromJSON(
  jsonString: string,
): SafeParseResult<InputMsk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMsk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMsk' from JSON`,
  );
}

/** @internal */
export const InputKafkaType$inboundSchema: z.ZodType<
  InputKafkaType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputKafkaType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputKafkaType$outboundSchema: z.ZodType<
  InputKafkaType,
  z.ZodTypeDef,
  InputKafkaType
> = z.union([
  z.nativeEnum(InputKafkaType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaType$ {
  /** @deprecated use `InputKafkaType$inboundSchema` instead. */
  export const inboundSchema = InputKafkaType$inboundSchema;
  /** @deprecated use `InputKafkaType$outboundSchema` instead. */
  export const outboundSchema = InputKafkaType$outboundSchema;
}

/** @internal */
export const InputKafkaConnection$inboundSchema: z.ZodType<
  InputKafkaConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputKafkaConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputKafkaConnection$outboundSchema: z.ZodType<
  InputKafkaConnection$Outbound,
  z.ZodTypeDef,
  InputKafkaConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaConnection$ {
  /** @deprecated use `InputKafkaConnection$inboundSchema` instead. */
  export const inboundSchema = InputKafkaConnection$inboundSchema;
  /** @deprecated use `InputKafkaConnection$outboundSchema` instead. */
  export const outboundSchema = InputKafkaConnection$outboundSchema;
  /** @deprecated use `InputKafkaConnection$Outbound` instead. */
  export type Outbound = InputKafkaConnection$Outbound;
}

export function inputKafkaConnectionToJSON(
  inputKafkaConnection: InputKafkaConnection,
): string {
  return JSON.stringify(
    InputKafkaConnection$outboundSchema.parse(inputKafkaConnection),
  );
}

export function inputKafkaConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputKafkaConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKafkaConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKafkaConnection' from JSON`,
  );
}

/** @internal */
export const InputKafkaMode$inboundSchema: z.ZodType<
  InputKafkaMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputKafkaMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputKafkaMode$outboundSchema: z.ZodType<
  InputKafkaMode,
  z.ZodTypeDef,
  InputKafkaMode
> = z.union([
  z.nativeEnum(InputKafkaMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaMode$ {
  /** @deprecated use `InputKafkaMode$inboundSchema` instead. */
  export const inboundSchema = InputKafkaMode$inboundSchema;
  /** @deprecated use `InputKafkaMode$outboundSchema` instead. */
  export const outboundSchema = InputKafkaMode$outboundSchema;
}

/** @internal */
export const InputKafkaCompression$inboundSchema: z.ZodType<
  InputKafkaCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputKafkaCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputKafkaCompression$outboundSchema: z.ZodType<
  InputKafkaCompression,
  z.ZodTypeDef,
  InputKafkaCompression
> = z.union([
  z.nativeEnum(InputKafkaCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaCompression$ {
  /** @deprecated use `InputKafkaCompression$inboundSchema` instead. */
  export const inboundSchema = InputKafkaCompression$inboundSchema;
  /** @deprecated use `InputKafkaCompression$outboundSchema` instead. */
  export const outboundSchema = InputKafkaCompression$outboundSchema;
}

/** @internal */
export const InputKafkaPq$inboundSchema: z.ZodType<
  InputKafkaPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputKafkaMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputKafkaCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputKafkaPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputKafkaPq$outboundSchema: z.ZodType<
  InputKafkaPq$Outbound,
  z.ZodTypeDef,
  InputKafkaPq
> = z.object({
  mode: InputKafkaMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputKafkaCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaPq$ {
  /** @deprecated use `InputKafkaPq$inboundSchema` instead. */
  export const inboundSchema = InputKafkaPq$inboundSchema;
  /** @deprecated use `InputKafkaPq$outboundSchema` instead. */
  export const outboundSchema = InputKafkaPq$outboundSchema;
  /** @deprecated use `InputKafkaPq$Outbound` instead. */
  export type Outbound = InputKafkaPq$Outbound;
}

export function inputKafkaPqToJSON(inputKafkaPq: InputKafkaPq): string {
  return JSON.stringify(InputKafkaPq$outboundSchema.parse(inputKafkaPq));
}

export function inputKafkaPqFromJSON(
  jsonString: string,
): SafeParseResult<InputKafkaPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKafkaPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKafkaPq' from JSON`,
  );
}

/** @internal */
export const InputKafkaAuth$inboundSchema: z.ZodType<
  InputKafkaAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/** @internal */
export type InputKafkaAuth$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputKafkaAuth$outboundSchema: z.ZodType<
  InputKafkaAuth$Outbound,
  z.ZodTypeDef,
  InputKafkaAuth
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaAuth$ {
  /** @deprecated use `InputKafkaAuth$inboundSchema` instead. */
  export const inboundSchema = InputKafkaAuth$inboundSchema;
  /** @deprecated use `InputKafkaAuth$outboundSchema` instead. */
  export const outboundSchema = InputKafkaAuth$outboundSchema;
  /** @deprecated use `InputKafkaAuth$Outbound` instead. */
  export type Outbound = InputKafkaAuth$Outbound;
}

export function inputKafkaAuthToJSON(inputKafkaAuth: InputKafkaAuth): string {
  return JSON.stringify(InputKafkaAuth$outboundSchema.parse(inputKafkaAuth));
}

export function inputKafkaAuthFromJSON(
  jsonString: string,
): SafeParseResult<InputKafkaAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKafkaAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKafkaAuth' from JSON`,
  );
}

/** @internal */
export const InputKafkaKafkaSchemaRegistryMinimumTLSVersion$inboundSchema:
  z.ZodType<
    InputKafkaKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(InputKafkaKafkaSchemaRegistryMinimumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const InputKafkaKafkaSchemaRegistryMinimumTLSVersion$outboundSchema:
  z.ZodType<
    InputKafkaKafkaSchemaRegistryMinimumTLSVersion,
    z.ZodTypeDef,
    InputKafkaKafkaSchemaRegistryMinimumTLSVersion
  > = z.union([
    z.nativeEnum(InputKafkaKafkaSchemaRegistryMinimumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaKafkaSchemaRegistryMinimumTLSVersion$ {
  /** @deprecated use `InputKafkaKafkaSchemaRegistryMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputKafkaKafkaSchemaRegistryMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputKafkaKafkaSchemaRegistryMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputKafkaKafkaSchemaRegistryMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputKafkaKafkaSchemaRegistryMaximumTLSVersion$inboundSchema:
  z.ZodType<
    InputKafkaKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    unknown
  > = z
    .union([
      z.nativeEnum(InputKafkaKafkaSchemaRegistryMaximumTLSVersion),
      z.string().transform(catchUnrecognizedEnum),
    ]);

/** @internal */
export const InputKafkaKafkaSchemaRegistryMaximumTLSVersion$outboundSchema:
  z.ZodType<
    InputKafkaKafkaSchemaRegistryMaximumTLSVersion,
    z.ZodTypeDef,
    InputKafkaKafkaSchemaRegistryMaximumTLSVersion
  > = z.union([
    z.nativeEnum(InputKafkaKafkaSchemaRegistryMaximumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaKafkaSchemaRegistryMaximumTLSVersion$ {
  /** @deprecated use `InputKafkaKafkaSchemaRegistryMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema =
    InputKafkaKafkaSchemaRegistryMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputKafkaKafkaSchemaRegistryMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema =
    InputKafkaKafkaSchemaRegistryMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema:
  z.ZodType<
    InputKafkaKafkaSchemaRegistryTLSSettingsClientSide,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: InputKafkaKafkaSchemaRegistryMinimumTLSVersion$inboundSchema
      .optional(),
    maxVersion: InputKafkaKafkaSchemaRegistryMaximumTLSVersion$inboundSchema
      .optional(),
  });

/** @internal */
export type InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema:
  z.ZodType<
    InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$Outbound,
    z.ZodTypeDef,
    InputKafkaKafkaSchemaRegistryTLSSettingsClientSide
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: InputKafkaKafkaSchemaRegistryMinimumTLSVersion$outboundSchema
      .optional(),
    maxVersion: InputKafkaKafkaSchemaRegistryMaximumTLSVersion$outboundSchema
      .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$ {
  /** @deprecated use `InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema =
    InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema =
    InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$Outbound` instead. */
  export type Outbound =
    InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$Outbound;
}

export function inputKafkaKafkaSchemaRegistryTLSSettingsClientSideToJSON(
  inputKafkaKafkaSchemaRegistryTLSSettingsClientSide:
    InputKafkaKafkaSchemaRegistryTLSSettingsClientSide,
): string {
  return JSON.stringify(
    InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema.parse(
      inputKafkaKafkaSchemaRegistryTLSSettingsClientSide,
    ),
  );
}

export function inputKafkaKafkaSchemaRegistryTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  InputKafkaKafkaSchemaRegistryTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputKafkaKafkaSchemaRegistryTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const InputKafkaKafkaSchemaRegistryAuthentication$inboundSchema:
  z.ZodType<
    InputKafkaKafkaSchemaRegistryAuthentication,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => InputKafkaAuth$inboundSchema).optional(),
    tls: z.lazy(() =>
      InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$inboundSchema
    ).optional(),
  });

/** @internal */
export type InputKafkaKafkaSchemaRegistryAuthentication$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: InputKafkaAuth$Outbound | undefined;
  tls?: InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$Outbound | undefined;
};

/** @internal */
export const InputKafkaKafkaSchemaRegistryAuthentication$outboundSchema:
  z.ZodType<
    InputKafkaKafkaSchemaRegistryAuthentication$Outbound,
    z.ZodTypeDef,
    InputKafkaKafkaSchemaRegistryAuthentication
  > = z.object({
    disabled: z.boolean().default(true),
    schemaRegistryURL: z.string().default("http://localhost:8081"),
    connectionTimeout: z.number().default(30000),
    requestTimeout: z.number().default(30000),
    maxRetries: z.number().default(1),
    auth: z.lazy(() => InputKafkaAuth$outboundSchema).optional(),
    tls: z.lazy(() =>
      InputKafkaKafkaSchemaRegistryTLSSettingsClientSide$outboundSchema
    ).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaKafkaSchemaRegistryAuthentication$ {
  /** @deprecated use `InputKafkaKafkaSchemaRegistryAuthentication$inboundSchema` instead. */
  export const inboundSchema =
    InputKafkaKafkaSchemaRegistryAuthentication$inboundSchema;
  /** @deprecated use `InputKafkaKafkaSchemaRegistryAuthentication$outboundSchema` instead. */
  export const outboundSchema =
    InputKafkaKafkaSchemaRegistryAuthentication$outboundSchema;
  /** @deprecated use `InputKafkaKafkaSchemaRegistryAuthentication$Outbound` instead. */
  export type Outbound = InputKafkaKafkaSchemaRegistryAuthentication$Outbound;
}

export function inputKafkaKafkaSchemaRegistryAuthenticationToJSON(
  inputKafkaKafkaSchemaRegistryAuthentication:
    InputKafkaKafkaSchemaRegistryAuthentication,
): string {
  return JSON.stringify(
    InputKafkaKafkaSchemaRegistryAuthentication$outboundSchema.parse(
      inputKafkaKafkaSchemaRegistryAuthentication,
    ),
  );
}

export function inputKafkaKafkaSchemaRegistryAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<
  InputKafkaKafkaSchemaRegistryAuthentication,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputKafkaKafkaSchemaRegistryAuthentication$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputKafkaKafkaSchemaRegistryAuthentication' from JSON`,
  );
}

/** @internal */
export const InputKafkaSASLMechanism$inboundSchema: z.ZodType<
  InputKafkaSASLMechanism,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputKafkaSASLMechanism),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputKafkaSASLMechanism$outboundSchema: z.ZodType<
  InputKafkaSASLMechanism,
  z.ZodTypeDef,
  InputKafkaSASLMechanism
> = z.union([
  z.nativeEnum(InputKafkaSASLMechanism),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaSASLMechanism$ {
  /** @deprecated use `InputKafkaSASLMechanism$inboundSchema` instead. */
  export const inboundSchema = InputKafkaSASLMechanism$inboundSchema;
  /** @deprecated use `InputKafkaSASLMechanism$outboundSchema` instead. */
  export const outboundSchema = InputKafkaSASLMechanism$outboundSchema;
}

/** @internal */
export const InputKafkaAuthentication$inboundSchema: z.ZodType<
  InputKafkaAuthentication,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: InputKafkaSASLMechanism$inboundSchema.default("plain"),
});

/** @internal */
export type InputKafkaAuthentication$Outbound = {
  disabled: boolean;
  mechanism: string;
};

/** @internal */
export const InputKafkaAuthentication$outboundSchema: z.ZodType<
  InputKafkaAuthentication$Outbound,
  z.ZodTypeDef,
  InputKafkaAuthentication
> = z.object({
  disabled: z.boolean().default(true),
  mechanism: InputKafkaSASLMechanism$outboundSchema.default("plain"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaAuthentication$ {
  /** @deprecated use `InputKafkaAuthentication$inboundSchema` instead. */
  export const inboundSchema = InputKafkaAuthentication$inboundSchema;
  /** @deprecated use `InputKafkaAuthentication$outboundSchema` instead. */
  export const outboundSchema = InputKafkaAuthentication$outboundSchema;
  /** @deprecated use `InputKafkaAuthentication$Outbound` instead. */
  export type Outbound = InputKafkaAuthentication$Outbound;
}

export function inputKafkaAuthenticationToJSON(
  inputKafkaAuthentication: InputKafkaAuthentication,
): string {
  return JSON.stringify(
    InputKafkaAuthentication$outboundSchema.parse(inputKafkaAuthentication),
  );
}

export function inputKafkaAuthenticationFromJSON(
  jsonString: string,
): SafeParseResult<InputKafkaAuthentication, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKafkaAuthentication$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKafkaAuthentication' from JSON`,
  );
}

/** @internal */
export const InputKafkaMinimumTLSVersion$inboundSchema: z.ZodType<
  InputKafkaMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputKafkaMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputKafkaMinimumTLSVersion$outboundSchema: z.ZodType<
  InputKafkaMinimumTLSVersion,
  z.ZodTypeDef,
  InputKafkaMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputKafkaMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaMinimumTLSVersion$ {
  /** @deprecated use `InputKafkaMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputKafkaMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputKafkaMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputKafkaMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputKafkaMaximumTLSVersion$inboundSchema: z.ZodType<
  InputKafkaMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputKafkaMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputKafkaMaximumTLSVersion$outboundSchema: z.ZodType<
  InputKafkaMaximumTLSVersion,
  z.ZodTypeDef,
  InputKafkaMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputKafkaMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaMaximumTLSVersion$ {
  /** @deprecated use `InputKafkaMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputKafkaMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputKafkaMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputKafkaMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputKafkaTLSSettingsClientSide$inboundSchema: z.ZodType<
  InputKafkaTLSSettingsClientSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: InputKafkaMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputKafkaMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputKafkaTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputKafkaTLSSettingsClientSide$outboundSchema: z.ZodType<
  InputKafkaTLSSettingsClientSide$Outbound,
  z.ZodTypeDef,
  InputKafkaTLSSettingsClientSide
> = z.object({
  disabled: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  servername: z.string().optional(),
  certificateName: z.string().optional(),
  caPath: z.string().optional(),
  privKeyPath: z.string().optional(),
  certPath: z.string().optional(),
  passphrase: z.string().optional(),
  minVersion: InputKafkaMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputKafkaMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaTLSSettingsClientSide$ {
  /** @deprecated use `InputKafkaTLSSettingsClientSide$inboundSchema` instead. */
  export const inboundSchema = InputKafkaTLSSettingsClientSide$inboundSchema;
  /** @deprecated use `InputKafkaTLSSettingsClientSide$outboundSchema` instead. */
  export const outboundSchema = InputKafkaTLSSettingsClientSide$outboundSchema;
  /** @deprecated use `InputKafkaTLSSettingsClientSide$Outbound` instead. */
  export type Outbound = InputKafkaTLSSettingsClientSide$Outbound;
}

export function inputKafkaTLSSettingsClientSideToJSON(
  inputKafkaTLSSettingsClientSide: InputKafkaTLSSettingsClientSide,
): string {
  return JSON.stringify(
    InputKafkaTLSSettingsClientSide$outboundSchema.parse(
      inputKafkaTLSSettingsClientSide,
    ),
  );
}

export function inputKafkaTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<InputKafkaTLSSettingsClientSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKafkaTLSSettingsClientSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKafkaTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const InputKafkaMetadatum$inboundSchema: z.ZodType<
  InputKafkaMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputKafkaMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputKafkaMetadatum$outboundSchema: z.ZodType<
  InputKafkaMetadatum$Outbound,
  z.ZodTypeDef,
  InputKafkaMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafkaMetadatum$ {
  /** @deprecated use `InputKafkaMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputKafkaMetadatum$inboundSchema;
  /** @deprecated use `InputKafkaMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputKafkaMetadatum$outboundSchema;
  /** @deprecated use `InputKafkaMetadatum$Outbound` instead. */
  export type Outbound = InputKafkaMetadatum$Outbound;
}

export function inputKafkaMetadatumToJSON(
  inputKafkaMetadatum: InputKafkaMetadatum,
): string {
  return JSON.stringify(
    InputKafkaMetadatum$outboundSchema.parse(inputKafkaMetadatum),
  );
}

export function inputKafkaMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputKafkaMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKafkaMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKafkaMetadatum' from JSON`,
  );
}

/** @internal */
export const InputKafka$inboundSchema: z.ZodType<
  InputKafka,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: InputKafkaType$inboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputKafkaConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputKafkaPq$inboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  kafkaSchemaRegistry: z.lazy(() =>
    InputKafkaKafkaSchemaRegistryAuthentication$inboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => InputKafkaAuthentication$inboundSchema).optional(),
  tls: z.lazy(() => InputKafkaTLSSettingsClientSide$inboundSchema).optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  metadata: z.array(z.lazy(() => InputKafkaMetadatum$inboundSchema)).optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputKafka$Outbound = {
  id: string;
  type?: string | undefined;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputKafkaConnection$Outbound> | undefined;
  pq?: InputKafkaPq$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId: string;
  fromBeginning: boolean;
  kafkaSchemaRegistry?:
    | InputKafkaKafkaSchemaRegistryAuthentication$Outbound
    | undefined;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  maxBackOff: number;
  initialBackoff: number;
  backoffRate: number;
  authenticationTimeout: number;
  reauthenticationThreshold: number;
  sasl?: InputKafkaAuthentication$Outbound | undefined;
  tls?: InputKafkaTLSSettingsClientSide$Outbound | undefined;
  sessionTimeout: number;
  rebalanceTimeout: number;
  heartbeatInterval: number;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition: number;
  maxBytes: number;
  maxSocketErrors: number;
  metadata?: Array<InputKafkaMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKafka$outboundSchema: z.ZodType<
  InputKafka$Outbound,
  z.ZodTypeDef,
  InputKafka
> = z.object({
  id: z.string(),
  type: InputKafkaType$outboundSchema.optional(),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputKafkaConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputKafkaPq$outboundSchema).optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().default("Cribl"),
  fromBeginning: z.boolean().default(true),
  kafkaSchemaRegistry: z.lazy(() =>
    InputKafkaKafkaSchemaRegistryAuthentication$outboundSchema
  ).optional(),
  connectionTimeout: z.number().default(10000),
  requestTimeout: z.number().default(60000),
  maxRetries: z.number().default(5),
  maxBackOff: z.number().default(30000),
  initialBackoff: z.number().default(300),
  backoffRate: z.number().default(2),
  authenticationTimeout: z.number().default(10000),
  reauthenticationThreshold: z.number().default(10000),
  sasl: z.lazy(() => InputKafkaAuthentication$outboundSchema).optional(),
  tls: z.lazy(() => InputKafkaTLSSettingsClientSide$outboundSchema).optional(),
  sessionTimeout: z.number().default(30000),
  rebalanceTimeout: z.number().default(60000),
  heartbeatInterval: z.number().default(3000),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().default(1048576),
  maxBytes: z.number().default(10485760),
  maxSocketErrors: z.number().default(0),
  metadata: z.array(z.lazy(() => InputKafkaMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputKafka$ {
  /** @deprecated use `InputKafka$inboundSchema` instead. */
  export const inboundSchema = InputKafka$inboundSchema;
  /** @deprecated use `InputKafka$outboundSchema` instead. */
  export const outboundSchema = InputKafka$outboundSchema;
  /** @deprecated use `InputKafka$Outbound` instead. */
  export type Outbound = InputKafka$Outbound;
}

export function inputKafkaToJSON(inputKafka: InputKafka): string {
  return JSON.stringify(InputKafka$outboundSchema.parse(inputKafka));
}

export function inputKafkaFromJSON(
  jsonString: string,
): SafeParseResult<InputKafka, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKafka$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKafka' from JSON`,
  );
}

/** @internal */
export const CreateInputRequest$inboundSchema: z.ZodType<
  CreateInputRequest,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputMsk$inboundSchema),
  z.lazy(() => InputWiz$inboundSchema),
  z.lazy(() => InputKafka$inboundSchema),
  z.lazy(() => InputAzureBlob$inboundSchema),
  z.lazy(() => InputConfluentCloud$inboundSchema),
  z.lazy(() => InputOffice365Mgmt$inboundSchema),
  z.lazy(() => InputOffice365Service$inboundSchema),
  z.lazy(() => InputEventhub$inboundSchema),
  z.lazy(() => InputExec$inboundSchema),
  z.lazy(() => InputGooglePubsub$inboundSchema),
  z.lazy(() => InputCrowdstrike$inboundSchema),
  z.lazy(() => InputDatagen$inboundSchema),
  z.lazy(() => InputKinesis$inboundSchema),
  z.lazy(() => InputS3$inboundSchema),
  z.lazy(() => InputS3Inventory$inboundSchema),
  z.lazy(() => InputWinEventLogs$inboundSchema),
  z.lazy(() => InputJournalFiles$inboundSchema),
  z.lazy(() => InputSecurityLake$inboundSchema),
  z.lazy(() => InputHttp$inboundSchema),
  z.lazy(() => InputSplunk$inboundSchema),
  z.lazy(() => InputSplunkSearch$inboundSchema),
  z.lazy(() => InputSplunkHec$inboundSchema),
  z.lazy(() => InputElastic$inboundSchema),
  z.lazy(() => InputLoki$inboundSchema),
  z.lazy(() => InputPrometheusRw$inboundSchema),
  z.lazy(() => InputFirehose$inboundSchema),
  models.InputCribl$inboundSchema,
  z.lazy(() => InputCriblTcp$inboundSchema),
  z.lazy(() => InputCriblHttp$inboundSchema),
  z.lazy(() => InputCriblLakeHttp$inboundSchema),
  z.lazy(() => InputTcpjson$inboundSchema),
  models.InputSystemMetrics$inboundSchema,
  models.InputSystemState$inboundSchema,
  models.InputKubeMetrics$inboundSchema,
  models.InputKubeLogs$inboundSchema,
  models.InputKubeEvents$inboundSchema,
  models.InputWindowsMetrics$inboundSchema,
  z.lazy(() => InputDatadogAgent$inboundSchema),
  z.lazy(() => InputHttpRaw$inboundSchema),
  models.InputCriblmetrics$inboundSchema,
  z.lazy(() => InputMetrics$inboundSchema),
  z.lazy(() => InputSqs$inboundSchema),
  models.InputFile$inboundSchema,
  z.lazy(() => InputTcp$inboundSchema),
  models.InputAppscope$inboundSchema,
  z.lazy(() => InputWef$inboundSchema),
  z.lazy(() => InputRawUdp$inboundSchema),
  z.lazy(() => InputZscalerHec$inboundSchema),
  models.InputCollection$inboundSchema,
  z.lazy(() => InputPrometheus$inboundSchema),
  z.lazy(() => InputEdgePrometheus$inboundSchema),
  z.lazy(() => InputOffice365MsgTrace$inboundSchema),
  z.lazy(() => InputSnmp$inboundSchema),
  z.lazy(() => InputOpenTelemetry$inboundSchema),
  z.lazy(() => InputModelDrivenTelemetry$inboundSchema),
  z.lazy(() => InputNetflow$inboundSchema),
  z.union([
    z.lazy(() => InputGrafana1$inboundSchema),
    z.lazy(() => InputGrafana2$inboundSchema),
  ]),
  z.union([
    z.lazy(() => InputSyslog1$inboundSchema),
    z.lazy(() => InputSyslog2$inboundSchema),
  ]),
]);

/** @internal */
export type CreateInputRequest$Outbound =
  | InputMsk$Outbound
  | InputWiz$Outbound
  | InputKafka$Outbound
  | InputAzureBlob$Outbound
  | InputConfluentCloud$Outbound
  | InputOffice365Mgmt$Outbound
  | InputOffice365Service$Outbound
  | InputEventhub$Outbound
  | InputExec$Outbound
  | InputGooglePubsub$Outbound
  | InputCrowdstrike$Outbound
  | InputDatagen$Outbound
  | InputKinesis$Outbound
  | InputS3$Outbound
  | InputS3Inventory$Outbound
  | InputWinEventLogs$Outbound
  | InputJournalFiles$Outbound
  | InputSecurityLake$Outbound
  | InputHttp$Outbound
  | InputSplunk$Outbound
  | InputSplunkSearch$Outbound
  | InputSplunkHec$Outbound
  | InputElastic$Outbound
  | InputLoki$Outbound
  | InputPrometheusRw$Outbound
  | InputFirehose$Outbound
  | models.InputCribl$Outbound
  | InputCriblTcp$Outbound
  | InputCriblHttp$Outbound
  | InputCriblLakeHttp$Outbound
  | InputTcpjson$Outbound
  | models.InputSystemMetrics$Outbound
  | models.InputSystemState$Outbound
  | models.InputKubeMetrics$Outbound
  | models.InputKubeLogs$Outbound
  | models.InputKubeEvents$Outbound
  | models.InputWindowsMetrics$Outbound
  | InputDatadogAgent$Outbound
  | InputHttpRaw$Outbound
  | models.InputCriblmetrics$Outbound
  | InputMetrics$Outbound
  | InputSqs$Outbound
  | models.InputFile$Outbound
  | InputTcp$Outbound
  | models.InputAppscope$Outbound
  | InputWef$Outbound
  | InputRawUdp$Outbound
  | InputZscalerHec$Outbound
  | models.InputCollection$Outbound
  | InputPrometheus$Outbound
  | InputEdgePrometheus$Outbound
  | InputOffice365MsgTrace$Outbound
  | InputSnmp$Outbound
  | InputOpenTelemetry$Outbound
  | InputModelDrivenTelemetry$Outbound
  | InputNetflow$Outbound
  | InputGrafana1$Outbound
  | InputGrafana2$Outbound
  | InputSyslog1$Outbound
  | InputSyslog2$Outbound;

/** @internal */
export const CreateInputRequest$outboundSchema: z.ZodType<
  CreateInputRequest$Outbound,
  z.ZodTypeDef,
  CreateInputRequest
> = z.union([
  z.lazy(() => InputMsk$outboundSchema),
  z.lazy(() => InputWiz$outboundSchema),
  z.lazy(() => InputKafka$outboundSchema),
  z.lazy(() => InputAzureBlob$outboundSchema),
  z.lazy(() => InputConfluentCloud$outboundSchema),
  z.lazy(() => InputOffice365Mgmt$outboundSchema),
  z.lazy(() => InputOffice365Service$outboundSchema),
  z.lazy(() => InputEventhub$outboundSchema),
  z.lazy(() => InputExec$outboundSchema),
  z.lazy(() => InputGooglePubsub$outboundSchema),
  z.lazy(() => InputCrowdstrike$outboundSchema),
  z.lazy(() => InputDatagen$outboundSchema),
  z.lazy(() => InputKinesis$outboundSchema),
  z.lazy(() => InputS3$outboundSchema),
  z.lazy(() => InputS3Inventory$outboundSchema),
  z.lazy(() => InputWinEventLogs$outboundSchema),
  z.lazy(() => InputJournalFiles$outboundSchema),
  z.lazy(() => InputSecurityLake$outboundSchema),
  z.lazy(() => InputHttp$outboundSchema),
  z.lazy(() => InputSplunk$outboundSchema),
  z.lazy(() => InputSplunkSearch$outboundSchema),
  z.lazy(() => InputSplunkHec$outboundSchema),
  z.lazy(() => InputElastic$outboundSchema),
  z.lazy(() => InputLoki$outboundSchema),
  z.lazy(() => InputPrometheusRw$outboundSchema),
  z.lazy(() => InputFirehose$outboundSchema),
  models.InputCribl$outboundSchema,
  z.lazy(() => InputCriblTcp$outboundSchema),
  z.lazy(() => InputCriblHttp$outboundSchema),
  z.lazy(() => InputCriblLakeHttp$outboundSchema),
  z.lazy(() => InputTcpjson$outboundSchema),
  models.InputSystemMetrics$outboundSchema,
  models.InputSystemState$outboundSchema,
  models.InputKubeMetrics$outboundSchema,
  models.InputKubeLogs$outboundSchema,
  models.InputKubeEvents$outboundSchema,
  models.InputWindowsMetrics$outboundSchema,
  z.lazy(() => InputDatadogAgent$outboundSchema),
  z.lazy(() => InputHttpRaw$outboundSchema),
  models.InputCriblmetrics$outboundSchema,
  z.lazy(() => InputMetrics$outboundSchema),
  z.lazy(() => InputSqs$outboundSchema),
  models.InputFile$outboundSchema,
  z.lazy(() => InputTcp$outboundSchema),
  models.InputAppscope$outboundSchema,
  z.lazy(() => InputWef$outboundSchema),
  z.lazy(() => InputRawUdp$outboundSchema),
  z.lazy(() => InputZscalerHec$outboundSchema),
  models.InputCollection$outboundSchema,
  z.lazy(() => InputPrometheus$outboundSchema),
  z.lazy(() => InputEdgePrometheus$outboundSchema),
  z.lazy(() => InputOffice365MsgTrace$outboundSchema),
  z.lazy(() => InputSnmp$outboundSchema),
  z.lazy(() => InputOpenTelemetry$outboundSchema),
  z.lazy(() => InputModelDrivenTelemetry$outboundSchema),
  z.lazy(() => InputNetflow$outboundSchema),
  z.union([
    z.lazy(() => InputGrafana1$outboundSchema),
    z.lazy(() => InputGrafana2$outboundSchema),
  ]),
  z.union([
    z.lazy(() => InputSyslog1$outboundSchema),
    z.lazy(() => InputSyslog2$outboundSchema),
  ]),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputRequest$ {
  /** @deprecated use `CreateInputRequest$inboundSchema` instead. */
  export const inboundSchema = CreateInputRequest$inboundSchema;
  /** @deprecated use `CreateInputRequest$outboundSchema` instead. */
  export const outboundSchema = CreateInputRequest$outboundSchema;
  /** @deprecated use `CreateInputRequest$Outbound` instead. */
  export type Outbound = CreateInputRequest$Outbound;
}

export function createInputRequestToJSON(
  createInputRequest: CreateInputRequest,
): string {
  return JSON.stringify(
    CreateInputRequest$outboundSchema.parse(createInputRequest),
  );
}

export function createInputRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputRequest' from JSON`,
  );
}

/** @internal */
export const CreateInputResponse$inboundSchema: z.ZodType<
  CreateInputResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().int().optional(),
  items: z.array(models.Input$inboundSchema).optional(),
});

/** @internal */
export type CreateInputResponse$Outbound = {
  count?: number | undefined;
  items?: Array<models.Input$Outbound> | undefined;
};

/** @internal */
export const CreateInputResponse$outboundSchema: z.ZodType<
  CreateInputResponse$Outbound,
  z.ZodTypeDef,
  CreateInputResponse
> = z.object({
  count: z.number().int().optional(),
  items: z.array(models.Input$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateInputResponse$ {
  /** @deprecated use `CreateInputResponse$inboundSchema` instead. */
  export const inboundSchema = CreateInputResponse$inboundSchema;
  /** @deprecated use `CreateInputResponse$outboundSchema` instead. */
  export const outboundSchema = CreateInputResponse$outboundSchema;
  /** @deprecated use `CreateInputResponse$Outbound` instead. */
  export type Outbound = CreateInputResponse$Outbound;
}

export function createInputResponseToJSON(
  createInputResponse: CreateInputResponse,
): string {
  return JSON.stringify(
    CreateInputResponse$outboundSchema.parse(createInputResponse),
  );
}

export function createInputResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateInputResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateInputResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateInputResponse' from JSON`,
  );
}
