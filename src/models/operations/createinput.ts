/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import * as models from "../index.js";

export const InputCloudflareHecType = {
  CloudflareHec: "cloudflare_hec",
} as const;
export type InputCloudflareHecType = ClosedEnum<typeof InputCloudflareHecType>;

/**
 * Select Secret to use a text secret to authenticate
 */
export const InputCloudflareHecAuthenticationMethod = {
  Secret: "secret",
  Manual: "manual",
} as const;
/**
 * Select Secret to use a text secret to authenticate
 */
export type InputCloudflareHecAuthenticationMethod = OpenEnum<
  typeof InputCloudflareHecAuthenticationMethod
>;

export type InputCloudflareHecAuthToken = {
  /**
   * Select Secret to use a text secret to authenticate
   */
  authType?: InputCloudflareHecAuthenticationMethod | undefined;
  /**
   * Select or create a stored text secret
   */
  tokenSecret?: string | undefined;
  /**
   * Shared secret to be provided by any client (Authorization: <token>)
   */
  token?: string | undefined;
  enabled?: boolean | undefined;
  description?: string | undefined;
  /**
   * Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
   */
  allowedIndexesAtToken?: Array<string> | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
};

export type InputCloudflareHecPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCloudflareHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputCloudflareHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint.
   */
  hecAPI: string;
  /**
   * Fields to add to every event. May be overridden by fields added at the token or request level.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputCloudflareHecPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCloudflareHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputCloudflareHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint.
   */
  hecAPI: string;
  /**
   * Fields to add to every event. May be overridden by fields added at the token or request level.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCloudflareHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputCloudflareHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint.
   */
  hecAPI: string;
  /**
   * Fields to add to every event. May be overridden by fields added at the token or request level.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputCloudflareHecSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCloudflareHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputCloudflareHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cloudflare HTTP Event Collector API requests. This input supports the /event endpoint.
   */
  hecAPI: string;
  /**
   * Fields to add to every event. May be overridden by fields added at the token or request level.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputCloudflareHec =
  | InputCloudflareHecSendToRoutesTrueConstraint
  | InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint
  | InputCloudflareHecPqEnabledFalseConstraint
  | InputCloudflareHecPqEnabledTrueWithPqConstraint;

export const InputZscalerHecType = {
  ZscalerHec: "zscaler_hec",
} as const;
export type InputZscalerHecType = ClosedEnum<typeof InputZscalerHecType>;

export type InputZscalerHecAuthToken = {
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Select or create a stored text secret
   */
  tokenSecret?: string | undefined;
  /**
   * Shared secret to be provided by any client (Authorization: <token>)
   */
  token: string;
  enabled?: boolean | undefined;
  description?: string | undefined;
  /**
   * Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
   */
  allowedIndexesAtToken?: Array<string> | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
};

export type InputZscalerHecPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputZscalerHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputZscalerHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
   */
  hecAPI: string;
  /**
   * Fields to add to every event. May be overridden by fields added at the token or request level.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Whether to enable Zscaler HEC acknowledgements
   */
  hecAcks?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputZscalerHecPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputZscalerHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputZscalerHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
   */
  hecAPI: string;
  /**
   * Fields to add to every event. May be overridden by fields added at the token or request level.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Whether to enable Zscaler HEC acknowledgements
   */
  hecAcks?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputZscalerHecSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputZscalerHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputZscalerHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
   */
  hecAPI: string;
  /**
   * Fields to add to every event. May be overridden by fields added at the token or request level.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Whether to enable Zscaler HEC acknowledgements
   */
  hecAcks?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputZscalerHecSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputZscalerHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputZscalerHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint.
   */
  hecAPI: string;
  /**
   * Fields to add to every event. May be overridden by fields added at the token or request level.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Whether to enable Zscaler HEC acknowledgements
   */
  hecAcks?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputZscalerHec =
  | InputZscalerHecSendToRoutesTrueConstraint
  | InputZscalerHecSendToRoutesFalseWithConnectionsConstraint
  | InputZscalerHecPqEnabledFalseConstraint
  | InputZscalerHecPqEnabledTrueWithPqConstraint;

export const InputSecurityLakeType = {
  SecurityLake: "security_lake",
} as const;
export type InputSecurityLakeType = ClosedEnum<typeof InputSecurityLakeType>;

export type InputSecurityLakePqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSecurityLakeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputSecurityLakePqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSecurityLakeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSecurityLakeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputSecurityLakeSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSecurityLakeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputSecurityLake =
  | InputSecurityLakeSendToRoutesTrueConstraint
  | InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint
  | InputSecurityLakePqEnabledFalseConstraint
  | InputSecurityLakePqEnabledTrueWithPqConstraint;

export const InputNetflowType = {
  Netflow: "netflow",
} as const;
export type InputNetflowType = ClosedEnum<typeof InputNetflowType>;

export type InputNetflowPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputNetflowType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
   */
  enablePassThrough?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
   */
  templateCacheMinutes?: number | undefined;
  /**
   * Accept messages in Netflow V5 format.
   */
  v5Enabled?: boolean | undefined;
  /**
   * Accept messages in Netflow V9 format.
   */
  v9Enabled?: boolean | undefined;
  /**
   * Accept messages in IPFIX format.
   */
  ipfixEnabled?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputNetflowPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputNetflowType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
   */
  enablePassThrough?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
   */
  templateCacheMinutes?: number | undefined;
  /**
   * Accept messages in Netflow V5 format.
   */
  v5Enabled?: boolean | undefined;
  /**
   * Accept messages in Netflow V9 format.
   */
  v9Enabled?: boolean | undefined;
  /**
   * Accept messages in IPFIX format.
   */
  ipfixEnabled?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputNetflowSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputNetflowType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
   */
  enablePassThrough?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
   */
  templateCacheMinutes?: number | undefined;
  /**
   * Accept messages in Netflow V5 format.
   */
  v5Enabled?: boolean | undefined;
  /**
   * Accept messages in Netflow V9 format.
   */
  v9Enabled?: boolean | undefined;
  /**
   * Accept messages in IPFIX format.
   */
  ipfixEnabled?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputNetflowSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputNetflowType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Allow forwarding of events to a NetFlow destination. Enabling this feature will generate an extra event containing __netflowRaw which can be routed to a NetFlow destination. Note that these events will not count against ingest quota.
   */
  enablePassThrough?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Specifies how many minutes NetFlow v9 templates are cached before being discarded if not refreshed. Adjust based on your network's template update frequency to optimize performance and memory usage.
   */
  templateCacheMinutes?: number | undefined;
  /**
   * Accept messages in Netflow V5 format.
   */
  v5Enabled?: boolean | undefined;
  /**
   * Accept messages in Netflow V9 format.
   */
  v9Enabled?: boolean | undefined;
  /**
   * Accept messages in IPFIX format.
   */
  ipfixEnabled?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputNetflow =
  | InputNetflowSendToRoutesTrueConstraint
  | InputNetflowSendToRoutesFalseWithConnectionsConstraint
  | InputNetflowPqEnabledFalseConstraint
  | InputNetflowPqEnabledTrueWithPqConstraint;

export const InputWizWebhookType = {
  WizWebhook: "wiz_webhook",
} as const;
export type InputWizWebhookType = ClosedEnum<typeof InputWizWebhookType>;

export type InputWizWebhookPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWizWebhookType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List of URI paths accepted by this input. Wildcards are supported (such as /api/v* /hook). Defaults to allow all.
   */
  allowedPaths?: Array<string> | undefined;
  /**
   * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
   */
  allowedMethods?: Array<string> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputWizWebhookPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWizWebhookType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List of URI paths accepted by this input. Wildcards are supported (such as /api/v* /hook). Defaults to allow all.
   */
  allowedPaths?: Array<string> | undefined;
  /**
   * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
   */
  allowedMethods?: Array<string> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputWizWebhookSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWizWebhookType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List of URI paths accepted by this input. Wildcards are supported (such as /api/v* /hook). Defaults to allow all.
   */
  allowedPaths?: Array<string> | undefined;
  /**
   * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
   */
  allowedMethods?: Array<string> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputWizWebhookSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWizWebhookType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List of URI paths accepted by this input. Wildcards are supported (such as /api/v* /hook). Defaults to allow all.
   */
  allowedPaths?: Array<string> | undefined;
  /**
   * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
   */
  allowedMethods?: Array<string> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputWizWebhook =
  | InputWizWebhookSendToRoutesTrueConstraint
  | InputWizWebhookSendToRoutesFalseWithConnectionsConstraint
  | InputWizWebhookPqEnabledFalseConstraint
  | InputWizWebhookPqEnabledTrueWithPqConstraint;

export const InputWizType = {
  Wiz: "wiz",
} as const;
export type InputWizType = ClosedEnum<typeof InputWizType>;

export type ManageState = {};

/**
 * Collector runtime log level
 */
export const InputWizLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
  Silly: "silly",
} as const;
/**
 * Collector runtime log level
 */
export type InputWizLogLevel = OpenEnum<typeof InputWizLogLevel>;

export type InputWizContentConfig = {
  /**
   * The name of the Wiz query
   */
  contentType: string;
  contentDescription?: string | undefined;
  enabled?: boolean | undefined;
  /**
   * Track collection progress between consecutive scheduled executions
   */
  stateTracking?: boolean | undefined;
  /**
   * JavaScript expression that defines how to update the state from an event. Use the event's data and the current state to compute the new state. See [Understanding State Expression Fields](https://docs.cribl.io/stream/collectors-rest#state-tracking-expression-fields) for more information.
   */
  stateUpdateExpression?: string | undefined;
  /**
   * JavaScript expression that defines which state to keep when merging a task's newly reported state with previously saved state. Evaluates `prevState` and `newState` variables, resolving to the state to keep.
   */
  stateMergeExpression?: string | undefined;
  manageState?: ManageState | undefined;
  /**
   * Template for POST body to send with the Collect request. Reference global variables, or functions using template params: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`.
   */
  contentQuery: string;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule: string;
  /**
   * Earliest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)
   */
  earliest: string;
  /**
   * Latest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)
   */
  latest: string;
  /**
   * Maximum time the job is allowed to run (examples: 30, 45s, 15m). Units default to seconds if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * Collector runtime log level
   */
  logLevel?: InputWizLogLevel | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 0. Set to 0 to retrieve all pages.
   */
  maxPages?: number | undefined;
};

export type InputWizPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWizType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
   */
  endpoint: string;
  /**
   * The authentication URL to generate an OAuth token
   */
  authUrl: string;
  /**
   * The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
   */
  authAudienceOverride?: string | undefined;
  /**
   * The client ID of the Wiz application
   */
  clientId: string;
  contentConfig: Array<InputWizContentConfig>;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * The client secret of the Wiz application
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputWizPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWizType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
   */
  endpoint: string;
  /**
   * The authentication URL to generate an OAuth token
   */
  authUrl: string;
  /**
   * The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
   */
  authAudienceOverride?: string | undefined;
  /**
   * The client ID of the Wiz application
   */
  clientId: string;
  contentConfig: Array<InputWizContentConfig>;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * The client secret of the Wiz application
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputWizSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWizType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
   */
  endpoint: string;
  /**
   * The authentication URL to generate an OAuth token
   */
  authUrl: string;
  /**
   * The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
   */
  authAudienceOverride?: string | undefined;
  /**
   * The client ID of the Wiz application
   */
  clientId: string;
  contentConfig: Array<InputWizContentConfig>;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * The client secret of the Wiz application
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputWizSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWizType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
   */
  endpoint: string;
  /**
   * The authentication URL to generate an OAuth token
   */
  authUrl: string;
  /**
   * The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
   */
  authAudienceOverride?: string | undefined;
  /**
   * The client ID of the Wiz application
   */
  clientId: string;
  contentConfig: Array<InputWizContentConfig>;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * The client secret of the Wiz application
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputWiz =
  | InputWizSendToRoutesTrueConstraint
  | InputWizSendToRoutesFalseWithConnectionsConstraint
  | InputWizPqEnabledFalseConstraint
  | InputWizPqEnabledTrueWithPqConstraint;

export const PqEnabledTrueWithPqConstraintInputJournalFilesType = {
  JournalFiles: "journal_files",
} as const;
export type PqEnabledTrueWithPqConstraintInputJournalFilesType = ClosedEnum<
  typeof PqEnabledTrueWithPqConstraintInputJournalFilesType
>;

export type PqEnabledTrueWithPqConstraintRule = {
  /**
   * JavaScript expression applied to Journal objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputJournalFilesPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: PqEnabledTrueWithPqConstraintInputJournalFilesType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
   */
  path: string;
  /**
   * Time, in seconds, between scanning for journals.
   */
  interval?: number | undefined;
  /**
   * The full path of discovered journals are matched against this wildcard list.
   */
  journals: Array<string>;
  /**
   * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<PqEnabledTrueWithPqConstraintRule> | undefined;
  /**
   * Skip log messages that are not part of the current boot session.
   */
  currentBoot?: boolean | undefined;
  /**
   * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export const PqEnabledFalseConstraintInputJournalFilesType = {
  JournalFiles: "journal_files",
} as const;
export type PqEnabledFalseConstraintInputJournalFilesType = ClosedEnum<
  typeof PqEnabledFalseConstraintInputJournalFilesType
>;

export type PqEnabledFalseConstraintRule = {
  /**
   * JavaScript expression applied to Journal objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputJournalFilesPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: PqEnabledFalseConstraintInputJournalFilesType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
   */
  path: string;
  /**
   * Time, in seconds, between scanning for journals.
   */
  interval?: number | undefined;
  /**
   * The full path of discovered journals are matched against this wildcard list.
   */
  journals: Array<string>;
  /**
   * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<PqEnabledFalseConstraintRule> | undefined;
  /**
   * Skip log messages that are not part of the current boot session.
   */
  currentBoot?: boolean | undefined;
  /**
   * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export const SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType = {
  JournalFiles: "journal_files",
} as const;
export type SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType =
  ClosedEnum<
    typeof SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType
  >;

export type SendToRoutesFalseWithConnectionsConstraintRule = {
  /**
   * JavaScript expression applied to Journal objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputJournalFilesSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
   */
  path: string;
  /**
   * Time, in seconds, between scanning for journals.
   */
  interval?: number | undefined;
  /**
   * The full path of discovered journals are matched against this wildcard list.
   */
  journals: Array<string>;
  /**
   * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<SendToRoutesFalseWithConnectionsConstraintRule> | undefined;
  /**
   * Skip log messages that are not part of the current boot session.
   */
  currentBoot?: boolean | undefined;
  /**
   * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export const SendToRoutesTrueConstraintInputJournalFilesType = {
  JournalFiles: "journal_files",
} as const;
export type SendToRoutesTrueConstraintInputJournalFilesType = ClosedEnum<
  typeof SendToRoutesTrueConstraintInputJournalFilesType
>;

export type SendToRoutesTrueConstraintRule = {
  /**
   * JavaScript expression applied to Journal objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputJournalFilesSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: SendToRoutesTrueConstraintInputJournalFilesType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Directory path to search for journals. Environment variables will be resolved, e.g. $CRIBL_EDGE_FS_ROOT/var/log/journal/$MACHINE_ID.
   */
  path: string;
  /**
   * Time, in seconds, between scanning for journals.
   */
  interval?: number | undefined;
  /**
   * The full path of discovered journals are matched against this wildcard list.
   */
  journals: Array<string>;
  /**
   * Add rules to decide which journal objects to allow. Events are generated if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<SendToRoutesTrueConstraintRule> | undefined;
  /**
   * Skip log messages that are not part of the current boot session.
   */
  currentBoot?: boolean | undefined;
  /**
   * The maximum log message age, in duration form (e.g,: 60s, 4h, 3d, 1w).  Default of no value will apply no max age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputJournalFiles =
  | InputJournalFilesSendToRoutesTrueConstraint
  | InputJournalFilesSendToRoutesFalseWithConnectionsConstraint
  | InputJournalFilesPqEnabledFalseConstraint
  | InputJournalFilesPqEnabledTrueWithPqConstraint;

export const InputRawUdpType = {
  RawUdp: "raw_udp",
} as const;
export type InputRawUdpType = ClosedEnum<typeof InputRawUdpType>;

export type InputRawUdpPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputRawUdpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
   */
  ingestRawBytes?: boolean | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputRawUdpPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputRawUdpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
   */
  ingestRawBytes?: boolean | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputRawUdpSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputRawUdpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
   */
  ingestRawBytes?: boolean | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputRawUdpSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputRawUdpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * If true, each UDP packet is assumed to contain a single message. If false, each UDP packet is assumed to contain multiple messages, separated by newlines.
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * If true, a __rawBytes field will be added to each event containing the raw bytes of the datagram.
   */
  ingestRawBytes?: boolean | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputRawUdp =
  | InputRawUdpSendToRoutesTrueConstraint
  | InputRawUdpSendToRoutesFalseWithConnectionsConstraint
  | InputRawUdpPqEnabledFalseConstraint
  | InputRawUdpPqEnabledTrueWithPqConstraint;

export const InputWinEventLogsType = {
  WinEventLogs: "win_event_logs",
} as const;
export type InputWinEventLogsType = ClosedEnum<typeof InputWinEventLogsType>;

/**
 * Read all stored and future event logs, or only future events
 */
export const ReadMode = {
  /**
   * Entire log
   */
  Oldest: "oldest",
  /**
   * From last entry
   */
  Newest: "newest",
} as const;
/**
 * Read all stored and future event logs, or only future events
 */
export type ReadMode = OpenEnum<typeof ReadMode>;

/**
 * Format of individual events
 */
export const EventFormat = {
  /**
   * JSON
   */
  Json: "json",
  /**
   * XML
   */
  Xml: "xml",
} as const;
/**
 * Format of individual events
 */
export type EventFormat = OpenEnum<typeof EventFormat>;

export type InputWinEventLogsPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWinEventLogsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat | undefined;
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableJsonRendering?: boolean | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableXmlRendering?: boolean | undefined;
};

export type InputWinEventLogsPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWinEventLogsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat | undefined;
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableJsonRendering?: boolean | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableXmlRendering?: boolean | undefined;
};

export type InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWinEventLogsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat | undefined;
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableJsonRendering?: boolean | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableXmlRendering?: boolean | undefined;
};

export type InputWinEventLogsSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWinEventLogsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat | undefined;
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableJsonRendering?: boolean | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableXmlRendering?: boolean | undefined;
};

export type InputWinEventLogs =
  | InputWinEventLogsSendToRoutesTrueConstraint
  | InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint
  | InputWinEventLogsPqEnabledFalseConstraint
  | InputWinEventLogsPqEnabledTrueWithPqConstraint;

export const InputWefType = {
  Wef: "wef",
} as const;
export type InputWefType = ClosedEnum<typeof InputWefType>;

/**
 * How to authenticate incoming client connections
 */
export const InputWefAuthenticationMethod = {
  /**
   * Client certificate
   */
  ClientCert: "clientCert",
  /**
   * Kerberos
   */
  Kerberos: "kerberos",
} as const;
/**
 * How to authenticate incoming client connections
 */
export type InputWefAuthenticationMethod = OpenEnum<
  typeof InputWefAuthenticationMethod
>;

export type MTLSSettings = {
  /**
   * Enable TLS
   */
  disabled?: boolean | undefined;
  /**
   * Required for WEF certificate authentication
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Required for WEF certificate authentication
   */
  requestCert?: boolean | undefined;
  /**
   * Name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath: string;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath: string;
  /**
   * Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it.
   */
  caPath: string;
  /**
   * Regex matching allowable common names in peer certificates' subject attribute
   */
  commonNameRegex?: string | undefined;
  minVersion?:
    | models.MinimumTlsVersionOptionsKafkaSchemaRegistryTls
    | undefined;
  maxVersion?:
    | models.MaximumTlsVersionOptionsKafkaSchemaRegistryTls
    | undefined;
  /**
   * Enable OCSP check of certificate
   */
  ocspCheck?: boolean | undefined;
  keytab?: any | undefined;
  principal?: any | undefined;
  /**
   * If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors.
   */
  ocspCheckFailClose?: boolean | undefined;
};

/**
 * Content format in which the endpoint should deliver events
 */
export const CreateInputFormat = {
  Raw: "Raw",
  RenderedText: "RenderedText",
} as const;
/**
 * Content format in which the endpoint should deliver events
 */
export type CreateInputFormat = OpenEnum<typeof CreateInputFormat>;

export const QueryBuilderMode = {
  Simple: "simple",
  Xml: "xml",
} as const;
export type QueryBuilderMode = OpenEnum<typeof QueryBuilderMode>;

export type Query = {
  /**
   * The Path attribute from the relevant XML Select element
   */
  path: string;
  /**
   * The XPath query inside the relevant XML Select element
   */
  queryExpression: string;
};

export type Subscription = {
  subscriptionName: string;
  /**
   * Version UUID for this subscription. If any subscription parameters are modified, this value will change.
   */
  version?: string | undefined;
  /**
   * Content format in which the endpoint should deliver events
   */
  contentFormat: CreateInputFormat;
  /**
   * Maximum time (in seconds) between endpoint checkins before considering it unavailable
   */
  heartbeatInterval: number;
  /**
   * Interval (in seconds) over which the endpoint should collect events before sending them to Stream
   */
  batchTimeout: number;
  /**
   * Newly subscribed endpoints will send previously existing events. Disable to receive new events only.
   */
  readExistingEvents?: boolean | undefined;
  /**
   * Keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events'. See [Cribl Docs](https://docs.cribl.io/stream/sources-wef/#subscriptions) for more details.
   */
  sendBookmarks?: boolean | undefined;
  /**
   * Receive compressed events from the source
   */
  compress?: boolean | undefined;
  /**
   * The DNS names of the endpoints that should forward these events. You may use wildcards, such as *.mydomain.com
   */
  targets: Array<string>;
  /**
   * The RFC-3066 locale the Windows clients should use when sending events. Defaults to "en-US".
   */
  locale?: string | undefined;
  querySelector?: QueryBuilderMode | undefined;
  /**
   * Fields to add to events ingested under this subscription
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  queries?: Array<Query> | undefined;
  /**
   * The XPath query to use for selecting events
   */
  xmlQuery?: string | undefined;
};

export type InputWefPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWefType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * How to authenticate incoming client connections
   */
  authMethod?: InputWefAuthenticationMethod | undefined;
  tls?: MTLSSettings | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
   */
  caFingerprint?: string | undefined;
  /**
   * Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
   */
  keytab?: string | undefined;
  /**
   * Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
   */
  principal?: string | undefined;
  /**
   * Allow events to be ingested even if their MachineID does not match the client certificate CN
   */
  allowMachineIdMismatch?: boolean | undefined;
  /**
   * Subscriptions to events on forwarding endpoints
   */
  subscriptions: Array<Subscription>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
   */
  logFingerprintMismatch?: boolean | undefined;
};

export type InputWefPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWefType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * How to authenticate incoming client connections
   */
  authMethod?: InputWefAuthenticationMethod | undefined;
  tls?: MTLSSettings | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
   */
  caFingerprint?: string | undefined;
  /**
   * Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
   */
  keytab?: string | undefined;
  /**
   * Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
   */
  principal?: string | undefined;
  /**
   * Allow events to be ingested even if their MachineID does not match the client certificate CN
   */
  allowMachineIdMismatch?: boolean | undefined;
  /**
   * Subscriptions to events on forwarding endpoints
   */
  subscriptions: Array<Subscription>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
   */
  logFingerprintMismatch?: boolean | undefined;
};

export type InputWefSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWefType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * How to authenticate incoming client connections
   */
  authMethod?: InputWefAuthenticationMethod | undefined;
  tls?: MTLSSettings | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
   */
  caFingerprint?: string | undefined;
  /**
   * Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
   */
  keytab?: string | undefined;
  /**
   * Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
   */
  principal?: string | undefined;
  /**
   * Allow events to be ingested even if their MachineID does not match the client certificate CN
   */
  allowMachineIdMismatch?: boolean | undefined;
  /**
   * Subscriptions to events on forwarding endpoints
   */
  subscriptions: Array<Subscription>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
   */
  logFingerprintMismatch?: boolean | undefined;
};

export type InputWefSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWefType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * How to authenticate incoming client connections
   */
  authMethod?: InputWefAuthenticationMethod | undefined;
  tls?: MTLSSettings | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Preserve the clients original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
   */
  caFingerprint?: string | undefined;
  /**
   * Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
   */
  keytab?: string | undefined;
  /**
   * Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
   */
  principal?: string | undefined;
  /**
   * Allow events to be ingested even if their MachineID does not match the client certificate CN
   */
  allowMachineIdMismatch?: boolean | undefined;
  /**
   * Subscriptions to events on forwarding endpoints
   */
  subscriptions: Array<Subscription>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder.
   */
  logFingerprintMismatch?: boolean | undefined;
};

export type InputWef =
  | InputWefSendToRoutesTrueConstraint
  | InputWefSendToRoutesFalseWithConnectionsConstraint
  | InputWefPqEnabledFalseConstraint
  | InputWefPqEnabledTrueWithPqConstraint;

export const InputAppscopeType = {
  Appscope: "appscope",
} as const;
export type InputAppscopeType = ClosedEnum<typeof InputAppscopeType>;

export type Allow = {
  /**
   * Specify the name of a process or family of processes.
   */
  procname: string;
  /**
   * Specify a string to substring-match against process command-line.
   */
  arg?: string | undefined;
  /**
   * Choose a config to apply to processes that match the process name and/or argument.
   */
  config: string;
};

export type InputAppscopeFilter = {
  /**
   * Specify processes that AppScope should be loaded into, and the config to use.
   */
  allow?: Array<Allow> | undefined;
  /**
   * To override the UNIX domain socket or address/port specified in General Settings (while leaving Authentication settings as is), enter a URL.
   */
  transportURL?: string | undefined;
};

export type InputAppscopePersistence = {
  /**
   * Spool events and metrics on disk for Cribl Edge and Search
   */
  enable?: boolean | undefined;
  /**
   * Time span for each file bucket
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
   */
  maxDataTime?: string | undefined;
  compress?: models.DataCompressionFormatOptionsPersistence | undefined;
  /**
   * Path to use to write metrics. Defaults to $CRIBL_HOME/state/appscope
   */
  destPath?: string | undefined;
};

export type InputAppscopePqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputAppscopeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter | undefined;
  persistence?: InputAppscopePersistence | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputAppscopePqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputAppscopeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter | undefined;
  persistence?: InputAppscopePersistence | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputAppscopeSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputAppscopeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter | undefined;
  persistence?: InputAppscopePersistence | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputAppscopeSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputAppscopeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Toggle to Yes to specify a file-backed UNIX domain socket connection, instead of a network host and port.
   */
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter | undefined;
  persistence?: InputAppscopePersistence | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  description?: string | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port?: number | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Path to the UNIX domain socket to listen on.
   */
  unixSocketPath?: string | undefined;
  /**
   * Permissions to set for socket e.g., 777. If empty, falls back to the runtime user's default permissions.
   */
  unixSocketPerms?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputAppscope =
  | InputAppscopeSendToRoutesTrueConstraint
  | InputAppscopeSendToRoutesFalseWithConnectionsConstraint
  | InputAppscopePqEnabledFalseConstraint
  | InputAppscopePqEnabledTrueWithPqConstraint;

export const InputTcpType = {
  Tcp: "tcp",
} as const;
export type InputTcpType = ClosedEnum<typeof InputTcpType>;

export type InputTcpPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputTcpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputTcpPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputTcpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputTcpSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputTcpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputTcpSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputTcpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputTcp =
  | InputTcpSendToRoutesTrueConstraint
  | InputTcpSendToRoutesFalseWithConnectionsConstraint
  | InputTcpPqEnabledFalseConstraint
  | InputTcpPqEnabledTrueWithPqConstraint;

export const PqEnabledTrueWithPqConstraintInputFileType = {
  File: "file",
} as const;
export type PqEnabledTrueWithPqConstraintInputFileType = ClosedEnum<
  typeof PqEnabledTrueWithPqConstraintInputFileType
>;

/**
 * Choose how to discover files to monitor
 */
export const PqEnabledTrueWithPqConstraintMode = {
  /**
   * Manual
   */
  Manual: "manual",
  /**
   * Auto
   */
  Auto: "auto",
} as const;
/**
 * Choose how to discover files to monitor
 */
export type PqEnabledTrueWithPqConstraintMode = OpenEnum<
  typeof PqEnabledTrueWithPqConstraintMode
>;

export type InputFilePqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: PqEnabledTrueWithPqConstraintInputFileType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Choose how to discover files to monitor
   */
  mode?: PqEnabledTrueWithPqConstraintMode | undefined;
  /**
   * Time, in seconds, between scanning for files
   */
  interval?: number | undefined;
  /**
   * The full path of discovered files are matched against this wildcard list
   */
  filenames?: Array<string> | undefined;
  /**
   * Apply filename allowlist to file entries in archive file types, like tar or zip.
   */
  filterArchivedFiles?: boolean | undefined;
  /**
   * Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head.
   */
  tailOnly?: boolean | undefined;
  /**
   * Time, in seconds, before an idle file is closed
   */
  idleTimeout?: number | undefined;
  /**
   * The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters.
   */
  minAgeDur?: string | undefined;
  /**
   * The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with "Check file modification times". Leave empty to apply no age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Skip files with modification times earlier than the maximum age duration
   */
  checkFileModTime?: boolean | undefined;
  /**
   * Forces files containing binary data to be streamed as text
   */
  forceText?: boolean | undefined;
  /**
   * Length of file header bytes to use in hash for unique file identification
   */
  hashLen?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  /**
   * Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
   */
  path?: string | undefined;
  /**
   * Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
   */
  depth?: number | undefined;
  suppressMissingPathErrors?: boolean | undefined;
  /**
   * Delete files after they have been collected
   */
  deleteFiles?: boolean | undefined;
  /**
   * Stream binary files as Base64-encoded chunks.
   */
  includeUnidentifiableBinary?: boolean | undefined;
};

export const PqEnabledFalseConstraintInputFileType = {
  File: "file",
} as const;
export type PqEnabledFalseConstraintInputFileType = ClosedEnum<
  typeof PqEnabledFalseConstraintInputFileType
>;

/**
 * Choose how to discover files to monitor
 */
export const PqEnabledFalseConstraintMode = {
  /**
   * Manual
   */
  Manual: "manual",
  /**
   * Auto
   */
  Auto: "auto",
} as const;
/**
 * Choose how to discover files to monitor
 */
export type PqEnabledFalseConstraintMode = OpenEnum<
  typeof PqEnabledFalseConstraintMode
>;

export type InputFilePqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: PqEnabledFalseConstraintInputFileType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Choose how to discover files to monitor
   */
  mode?: PqEnabledFalseConstraintMode | undefined;
  /**
   * Time, in seconds, between scanning for files
   */
  interval?: number | undefined;
  /**
   * The full path of discovered files are matched against this wildcard list
   */
  filenames?: Array<string> | undefined;
  /**
   * Apply filename allowlist to file entries in archive file types, like tar or zip.
   */
  filterArchivedFiles?: boolean | undefined;
  /**
   * Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head.
   */
  tailOnly?: boolean | undefined;
  /**
   * Time, in seconds, before an idle file is closed
   */
  idleTimeout?: number | undefined;
  /**
   * The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters.
   */
  minAgeDur?: string | undefined;
  /**
   * The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with "Check file modification times". Leave empty to apply no age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Skip files with modification times earlier than the maximum age duration
   */
  checkFileModTime?: boolean | undefined;
  /**
   * Forces files containing binary data to be streamed as text
   */
  forceText?: boolean | undefined;
  /**
   * Length of file header bytes to use in hash for unique file identification
   */
  hashLen?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  /**
   * Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
   */
  path?: string | undefined;
  /**
   * Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
   */
  depth?: number | undefined;
  suppressMissingPathErrors?: boolean | undefined;
  /**
   * Delete files after they have been collected
   */
  deleteFiles?: boolean | undefined;
  /**
   * Stream binary files as Base64-encoded chunks.
   */
  includeUnidentifiableBinary?: boolean | undefined;
};

export const SendToRoutesFalseWithConnectionsConstraintInputFileType = {
  File: "file",
} as const;
export type SendToRoutesFalseWithConnectionsConstraintInputFileType =
  ClosedEnum<typeof SendToRoutesFalseWithConnectionsConstraintInputFileType>;

/**
 * Choose how to discover files to monitor
 */
export const SendToRoutesFalseWithConnectionsConstraintMode = {
  /**
   * Manual
   */
  Manual: "manual",
  /**
   * Auto
   */
  Auto: "auto",
} as const;
/**
 * Choose how to discover files to monitor
 */
export type SendToRoutesFalseWithConnectionsConstraintMode = OpenEnum<
  typeof SendToRoutesFalseWithConnectionsConstraintMode
>;

export type InputFileSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: SendToRoutesFalseWithConnectionsConstraintInputFileType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Choose how to discover files to monitor
   */
  mode?: SendToRoutesFalseWithConnectionsConstraintMode | undefined;
  /**
   * Time, in seconds, between scanning for files
   */
  interval?: number | undefined;
  /**
   * The full path of discovered files are matched against this wildcard list
   */
  filenames?: Array<string> | undefined;
  /**
   * Apply filename allowlist to file entries in archive file types, like tar or zip.
   */
  filterArchivedFiles?: boolean | undefined;
  /**
   * Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head.
   */
  tailOnly?: boolean | undefined;
  /**
   * Time, in seconds, before an idle file is closed
   */
  idleTimeout?: number | undefined;
  /**
   * The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters.
   */
  minAgeDur?: string | undefined;
  /**
   * The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with "Check file modification times". Leave empty to apply no age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Skip files with modification times earlier than the maximum age duration
   */
  checkFileModTime?: boolean | undefined;
  /**
   * Forces files containing binary data to be streamed as text
   */
  forceText?: boolean | undefined;
  /**
   * Length of file header bytes to use in hash for unique file identification
   */
  hashLen?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  /**
   * Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
   */
  path?: string | undefined;
  /**
   * Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
   */
  depth?: number | undefined;
  suppressMissingPathErrors?: boolean | undefined;
  /**
   * Delete files after they have been collected
   */
  deleteFiles?: boolean | undefined;
  /**
   * Stream binary files as Base64-encoded chunks.
   */
  includeUnidentifiableBinary?: boolean | undefined;
};

export const SendToRoutesTrueConstraintInputFileType = {
  File: "file",
} as const;
export type SendToRoutesTrueConstraintInputFileType = ClosedEnum<
  typeof SendToRoutesTrueConstraintInputFileType
>;

/**
 * Choose how to discover files to monitor
 */
export const SendToRoutesTrueConstraintMode = {
  /**
   * Manual
   */
  Manual: "manual",
  /**
   * Auto
   */
  Auto: "auto",
} as const;
/**
 * Choose how to discover files to monitor
 */
export type SendToRoutesTrueConstraintMode = OpenEnum<
  typeof SendToRoutesTrueConstraintMode
>;

export type InputFileSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: SendToRoutesTrueConstraintInputFileType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Choose how to discover files to monitor
   */
  mode?: SendToRoutesTrueConstraintMode | undefined;
  /**
   * Time, in seconds, between scanning for files
   */
  interval?: number | undefined;
  /**
   * The full path of discovered files are matched against this wildcard list
   */
  filenames?: Array<string> | undefined;
  /**
   * Apply filename allowlist to file entries in archive file types, like tar or zip.
   */
  filterArchivedFiles?: boolean | undefined;
  /**
   * Read only new entries at the end of all files discovered at next startup. @{product} will then read newly discovered files from the head. Disable this to resume reading all files from head.
   */
  tailOnly?: boolean | undefined;
  /**
   * Time, in seconds, before an idle file is closed
   */
  idleTimeout?: number | undefined;
  /**
   * The minimum age of files to monitor. Format examples: 30s, 15m, 1h. Age is relative to file modification time. Leave empty to apply no age filters.
   */
  minAgeDur?: string | undefined;
  /**
   * The maximum age of event timestamps to collect. Format examples: 60s, 4h, 3d, 1w. Can be used in conjuction with "Check file modification times". Leave empty to apply no age filters.
   */
  maxAgeDur?: string | undefined;
  /**
   * Skip files with modification times earlier than the maximum age duration
   */
  checkFileModTime?: boolean | undefined;
  /**
   * Forces files containing binary data to be streamed as text
   */
  forceText?: boolean | undefined;
  /**
   * Length of file header bytes to use in hash for unique file identification
   */
  hashLen?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  /**
   * Directory path to search for files. Environment variables will be resolved, e.g. $CRIBL_HOME/log/.
   */
  path?: string | undefined;
  /**
   * Set how many subdirectories deep to search. Use 0 to search only files in the given path, 1 to also look in its immediate subdirectories, etc. Leave it empty for unlimited depth.
   */
  depth?: number | undefined;
  suppressMissingPathErrors?: boolean | undefined;
  /**
   * Delete files after they have been collected
   */
  deleteFiles?: boolean | undefined;
  /**
   * Stream binary files as Base64-encoded chunks.
   */
  includeUnidentifiableBinary?: boolean | undefined;
};

export type InputFile =
  | InputFileSendToRoutesTrueConstraint
  | InputFileSendToRoutesFalseWithConnectionsConstraint
  | InputFilePqEnabledFalseConstraint
  | InputFilePqEnabledTrueWithPqConstraint;

export const InputSyslogType2 = {
  Syslog: "syslog",
} as const;
export type InputSyslogType2 = ClosedEnum<typeof InputSyslogType2>;

export type InputSyslogSyslog2 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSyslogType2;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort: number;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * Treat UDP packet data received as full syslog message
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Wildcard list of fields to keep from source data; * = ALL (default)
   */
  keepFieldsList?: Array<string> | undefined;
  /**
   * Enable if incoming messages use octet counting per RFC 6587.
   */
  octetCounting?: boolean | undefined;
  /**
   * Enable if we should infer the syslog framing of the incoming messages.
   */
  inferFraming?: boolean | undefined;
  /**
   * Enable if we should infer octet counting only if the messages comply with RFC 5424.
   */
  strictlyInferOctetCounting?: boolean | undefined;
  /**
   * Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
   */
  allowNonStandardAppName?: boolean | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
  /**
   * When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
   */
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

export const InputSyslogType1 = {
  Syslog: "syslog",
} as const;
export type InputSyslogType1 = ClosedEnum<typeof InputSyslogType1>;

export type InputSyslogSyslog1 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSyslogType1;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort: number;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * Treat UDP packet data received as full syslog message
   */
  singleMsgUdpPackets?: boolean | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Wildcard list of fields to keep from source data; * = ALL (default)
   */
  keepFieldsList?: Array<string> | undefined;
  /**
   * Enable if incoming messages use octet counting per RFC 6587.
   */
  octetCounting?: boolean | undefined;
  /**
   * Enable if we should infer the syslog framing of the incoming messages.
   */
  inferFraming?: boolean | undefined;
  /**
   * Enable if we should infer octet counting only if the messages comply with RFC 5424.
   */
  strictlyInferOctetCounting?: boolean | undefined;
  /**
   * Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages.
   */
  allowNonStandardAppName?: boolean | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
  /**
   * When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
   */
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

export type InputSyslog = InputSyslogSyslog1 | InputSyslogSyslog2;

export const InputSqsType = {
  Sqs: "sqs",
} as const;
export type InputSqsType = ClosedEnum<typeof InputSqsType>;

/**
 * The queue type used (or created)
 */
export const CreateInputQueueType = {
  /**
   * Standard
   */
  Standard: "standard",
  /**
   * FIFO
   */
  Fifo: "fifo",
} as const;
/**
 * The queue type used (or created)
 */
export type CreateInputQueueType = OpenEnum<typeof CreateInputQueueType>;

export type InputSqsPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSqsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * The queue type used (or created)
   */
  queueType: CreateInputQueueType;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * Create queue if it does not exist
   */
  createQueue?: boolean | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing SQS requests
   */
  signatureVersion?: models.SignatureVersionOptions3 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access SQS
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
};

export type InputSqsPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSqsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * The queue type used (or created)
   */
  queueType: CreateInputQueueType;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * Create queue if it does not exist
   */
  createQueue?: boolean | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing SQS requests
   */
  signatureVersion?: models.SignatureVersionOptions3 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access SQS
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
};

export type InputSqsSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSqsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * The queue type used (or created)
   */
  queueType: CreateInputQueueType;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * Create queue if it does not exist
   */
  createQueue?: boolean | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing SQS requests
   */
  signatureVersion?: models.SignatureVersionOptions3 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access SQS
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
};

export type InputSqsSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSqsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * The queue type used (or created)
   */
  queueType: CreateInputQueueType;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * Create queue if it does not exist
   */
  createQueue?: boolean | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing SQS requests
   */
  signatureVersion?: models.SignatureVersionOptions3 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access SQS
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
};

export type InputSqs =
  | InputSqsSendToRoutesTrueConstraint
  | InputSqsSendToRoutesFalseWithConnectionsConstraint
  | InputSqsPqEnabledFalseConstraint
  | InputSqsPqEnabledTrueWithPqConstraint;

export const InputModelDrivenTelemetryType = {
  ModelDrivenTelemetry: "model_driven_telemetry",
} as const;
export type InputModelDrivenTelemetryType = ClosedEnum<
  typeof InputModelDrivenTelemetryType
>;

export type InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputModelDrivenTelemetryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
   */
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

export type InputModelDrivenTelemetryPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputModelDrivenTelemetryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
   */
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

export type InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint =
  {
    /**
     * Select whether to send data to Routes, or directly to Destinations.
     */
    sendToRoutes: boolean;
    /**
     * Direct connections to Destinations, and optionally via a Pipeline or a Pack
     */
    connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
    /**
     * Unique ID for this input
     */
    id: string;
    type: InputModelDrivenTelemetryType;
    disabled?: boolean | undefined;
    /**
     * Pipeline to process data from this Source before sending it through the Routes
     */
    pipeline?: string | undefined;
    /**
     * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
     */
    environment?: string | undefined;
    /**
     * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
     */
    pqEnabled?: boolean | undefined;
    /**
     * Tags for filtering and grouping in @{product}
     */
    streamtags?: Array<string> | undefined;
    pq?: models.PqType | undefined;
    /**
     * Address to bind on. Defaults to 0.0.0.0 (all addresses).
     */
    host: string;
    /**
     * Port to listen on
     */
    port: number;
    tls?: models.TlsSettingsServerSideType | undefined;
    /**
     * Fields to add to events from this input
     */
    metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
    /**
     * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
     */
    maxActiveCxn?: number | undefined;
    /**
     * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
     */
    shutdownTimeoutMs?: number | undefined;
    description?: string | undefined;
  };

export type InputModelDrivenTelemetrySendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputModelDrivenTelemetryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * Time in milliseconds to allow the server to shutdown gracefully before forcing shutdown. Defaults to 5000.
   */
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

export type InputModelDrivenTelemetry =
  | InputModelDrivenTelemetrySendToRoutesTrueConstraint
  | InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint
  | InputModelDrivenTelemetryPqEnabledFalseConstraint
  | InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint;

export const InputOpenTelemetryType = {
  OpenTelemetry: "open_telemetry",
} as const;
export type InputOpenTelemetryType = ClosedEnum<typeof InputOpenTelemetryType>;

/**
 * Select whether to leverage gRPC or HTTP for OpenTelemetry
 */
export const CreateInputProtocol = {
  /**
   * gRPC
   */
  Grpc: "grpc",
  /**
   * HTTP
   */
  Http: "http",
} as const;
/**
 * Select whether to leverage gRPC or HTTP for OpenTelemetry
 */
export type CreateInputProtocol = OpenEnum<typeof CreateInputProtocol>;

/**
 * The version of OTLP Protobuf definitions to use when interpreting received data
 */
export const CreateInputOTLPVersion = {
  /**
   * 0.10.0
   */
  ZeroDot10Dot0: "0.10.0",
  /**
   * 1.3.1
   */
  OneDot3Dot1: "1.3.1",
} as const;
/**
 * The version of OTLP Protobuf definitions to use when interpreting received data
 */
export type CreateInputOTLPVersion = OpenEnum<typeof CreateInputOTLPVersion>;

export type InputOpenTelemetryPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOpenTelemetryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: any | undefined;
  captureHeaders?: any | undefined;
  activityLogSampleRate?: any | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Select whether to leverage gRPC or HTTP for OpenTelemetry
   */
  protocol?: CreateInputProtocol | undefined;
  /**
   * Enable to extract each incoming span to a separate event
   */
  extractSpans?: boolean | undefined;
  /**
   * Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
   */
  extractMetrics?: boolean | undefined;
  /**
   * The version of OTLP Protobuf definitions to use when interpreting received data
   */
  otlpVersion?: CreateInputOTLPVersion | undefined;
  /**
   * OpenTelemetry authentication type
   */
  authType?: models.AuthenticationTypeOptions | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
  /**
   * Enable to extract each incoming log record to a separate event
   */
  extractLogs?: boolean | undefined;
};

export type InputOpenTelemetryPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOpenTelemetryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: any | undefined;
  captureHeaders?: any | undefined;
  activityLogSampleRate?: any | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Select whether to leverage gRPC or HTTP for OpenTelemetry
   */
  protocol?: CreateInputProtocol | undefined;
  /**
   * Enable to extract each incoming span to a separate event
   */
  extractSpans?: boolean | undefined;
  /**
   * Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
   */
  extractMetrics?: boolean | undefined;
  /**
   * The version of OTLP Protobuf definitions to use when interpreting received data
   */
  otlpVersion?: CreateInputOTLPVersion | undefined;
  /**
   * OpenTelemetry authentication type
   */
  authType?: models.AuthenticationTypeOptions | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
  /**
   * Enable to extract each incoming log record to a separate event
   */
  extractLogs?: boolean | undefined;
};

export type InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOpenTelemetryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: any | undefined;
  captureHeaders?: any | undefined;
  activityLogSampleRate?: any | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Select whether to leverage gRPC or HTTP for OpenTelemetry
   */
  protocol?: CreateInputProtocol | undefined;
  /**
   * Enable to extract each incoming span to a separate event
   */
  extractSpans?: boolean | undefined;
  /**
   * Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
   */
  extractMetrics?: boolean | undefined;
  /**
   * The version of OTLP Protobuf definitions to use when interpreting received data
   */
  otlpVersion?: CreateInputOTLPVersion | undefined;
  /**
   * OpenTelemetry authentication type
   */
  authType?: models.AuthenticationTypeOptions | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
  /**
   * Enable to extract each incoming log record to a separate event
   */
  extractLogs?: boolean | undefined;
};

export type InputOpenTelemetrySendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOpenTelemetryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: any | undefined;
  captureHeaders?: any | undefined;
  activityLogSampleRate?: any | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 sec.; maximum 600 sec. (10 min.).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Enable to expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist.
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Select whether to leverage gRPC or HTTP for OpenTelemetry
   */
  protocol?: CreateInputProtocol | undefined;
  /**
   * Enable to extract each incoming span to a separate event
   */
  extractSpans?: boolean | undefined;
  /**
   * Enable to extract each incoming Gauge or IntGauge metric to multiple events, one per data point
   */
  extractMetrics?: boolean | undefined;
  /**
   * The version of OTLP Protobuf definitions to use when interpreting received data
   */
  otlpVersion?: CreateInputOTLPVersion | undefined;
  /**
   * OpenTelemetry authentication type
   */
  authType?: models.AuthenticationTypeOptions | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
  /**
   * Enable to extract each incoming log record to a separate event
   */
  extractLogs?: boolean | undefined;
};

export type InputOpenTelemetry =
  | InputOpenTelemetrySendToRoutesTrueConstraint
  | InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint
  | InputOpenTelemetryPqEnabledFalseConstraint
  | InputOpenTelemetryPqEnabledTrueWithPqConstraint;

export const InputSnmpType = {
  Snmp: "snmp",
} as const;
export type InputSnmpType = ClosedEnum<typeof InputSnmpType>;

export const PrivacyProtocol = {
  /**
   * None
   */
  None: "none",
  /**
   * DES
   */
  Des: "des",
  /**
   * AES128
   */
  Aes: "aes",
  /**
   * AES256b (Blumenthal)
   */
  Aes256b: "aes256b",
  /**
   * AES256r (Reeder)
   */
  Aes256r: "aes256r",
} as const;
export type PrivacyProtocol = OpenEnum<typeof PrivacyProtocol>;

export type V3User = {
  name: string;
  authProtocol?: models.AuthenticationProtocolOptionsV3User | undefined;
  authKey?: string | undefined;
  privProtocol?: PrivacyProtocol | undefined;
  privKey?: string | undefined;
};

/**
 * Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
 */
export type SNMPv3Authentication = {
  v3AuthEnabled: boolean;
  /**
   * Pass through traps that don't match any of the configured users. @{product} will not attempt to decrypt these traps.
   */
  allowUnmatchedTrap?: boolean | undefined;
  /**
   * User credentials for receiving v3 traps
   */
  v3Users?: Array<V3User> | undefined;
};

export type InputSnmpPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSnmpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * UDP port to receive SNMP traps on. Defaults to 162.
   */
  port: number;
  /**
   * Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
   */
  snmpV3Auth?: SNMPv3Authentication | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * If enabled, parses varbinds as an array of objects that include OID, value, and type
   */
  varbindsWithTypes?: boolean | undefined;
  /**
   * If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
   */
  bestEffortParsing?: boolean | undefined;
  description?: string | undefined;
};

export type InputSnmpPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSnmpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * UDP port to receive SNMP traps on. Defaults to 162.
   */
  port: number;
  /**
   * Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
   */
  snmpV3Auth?: SNMPv3Authentication | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * If enabled, parses varbinds as an array of objects that include OID, value, and type
   */
  varbindsWithTypes?: boolean | undefined;
  /**
   * If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
   */
  bestEffortParsing?: boolean | undefined;
  description?: string | undefined;
};

export type InputSnmpSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSnmpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * UDP port to receive SNMP traps on. Defaults to 162.
   */
  port: number;
  /**
   * Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
   */
  snmpV3Auth?: SNMPv3Authentication | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * If enabled, parses varbinds as an array of objects that include OID, value, and type
   */
  varbindsWithTypes?: boolean | undefined;
  /**
   * If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
   */
  bestEffortParsing?: boolean | undefined;
  description?: string | undefined;
};

export type InputSnmpSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSnmpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * UDP port to receive SNMP traps on. Defaults to 162.
   */
  port: number;
  /**
   * Authentication parameters for SNMPv3 trap. Set the log level to debug if you are experiencing authentication or decryption issues.
   */
  snmpV3Auth?: SNMPv3Authentication | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  /**
   * If enabled, parses varbinds as an array of objects that include OID, value, and type
   */
  varbindsWithTypes?: boolean | undefined;
  /**
   * If enabled, the parser will attempt to parse varbind octet strings as UTF-8, first, otherwise will fallback to other methods
   */
  bestEffortParsing?: boolean | undefined;
  description?: string | undefined;
};

export type InputSnmp =
  | InputSnmpSendToRoutesTrueConstraint
  | InputSnmpSendToRoutesFalseWithConnectionsConstraint
  | InputSnmpPqEnabledFalseConstraint
  | InputSnmpPqEnabledTrueWithPqConstraint;

export const InputS3InventoryType = {
  S3Inventory: "s3_inventory",
} as const;
export type InputS3InventoryType = ClosedEnum<typeof InputS3InventoryType>;

export type InputS3InventoryPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputS3InventoryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
   */
  checksumSuffix?: string | undefined;
  /**
   * Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
   */
  maxManifestSizeKB?: number | undefined;
  /**
   * If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
   */
  validateInventoryFiles?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputS3InventoryPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputS3InventoryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
   */
  checksumSuffix?: string | undefined;
  /**
   * Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
   */
  maxManifestSizeKB?: number | undefined;
  /**
   * If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
   */
  validateInventoryFiles?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputS3InventorySendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputS3InventoryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
   */
  checksumSuffix?: string | undefined;
  /**
   * Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
   */
  maxManifestSizeKB?: number | undefined;
  /**
   * If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
   */
  validateInventoryFiles?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputS3InventorySendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputS3InventoryType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Filename suffix of the manifest checksum file. If a filename matching this suffix is received        in the queue, the matching manifest file will be downloaded and validated against its value. Defaults to "checksum"
   */
  checksumSuffix?: string | undefined;
  /**
   * Maximum download size (KB) of each manifest or checksum file. Manifest files larger than this size will not be read.        Defaults to 4096.
   */
  maxManifestSizeKB?: number | undefined;
  /**
   * If set to Yes, each inventory file in the manifest will be validated against its checksum. Defaults to false
   */
  validateInventoryFiles?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputS3Inventory =
  | InputS3InventorySendToRoutesTrueConstraint
  | InputS3InventorySendToRoutesFalseWithConnectionsConstraint
  | InputS3InventoryPqEnabledFalseConstraint
  | InputS3InventoryPqEnabledTrueWithPqConstraint;

export const InputS3Type = {
  S3: "s3",
} as const;
export type InputS3Type = ClosedEnum<typeof InputS3Type>;

export type InputS3PqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputS3Type;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
   */
  tagAfterProcessing?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputS3PqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputS3Type;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
   */
  tagAfterProcessing?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputS3SendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputS3Type;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
   */
  tagAfterProcessing?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputS3SendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputS3Type;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * Add a tag to processed S3 objects. Requires s3:GetObjectTagging and s3:PutObjectTagging AWS permissions.
   */
  tagAfterProcessing?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputS3 =
  | InputS3SendToRoutesTrueConstraint
  | InputS3SendToRoutesFalseWithConnectionsConstraint
  | InputS3PqEnabledFalseConstraint
  | InputS3PqEnabledTrueWithPqConstraint;

export const InputMetricsType = {
  Metrics: "metrics",
} as const;
export type InputMetricsType = ClosedEnum<typeof InputMetricsType>;

export type InputMetricsPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

export type InputMetricsPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

export type InputMetricsSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

export type InputMetricsSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host: string;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

export type InputMetrics =
  | InputMetricsSendToRoutesTrueConstraint
  | InputMetricsSendToRoutesFalseWithConnectionsConstraint
  | InputMetricsPqEnabledFalseConstraint
  | InputMetricsPqEnabledTrueWithPqConstraint;

export const InputCriblmetricsType = {
  Criblmetrics: "criblmetrics",
} as const;
export type InputCriblmetricsType = ClosedEnum<typeof InputCriblmetricsType>;

export type InputCriblmetricsPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblmetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * A prefix that is applied to the metrics provided by Cribl Stream
   */
  prefix?: string | undefined;
  /**
   * Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`.
   */
  fullFidelity?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCriblmetricsPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblmetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * A prefix that is applied to the metrics provided by Cribl Stream
   */
  prefix?: string | undefined;
  /**
   * Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`.
   */
  fullFidelity?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblmetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * A prefix that is applied to the metrics provided by Cribl Stream
   */
  prefix?: string | undefined;
  /**
   * Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`.
   */
  fullFidelity?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCriblmetricsSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblmetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * A prefix that is applied to the metrics provided by Cribl Stream
   */
  prefix?: string | undefined;
  /**
   * Include granular metrics. Disabling this will drop the following metrics events: `cribl.logstream.host.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.index.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.source.(in_bytes,in_events,out_bytes,out_events)`, `cribl.logstream.sourcetype.(in_bytes,in_events,out_bytes,out_events)`.
   */
  fullFidelity?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCriblmetrics =
  | InputCriblmetricsSendToRoutesTrueConstraint
  | InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint
  | InputCriblmetricsPqEnabledFalseConstraint
  | InputCriblmetricsPqEnabledTrueWithPqConstraint;

export const InputKinesisType = {
  Kinesis: "kinesis",
} as const;
export type InputKinesisType = ClosedEnum<typeof InputKinesisType>;

/**
 * Location at which to start reading a shard for the first time
 */
export const ShardIteratorStart = {
  /**
   * Earliest record
   */
  TrimHorizon: "TRIM_HORIZON",
  /**
   * Latest record
   */
  Latest: "LATEST",
} as const;
/**
 * Location at which to start reading a shard for the first time
 */
export type ShardIteratorStart = OpenEnum<typeof ShardIteratorStart>;

/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export const RecordDataFormat = {
  /**
   * Cribl
   */
  Cribl: "cribl",
  /**
   * Newline JSON
   */
  Ndjson: "ndjson",
  /**
   * Cloudwatch Logs
   */
  Cloudwatch: "cloudwatch",
  /**
   * Event per line
   */
  Line: "line",
} as const;
/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export type RecordDataFormat = OpenEnum<typeof RecordDataFormat>;

/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export const ShardLoadBalancing = {
  /**
   * Consistent Hashing
   */
  ConsistentHashing: "ConsistentHashing",
  /**
   * Round Robin
   */
  RoundRobin: "RoundRobin",
} as const;
/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export type ShardLoadBalancing = OpenEnum<typeof ShardLoadBalancing>;

export type InputKinesisPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKinesisType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Kinesis stream requests
   */
  signatureVersion?: models.SignatureVersionOptions2 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export type InputKinesisPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKinesisType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Kinesis stream requests
   */
  signatureVersion?: models.SignatureVersionOptions2 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export type InputKinesisSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKinesisType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Kinesis stream requests
   */
  signatureVersion?: models.SignatureVersionOptions2 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export type InputKinesisSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKinesisType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Kinesis stream requests
   */
  signatureVersion?: models.SignatureVersionOptions2 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export type InputKinesis =
  | InputKinesisSendToRoutesTrueConstraint
  | InputKinesisSendToRoutesFalseWithConnectionsConstraint
  | InputKinesisPqEnabledFalseConstraint
  | InputKinesisPqEnabledTrueWithPqConstraint;

export const InputHttpRawType = {
  HttpRaw: "http_raw",
} as const;
export type InputHttpRawType = ClosedEnum<typeof InputHttpRawType>;

export type InputHttpRawPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputHttpRawType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List of URI paths accepted by this input, wildcards are supported, e.g /api/v* /hook. Defaults to allow all.
   */
  allowedPaths?: Array<string> | undefined;
  /**
   * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
   */
  allowedMethods?: Array<string> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputHttpRawPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputHttpRawType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List of URI paths accepted by this input, wildcards are supported, e.g /api/v* /hook. Defaults to allow all.
   */
  allowedPaths?: Array<string> | undefined;
  /**
   * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
   */
  allowedMethods?: Array<string> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputHttpRawSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputHttpRawType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List of URI paths accepted by this input, wildcards are supported, e.g /api/v* /hook. Defaults to allow all.
   */
  allowedPaths?: Array<string> | undefined;
  /**
   * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
   */
  allowedMethods?: Array<string> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputHttpRawSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputHttpRawType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List of URI paths accepted by this input, wildcards are supported, e.g /api/v* /hook. Defaults to allow all.
   */
  allowedPaths?: Array<string> | undefined;
  /**
   * List of HTTP methods accepted by this input. Wildcards are supported (such as P*, GET). Defaults to allow all.
   */
  allowedMethods?: Array<string> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputHttpRaw =
  | InputHttpRawSendToRoutesTrueConstraint
  | InputHttpRawSendToRoutesFalseWithConnectionsConstraint
  | InputHttpRawPqEnabledFalseConstraint
  | InputHttpRawPqEnabledTrueWithPqConstraint;

export const InputDatagenType = {
  Datagen: "datagen",
} as const;
export type InputDatagenType = ClosedEnum<typeof InputDatagenType>;

export type Sample = {
  sample: string;
  /**
   * Maximum number of events to generate per second per Worker Node. Defaults to 10.
   */
  eventsPerSec: number;
};

export type InputDatagenPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputDatagenType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  samples: Array<Sample>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputDatagenPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputDatagenType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  samples: Array<Sample>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputDatagenSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputDatagenType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  samples: Array<Sample>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputDatagenSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputDatagenType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  samples: Array<Sample>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputDatagen =
  | InputDatagenSendToRoutesTrueConstraint
  | InputDatagenSendToRoutesFalseWithConnectionsConstraint
  | InputDatagenPqEnabledFalseConstraint
  | InputDatagenPqEnabledTrueWithPqConstraint;

export const InputDatadogAgentType = {
  DatadogAgent: "datadog_agent",
} as const;
export type InputDatadogAgentType = ClosedEnum<typeof InputDatadogAgentType>;

export type InputDatadogAgentProxyMode = {
  /**
   * Toggle to Yes to send key validation requests from Datadog Agent to the Datadog API. If toggled to No (the default), Stream handles key validation requests by always responding that the key is valid.
   */
  enabled: boolean;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
};

export type InputDatadogAgentPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputDatadogAgentType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
   */
  extractMetrics?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  proxyMode?: InputDatadogAgentProxyMode | undefined;
  description?: string | undefined;
};

export type InputDatadogAgentPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputDatadogAgentType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
   */
  extractMetrics?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  proxyMode?: InputDatadogAgentProxyMode | undefined;
  description?: string | undefined;
};

export type InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputDatadogAgentType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
   */
  extractMetrics?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  proxyMode?: InputDatadogAgentProxyMode | undefined;
  description?: string | undefined;
};

export type InputDatadogAgentSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputDatadogAgentType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Toggle to Yes to extract each incoming metric to multiple events, one per data point. This works well when sending metrics to a statsd-type output. If sending metrics to DatadogHQ or any destination that accepts arbitrary JSON, leave toggled to No (the default).
   */
  extractMetrics?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  proxyMode?: InputDatadogAgentProxyMode | undefined;
  description?: string | undefined;
};

export type InputDatadogAgent =
  | InputDatadogAgentSendToRoutesTrueConstraint
  | InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint
  | InputDatadogAgentPqEnabledFalseConstraint
  | InputDatadogAgentPqEnabledTrueWithPqConstraint;

export const InputCrowdstrikeType = {
  Crowdstrike: "crowdstrike",
} as const;
export type InputCrowdstrikeType = ClosedEnum<typeof InputCrowdstrikeType>;

export type InputCrowdstrikePqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCrowdstrikeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputCrowdstrikePqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCrowdstrikeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCrowdstrikeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputCrowdstrikeSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCrowdstrikeType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The name, URL, or ARN of the SQS queue to read notifications from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
   */
  awsAccountId?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * AWS Region where the S3 bucket and SQS queue are located. Required, unless the Queue entry is a URL or ARN that includes a Region.
   */
  region?: string | undefined;
  /**
   * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing S3 requests
   */
  signatureVersion?: models.SignatureVersionOptionsS3CollectorConf | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10.
   */
  maxMessages?: number | undefined;
  /**
   * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours).
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * Socket inactivity timeout (in seconds). Increase this value if timeouts occur due to backpressure.
   */
  socketTimeout?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Attach SQS notification metadata to a __sqsMetadata field on each event
   */
  includeSqsMetadata?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Amazon S3
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Use Assume Role credentials when accessing Amazon SQS
   */
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  checkpointing?: models.CheckpointingType | undefined;
  /**
   * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts.
   */
  pollTimeout?: number | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  tagAfterProcessing?: models.TagAfterProcessingOptions | undefined;
  /**
   * The key for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagKey?: string | undefined;
  /**
   * The value for the S3 object tag applied after processing. This field accepts an expression for dynamic generation.
   */
  processedTagValue?: string | undefined;
};

export type InputCrowdstrike =
  | InputCrowdstrikeSendToRoutesTrueConstraint
  | InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint
  | InputCrowdstrikePqEnabledFalseConstraint
  | InputCrowdstrikePqEnabledTrueWithPqConstraint;

export const InputWindowsMetricsType = {
  WindowsMetrics: "windows_metrics",
} as const;
export type InputWindowsMetricsType = ClosedEnum<
  typeof InputWindowsMetricsType
>;

/**
 * Select the level of details for system metrics
 */
export const InputWindowsMetricsSystemMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for system metrics
 */
export type InputWindowsMetricsSystemMode = OpenEnum<
  typeof InputWindowsMetricsSystemMode
>;

export type InputWindowsMetricsSystem = {
  /**
   * Select the level of details for system metrics
   */
  mode?: InputWindowsMetricsSystemMode | undefined;
  /**
   * Generate metrics for all system information
   */
  detail?: boolean | undefined;
};

/**
 * Select the level of details for CPU metrics
 */
export const InputWindowsMetricsCpuMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for CPU metrics
 */
export type InputWindowsMetricsCpuMode = OpenEnum<
  typeof InputWindowsMetricsCpuMode
>;

export type InputWindowsMetricsCpu = {
  /**
   * Select the level of details for CPU metrics
   */
  mode?: InputWindowsMetricsCpuMode | undefined;
  /**
   * Generate metrics for each CPU
   */
  perCpu?: boolean | undefined;
  /**
   * Generate metrics for all CPU states
   */
  detail?: boolean | undefined;
  /**
   * Generate raw, monotonic CPU time counters
   */
  time?: boolean | undefined;
};

/**
 * Select the level of details for memory metrics
 */
export const InputWindowsMetricsMemoryMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for memory metrics
 */
export type InputWindowsMetricsMemoryMode = OpenEnum<
  typeof InputWindowsMetricsMemoryMode
>;

export type InputWindowsMetricsMemory = {
  /**
   * Select the level of details for memory metrics
   */
  mode?: InputWindowsMetricsMemoryMode | undefined;
  /**
   * Generate metrics for all memory states
   */
  detail?: boolean | undefined;
};

/**
 * Select the level of details for network metrics
 */
export const InputWindowsMetricsNetworkMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for network metrics
 */
export type InputWindowsMetricsNetworkMode = OpenEnum<
  typeof InputWindowsMetricsNetworkMode
>;

export type InputWindowsMetricsNetwork = {
  /**
   * Select the level of details for network metrics
   */
  mode?: InputWindowsMetricsNetworkMode | undefined;
  /**
   * Generate full network metrics
   */
  detail?: boolean | undefined;
  /**
   * Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
   */
  protocols?: boolean | undefined;
  /**
   * Network interfaces to include/exclude. All interfaces are included if this list is empty.
   */
  devices?: Array<string> | undefined;
  /**
   * Generate separate metrics for each interface
   */
  perInterface?: boolean | undefined;
};

/**
 * Select the level of details for disk metrics
 */
export const InputWindowsMetricsDiskMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for disk metrics
 */
export type InputWindowsMetricsDiskMode = OpenEnum<
  typeof InputWindowsMetricsDiskMode
>;

export type InputWindowsMetricsDisk = {
  /**
   * Select the level of details for disk metrics
   */
  mode?: InputWindowsMetricsDiskMode | undefined;
  /**
   * Generate separate metrics for each volume
   */
  perVolume?: boolean | undefined;
  /**
   * Generate full disk metrics
   */
  detail?: boolean | undefined;
  /**
   * Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty.
   */
  volumes?: Array<string> | undefined;
};

export type InputWindowsMetricsCustom = {
  system?: InputWindowsMetricsSystem | undefined;
  cpu?: InputWindowsMetricsCpu | undefined;
  memory?: InputWindowsMetricsMemory | undefined;
  network?: InputWindowsMetricsNetwork | undefined;
  disk?: InputWindowsMetricsDisk | undefined;
};

export type InputWindowsMetricsHost = {
  /**
   * Select level of detail for host metrics
   */
  mode?: models.ModeOptionsHost | undefined;
  custom?: InputWindowsMetricsCustom | undefined;
};

export type InputWindowsMetricsPersistence = {
  /**
   * Spool metrics to disk for Cribl Edge and Search
   */
  enable?: boolean | undefined;
  /**
   * Time span for each file bucket
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
   */
  maxDataTime?: string | undefined;
  compress?: models.DataCompressionFormatOptionsPersistence | undefined;
  /**
   * Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics
   */
  destPath?: string | undefined;
};

export type InputWindowsMetricsPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWindowsMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputWindowsMetricsHost | undefined;
  process?: models.ProcessType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputWindowsMetricsPersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputWindowsMetricsPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWindowsMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputWindowsMetricsHost | undefined;
  process?: models.ProcessType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputWindowsMetricsPersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWindowsMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputWindowsMetricsHost | undefined;
  process?: models.ProcessType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputWindowsMetricsPersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputWindowsMetricsSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputWindowsMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputWindowsMetricsHost | undefined;
  process?: models.ProcessType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputWindowsMetricsPersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputWindowsMetrics =
  | InputWindowsMetricsSendToRoutesTrueConstraint
  | InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint
  | InputWindowsMetricsPqEnabledFalseConstraint
  | InputWindowsMetricsPqEnabledTrueWithPqConstraint;

export const InputKubeEventsType = {
  KubeEvents: "kube_events",
} as const;
export type InputKubeEventsType = ClosedEnum<typeof InputKubeEventsType>;

export type InputKubeEventsPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeEventsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Filtering on event fields
   */
  rules?: Array<models.ItemsTypeRules> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputKubeEventsPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeEventsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Filtering on event fields
   */
  rules?: Array<models.ItemsTypeRules> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputKubeEventsSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeEventsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Filtering on event fields
   */
  rules?: Array<models.ItemsTypeRules> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputKubeEventsSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeEventsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Filtering on event fields
   */
  rules?: Array<models.ItemsTypeRules> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputKubeEvents =
  | InputKubeEventsSendToRoutesTrueConstraint
  | InputKubeEventsSendToRoutesFalseWithConnectionsConstraint
  | InputKubeEventsPqEnabledFalseConstraint
  | InputKubeEventsPqEnabledTrueWithPqConstraint;

export const InputKubeLogsType = {
  KubeLogs: "kube_logs",
} as const;
export type InputKubeLogsType = ClosedEnum<typeof InputKubeLogsType>;

export type InputKubeLogsRule = {
  /**
   * JavaScript expression applied to Pod objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputKubeLogsPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeLogsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Time, in seconds, between checks for new containers. Default is 15 secs.
   */
  interval?: number | undefined;
  /**
   * Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<InputKubeLogsRule> | undefined;
  /**
   * For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted.
   */
  timestamps?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: models.DiskSpoolingType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
};

export type InputKubeLogsPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeLogsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between checks for new containers. Default is 15 secs.
   */
  interval?: number | undefined;
  /**
   * Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<InputKubeLogsRule> | undefined;
  /**
   * For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted.
   */
  timestamps?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: models.DiskSpoolingType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
};

export type InputKubeLogsSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeLogsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between checks for new containers. Default is 15 secs.
   */
  interval?: number | undefined;
  /**
   * Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<InputKubeLogsRule> | undefined;
  /**
   * For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted.
   */
  timestamps?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: models.DiskSpoolingType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
};

export type InputKubeLogsSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeLogsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between checks for new containers. Default is 15 secs.
   */
  interval?: number | undefined;
  /**
   * Add rules to decide which Pods to collect logs from. Logs are collected if no rules are given or if all the rules' expressions evaluate to true.
   */
  rules?: Array<InputKubeLogsRule> | undefined;
  /**
   * For use when containers do not emit a timestamp, prefix each line of output with a timestamp. If you enable this setting, you can use the Kubernetes Logs Event Breaker and the kubernetes_logs Pre-processing Pipeline to remove them from the events after the timestamps are extracted.
   */
  timestamps?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: models.DiskSpoolingType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
};

export type InputKubeLogs =
  | InputKubeLogsSendToRoutesTrueConstraint
  | InputKubeLogsSendToRoutesFalseWithConnectionsConstraint
  | InputKubeLogsPqEnabledFalseConstraint
  | InputKubeLogsPqEnabledTrueWithPqConstraint;

export const InputKubeMetricsType = {
  KubeMetrics: "kube_metrics",
} as const;
export type InputKubeMetricsType = ClosedEnum<typeof InputKubeMetricsType>;

export type InputKubeMetricsPersistence = {
  /**
   * Spool metrics on disk for Cribl Search
   */
  enable?: boolean | undefined;
  /**
   * Time span for each file bucket
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
   */
  maxDataTime?: string | undefined;
  compress?: models.DataCompressionFormatOptionsPersistence | undefined;
  /**
   * Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>
   */
  destPath?: string | undefined;
};

export type InputKubeMetricsPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Time, in seconds, between consecutive metrics collections. Default is 15 secs.
   */
  interval?: number | undefined;
  /**
   * Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
   */
  rules?: Array<models.ItemsTypeRules> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputKubeMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputKubeMetricsPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive metrics collections. Default is 15 secs.
   */
  interval?: number | undefined;
  /**
   * Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
   */
  rules?: Array<models.ItemsTypeRules> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputKubeMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive metrics collections. Default is 15 secs.
   */
  interval?: number | undefined;
  /**
   * Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
   */
  rules?: Array<models.ItemsTypeRules> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputKubeMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputKubeMetricsSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKubeMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive metrics collections. Default is 15 secs.
   */
  interval?: number | undefined;
  /**
   * Add rules to decide which Kubernetes objects to generate metrics for. Events are generated if no rules are given or of all the rules' expressions evaluate to true.
   */
  rules?: Array<models.ItemsTypeRules> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputKubeMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputKubeMetrics =
  | InputKubeMetricsSendToRoutesTrueConstraint
  | InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint
  | InputKubeMetricsPqEnabledFalseConstraint
  | InputKubeMetricsPqEnabledTrueWithPqConstraint;

export const InputSystemStateType = {
  SystemState: "system_state",
} as const;
export type InputSystemStateType = ClosedEnum<typeof InputSystemStateType>;

/**
 * Creates events based on entries collected from the hosts file
 */
export type HostsFile = {
  enable?: boolean | undefined;
};

/**
 * Creates events for each of the hosts network interfaces
 */
export type Interfaces = {
  enable?: boolean | undefined;
};

/**
 * Creates events for physical disks, partitions, and file systems
 */
export type DisksAndFileSystems = {
  enable?: boolean | undefined;
};

/**
 * Creates events based on the host systems current state
 */
export type HostInfo = {
  enable?: boolean | undefined;
};

/**
 * Creates events based on entries collected from the hosts network routes
 */
export type Routes = {
  enable?: boolean | undefined;
};

/**
 * Creates events for DNS resolvers and search entries
 */
export type Dns = {
  enable?: boolean | undefined;
};

/**
 * Creates events for local users and groups
 */
export type UsersAndGroups = {
  enable?: boolean | undefined;
};

/**
 * Creates events for Firewall rules entries
 */
export type Firewall = {
  enable?: boolean | undefined;
};

/**
 * Creates events from the list of services
 */
export type Services = {
  enable?: boolean | undefined;
};

/**
 * Creates events from list of listening ports
 */
export type ListeningPorts = {
  enable?: boolean | undefined;
};

/**
 * Creates events from list of logged-in users
 */
export type LoggedInUsers = {
  enable?: boolean | undefined;
};

export type Collectors = {
  /**
   * Creates events based on entries collected from the hosts file
   */
  hostsfile?: HostsFile | undefined;
  /**
   * Creates events for each of the hosts network interfaces
   */
  interfaces?: Interfaces | undefined;
  /**
   * Creates events for physical disks, partitions, and file systems
   */
  disk?: DisksAndFileSystems | undefined;
  /**
   * Creates events based on the host systems current state
   */
  metadata?: HostInfo | undefined;
  /**
   * Creates events based on entries collected from the hosts network routes
   */
  routes?: Routes | undefined;
  /**
   * Creates events for DNS resolvers and search entries
   */
  dns?: Dns | undefined;
  /**
   * Creates events for local users and groups
   */
  user?: UsersAndGroups | undefined;
  /**
   * Creates events for Firewall rules entries
   */
  firewall?: Firewall | undefined;
  /**
   * Creates events from the list of services
   */
  services?: Services | undefined;
  /**
   * Creates events from list of listening ports
   */
  ports?: ListeningPorts | undefined;
  /**
   * Creates events from list of logged-in users
   */
  loginUsers?: LoggedInUsers | undefined;
};

export type InputSystemStatePersistence = {
  /**
   * Spool metrics to disk for Cribl Edge and Search
   */
  enable?: boolean | undefined;
  /**
   * Time span for each file bucket
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
   */
  maxDataTime?: string | undefined;
  compress?: models.DataCompressionFormatOptionsPersistence | undefined;
  /**
   * Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_state
   */
  destPath?: string | undefined;
};

export type InputSystemStatePqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSystemStateType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
   */
  interval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  collectors?: Collectors | undefined;
  persistence?: InputSystemStatePersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputSystemStatePqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSystemStateType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
   */
  interval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  collectors?: Collectors | undefined;
  persistence?: InputSystemStatePersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputSystemStateSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSystemStateType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
   */
  interval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  collectors?: Collectors | undefined;
  persistence?: InputSystemStatePersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputSystemStateSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSystemStateType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
   */
  interval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  collectors?: Collectors | undefined;
  persistence?: InputSystemStatePersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputSystemState =
  | InputSystemStateSendToRoutesTrueConstraint
  | InputSystemStateSendToRoutesFalseWithConnectionsConstraint
  | InputSystemStatePqEnabledFalseConstraint
  | InputSystemStatePqEnabledTrueWithPqConstraint;

export const InputSystemMetricsType = {
  SystemMetrics: "system_metrics",
} as const;
export type InputSystemMetricsType = ClosedEnum<typeof InputSystemMetricsType>;

/**
 * Select the level of detail for system metrics
 */
export const InputSystemMetricsSystemMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for system metrics
 */
export type InputSystemMetricsSystemMode = OpenEnum<
  typeof InputSystemMetricsSystemMode
>;

export type InputSystemMetricsSystem = {
  /**
   * Select the level of detail for system metrics
   */
  mode?: InputSystemMetricsSystemMode | undefined;
  /**
   * Generate metrics for the numbers of processes in various states
   */
  processes?: boolean | undefined;
};

/**
 * Select the level of detail for CPU metrics
 */
export const InputSystemMetricsCpuMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for CPU metrics
 */
export type InputSystemMetricsCpuMode = OpenEnum<
  typeof InputSystemMetricsCpuMode
>;

export type InputSystemMetricsCpu = {
  /**
   * Select the level of detail for CPU metrics
   */
  mode?: InputSystemMetricsCpuMode | undefined;
  /**
   * Generate metrics for each CPU
   */
  perCpu?: boolean | undefined;
  /**
   * Generate metrics for all CPU states
   */
  detail?: boolean | undefined;
  /**
   * Generate raw, monotonic CPU time counters
   */
  time?: boolean | undefined;
};

/**
 * Select the level of detail for memory metrics
 */
export const InputSystemMetricsMemoryMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for memory metrics
 */
export type InputSystemMetricsMemoryMode = OpenEnum<
  typeof InputSystemMetricsMemoryMode
>;

export type InputSystemMetricsMemory = {
  /**
   * Select the level of detail for memory metrics
   */
  mode?: InputSystemMetricsMemoryMode | undefined;
  /**
   * Generate metrics for all memory states
   */
  detail?: boolean | undefined;
};

/**
 * Select the level of detail for network metrics
 */
export const InputSystemMetricsNetworkMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for network metrics
 */
export type InputSystemMetricsNetworkMode = OpenEnum<
  typeof InputSystemMetricsNetworkMode
>;

export type InputSystemMetricsNetwork = {
  /**
   * Select the level of detail for network metrics
   */
  mode?: InputSystemMetricsNetworkMode | undefined;
  /**
   * Generate full network metrics
   */
  detail?: boolean | undefined;
  /**
   * Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
   */
  protocols?: boolean | undefined;
  /**
   * Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty.
   */
  devices?: Array<string> | undefined;
  /**
   * Generate separate metrics for each interface
   */
  perInterface?: boolean | undefined;
};

/**
 * Select the level of detail for disk metrics
 */
export const InputSystemMetricsDiskMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for disk metrics
 */
export type InputSystemMetricsDiskMode = OpenEnum<
  typeof InputSystemMetricsDiskMode
>;

export type InputSystemMetricsDisk = {
  /**
   * Select the level of detail for disk metrics
   */
  mode?: InputSystemMetricsDiskMode | undefined;
  /**
   * Generate full disk metrics
   */
  detail?: boolean | undefined;
  /**
   * Generate filesystem inode metrics
   */
  inodes?: boolean | undefined;
  /**
   * Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty.
   */
  devices?: Array<string> | undefined;
  /**
   * Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty.
   */
  mountpoints?: Array<string> | undefined;
  /**
   * Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty.
   */
  fstypes?: Array<string> | undefined;
  /**
   * Generate separate metrics for each device
   */
  perDevice?: boolean | undefined;
};

export type InputSystemMetricsCustom = {
  system?: InputSystemMetricsSystem | undefined;
  cpu?: InputSystemMetricsCpu | undefined;
  memory?: InputSystemMetricsMemory | undefined;
  network?: InputSystemMetricsNetwork | undefined;
  disk?: InputSystemMetricsDisk | undefined;
};

export type InputSystemMetricsHost = {
  /**
   * Select level of detail for host metrics
   */
  mode?: models.ModeOptionsHost | undefined;
  custom?: InputSystemMetricsCustom | undefined;
};

/**
 * Select the level of detail for container metrics
 */
export const ContainerMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for container metrics
 */
export type ContainerMode = OpenEnum<typeof ContainerMode>;

export type InputSystemMetricsFilter = {
  expr: string;
};

export type Container = {
  /**
   * Select the level of detail for container metrics
   */
  mode?: ContainerMode | undefined;
  /**
   * Full paths for Docker's UNIX-domain socket
   */
  dockerSocket?: Array<string> | undefined;
  /**
   * Timeout, in seconds, for the Docker API
   */
  dockerTimeout?: number | undefined;
  /**
   * Containers matching any of these will be included. All are included if no filters are added.
   */
  filters?: Array<InputSystemMetricsFilter> | undefined;
  /**
   * Include stopped and paused containers
   */
  allContainers?: boolean | undefined;
  /**
   * Generate separate metrics for each device
   */
  perDevice?: boolean | undefined;
  /**
   * Generate full container metrics
   */
  detail?: boolean | undefined;
};

export type InputSystemMetricsPersistence = {
  /**
   * Spool metrics to disk for Cribl Edge and Search
   */
  enable?: boolean | undefined;
  /**
   * Time span for each file bucket
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
   */
  maxDataTime?: string | undefined;
  compress?: models.DataCompressionFormatOptionsPersistence | undefined;
  /**
   * Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics
   */
  destPath?: string | undefined;
};

export type InputSystemMetricsPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSystemMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputSystemMetricsHost | undefined;
  process?: models.ProcessType | undefined;
  container?: Container | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputSystemMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputSystemMetricsPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSystemMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputSystemMetricsHost | undefined;
  process?: models.ProcessType | undefined;
  container?: Container | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputSystemMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSystemMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputSystemMetricsHost | undefined;
  process?: models.ProcessType | undefined;
  container?: Container | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputSystemMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputSystemMetricsSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSystemMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputSystemMetricsHost | undefined;
  process?: models.ProcessType | undefined;
  container?: Container | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputSystemMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputSystemMetrics =
  | InputSystemMetricsSendToRoutesTrueConstraint
  | InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint
  | InputSystemMetricsPqEnabledFalseConstraint
  | InputSystemMetricsPqEnabledTrueWithPqConstraint;

export const InputTcpjsonType = {
  Tcpjson: "tcpjson",
} as const;
export type InputTcpjsonType = ClosedEnum<typeof InputTcpjsonType>;

export type InputTcpjsonPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputTcpjsonType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputTcpjsonPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputTcpjsonType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputTcpjsonSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputTcpjsonType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputTcpjsonSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputTcpjsonType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputTcpjson =
  | InputTcpjsonSendToRoutesTrueConstraint
  | InputTcpjsonSendToRoutesFalseWithConnectionsConstraint
  | InputTcpjsonPqEnabledFalseConstraint
  | InputTcpjsonPqEnabledTrueWithPqConstraint;

export const InputCriblLakeHttpType = {
  CriblLakeHttp: "cribl_lake_http",
} as const;
export type InputCriblLakeHttpType = ClosedEnum<typeof InputCriblLakeHttpType>;

export type SplunkHecMetadata = {
  enabled?: boolean | undefined;
  defaultDataset?: string | undefined;
  allowedIndexesAtToken?: Array<string> | undefined;
};

export type ElasticsearchMetadata = {
  enabled?: boolean | undefined;
  defaultDataset?: string | undefined;
};

export type AuthTokensExt = {
  token: string;
  description?: string | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  splunkHecMetadata?: SplunkHecMetadata | undefined;
  elasticsearchMetadata?: ElasticsearchMetadata | undefined;
};

export type InputCriblLakeHttpPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblLakeHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
   */
  criblAPI?: string | undefined;
  /**
   * Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
   */
  elasticAPI?: string | undefined;
  /**
   * Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
   */
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  authTokensExt?: Array<AuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputCriblLakeHttpPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblLakeHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
   */
  criblAPI?: string | undefined;
  /**
   * Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
   */
  elasticAPI?: string | undefined;
  /**
   * Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
   */
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  authTokensExt?: Array<AuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblLakeHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
   */
  criblAPI?: string | undefined;
  /**
   * Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
   */
  elasticAPI?: string | undefined;
  /**
   * Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
   */
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  authTokensExt?: Array<AuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputCriblLakeHttpSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblLakeHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
   */
  criblAPI?: string | undefined;
  /**
   * Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
   */
  elasticAPI?: string | undefined;
  /**
   * Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
   */
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  authTokensExt?: Array<AuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputCriblLakeHttp =
  | InputCriblLakeHttpSendToRoutesTrueConstraint
  | InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint
  | InputCriblLakeHttpPqEnabledFalseConstraint
  | InputCriblLakeHttpPqEnabledTrueWithPqConstraint;

export const InputCriblHttpType = {
  CriblHttp: "cribl_http",
} as const;
export type InputCriblHttpType = ClosedEnum<typeof InputCriblHttpType>;

export type InputCriblHttpPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments.
   */
  authTokens?: Array<models.ItemsTypeAuthTokens> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCriblHttpPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments.
   */
  authTokens?: Array<models.ItemsTypeAuthTokens> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCriblHttpSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments.
   */
  authTokens?: Array<models.ItemsTypeAuthTokens> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCriblHttpSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl HTTP destinations in connected environments.
   */
  authTokens?: Array<models.ItemsTypeAuthTokens> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCriblHttp =
  | InputCriblHttpSendToRoutesTrueConstraint
  | InputCriblHttpSendToRoutesFalseWithConnectionsConstraint
  | InputCriblHttpPqEnabledFalseConstraint
  | InputCriblHttpPqEnabledTrueWithPqConstraint;

export const InputCriblTcpType = {
  CriblTcp: "cribl_tcp",
} as const;
export type InputCriblTcpType = ClosedEnum<typeof InputCriblTcpType>;

export type InputCriblTcpPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblTcpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  /**
   * Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments.
   */
  authTokens?: Array<models.ItemsTypeAuthTokens> | undefined;
  description?: string | undefined;
};

export type InputCriblTcpPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblTcpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  /**
   * Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments.
   */
  authTokens?: Array<models.ItemsTypeAuthTokens> | undefined;
  description?: string | undefined;
};

export type InputCriblTcpSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblTcpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  /**
   * Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments.
   */
  authTokens?: Array<models.ItemsTypeAuthTokens> | undefined;
  description?: string | undefined;
};

export type InputCriblTcpSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblTcpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Load balance traffic across all Worker Processes
   */
  enableLoadBalancing?: boolean | undefined;
  /**
   * Shared secrets to be used by connected environments to authorize connections. These tokens should be installed in Cribl TCP destinations in connected environments.
   */
  authTokens?: Array<models.ItemsTypeAuthTokens> | undefined;
  description?: string | undefined;
};

export type InputCriblTcp =
  | InputCriblTcpSendToRoutesTrueConstraint
  | InputCriblTcpSendToRoutesFalseWithConnectionsConstraint
  | InputCriblTcpPqEnabledFalseConstraint
  | InputCriblTcpPqEnabledTrueWithPqConstraint;

export const InputCriblType = {
  Cribl: "cribl",
} as const;
export type InputCriblType = ClosedEnum<typeof InputCriblType>;

export type InputCriblPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  filter?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCriblPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  filter?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCriblSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  filter?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCriblSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCriblType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  filter?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputCribl =
  | InputCriblSendToRoutesTrueConstraint
  | InputCriblSendToRoutesFalseWithConnectionsConstraint
  | InputCriblPqEnabledFalseConstraint
  | InputCriblPqEnabledTrueWithPqConstraint;

export const InputGooglePubsubType = {
  GooglePubsub: "google_pubsub",
} as const;
export type InputGooglePubsubType = ClosedEnum<typeof InputGooglePubsubType>;

export type InputGooglePubsubPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputGooglePubsubType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered.
   */
  topicName: string;
  /**
   * ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription
   */
  subscriptionName: string;
  /**
   * Use when the subscription is not created by this Source and topic is not known
   */
  monitorSubscription?: boolean | undefined;
  /**
   * Create topic if it does not exist
   */
  createTopic?: boolean | undefined;
  /**
   * Create subscription if it does not exist
   */
  createSubscription?: boolean | undefined;
  /**
   * Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   */
  region?: string | undefined;
  /**
   * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
   */
  googleAuthMethod?: models.GoogleAuthenticationMethodOptions | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  secret?: string | undefined;
  /**
   * If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
   */
  maxBacklog?: number | undefined;
  /**
   * How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
   */
  concurrency?: number | undefined;
  /**
   * Pull request timeout, in milliseconds
   */
  requestTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
   */
  orderedDelivery?: boolean | undefined;
};

export type InputGooglePubsubPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputGooglePubsubType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered.
   */
  topicName: string;
  /**
   * ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription
   */
  subscriptionName: string;
  /**
   * Use when the subscription is not created by this Source and topic is not known
   */
  monitorSubscription?: boolean | undefined;
  /**
   * Create topic if it does not exist
   */
  createTopic?: boolean | undefined;
  /**
   * Create subscription if it does not exist
   */
  createSubscription?: boolean | undefined;
  /**
   * Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   */
  region?: string | undefined;
  /**
   * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
   */
  googleAuthMethod?: models.GoogleAuthenticationMethodOptions | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  secret?: string | undefined;
  /**
   * If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
   */
  maxBacklog?: number | undefined;
  /**
   * How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
   */
  concurrency?: number | undefined;
  /**
   * Pull request timeout, in milliseconds
   */
  requestTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
   */
  orderedDelivery?: boolean | undefined;
};

export type InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputGooglePubsubType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered.
   */
  topicName: string;
  /**
   * ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription
   */
  subscriptionName: string;
  /**
   * Use when the subscription is not created by this Source and topic is not known
   */
  monitorSubscription?: boolean | undefined;
  /**
   * Create topic if it does not exist
   */
  createTopic?: boolean | undefined;
  /**
   * Create subscription if it does not exist
   */
  createSubscription?: boolean | undefined;
  /**
   * Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   */
  region?: string | undefined;
  /**
   * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
   */
  googleAuthMethod?: models.GoogleAuthenticationMethodOptions | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  secret?: string | undefined;
  /**
   * If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
   */
  maxBacklog?: number | undefined;
  /**
   * How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
   */
  concurrency?: number | undefined;
  /**
   * Pull request timeout, in milliseconds
   */
  requestTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
   */
  orderedDelivery?: boolean | undefined;
};

export type InputGooglePubsubSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputGooglePubsubType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * ID of the topic to receive events from. When Monitor subscription is enabled, any value may be entered.
   */
  topicName: string;
  /**
   * ID of the subscription to use when receiving events. When Monitor subscription is enabled, the fully qualified subscription name must be entered. Example: projects/myProject/subscriptions/mySubscription
   */
  subscriptionName: string;
  /**
   * Use when the subscription is not created by this Source and topic is not known
   */
  monitorSubscription?: boolean | undefined;
  /**
   * Create topic if it does not exist
   */
  createTopic?: boolean | undefined;
  /**
   * Create subscription if it does not exist
   */
  createSubscription?: boolean | undefined;
  /**
   * Region to retrieve messages from. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
   */
  region?: string | undefined;
  /**
   * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials.
   */
  googleAuthMethod?: models.GoogleAuthenticationMethodOptions | undefined;
  /**
   * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
   */
  serviceAccountCredentials?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  secret?: string | undefined;
  /**
   * If Destination exerts backpressure, this setting limits how many inbound events Stream will queue for processing before it stops retrieving events
   */
  maxBacklog?: number | undefined;
  /**
   * How many streams to pull messages from at one time. Doubling the value doubles the number of messages this Source pulls from the topic (if available), while consuming more CPU and memory. Defaults to 5.
   */
  concurrency?: number | undefined;
  /**
   * Pull request timeout, in milliseconds
   */
  requestTimeout?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Receive events in the order they were added to the queue. The process sending events must have ordering enabled.
   */
  orderedDelivery?: boolean | undefined;
};

export type InputGooglePubsub =
  | InputGooglePubsubSendToRoutesTrueConstraint
  | InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint
  | InputGooglePubsubPqEnabledFalseConstraint
  | InputGooglePubsubPqEnabledTrueWithPqConstraint;

export const InputFirehoseType = {
  Firehose: "firehose",
} as const;
export type InputFirehoseType = ClosedEnum<typeof InputFirehoseType>;

export type InputFirehosePqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputFirehoseType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputFirehosePqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputFirehoseType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputFirehoseSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputFirehoseType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputFirehoseSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputFirehoseType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputFirehose =
  | InputFirehoseSendToRoutesTrueConstraint
  | InputFirehoseSendToRoutesFalseWithConnectionsConstraint
  | InputFirehosePqEnabledFalseConstraint
  | InputFirehosePqEnabledTrueWithPqConstraint;

export const PqEnabledTrueWithPqConstraintInputExecType = {
  Exec: "exec",
} as const;
export type PqEnabledTrueWithPqConstraintInputExecType = ClosedEnum<
  typeof PqEnabledTrueWithPqConstraintInputExecType
>;

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const PqEnabledTrueWithPqConstraintScheduleType = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type PqEnabledTrueWithPqConstraintScheduleType = OpenEnum<
  typeof PqEnabledTrueWithPqConstraintScheduleType
>;

export type InputExecPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: PqEnabledTrueWithPqConstraintInputExecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: PqEnabledTrueWithPqConstraintScheduleType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

export const PqEnabledFalseConstraintInputExecType = {
  Exec: "exec",
} as const;
export type PqEnabledFalseConstraintInputExecType = ClosedEnum<
  typeof PqEnabledFalseConstraintInputExecType
>;

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const PqEnabledFalseConstraintScheduleType = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type PqEnabledFalseConstraintScheduleType = OpenEnum<
  typeof PqEnabledFalseConstraintScheduleType
>;

export type InputExecPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: PqEnabledFalseConstraintInputExecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: PqEnabledFalseConstraintScheduleType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

export const SendToRoutesFalseWithConnectionsConstraintInputExecType = {
  Exec: "exec",
} as const;
export type SendToRoutesFalseWithConnectionsConstraintInputExecType =
  ClosedEnum<typeof SendToRoutesFalseWithConnectionsConstraintInputExecType>;

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const SendToRoutesFalseWithConnectionsConstraintScheduleType = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type SendToRoutesFalseWithConnectionsConstraintScheduleType = OpenEnum<
  typeof SendToRoutesFalseWithConnectionsConstraintScheduleType
>;

export type InputExecSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: SendToRoutesFalseWithConnectionsConstraintInputExecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?:
    | SendToRoutesFalseWithConnectionsConstraintScheduleType
    | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

export const SendToRoutesTrueConstraintInputExecType = {
  Exec: "exec",
} as const;
export type SendToRoutesTrueConstraintInputExecType = ClosedEnum<
  typeof SendToRoutesTrueConstraintInputExecType
>;

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const SendToRoutesTrueConstraintScheduleType = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type SendToRoutesTrueConstraintScheduleType = OpenEnum<
  typeof SendToRoutesTrueConstraintScheduleType
>;

export type InputExecSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: SendToRoutesTrueConstraintInputExecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: SendToRoutesTrueConstraintScheduleType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

export type InputExec =
  | InputExecSendToRoutesTrueConstraint
  | InputExecSendToRoutesFalseWithConnectionsConstraint
  | InputExecPqEnabledFalseConstraint
  | InputExecPqEnabledTrueWithPqConstraint;

export const InputEventhubType = {
  Eventhub: "eventhub",
} as const;
export type InputEventhubType = ClosedEnum<typeof InputEventhubType>;

export type InputEventhubPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputEventhubType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
   */
  brokers: Array<string>;
  /**
   * The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
   */
  topics: Array<string>;
  /**
   * The consumer group this instance belongs to. Default is 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Start reading from earliest available data; relevant only during initial subscription
   */
  fromBeginning?: boolean | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType1 | undefined;
  tls?: models.TlsSettingsClientSideType | undefined;
  /**
   *       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
   *       Value must be lower than rebalanceTimeout.
   *       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Minimize duplicate events by starting only one consumer for each topic partition
   */
  minimizeDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputEventhubPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputEventhubType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
   */
  brokers: Array<string>;
  /**
   * The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
   */
  topics: Array<string>;
  /**
   * The consumer group this instance belongs to. Default is 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Start reading from earliest available data; relevant only during initial subscription
   */
  fromBeginning?: boolean | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType1 | undefined;
  tls?: models.TlsSettingsClientSideType | undefined;
  /**
   *       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
   *       Value must be lower than rebalanceTimeout.
   *       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Minimize duplicate events by starting only one consumer for each topic partition
   */
  minimizeDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputEventhubSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputEventhubType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
   */
  brokers: Array<string>;
  /**
   * The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
   */
  topics: Array<string>;
  /**
   * The consumer group this instance belongs to. Default is 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Start reading from earliest available data; relevant only during initial subscription
   */
  fromBeginning?: boolean | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType1 | undefined;
  tls?: models.TlsSettingsClientSideType | undefined;
  /**
   *       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
   *       Value must be lower than rebalanceTimeout.
   *       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Minimize duplicate events by starting only one consumer for each topic partition
   */
  minimizeDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputEventhubSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputEventhubType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * List of Event Hubs Kafka brokers to connect to (example: yourdomain.servicebus.windows.net:9093). The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
   */
  brokers: Array<string>;
  /**
   * The name of the Event Hub (Kafka topic) to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Event Hubs Source to only a single topic.
   */
  topics: Array<string>;
  /**
   * The consumer group this instance belongs to. Default is 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Start reading from earliest available data; relevant only during initial subscription
   */
  fromBeginning?: boolean | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType1 | undefined;
  tls?: models.TlsSettingsClientSideType | undefined;
  /**
   *       Timeout (session.timeout.ms in Kafka domain) used to detect client failures when using Kafka's group-management facilities.
   *
   * @remarks
   *       If the client sends no heartbeats to the broker before the timeout expires, the broker will remove the client from the group and initiate a rebalance.
   *       Value must be lower than rebalanceTimeout.
   *       See details [here](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time (rebalance.timeout.ms in Kafka domain) for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time (heartbeat.interval.ms in Kafka domain) between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Recommended configurations](https://github.com/Azure/azure-event-hubs-for-kafka/blob/master/CONFIGURATION.md).
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Minimize duplicate events by starting only one consumer for each topic partition
   */
  minimizeDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputEventhub =
  | InputEventhubSendToRoutesTrueConstraint
  | InputEventhubSendToRoutesFalseWithConnectionsConstraint
  | InputEventhubPqEnabledFalseConstraint
  | InputEventhubPqEnabledTrueWithPqConstraint;

export const InputOffice365MsgTraceType = {
  Office365MsgTrace: "office365_msg_trace",
} as const;
export type InputOffice365MsgTraceType = ClosedEnum<
  typeof InputOffice365MsgTraceType
>;

/**
 * Select authentication method.
 */
export const InputOffice365MsgTraceAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  OauthCert: "oauthCert",
} as const;
/**
 * Select authentication method.
 */
export type InputOffice365MsgTraceAuthenticationMethod = OpenEnum<
  typeof InputOffice365MsgTraceAuthenticationMethod
>;

/**
 * Log Level (verbosity) for collection runtime behavior.
 */
export const InputOffice365MsgTraceLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
  Silly: "silly",
} as const;
/**
 * Log Level (verbosity) for collection runtime behavior.
 */
export type InputOffice365MsgTraceLogLevel = OpenEnum<
  typeof InputOffice365MsgTraceLogLevel
>;

export type CertOptions = {
  /**
   * The name of the predefined certificate.
   */
  certificateName?: string | undefined;
  /**
   * Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS.
   */
  privKeyPath: string;
  /**
   * Passphrase to use to decrypt the private key.
   */
  passphrase?: string | undefined;
  /**
   * Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS.
   */
  certPath: string;
};

export type InputOffice365MsgTracePqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365MsgTraceType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * URL to use when retrieving report data.
   */
  url: string;
  /**
   * How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
   */
  interval: number;
  /**
   * Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
   */
  startDate?: string | undefined;
  /**
   * Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
   */
  endDate?: string | undefined;
  /**
   * HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
   */
  timeout?: number | undefined;
  /**
   * Disables time filtering of events when a date range is specified.
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Select authentication method.
   */
  authType?: InputOffice365MsgTraceAuthenticationMethod | undefined;
  /**
   * Reschedule tasks that failed with non-fatal errors
   */
  rescheduleDroppedTasks?: boolean | undefined;
  /**
   * Maximum number of times a task can be rescheduled
   */
  maxTaskReschedule?: number | undefined;
  /**
   * Log Level (verbosity) for collection runtime behavior.
   */
  logLevel?: InputOffice365MsgTraceLogLevel | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  description?: string | undefined;
  /**
   * Username to run Message Trace API call.
   */
  username?: string | undefined;
  /**
   * Password to run Message Trace API call.
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials.
   */
  credentialsSecret?: string | undefined;
  /**
   * client_secret to pass in the OAuth request parameter.
   */
  clientSecret?: string | undefined;
  /**
   * Directory ID (tenant identifier) in Azure Active Directory.
   */
  tenantId?: string | undefined;
  /**
   * client_id to pass in the OAuth request parameter.
   */
  clientId?: string | undefined;
  /**
   * Resource to pass in the OAuth request parameter.
   */
  resource?: string | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: models.SubscriptionPlanOptions | undefined;
  /**
   * Select or create a secret that references your client_secret to pass in the OAuth request parameter.
   */
  textSecret?: string | undefined;
  certOptions?: CertOptions | undefined;
};

export type InputOffice365MsgTracePqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365MsgTraceType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * URL to use when retrieving report data.
   */
  url: string;
  /**
   * How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
   */
  interval: number;
  /**
   * Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
   */
  startDate?: string | undefined;
  /**
   * Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
   */
  endDate?: string | undefined;
  /**
   * HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
   */
  timeout?: number | undefined;
  /**
   * Disables time filtering of events when a date range is specified.
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Select authentication method.
   */
  authType?: InputOffice365MsgTraceAuthenticationMethod | undefined;
  /**
   * Reschedule tasks that failed with non-fatal errors
   */
  rescheduleDroppedTasks?: boolean | undefined;
  /**
   * Maximum number of times a task can be rescheduled
   */
  maxTaskReschedule?: number | undefined;
  /**
   * Log Level (verbosity) for collection runtime behavior.
   */
  logLevel?: InputOffice365MsgTraceLogLevel | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  description?: string | undefined;
  /**
   * Username to run Message Trace API call.
   */
  username?: string | undefined;
  /**
   * Password to run Message Trace API call.
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials.
   */
  credentialsSecret?: string | undefined;
  /**
   * client_secret to pass in the OAuth request parameter.
   */
  clientSecret?: string | undefined;
  /**
   * Directory ID (tenant identifier) in Azure Active Directory.
   */
  tenantId?: string | undefined;
  /**
   * client_id to pass in the OAuth request parameter.
   */
  clientId?: string | undefined;
  /**
   * Resource to pass in the OAuth request parameter.
   */
  resource?: string | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: models.SubscriptionPlanOptions | undefined;
  /**
   * Select or create a secret that references your client_secret to pass in the OAuth request parameter.
   */
  textSecret?: string | undefined;
  certOptions?: CertOptions | undefined;
};

export type InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365MsgTraceType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * URL to use when retrieving report data.
   */
  url: string;
  /**
   * How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
   */
  interval: number;
  /**
   * Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
   */
  startDate?: string | undefined;
  /**
   * Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
   */
  endDate?: string | undefined;
  /**
   * HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
   */
  timeout?: number | undefined;
  /**
   * Disables time filtering of events when a date range is specified.
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Select authentication method.
   */
  authType?: InputOffice365MsgTraceAuthenticationMethod | undefined;
  /**
   * Reschedule tasks that failed with non-fatal errors
   */
  rescheduleDroppedTasks?: boolean | undefined;
  /**
   * Maximum number of times a task can be rescheduled
   */
  maxTaskReschedule?: number | undefined;
  /**
   * Log Level (verbosity) for collection runtime behavior.
   */
  logLevel?: InputOffice365MsgTraceLogLevel | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  description?: string | undefined;
  /**
   * Username to run Message Trace API call.
   */
  username?: string | undefined;
  /**
   * Password to run Message Trace API call.
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials.
   */
  credentialsSecret?: string | undefined;
  /**
   * client_secret to pass in the OAuth request parameter.
   */
  clientSecret?: string | undefined;
  /**
   * Directory ID (tenant identifier) in Azure Active Directory.
   */
  tenantId?: string | undefined;
  /**
   * client_id to pass in the OAuth request parameter.
   */
  clientId?: string | undefined;
  /**
   * Resource to pass in the OAuth request parameter.
   */
  resource?: string | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: models.SubscriptionPlanOptions | undefined;
  /**
   * Select or create a secret that references your client_secret to pass in the OAuth request parameter.
   */
  textSecret?: string | undefined;
  certOptions?: CertOptions | undefined;
};

export type InputOffice365MsgTraceSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365MsgTraceType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * URL to use when retrieving report data.
   */
  url: string;
  /**
   * How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
   */
  interval: number;
  /**
   * Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
   */
  startDate?: string | undefined;
  /**
   * Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
   */
  endDate?: string | undefined;
  /**
   * HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
   */
  timeout?: number | undefined;
  /**
   * Disables time filtering of events when a date range is specified.
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Select authentication method.
   */
  authType?: InputOffice365MsgTraceAuthenticationMethod | undefined;
  /**
   * Reschedule tasks that failed with non-fatal errors
   */
  rescheduleDroppedTasks?: boolean | undefined;
  /**
   * Maximum number of times a task can be rescheduled
   */
  maxTaskReschedule?: number | undefined;
  /**
   * Log Level (verbosity) for collection runtime behavior.
   */
  logLevel?: InputOffice365MsgTraceLogLevel | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  description?: string | undefined;
  /**
   * Username to run Message Trace API call.
   */
  username?: string | undefined;
  /**
   * Password to run Message Trace API call.
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials.
   */
  credentialsSecret?: string | undefined;
  /**
   * client_secret to pass in the OAuth request parameter.
   */
  clientSecret?: string | undefined;
  /**
   * Directory ID (tenant identifier) in Azure Active Directory.
   */
  tenantId?: string | undefined;
  /**
   * client_id to pass in the OAuth request parameter.
   */
  clientId?: string | undefined;
  /**
   * Resource to pass in the OAuth request parameter.
   */
  resource?: string | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: models.SubscriptionPlanOptions | undefined;
  /**
   * Select or create a secret that references your client_secret to pass in the OAuth request parameter.
   */
  textSecret?: string | undefined;
  certOptions?: CertOptions | undefined;
};

export type InputOffice365MsgTrace =
  | InputOffice365MsgTraceSendToRoutesTrueConstraint
  | InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint
  | InputOffice365MsgTracePqEnabledFalseConstraint
  | InputOffice365MsgTracePqEnabledTrueWithPqConstraint;

export const InputOffice365ServiceType = {
  Office365Service: "office365_service",
} as const;
export type InputOffice365ServiceType = ClosedEnum<
  typeof InputOffice365ServiceType
>;

export type InputOffice365ServiceContentConfig = {
  /**
   * Office 365 Services API Content Type
   */
  contentType?: string | undefined;
  /**
   * If interval type is minutes the value entered must evenly divisible by 60 or save will fail
   */
  description?: string | undefined;
  interval?: number | undefined;
  /**
   * Collector runtime Log Level
   */
  logLevel?: models.LogLevelOptionsContentConfigItems | undefined;
  enabled?: boolean | undefined;
};

export type InputOffice365ServicePqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365ServiceType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: models.SubscriptionPlanOptions | undefined;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<InputOffice365ServiceContentConfig> | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputOffice365ServicePqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365ServiceType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: models.SubscriptionPlanOptions | undefined;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<InputOffice365ServiceContentConfig> | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365ServiceType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: models.SubscriptionPlanOptions | undefined;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<InputOffice365ServiceContentConfig> | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputOffice365ServiceSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365ServiceType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: models.SubscriptionPlanOptions | undefined;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enable Office 365 Service Communication API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered for current and historical status must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<InputOffice365ServiceContentConfig> | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputOffice365Service =
  | InputOffice365ServiceSendToRoutesTrueConstraint
  | InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint
  | InputOffice365ServicePqEnabledFalseConstraint
  | InputOffice365ServicePqEnabledTrueWithPqConstraint;

export const InputOffice365MgmtType = {
  Office365Mgmt: "office365_mgmt",
} as const;
export type InputOffice365MgmtType = ClosedEnum<typeof InputOffice365MgmtType>;

export type InputOffice365MgmtContentConfig = {
  /**
   * Office 365 Management Activity API Content Type
   */
  contentType?: string | undefined;
  /**
   * If interval type is minutes the value entered must evenly divisible by 60 or save will fail
   */
  description?: string | undefined;
  interval?: number | undefined;
  /**
   * Collector runtime Log Level
   */
  logLevel?: models.LogLevelOptionsContentConfigItems | undefined;
  enabled?: boolean | undefined;
};

export type InputOffice365MgmtPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365MgmtType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType: models.SubscriptionPlanOptions;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
   */
  publisherIdentifier?: string | undefined;
  /**
   * Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<InputOffice365MgmtContentConfig> | undefined;
  /**
   * Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
   */
  ingestionLag?: number | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputOffice365MgmtPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365MgmtType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType: models.SubscriptionPlanOptions;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
   */
  publisherIdentifier?: string | undefined;
  /**
   * Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<InputOffice365MgmtContentConfig> | undefined;
  /**
   * Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
   */
  ingestionLag?: number | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365MgmtType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType: models.SubscriptionPlanOptions;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
   */
  publisherIdentifier?: string | undefined;
  /**
   * Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<InputOffice365MgmtContentConfig> | undefined;
  /**
   * Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
   */
  ingestionLag?: number | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputOffice365MgmtSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputOffice365MgmtType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType: models.SubscriptionPlanOptions;
  /**
   * Office 365 Azure Tenant ID
   */
  tenantId: string;
  /**
   * Office 365 Azure Application ID
   */
  appId: string;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Optional Publisher Identifier to use in API requests, defaults to tenant id if not defined. For more information see [here](https://docs.microsoft.com/en-us/office/office-365-management-api/office-365-management-activity-api-reference#start-a-subscription)
   */
  publisherIdentifier?: string | undefined;
  /**
   * Enable Office 365 Management Activity API content types and polling intervals. Polling intervals are used to set up search date range and cron schedule, e.g.: * /${interval} * * * *. Because of this, intervals entered must be evenly divisible by 60 to give a predictable schedule.
   */
  contentConfig?: Array<InputOffice365MgmtContentConfig> | undefined;
  /**
   * Use this setting to account for ingestion lag. This is necessary because there can be a lag of 60 - 90 minutes (or longer) before Office 365 events are available for retrieval.
   */
  ingestionLag?: number | undefined;
  retryRules?: models.RetryRulesType1 | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * Office 365 Azure client secret
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputOffice365Mgmt =
  | InputOffice365MgmtSendToRoutesTrueConstraint
  | InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint
  | InputOffice365MgmtPqEnabledFalseConstraint
  | InputOffice365MgmtPqEnabledTrueWithPqConstraint;

export const InputEdgePrometheusType = {
  EdgePrometheus: "edge_prometheus",
} as const;
export type InputEdgePrometheusType = ClosedEnum<
  typeof InputEdgePrometheusType
>;

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputEdgePrometheusDiscoveryType = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
  /**
   * Kubernetes Node
   */
  K8sNode: "k8s-node",
  /**
   * Kubernetes Pods
   */
  K8sPods: "k8s-pods",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputEdgePrometheusDiscoveryType = OpenEnum<
  typeof InputEdgePrometheusDiscoveryType
>;

/**
 * Enter credentials directly, or select a stored secret
 */
export const InputEdgePrometheusAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  Kubernetes: "kubernetes",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type InputEdgePrometheusAuthenticationMethod = OpenEnum<
  typeof InputEdgePrometheusAuthenticationMethod
>;

export type Target = {
  /**
   * Protocol to use when collecting metrics
   */
  protocol?: models.ProtocolOptionsTargetsItems | undefined;
  /**
   * Name of host from which to pull metrics.
   */
  host: string;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  port?: number | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  path?: string | undefined;
};

export type PodFilter = {
  /**
   * JavaScript expression applied to pods objects. Return 'true' to include it.
   */
  filter: string;
  /**
   * Optional description of this rule's purpose
   */
  description?: string | undefined;
};

export type InputEdgePrometheusPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputEdgePrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType: InputEdgePrometheusDiscoveryType;
  /**
   * How often in seconds to scrape targets for metrics.
   */
  interval: number;
  /**
   * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
   */
  timeout?: number | undefined;
  persistence?: models.DiskSpoolingType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputEdgePrometheusAuthenticationMethod | undefined;
  description?: string | undefined;
  targets?: Array<Target> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: models.RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: models.ProtocolOptionsTargetsItems | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<models.ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: models.SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocolExpr?: string | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePortExpr?: string | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePathExpr?: string | undefined;
  /**
   *   Add rules to decide which pods to discover for metrics.
   *
   * @remarks
   *   Pods are searched if no rules are given or of all the rules'
   *   expressions evaluate to true.
   */
  podFilter?: Array<PodFilter> | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputEdgePrometheusPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputEdgePrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType: InputEdgePrometheusDiscoveryType;
  /**
   * How often in seconds to scrape targets for metrics.
   */
  interval: number;
  /**
   * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
   */
  timeout?: number | undefined;
  persistence?: models.DiskSpoolingType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputEdgePrometheusAuthenticationMethod | undefined;
  description?: string | undefined;
  targets?: Array<Target> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: models.RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: models.ProtocolOptionsTargetsItems | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<models.ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: models.SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocolExpr?: string | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePortExpr?: string | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePathExpr?: string | undefined;
  /**
   *   Add rules to decide which pods to discover for metrics.
   *
   * @remarks
   *   Pods are searched if no rules are given or of all the rules'
   *   expressions evaluate to true.
   */
  podFilter?: Array<PodFilter> | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputEdgePrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType: InputEdgePrometheusDiscoveryType;
  /**
   * How often in seconds to scrape targets for metrics.
   */
  interval: number;
  /**
   * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
   */
  timeout?: number | undefined;
  persistence?: models.DiskSpoolingType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputEdgePrometheusAuthenticationMethod | undefined;
  description?: string | undefined;
  targets?: Array<Target> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: models.RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: models.ProtocolOptionsTargetsItems | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<models.ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: models.SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocolExpr?: string | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePortExpr?: string | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePathExpr?: string | undefined;
  /**
   *   Add rules to decide which pods to discover for metrics.
   *
   * @remarks
   *   Pods are searched if no rules are given or of all the rules'
   *   expressions evaluate to true.
   */
  podFilter?: Array<PodFilter> | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputEdgePrometheusSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputEdgePrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType: InputEdgePrometheusDiscoveryType;
  /**
   * How often in seconds to scrape targets for metrics.
   */
  interval: number;
  /**
   * Timeout, in milliseconds, before aborting HTTP connection attempts; 1-60000 or 0 to disable
   */
  timeout?: number | undefined;
  persistence?: models.DiskSpoolingType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputEdgePrometheusAuthenticationMethod | undefined;
  description?: string | undefined;
  targets?: Array<Target> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: models.RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: models.ProtocolOptionsTargetsItems | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<models.ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: models.SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocolExpr?: string | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePortExpr?: string | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePathExpr?: string | undefined;
  /**
   *   Add rules to decide which pods to discover for metrics.
   *
   * @remarks
   *   Pods are searched if no rules are given or of all the rules'
   *   expressions evaluate to true.
   */
  podFilter?: Array<PodFilter> | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputEdgePrometheus =
  | InputEdgePrometheusSendToRoutesTrueConstraint
  | InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint
  | InputEdgePrometheusPqEnabledFalseConstraint
  | InputEdgePrometheusPqEnabledTrueWithPqConstraint;

export const InputPrometheusType = {
  Prometheus: "prometheus",
} as const;
export type InputPrometheusType = ClosedEnum<typeof InputPrometheusType>;

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType = OpenEnum<
  typeof InputPrometheusDiscoveryType
>;

/**
 * Collector runtime log level
 */
export const InputPrometheusLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime log level
 */
export type InputPrometheusLogLevel = OpenEnum<typeof InputPrometheusLogLevel>;

/**
 * Protocol to use when collecting metrics
 */
export const MetricsProtocol = {
  Http: "http",
  Https: "https",
} as const;
/**
 * Protocol to use when collecting metrics
 */
export type MetricsProtocol = OpenEnum<typeof MetricsProtocol>;

export type InputPrometheusPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputPrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType | undefined;
  /**
   * How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
   */
  interval: number;
  /**
   * Collector runtime log level
   */
  logLevel: InputPrometheusLogLevel;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptionsSasl | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: models.RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: MetricsProtocol | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<models.ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: models.SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputPrometheusPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputPrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType | undefined;
  /**
   * How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
   */
  interval: number;
  /**
   * Collector runtime log level
   */
  logLevel: InputPrometheusLogLevel;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptionsSasl | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: models.RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: MetricsProtocol | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<models.ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: models.SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputPrometheusSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputPrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType | undefined;
  /**
   * How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
   */
  interval: number;
  /**
   * Collector runtime log level
   */
  logLevel: InputPrometheusLogLevel;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptionsSasl | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: models.RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: MetricsProtocol | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<models.ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: models.SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputPrometheusSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputPrometheusType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType | undefined;
  /**
   * How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
   */
  interval: number;
  /**
   * Collector runtime log level
   */
  logLevel: InputPrometheusLogLevel;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: models.AuthenticationMethodOptionsSasl | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: models.RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: MetricsProtocol | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<models.ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: models.SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputPrometheus =
  | InputPrometheusSendToRoutesTrueConstraint
  | InputPrometheusSendToRoutesFalseWithConnectionsConstraint
  | InputPrometheusPqEnabledFalseConstraint
  | InputPrometheusPqEnabledTrueWithPqConstraint;

export const InputPrometheusRwType = {
  PrometheusRw: "prometheus_rw",
} as const;
export type InputPrometheusRwType = ClosedEnum<typeof InputPrometheusRwType>;

export type InputPrometheusRwPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputPrometheusRwType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
   */
  prometheusAPI: string;
  /**
   * Remote Write authentication type
   */
  authType?: models.AuthenticationTypeOptionsPrometheusAuth | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputPrometheusRwPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputPrometheusRwType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
   */
  prometheusAPI: string;
  /**
   * Remote Write authentication type
   */
  authType?: models.AuthenticationTypeOptionsPrometheusAuth | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputPrometheusRwType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
   */
  prometheusAPI: string;
  /**
   * Remote Write authentication type
   */
  authType?: models.AuthenticationTypeOptionsPrometheusAuth | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputPrometheusRwSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputPrometheusRwType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Prometheus requests. Defaults to /write, which will expand as: http://<yourupstreamURL>:<yourport>/write.
   */
  prometheusAPI: string;
  /**
   * Remote Write authentication type
   */
  authType?: models.AuthenticationTypeOptionsPrometheusAuth | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputPrometheusRw =
  | InputPrometheusRwSendToRoutesTrueConstraint
  | InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint
  | InputPrometheusRwPqEnabledFalseConstraint
  | InputPrometheusRwPqEnabledTrueWithPqConstraint;

export const InputLokiType = {
  Loki: "loki",
} as const;
export type InputLokiType = ClosedEnum<typeof InputLokiType>;

export type InputLokiPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputLokiType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
   */
  lokiAPI: string;
  /**
   * Loki logs authentication type
   */
  authType?: models.AuthenticationTypeOptionsLokiAuth | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputLokiPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputLokiType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
   */
  lokiAPI: string;
  /**
   * Loki logs authentication type
   */
  authType?: models.AuthenticationTypeOptionsLokiAuth | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputLokiSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputLokiType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
   */
  lokiAPI: string;
  /**
   * Loki logs authentication type
   */
  authType?: models.AuthenticationTypeOptionsLokiAuth | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputLokiSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputLokiType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'.
   */
  lokiAPI: string;
  /**
   * Loki logs authentication type
   */
  authType?: models.AuthenticationTypeOptionsLokiAuth | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputLoki =
  | InputLokiSendToRoutesTrueConstraint
  | InputLokiSendToRoutesFalseWithConnectionsConstraint
  | InputLokiPqEnabledFalseConstraint
  | InputLokiPqEnabledTrueWithPqConstraint;

export const InputGrafanaType2 = {
  Grafana: "grafana",
} as const;
export type InputGrafanaType2 = ClosedEnum<typeof InputGrafanaType2>;

export type PrometheusAuth2 = {
  /**
   * Remote Write authentication type
   */
  authType?: models.AuthenticationTypeOptionsPrometheusAuth | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type LokiAuth2 = {
  /**
   * Loki logs authentication type
   */
  authType?: models.AuthenticationTypeOptionsLokiAuth | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputGrafanaGrafana2 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputGrafanaType2;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
   */
  prometheusAPI?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
   */
  lokiAPI: string;
  prometheusAuth?: PrometheusAuth2 | undefined;
  lokiAuth?: LokiAuth2 | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export const InputGrafanaType1 = {
  Grafana: "grafana",
} as const;
export type InputGrafanaType1 = ClosedEnum<typeof InputGrafanaType1>;

export type PrometheusAuth1 = {
  /**
   * Remote Write authentication type
   */
  authType?: models.AuthenticationTypeOptionsPrometheusAuth | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type LokiAuth1 = {
  /**
   * Loki logs authentication type
   */
  authType?: models.AuthenticationTypeOptionsLokiAuth | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputGrafanaGrafana1 = {
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputGrafanaType1;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<yourupstreamURL>:<yourport>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
   */
  prometheusAPI: string;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<yourupstreamURL>:<yourport>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
   */
  lokiAPI?: string | undefined;
  prometheusAuth?: PrometheusAuth1 | undefined;
  lokiAuth?: LokiAuth1 | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputGrafana = InputGrafanaGrafana1 | InputGrafanaGrafana2;

export const InputConfluentCloudType = {
  ConfluentCloud: "confluent_cloud",
} as const;
export type InputConfluentCloudType = ClosedEnum<
  typeof InputConfluentCloudType
>;

export type InputConfluentCloudPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputConfluentCloudType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
   */
  brokers: Array<string>;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputConfluentCloudPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputConfluentCloudType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
   */
  brokers: Array<string>;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputConfluentCloudType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
   */
  brokers: Array<string>;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputConfluentCloudSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputConfluentCloudType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092
   */
  brokers: Array<string>;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputConfluentCloud =
  | InputConfluentCloudSendToRoutesTrueConstraint
  | InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint
  | InputConfluentCloudPqEnabledFalseConstraint
  | InputConfluentCloudPqEnabledTrueWithPqConstraint;

export const InputElasticType = {
  Elastic: "elastic",
} as const;
export type InputElasticType = ClosedEnum<typeof InputElasticType>;

export const InputElasticAuthenticationType = {
  /**
   * None
   */
  None: "none",
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * Basic (credentials secret)
   */
  CredentialsSecret: "credentialsSecret",
  /**
   * Auth Tokens
   */
  AuthTokens: "authTokens",
} as const;
export type InputElasticAuthenticationType = OpenEnum<
  typeof InputElasticAuthenticationType
>;

/**
 * The API version to use for communicating with the server
 */
export const CreateInputAPIVersion = {
  /**
   * 6.8.4
   */
  SixDot8Dot4: "6.8.4",
  /**
   * 8.3.2
   */
  EightDot3Dot2: "8.3.2",
  /**
   * Custom
   */
  Custom: "custom",
} as const;
/**
 * The API version to use for communicating with the server
 */
export type CreateInputAPIVersion = OpenEnum<typeof CreateInputAPIVersion>;

/**
 * Enter credentials directly, or select a stored secret
 */
export const InputElasticAuthenticationMethod = {
  None: "none",
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type InputElasticAuthenticationMethod = OpenEnum<
  typeof InputElasticAuthenticationMethod
>;

export type InputElasticProxyMode = {
  /**
   * Enable proxying of non-bulk API requests to an external Elastic server. Enable this only if you understand the implications. See [Cribl Docs](https://docs.cribl.io/stream/sources-elastic/#proxy-mode) for more details.
   */
  enabled: boolean;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: InputElasticAuthenticationMethod | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL of the Elastic server to proxy non-bulk requests to, such as http://elastic:9200
   */
  url?: string | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * List of headers to remove from the request to proxy
   */
  removeHeaders?: Array<string> | undefined;
  /**
   * Amount of time, in seconds, to wait for a proxy request to complete before canceling it
   */
  timeoutSec?: number | undefined;
};

export type InputElasticPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputElasticType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
   */
  elasticAPI: string;
  authType?: InputElasticAuthenticationType | undefined;
  /**
   * The API version to use for communicating with the server
   */
  apiVersion?: CreateInputAPIVersion | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<models.ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  proxyMode?: InputElasticProxyMode | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Bearer tokens to include in the authorization header
   */
  authTokens?: Array<string> | undefined;
  /**
   * Custom version information to respond to requests
   */
  customAPIVersion?: string | undefined;
};

export type InputElasticPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputElasticType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
   */
  elasticAPI: string;
  authType?: InputElasticAuthenticationType | undefined;
  /**
   * The API version to use for communicating with the server
   */
  apiVersion?: CreateInputAPIVersion | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<models.ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  proxyMode?: InputElasticProxyMode | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Bearer tokens to include in the authorization header
   */
  authTokens?: Array<string> | undefined;
  /**
   * Custom version information to respond to requests
   */
  customAPIVersion?: string | undefined;
};

export type InputElasticSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputElasticType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
   */
  elasticAPI: string;
  authType?: InputElasticAuthenticationType | undefined;
  /**
   * The API version to use for communicating with the server
   */
  apiVersion?: CreateInputAPIVersion | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<models.ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  proxyMode?: InputElasticProxyMode | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Bearer tokens to include in the authorization header
   */
  authTokens?: Array<string> | undefined;
  /**
   * Custom version information to respond to requests
   */
  customAPIVersion?: string | undefined;
};

export type InputElasticSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputElasticType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Elasticsearch API requests. Defaults to /. _bulk will be appended automatically. For example, /myPath becomes /myPath/_bulk. Requests can then be made to either /myPath/_bulk or /myPath/<myIndexName>/_bulk. Other entries are faked as success.
   */
  elasticAPI: string;
  authType?: InputElasticAuthenticationType | undefined;
  /**
   * The API version to use for communicating with the server
   */
  apiVersion?: CreateInputAPIVersion | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<models.ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  proxyMode?: InputElasticProxyMode | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Bearer tokens to include in the authorization header
   */
  authTokens?: Array<string> | undefined;
  /**
   * Custom version information to respond to requests
   */
  customAPIVersion?: string | undefined;
};

export type InputElastic =
  | InputElasticSendToRoutesTrueConstraint
  | InputElasticSendToRoutesFalseWithConnectionsConstraint
  | InputElasticPqEnabledFalseConstraint
  | InputElasticPqEnabledTrueWithPqConstraint;

export const InputAzureBlobType = {
  AzureBlob: "azure_blob",
} as const;
export type InputAzureBlobType = ClosedEnum<typeof InputAzureBlobType>;

export type InputAzureBlobPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputAzureBlobType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
   */
  maxMessages?: number | undefined;
  /**
   * The duration (in seconds) which pollers should be validated and restarted if exited
   */
  servicePeriodSecs?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  authType?: models.AuthenticationMethodOptions | undefined;
  description?: string | undefined;
  /**
   * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
   */
  connectionString?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The name of your Azure storage account
   */
  storageAccountName?: string | undefined;
  /**
   * The service principal's tenant ID
   */
  tenantId?: string | undefined;
  /**
   * The service principal's client ID
   */
  clientId?: string | undefined;
  /**
   * The Azure cloud to use. Defaults to Azure Public Cloud.
   */
  azureCloud?: string | undefined;
  /**
   * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
   */
  endpointSuffix?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  clientTextSecret?: string | undefined;
  certificate?: models.CertificateTypeAzureBlobAuthTypeClientCert | undefined;
};

export type InputAzureBlobPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputAzureBlobType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
   */
  maxMessages?: number | undefined;
  /**
   * The duration (in seconds) which pollers should be validated and restarted if exited
   */
  servicePeriodSecs?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  authType?: models.AuthenticationMethodOptions | undefined;
  description?: string | undefined;
  /**
   * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
   */
  connectionString?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The name of your Azure storage account
   */
  storageAccountName?: string | undefined;
  /**
   * The service principal's tenant ID
   */
  tenantId?: string | undefined;
  /**
   * The service principal's client ID
   */
  clientId?: string | undefined;
  /**
   * The Azure cloud to use. Defaults to Azure Public Cloud.
   */
  azureCloud?: string | undefined;
  /**
   * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
   */
  endpointSuffix?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  clientTextSecret?: string | undefined;
  certificate?: models.CertificateTypeAzureBlobAuthTypeClientCert | undefined;
};

export type InputAzureBlobSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputAzureBlobType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
   */
  maxMessages?: number | undefined;
  /**
   * The duration (in seconds) which pollers should be validated and restarted if exited
   */
  servicePeriodSecs?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  authType?: models.AuthenticationMethodOptions | undefined;
  description?: string | undefined;
  /**
   * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
   */
  connectionString?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The name of your Azure storage account
   */
  storageAccountName?: string | undefined;
  /**
   * The service principal's tenant ID
   */
  tenantId?: string | undefined;
  /**
   * The service principal's client ID
   */
  clientId?: string | undefined;
  /**
   * The Azure cloud to use. Defaults to Azure Public Cloud.
   */
  azureCloud?: string | undefined;
  /**
   * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
   */
  endpointSuffix?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  clientTextSecret?: string | undefined;
  certificate?: models.CertificateTypeAzureBlobAuthTypeClientCert | undefined;
};

export type InputAzureBlobSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputAzureBlobType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * The storage account queue name blob notifications will be read from. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myQueue-${C.vars.myVar}`
   */
  queueName: string;
  /**
   * Regex matching file names to download and process. Defaults to: .*
   */
  fileFilter?: string | undefined;
  /**
   * The duration (in seconds) that the received messages are hidden from subsequent retrieve requests after being retrieved by a ReceiveMessage request.
   */
  visibilityTimeout?: number | undefined;
  /**
   * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead.
   */
  numReceivers?: number | undefined;
  /**
   * The maximum number of messages to return in a poll request. Azure storage queues never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 32.
   */
  maxMessages?: number | undefined;
  /**
   * The duration (in seconds) which pollers should be validated and restarted if exited
   */
  servicePeriodSecs?: number | undefined;
  /**
   * Skip files that trigger a processing error. Disabled by default, which allows retries after processing errors.
   */
  skipOnError?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Maximum file size for each Parquet chunk
   */
  parquetChunkSizeMB?: number | undefined;
  /**
   * The maximum time allowed for downloading a Parquet chunk. Processing will stop if a chunk cannot be downloaded within the time specified.
   */
  parquetChunkDownloadTimeout?: number | undefined;
  authType?: models.AuthenticationMethodOptions | undefined;
  description?: string | undefined;
  /**
   * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
   */
  connectionString?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * The name of your Azure storage account
   */
  storageAccountName?: string | undefined;
  /**
   * The service principal's tenant ID
   */
  tenantId?: string | undefined;
  /**
   * The service principal's client ID
   */
  clientId?: string | undefined;
  /**
   * The Azure cloud to use. Defaults to Azure Public Cloud.
   */
  azureCloud?: string | undefined;
  /**
   * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
   */
  endpointSuffix?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  clientTextSecret?: string | undefined;
  certificate?: models.CertificateTypeAzureBlobAuthTypeClientCert | undefined;
};

export type InputAzureBlob =
  | InputAzureBlobSendToRoutesTrueConstraint
  | InputAzureBlobSendToRoutesFalseWithConnectionsConstraint
  | InputAzureBlobPqEnabledFalseConstraint
  | InputAzureBlobPqEnabledTrueWithPqConstraint;

export const InputSplunkHecType = {
  SplunkHec: "splunk_hec",
} as const;
export type InputSplunkHecType = ClosedEnum<typeof InputSplunkHecType>;

export type InputSplunkHecAuthToken = {
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: models.AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Select or create a stored text secret
   */
  tokenSecret?: string | undefined;
  /**
   * Shared secret to be provided by any client (Authorization: <token>)
   */
  token: string;
  enabled?: boolean | undefined;
  /**
   * Optional token description
   */
  description?: string | undefined;
  /**
   * Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
   */
  allowedIndexesAtToken?: Array<string> | undefined;
  /**
   * Fields to add to events referencing this token
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
};

export type InputSplunkHecPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputSplunkHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
   */
  splunkHecAPI: string;
  /**
   * Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Enable Splunk HEC acknowledgements
   */
  splunkHecAcks?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputSplunkHecPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputSplunkHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
   */
  splunkHecAPI: string;
  /**
   * Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Enable Splunk HEC acknowledgements
   */
  splunkHecAcks?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputSplunkHecSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputSplunkHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
   */
  splunkHecAPI: string;
  /**
   * Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Enable Splunk HEC acknowledgements
   */
  splunkHecAcks?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputSplunkHecSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkHecType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputSplunkHecAuthToken> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints.
   */
  splunkHecAPI: string;
  /**
   * Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
   */
  allowedIndexes?: Array<string> | undefined;
  /**
   * Enable Splunk HEC acknowledgements
   */
  splunkHecAcks?: boolean | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
   */
  accessControlAllowOrigin?: Array<string> | undefined;
  /**
   * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
   */
  accessControlAllowHeaders?: Array<string> | undefined;
  /**
   * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics
   */
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

export type InputSplunkHec =
  | InputSplunkHecSendToRoutesTrueConstraint
  | InputSplunkHecSendToRoutesFalseWithConnectionsConstraint
  | InputSplunkHecPqEnabledFalseConstraint
  | InputSplunkHecPqEnabledTrueWithPqConstraint;

export const InputSplunkSearchType = {
  SplunkSearch: "splunk_search",
} as const;
export type InputSplunkSearchType = ClosedEnum<typeof InputSplunkSearchType>;

export type EndpointParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
   */
  value: string;
};

export type EndpointHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
   */
  value: string;
};

/**
 * Collector runtime log level (verbosity)
 */
export const InputSplunkSearchLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime log level (verbosity)
 */
export type InputSplunkSearchLogLevel = OpenEnum<
  typeof InputSplunkSearchLogLevel
>;

/**
 * Splunk Search authentication type
 */
export const InputSplunkSearchAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Splunk Search authentication type
 */
export type InputSplunkSearchAuthenticationType = OpenEnum<
  typeof InputSplunkSearchAuthenticationType
>;

export type InputSplunkSearchPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkSearchType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead: string;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule: string;
  /**
   * REST API used to create a search
   */
  endpoint: string;
  /**
   * Format of the returned output
   */
  outputMode: models.OutputModeOptionsSplunkCollectorConf;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<EndpointParam> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<EndpointHeader> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: InputSplunkSearchLogLevel | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: InputSplunkSearchAuthenticationType | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputSplunkSearchPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkSearchType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead: string;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule: string;
  /**
   * REST API used to create a search
   */
  endpoint: string;
  /**
   * Format of the returned output
   */
  outputMode: models.OutputModeOptionsSplunkCollectorConf;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<EndpointParam> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<EndpointHeader> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: InputSplunkSearchLogLevel | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: InputSplunkSearchAuthenticationType | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkSearchType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead: string;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule: string;
  /**
   * REST API used to create a search
   */
  endpoint: string;
  /**
   * Format of the returned output
   */
  outputMode: models.OutputModeOptionsSplunkCollectorConf;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<EndpointParam> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<EndpointHeader> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: InputSplunkSearchLogLevel | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: InputSplunkSearchAuthenticationType | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputSplunkSearchSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkSearchType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead: string;
  /**
   * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule: string;
  /**
   * REST API used to create a search
   */
  endpoint: string;
  /**
   * Format of the returned output
   */
  outputMode: models.OutputModeOptionsSplunkCollectorConf;
  /**
   * Optional request parameters to send to the endpoint
   */
  endpointParams?: Array<EndpointParam> | undefined;
  /**
   * Optional request headers to send to the endpoint
   */
  endpointHeaders?: Array<EndpointHeader> | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel?: InputSplunkSearchLogLevel | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  requestTimeout?: number | undefined;
  /**
   * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
   */
  encoding?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  retryRules?: models.RetryRulesType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Splunk Search authentication type
   */
  authType?: InputSplunkSearchAuthenticationType | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<models.ItemsTypeOauthParams> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders> | undefined;
};

export type InputSplunkSearch =
  | InputSplunkSearchSendToRoutesTrueConstraint
  | InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint
  | InputSplunkSearchPqEnabledFalseConstraint
  | InputSplunkSearchPqEnabledTrueWithPqConstraint;

export const InputSplunkType = {
  Splunk: "splunk",
} as const;
export type InputSplunkType = ClosedEnum<typeof InputSplunkType>;

export type InputSplunkAuthToken = {
  /**
   * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
   */
  token: string;
  description?: string | undefined;
};

/**
 * The highest S2S protocol version to advertise during handshake
 */
export const MaxS2SVersion = {
  /**
   * v3
   */
  V3: "v3",
  /**
   * v4
   */
  V4: "v4",
} as const;
/**
 * The highest S2S protocol version to advertise during handshake
 */
export type MaxS2SVersion = OpenEnum<typeof MaxS2SVersion>;

/**
 * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
 */
export const CreateInputCompression = {
  /**
   * Disabled
   */
  Disabled: "disabled",
  /**
   * Automatic
   */
  Auto: "auto",
  /**
   * Always
   */
  Always: "always",
} as const;
/**
 * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
 */
export type CreateInputCompression = OpenEnum<typeof CreateInputCompression>;

export type InputSplunkPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputSplunkAuthToken> | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: MaxS2SVersion | undefined;
  description?: string | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
   */
  compress?: CreateInputCompression | undefined;
};

export type InputSplunkPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputSplunkAuthToken> | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: MaxS2SVersion | undefined;
  description?: string | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
   */
  compress?: CreateInputCompression | undefined;
};

export type InputSplunkSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputSplunkAuthToken> | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: MaxS2SVersion | undefined;
  description?: string | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
   */
  compress?: CreateInputCompression | undefined;
};

export type InputSplunkSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputSplunkType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
   */
  authTokens?: Array<InputSplunkAuthToken> | undefined;
  /**
   * The highest S2S protocol version to advertise during handshake
   */
  maxS2Sversion?: MaxS2SVersion | undefined;
  description?: string | undefined;
  /**
   * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event
   */
  useFwdTimezone?: boolean | undefined;
  /**
   * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`.
   */
  dropControlFields?: boolean | undefined;
  /**
   * Extract and process Splunk-generated metrics as Cribl metrics
   */
  extractMetrics?: boolean | undefined;
  /**
   * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections.
   */
  compress?: CreateInputCompression | undefined;
};

export type InputSplunk =
  | InputSplunkSendToRoutesTrueConstraint
  | InputSplunkSendToRoutesFalseWithConnectionsConstraint
  | InputSplunkPqEnabledFalseConstraint
  | InputSplunkPqEnabledTrueWithPqConstraint;

export const InputHttpType = {
  Http: "http",
} as const;
export type InputHttpType = ClosedEnum<typeof InputHttpType>;

export type InputHttpPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
   */
  criblAPI?: string | undefined;
  /**
   * Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
   */
  elasticAPI?: string | undefined;
  /**
   * Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
   */
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputHttpPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
   */
  criblAPI?: string | undefined;
  /**
   * Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
   */
  elasticAPI?: string | undefined;
  /**
   * Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
   */
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputHttpSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
   */
  criblAPI?: string | undefined;
  /**
   * Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
   */
  elasticAPI?: string | undefined;
  /**
   * Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
   */
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputHttpSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputHttpType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host: string;
  /**
   * Port to listen on
   */
  port: number;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes).
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for the Cribl HTTP API requests. Only _bulk (default /cribl/_bulk) is available. Use empty string to disable.
   */
  criblAPI?: string | undefined;
  /**
   * Absolute path on which to listen for the Elasticsearch API requests. Only _bulk (default /elastic/_bulk) is available. Use empty string to disable.
   */
  elasticAPI?: string | undefined;
  /**
   * Absolute path on which listen for the Splunk HTTP Event Collector API requests. Use empty string to disable.
   */
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
   */
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt> | undefined;
  description?: string | undefined;
};

export type InputHttp =
  | InputHttpSendToRoutesTrueConstraint
  | InputHttpSendToRoutesFalseWithConnectionsConstraint
  | InputHttpPqEnabledFalseConstraint
  | InputHttpPqEnabledTrueWithPqConstraint;

export const InputMskType = {
  Msk: "msk",
} as const;
export type InputMskType = ClosedEnum<typeof InputMskType>;

export type InputMskPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputMskType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  /**
   * Region where the MSK cluster is located
   */
  region: string;
  /**
   * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: models.SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access MSK
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export type InputMskPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputMskType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  /**
   * Region where the MSK cluster is located
   */
  region: string;
  /**
   * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: models.SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access MSK
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export type InputMskSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputMskType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  /**
   * Region where the MSK cluster is located
   */
  region: string;
  /**
   * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: models.SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access MSK
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export type InputMskSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputMskType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  /**
   * Region where the MSK cluster is located
   */
  region: string;
  /**
   * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: models.SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access MSK
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export type InputMsk =
  | InputMskSendToRoutesTrueConstraint
  | InputMskSendToRoutesFalseWithConnectionsConstraint
  | InputMskPqEnabledFalseConstraint
  | InputMskPqEnabledTrueWithPqConstraint;

export const InputKafkaType = {
  Kafka: "kafka",
} as const;
export type InputKafkaType = ClosedEnum<typeof InputKafkaType>;

export type InputKafkaPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKafkaType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputKafkaPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKafkaType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputKafkaSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKafkaType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputKafkaSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputKafkaType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * Enter each Kafka bootstrap server you want to use. Specify the hostname and port (such as mykafkabroker:9092) or just the hostname (in which case @{product} will assign port 9092).
   */
  brokers: Array<string>;
  /**
   * Topic to subscribe to. Warning: To optimize performance, Cribl suggests subscribing each Kafka Source to a single topic only.
   */
  topics: Array<string>;
  /**
   * The consumer group to which this instance belongs. Defaults to 'Cribl'.
   */
  groupId?: string | undefined;
  /**
   * Leave enabled if you want the Source, upon first subscribing to a topic, to read starting with the earliest available message
   */
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType
    | undefined;
  /**
   * Maximum time to wait for a connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data
   */
  maxRetries?: number | undefined;
  /**
   * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds).
   */
  maxBackOff?: number | undefined;
  /**
   * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes).
   */
  initialBackoff?: number | undefined;
  /**
   * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details.
   */
  backoffRate?: number | undefined;
  /**
   * Maximum time to wait for Kafka to respond to an authentication request
   */
  authenticationTimeout?: number | undefined;
  /**
   * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire.
   */
  reauthenticationThreshold?: number | undefined;
  /**
   * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
   */
  sasl?: models.AuthenticationType | undefined;
  tls?: models.TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * @remarks
   *       Timeout used to detect client failures when using Kafka's group-management facilities.
   *       If the client sends no heartbeats to the broker before the timeout expires,
   *       the broker will remove the client from the group and initiate a rebalance.
   *       Value must be between the broker's configured group.min.session.timeout.ms and group.max.session.timeout.ms.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_session.timeout.ms) for details.
   */
  sessionTimeout?: number | undefined;
  /**
   *       Maximum allowed time for each worker to join the group after a rebalance begins.
   *
   * @remarks
   *       If the timeout is exceeded, the coordinator broker will remove the worker from the group.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#connectconfigs_rebalance.timeout.ms) for details.
   */
  rebalanceTimeout?: number | undefined;
  /**
   *       Expected time between heartbeats to the consumer coordinator when using Kafka's group-management facilities.
   *
   * @remarks
   *       Value must be lower than sessionTimeout and typically should not exceed 1/3 of the sessionTimeout value.
   *       See [Kafka's documentation](https://kafka.apache.org/documentation/#consumerconfigs_heartbeat.interval.ms) for details.
   */
  heartbeatInterval?: number | undefined;
  /**
   * How often to commit offsets. If both this and Offset commit threshold are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitInterval?: number | undefined;
  /**
   * How many events are needed to trigger an offset commit. If both this and Offset commit interval are set, @{product} commits offsets when either condition is met. If both are empty, @{product} commits offsets after each batch.
   */
  autoCommitThreshold?: number | undefined;
  /**
   * Maximum amount of data that Kafka will return per partition, per fetch request. Must equal or exceed the maximum message size (maxBytesPerPartition) that Kafka is configured to allow. Otherwise, @{product} can get stuck trying to retrieve messages. Defaults to 1048576 (1 MB).
   */
  maxBytesPerPartition?: number | undefined;
  /**
   * Maximum number of bytes that Kafka will return per fetch request. Defaults to 10485760 (10 MB).
   */
  maxBytes?: number | undefined;
  /**
   * Maximum number of network errors before the consumer re-creates a socket
   */
  maxSocketErrors?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
};

export type InputKafka =
  | InputKafkaSendToRoutesTrueConstraint
  | InputKafkaSendToRoutesFalseWithConnectionsConstraint
  | InputKafkaPqEnabledFalseConstraint
  | InputKafkaPqEnabledTrueWithPqConstraint;

export const InputCollectionType = {
  Collection: "collection",
} as const;
export type InputCollectionType = ClosedEnum<typeof InputCollectionType>;

export type InputCollectionPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  pq?: models.PqType | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCollectionType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process results
   */
  pipeline?: string | undefined;
  /**
   * Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Destination to send results to
   */
  output?: string | undefined;
};

export type InputCollectionPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCollectionType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process results
   */
  pipeline?: string | undefined;
  /**
   * Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Destination to send results to
   */
  output?: string | undefined;
};

export type InputCollectionSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination.
   */
  sendToRoutes: boolean;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCollectionType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process results
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: models.PqType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Destination to send results to
   */
  output?: string | undefined;
};

export type InputCollectionSendToRoutesTrueConstraint = {
  /**
   * Send events to normal routing and event processing. Disable to select a specific Pipeline/Destination combination.
   */
  sendToRoutes: boolean;
  /**
   * Unique ID for this input
   */
  id: string;
  type: InputCollectionType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process results
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<models.ItemsTypeConnectionsOptional> | undefined;
  pq?: models.PqType | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  preprocess?: models.PreprocessTypeSavedJobCollectionInput | undefined;
  /**
   * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling.
   */
  throttleRatePerSec?: string | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<models.ItemsTypeNotificationMetadata> | undefined;
  /**
   * Destination to send results to
   */
  output?: string | undefined;
};

export type InputCollection =
  | InputCollectionSendToRoutesTrueConstraint
  | InputCollectionSendToRoutesFalseWithConnectionsConstraint
  | InputCollectionPqEnabledFalseConstraint
  | InputCollectionPqEnabledTrueWithPqConstraint;

/**
 * Input object
 */
export type CreateInputRequest =
  | (
    | InputCollectionSendToRoutesTrueConstraint
    | InputCollectionSendToRoutesFalseWithConnectionsConstraint
    | InputCollectionPqEnabledFalseConstraint
    | InputCollectionPqEnabledTrueWithPqConstraint & { type: "collection" }
  )
  | (
    | InputKafkaSendToRoutesTrueConstraint
    | InputKafkaSendToRoutesFalseWithConnectionsConstraint
    | InputKafkaPqEnabledFalseConstraint
    | InputKafkaPqEnabledTrueWithPqConstraint & { type: "kafka" }
  )
  | (
    | InputMskSendToRoutesTrueConstraint
    | InputMskSendToRoutesFalseWithConnectionsConstraint
    | InputMskPqEnabledFalseConstraint
    | InputMskPqEnabledTrueWithPqConstraint & { type: "msk" }
  )
  | (
    | InputHttpSendToRoutesTrueConstraint
    | InputHttpSendToRoutesFalseWithConnectionsConstraint
    | InputHttpPqEnabledFalseConstraint
    | InputHttpPqEnabledTrueWithPqConstraint & { type: "http" }
  )
  | (
    | InputSplunkSendToRoutesTrueConstraint
    | InputSplunkSendToRoutesFalseWithConnectionsConstraint
    | InputSplunkPqEnabledFalseConstraint
    | InputSplunkPqEnabledTrueWithPqConstraint & { type: "splunk" }
  )
  | (
    | InputSplunkSearchSendToRoutesTrueConstraint
    | InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint
    | InputSplunkSearchPqEnabledFalseConstraint
    | InputSplunkSearchPqEnabledTrueWithPqConstraint & { type: "splunk_search" }
  )
  | (
    | InputSplunkHecSendToRoutesTrueConstraint
    | InputSplunkHecSendToRoutesFalseWithConnectionsConstraint
    | InputSplunkHecPqEnabledFalseConstraint
    | InputSplunkHecPqEnabledTrueWithPqConstraint & { type: "splunk_hec" }
  )
  | (
    | InputAzureBlobSendToRoutesTrueConstraint
    | InputAzureBlobSendToRoutesFalseWithConnectionsConstraint
    | InputAzureBlobPqEnabledFalseConstraint
    | InputAzureBlobPqEnabledTrueWithPqConstraint & { type: "azure_blob" }
  )
  | (
    | InputElasticSendToRoutesTrueConstraint
    | InputElasticSendToRoutesFalseWithConnectionsConstraint
    | InputElasticPqEnabledFalseConstraint
    | InputElasticPqEnabledTrueWithPqConstraint & { type: "elastic" }
  )
  | (
    | InputConfluentCloudSendToRoutesTrueConstraint
    | InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint
    | InputConfluentCloudPqEnabledFalseConstraint
    | InputConfluentCloudPqEnabledTrueWithPqConstraint & {
      type: "confluent_cloud";
    }
  )
  | (InputGrafanaGrafana1 | InputGrafanaGrafana2 & { type: "grafana" })
  | (
    | InputLokiSendToRoutesTrueConstraint
    | InputLokiSendToRoutesFalseWithConnectionsConstraint
    | InputLokiPqEnabledFalseConstraint
    | InputLokiPqEnabledTrueWithPqConstraint & { type: "loki" }
  )
  | (
    | InputPrometheusRwSendToRoutesTrueConstraint
    | InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint
    | InputPrometheusRwPqEnabledFalseConstraint
    | InputPrometheusRwPqEnabledTrueWithPqConstraint & { type: "prometheus_rw" }
  )
  | (
    | InputPrometheusSendToRoutesTrueConstraint
    | InputPrometheusSendToRoutesFalseWithConnectionsConstraint
    | InputPrometheusPqEnabledFalseConstraint
    | InputPrometheusPqEnabledTrueWithPqConstraint & { type: "prometheus" }
  )
  | (
    | InputEdgePrometheusSendToRoutesTrueConstraint
    | InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint
    | InputEdgePrometheusPqEnabledFalseConstraint
    | InputEdgePrometheusPqEnabledTrueWithPqConstraint & {
      type: "edge_prometheus";
    }
  )
  | (
    | InputOffice365MgmtSendToRoutesTrueConstraint
    | InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint
    | InputOffice365MgmtPqEnabledFalseConstraint
    | InputOffice365MgmtPqEnabledTrueWithPqConstraint & {
      type: "office365_mgmt";
    }
  )
  | (
    | InputOffice365ServiceSendToRoutesTrueConstraint
    | InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint
    | InputOffice365ServicePqEnabledFalseConstraint
    | InputOffice365ServicePqEnabledTrueWithPqConstraint & {
      type: "office365_service";
    }
  )
  | (
    | InputOffice365MsgTraceSendToRoutesTrueConstraint
    | InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint
    | InputOffice365MsgTracePqEnabledFalseConstraint
    | InputOffice365MsgTracePqEnabledTrueWithPqConstraint & {
      type: "office365_msg_trace";
    }
  )
  | (
    | InputEventhubSendToRoutesTrueConstraint
    | InputEventhubSendToRoutesFalseWithConnectionsConstraint
    | InputEventhubPqEnabledFalseConstraint
    | InputEventhubPqEnabledTrueWithPqConstraint & { type: "eventhub" }
  )
  | (
    | InputExecSendToRoutesTrueConstraint
    | InputExecSendToRoutesFalseWithConnectionsConstraint
    | InputExecPqEnabledFalseConstraint
    | InputExecPqEnabledTrueWithPqConstraint & { type: "exec" }
  )
  | (
    | InputFirehoseSendToRoutesTrueConstraint
    | InputFirehoseSendToRoutesFalseWithConnectionsConstraint
    | InputFirehosePqEnabledFalseConstraint
    | InputFirehosePqEnabledTrueWithPqConstraint & { type: "firehose" }
  )
  | (
    | InputGooglePubsubSendToRoutesTrueConstraint
    | InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint
    | InputGooglePubsubPqEnabledFalseConstraint
    | InputGooglePubsubPqEnabledTrueWithPqConstraint & { type: "google_pubsub" }
  )
  | (
    | InputCriblSendToRoutesTrueConstraint
    | InputCriblSendToRoutesFalseWithConnectionsConstraint
    | InputCriblPqEnabledFalseConstraint
    | InputCriblPqEnabledTrueWithPqConstraint & { type: "cribl" }
  )
  | (
    | InputCriblTcpSendToRoutesTrueConstraint
    | InputCriblTcpSendToRoutesFalseWithConnectionsConstraint
    | InputCriblTcpPqEnabledFalseConstraint
    | InputCriblTcpPqEnabledTrueWithPqConstraint & { type: "cribl_tcp" }
  )
  | (
    | InputCriblHttpSendToRoutesTrueConstraint
    | InputCriblHttpSendToRoutesFalseWithConnectionsConstraint
    | InputCriblHttpPqEnabledFalseConstraint
    | InputCriblHttpPqEnabledTrueWithPqConstraint & { type: "cribl_http" }
  )
  | (
    | InputCriblLakeHttpSendToRoutesTrueConstraint
    | InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint
    | InputCriblLakeHttpPqEnabledFalseConstraint
    | InputCriblLakeHttpPqEnabledTrueWithPqConstraint & {
      type: "cribl_lake_http";
    }
  )
  | (
    | InputTcpjsonSendToRoutesTrueConstraint
    | InputTcpjsonSendToRoutesFalseWithConnectionsConstraint
    | InputTcpjsonPqEnabledFalseConstraint
    | InputTcpjsonPqEnabledTrueWithPqConstraint & { type: "tcpjson" }
  )
  | (
    | InputSystemMetricsSendToRoutesTrueConstraint
    | InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint
    | InputSystemMetricsPqEnabledFalseConstraint
    | InputSystemMetricsPqEnabledTrueWithPqConstraint & {
      type: "system_metrics";
    }
  )
  | (
    | InputSystemStateSendToRoutesTrueConstraint
    | InputSystemStateSendToRoutesFalseWithConnectionsConstraint
    | InputSystemStatePqEnabledFalseConstraint
    | InputSystemStatePqEnabledTrueWithPqConstraint & { type: "system_state" }
  )
  | (
    | InputKubeMetricsSendToRoutesTrueConstraint
    | InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint
    | InputKubeMetricsPqEnabledFalseConstraint
    | InputKubeMetricsPqEnabledTrueWithPqConstraint & { type: "kube_metrics" }
  )
  | (
    | InputKubeLogsSendToRoutesTrueConstraint
    | InputKubeLogsSendToRoutesFalseWithConnectionsConstraint
    | InputKubeLogsPqEnabledFalseConstraint
    | InputKubeLogsPqEnabledTrueWithPqConstraint & { type: "kube_logs" }
  )
  | (
    | InputKubeEventsSendToRoutesTrueConstraint
    | InputKubeEventsSendToRoutesFalseWithConnectionsConstraint
    | InputKubeEventsPqEnabledFalseConstraint
    | InputKubeEventsPqEnabledTrueWithPqConstraint & { type: "kube_events" }
  )
  | (
    | InputWindowsMetricsSendToRoutesTrueConstraint
    | InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint
    | InputWindowsMetricsPqEnabledFalseConstraint
    | InputWindowsMetricsPqEnabledTrueWithPqConstraint & {
      type: "windows_metrics";
    }
  )
  | (
    | InputCrowdstrikeSendToRoutesTrueConstraint
    | InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint
    | InputCrowdstrikePqEnabledFalseConstraint
    | InputCrowdstrikePqEnabledTrueWithPqConstraint & { type: "crowdstrike" }
  )
  | (
    | InputDatadogAgentSendToRoutesTrueConstraint
    | InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint
    | InputDatadogAgentPqEnabledFalseConstraint
    | InputDatadogAgentPqEnabledTrueWithPqConstraint & { type: "datadog_agent" }
  )
  | (
    | InputDatagenSendToRoutesTrueConstraint
    | InputDatagenSendToRoutesFalseWithConnectionsConstraint
    | InputDatagenPqEnabledFalseConstraint
    | InputDatagenPqEnabledTrueWithPqConstraint & { type: "datagen" }
  )
  | (
    | InputHttpRawSendToRoutesTrueConstraint
    | InputHttpRawSendToRoutesFalseWithConnectionsConstraint
    | InputHttpRawPqEnabledFalseConstraint
    | InputHttpRawPqEnabledTrueWithPqConstraint & { type: "http_raw" }
  )
  | (
    | InputKinesisSendToRoutesTrueConstraint
    | InputKinesisSendToRoutesFalseWithConnectionsConstraint
    | InputKinesisPqEnabledFalseConstraint
    | InputKinesisPqEnabledTrueWithPqConstraint & { type: "kinesis" }
  )
  | (
    | InputCriblmetricsSendToRoutesTrueConstraint
    | InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint
    | InputCriblmetricsPqEnabledFalseConstraint
    | InputCriblmetricsPqEnabledTrueWithPqConstraint & { type: "criblmetrics" }
  )
  | (
    | InputMetricsSendToRoutesTrueConstraint
    | InputMetricsSendToRoutesFalseWithConnectionsConstraint
    | InputMetricsPqEnabledFalseConstraint
    | InputMetricsPqEnabledTrueWithPqConstraint & { type: "metrics" }
  )
  | (
    | InputS3SendToRoutesTrueConstraint
    | InputS3SendToRoutesFalseWithConnectionsConstraint
    | InputS3PqEnabledFalseConstraint
    | InputS3PqEnabledTrueWithPqConstraint & { type: "s3" }
  )
  | (
    | InputS3InventorySendToRoutesTrueConstraint
    | InputS3InventorySendToRoutesFalseWithConnectionsConstraint
    | InputS3InventoryPqEnabledFalseConstraint
    | InputS3InventoryPqEnabledTrueWithPqConstraint & { type: "s3_inventory" }
  )
  | (
    | InputSnmpSendToRoutesTrueConstraint
    | InputSnmpSendToRoutesFalseWithConnectionsConstraint
    | InputSnmpPqEnabledFalseConstraint
    | InputSnmpPqEnabledTrueWithPqConstraint & { type: "snmp" }
  )
  | (
    | InputOpenTelemetrySendToRoutesTrueConstraint
    | InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint
    | InputOpenTelemetryPqEnabledFalseConstraint
    | InputOpenTelemetryPqEnabledTrueWithPqConstraint & {
      type: "open_telemetry";
    }
  )
  | (
    | InputModelDrivenTelemetrySendToRoutesTrueConstraint
    | InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint
    | InputModelDrivenTelemetryPqEnabledFalseConstraint
    | InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint & {
      type: "model_driven_telemetry";
    }
  )
  | (
    | InputSqsSendToRoutesTrueConstraint
    | InputSqsSendToRoutesFalseWithConnectionsConstraint
    | InputSqsPqEnabledFalseConstraint
    | InputSqsPqEnabledTrueWithPqConstraint & { type: "sqs" }
  )
  | (InputSyslogSyslog1 | InputSyslogSyslog2 & { type: "syslog" })
  | (
    | InputFileSendToRoutesTrueConstraint
    | InputFileSendToRoutesFalseWithConnectionsConstraint
    | InputFilePqEnabledFalseConstraint
    | InputFilePqEnabledTrueWithPqConstraint & { type: "file" }
  )
  | (
    | InputTcpSendToRoutesTrueConstraint
    | InputTcpSendToRoutesFalseWithConnectionsConstraint
    | InputTcpPqEnabledFalseConstraint
    | InputTcpPqEnabledTrueWithPqConstraint & { type: "tcp" }
  )
  | (
    | InputAppscopeSendToRoutesTrueConstraint
    | InputAppscopeSendToRoutesFalseWithConnectionsConstraint
    | InputAppscopePqEnabledFalseConstraint
    | InputAppscopePqEnabledTrueWithPqConstraint & { type: "appscope" }
  )
  | (
    | InputWefSendToRoutesTrueConstraint
    | InputWefSendToRoutesFalseWithConnectionsConstraint
    | InputWefPqEnabledFalseConstraint
    | InputWefPqEnabledTrueWithPqConstraint & { type: "wef" }
  )
  | (
    | InputWinEventLogsSendToRoutesTrueConstraint
    | InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint
    | InputWinEventLogsPqEnabledFalseConstraint
    | InputWinEventLogsPqEnabledTrueWithPqConstraint & {
      type: "win_event_logs";
    }
  )
  | (
    | InputRawUdpSendToRoutesTrueConstraint
    | InputRawUdpSendToRoutesFalseWithConnectionsConstraint
    | InputRawUdpPqEnabledFalseConstraint
    | InputRawUdpPqEnabledTrueWithPqConstraint & { type: "raw_udp" }
  )
  | (
    | InputJournalFilesSendToRoutesTrueConstraint
    | InputJournalFilesSendToRoutesFalseWithConnectionsConstraint
    | InputJournalFilesPqEnabledFalseConstraint
    | InputJournalFilesPqEnabledTrueWithPqConstraint & { type: "journal_files" }
  )
  | (
    | InputWizSendToRoutesTrueConstraint
    | InputWizSendToRoutesFalseWithConnectionsConstraint
    | InputWizPqEnabledFalseConstraint
    | InputWizPqEnabledTrueWithPqConstraint & { type: "wiz" }
  )
  | (
    | InputWizWebhookSendToRoutesTrueConstraint
    | InputWizWebhookSendToRoutesFalseWithConnectionsConstraint
    | InputWizWebhookPqEnabledFalseConstraint
    | InputWizWebhookPqEnabledTrueWithPqConstraint & { type: "wiz_webhook" }
  )
  | (
    | InputNetflowSendToRoutesTrueConstraint
    | InputNetflowSendToRoutesFalseWithConnectionsConstraint
    | InputNetflowPqEnabledFalseConstraint
    | InputNetflowPqEnabledTrueWithPqConstraint & { type: "netflow" }
  )
  | (
    | InputSecurityLakeSendToRoutesTrueConstraint
    | InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint
    | InputSecurityLakePqEnabledFalseConstraint
    | InputSecurityLakePqEnabledTrueWithPqConstraint & { type: "security_lake" }
  )
  | (
    | InputZscalerHecSendToRoutesTrueConstraint
    | InputZscalerHecSendToRoutesFalseWithConnectionsConstraint
    | InputZscalerHecPqEnabledFalseConstraint
    | InputZscalerHecPqEnabledTrueWithPqConstraint & { type: "zscaler_hec" }
  )
  | (
    | InputCloudflareHecSendToRoutesTrueConstraint
    | InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint
    | InputCloudflareHecPqEnabledFalseConstraint
    | InputCloudflareHecPqEnabledTrueWithPqConstraint & {
      type: "cloudflare_hec";
    }
  );

/** @internal */
export const InputCloudflareHecType$outboundSchema: z.ZodNativeEnum<
  typeof InputCloudflareHecType
> = z.nativeEnum(InputCloudflareHecType);

/** @internal */
export const InputCloudflareHecAuthenticationMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputCloudflareHecAuthenticationMethod
> = openEnums.outboundSchema(InputCloudflareHecAuthenticationMethod);

/** @internal */
export type InputCloudflareHecAuthToken$Outbound = {
  authType?: string | undefined;
  tokenSecret?: string | undefined;
  token?: string | undefined;
  enabled?: boolean | undefined;
  description?: string | undefined;
  allowedIndexesAtToken?: Array<string> | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
};

/** @internal */
export const InputCloudflareHecAuthToken$outboundSchema: z.ZodType<
  InputCloudflareHecAuthToken$Outbound,
  z.ZodTypeDef,
  InputCloudflareHecAuthToken
> = z.object({
  authType: InputCloudflareHecAuthenticationMethod$outboundSchema.optional(),
  tokenSecret: z.string().optional(),
  token: z.string().optional(),
  enabled: z.boolean().optional(),
  description: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
});

export function inputCloudflareHecAuthTokenToJSON(
  inputCloudflareHecAuthToken: InputCloudflareHecAuthToken,
): string {
  return JSON.stringify(
    InputCloudflareHecAuthToken$outboundSchema.parse(
      inputCloudflareHecAuthToken,
    ),
  );
}

/** @internal */
export type InputCloudflareHecPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  authTokens?: Array<InputCloudflareHecAuthToken$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  hecAPI: string;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCloudflareHecPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputCloudflareHecPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputCloudflareHecPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputCloudflareHecType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(
      z.lazy(() => InputCloudflareHecAuthToken$outboundSchema),
    ).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.any().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    hecAPI: z.string(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedIndexes: z.array(z.string()).optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    accessControlAllowOrigin: z.array(z.string()).optional(),
    accessControlAllowHeaders: z.array(z.string()).optional(),
    emitTokenMetrics: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputCloudflareHecPqEnabledTrueWithPqConstraintToJSON(
  inputCloudflareHecPqEnabledTrueWithPqConstraint:
    InputCloudflareHecPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputCloudflareHecPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputCloudflareHecPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputCloudflareHecPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<InputCloudflareHecAuthToken$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  hecAPI: string;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCloudflareHecPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputCloudflareHecPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputCloudflareHecPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputCloudflareHecType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(
      z.lazy(() => InputCloudflareHecAuthToken$outboundSchema),
    ).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.any().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    hecAPI: z.string(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedIndexes: z.array(z.string()).optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    accessControlAllowOrigin: z.array(z.string()).optional(),
    accessControlAllowHeaders: z.array(z.string()).optional(),
    emitTokenMetrics: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputCloudflareHecPqEnabledFalseConstraintToJSON(
  inputCloudflareHecPqEnabledFalseConstraint:
    InputCloudflareHecPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputCloudflareHecPqEnabledFalseConstraint$outboundSchema.parse(
      inputCloudflareHecPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    host: string;
    port: number;
    authTokens?: Array<InputCloudflareHecAuthToken$Outbound> | undefined;
    tls?: models.TlsSettingsServerSideType$Outbound | undefined;
    maxActiveReq?: number | undefined;
    maxRequestsPerSocket?: number | undefined;
    enableProxyHeader?: boolean | undefined;
    captureHeaders?: boolean | undefined;
    activityLogSampleRate?: number | undefined;
    requestTimeout?: number | undefined;
    socketTimeout?: number | undefined;
    keepAliveTimeout?: number | undefined;
    enableHealthCheck?: any | undefined;
    ipAllowlistRegex?: string | undefined;
    ipDenylistRegex?: string | undefined;
    hecAPI: string;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    allowedIndexes?: Array<string> | undefined;
    breakerRulesets?: Array<string> | undefined;
    staleChannelFlushMs?: number | undefined;
    accessControlAllowOrigin?: Array<string> | undefined;
    accessControlAllowHeaders?: Array<string> | undefined;
    emitTokenMetrics?: boolean | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputCloudflareHecType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(
      z.lazy(() => InputCloudflareHecAuthToken$outboundSchema),
    ).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.any().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    hecAPI: z.string(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedIndexes: z.array(z.string()).optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    accessControlAllowOrigin: z.array(z.string()).optional(),
    accessControlAllowHeaders: z.array(z.string()).optional(),
    emitTokenMetrics: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputCloudflareHecSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputCloudflareHecSendToRoutesFalseWithConnectionsConstraint:
    InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputCloudflareHecSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputCloudflareHecSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<InputCloudflareHecAuthToken$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  hecAPI: string;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCloudflareHecSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputCloudflareHecSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputCloudflareHecSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputCloudflareHecType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(
      z.lazy(() => InputCloudflareHecAuthToken$outboundSchema),
    ).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.any().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    hecAPI: z.string(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedIndexes: z.array(z.string()).optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    accessControlAllowOrigin: z.array(z.string()).optional(),
    accessControlAllowHeaders: z.array(z.string()).optional(),
    emitTokenMetrics: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputCloudflareHecSendToRoutesTrueConstraintToJSON(
  inputCloudflareHecSendToRoutesTrueConstraint:
    InputCloudflareHecSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputCloudflareHecSendToRoutesTrueConstraint$outboundSchema.parse(
      inputCloudflareHecSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputCloudflareHec$Outbound =
  | InputCloudflareHecSendToRoutesTrueConstraint$Outbound
  | InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputCloudflareHecPqEnabledFalseConstraint$Outbound
  | InputCloudflareHecPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputCloudflareHec$outboundSchema: z.ZodType<
  InputCloudflareHec$Outbound,
  z.ZodTypeDef,
  InputCloudflareHec
> = z.union([
  z.lazy(() => InputCloudflareHecSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputCloudflareHecPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputCloudflareHecPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputCloudflareHecToJSON(
  inputCloudflareHec: InputCloudflareHec,
): string {
  return JSON.stringify(
    InputCloudflareHec$outboundSchema.parse(inputCloudflareHec),
  );
}

/** @internal */
export const InputZscalerHecType$outboundSchema: z.ZodNativeEnum<
  typeof InputZscalerHecType
> = z.nativeEnum(InputZscalerHecType);

/** @internal */
export type InputZscalerHecAuthToken$Outbound = {
  authType?: string | undefined;
  tokenSecret?: string | undefined;
  token: string;
  enabled?: boolean | undefined;
  description?: string | undefined;
  allowedIndexesAtToken?: Array<string> | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
};

/** @internal */
export const InputZscalerHecAuthToken$outboundSchema: z.ZodType<
  InputZscalerHecAuthToken$Outbound,
  z.ZodTypeDef,
  InputZscalerHecAuthToken
> = z.object({
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  tokenSecret: z.string().optional(),
  token: z.string(),
  enabled: z.boolean().optional(),
  description: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
});

export function inputZscalerHecAuthTokenToJSON(
  inputZscalerHecAuthToken: InputZscalerHecAuthToken,
): string {
  return JSON.stringify(
    InputZscalerHecAuthToken$outboundSchema.parse(inputZscalerHecAuthToken),
  );
}

/** @internal */
export type InputZscalerHecPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  authTokens?: Array<InputZscalerHecAuthToken$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  hecAPI: string;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  hecAcks?: boolean | undefined;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputZscalerHecPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputZscalerHecPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputZscalerHecPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputZscalerHecType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.lazy(() => InputZscalerHecAuthToken$outboundSchema))
      .optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.any().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    hecAPI: z.string(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedIndexes: z.array(z.string()).optional(),
    hecAcks: z.boolean().optional(),
    accessControlAllowOrigin: z.array(z.string()).optional(),
    accessControlAllowHeaders: z.array(z.string()).optional(),
    emitTokenMetrics: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputZscalerHecPqEnabledTrueWithPqConstraintToJSON(
  inputZscalerHecPqEnabledTrueWithPqConstraint:
    InputZscalerHecPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputZscalerHecPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputZscalerHecPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputZscalerHecPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<InputZscalerHecAuthToken$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  hecAPI: string;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  hecAcks?: boolean | undefined;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputZscalerHecPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputZscalerHecPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputZscalerHecPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputZscalerHecType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(z.lazy(() => InputZscalerHecAuthToken$outboundSchema))
    .optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.any().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  hecAPI: z.string(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  allowedIndexes: z.array(z.string()).optional(),
  hecAcks: z.boolean().optional(),
  accessControlAllowOrigin: z.array(z.string()).optional(),
  accessControlAllowHeaders: z.array(z.string()).optional(),
  emitTokenMetrics: z.boolean().optional(),
  description: z.string().optional(),
});

export function inputZscalerHecPqEnabledFalseConstraintToJSON(
  inputZscalerHecPqEnabledFalseConstraint:
    InputZscalerHecPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputZscalerHecPqEnabledFalseConstraint$outboundSchema.parse(
      inputZscalerHecPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputZscalerHecSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    host: string;
    port: number;
    authTokens?: Array<InputZscalerHecAuthToken$Outbound> | undefined;
    tls?: models.TlsSettingsServerSideType$Outbound | undefined;
    maxActiveReq?: number | undefined;
    maxRequestsPerSocket?: number | undefined;
    enableProxyHeader?: boolean | undefined;
    captureHeaders?: boolean | undefined;
    activityLogSampleRate?: number | undefined;
    requestTimeout?: number | undefined;
    socketTimeout?: number | undefined;
    keepAliveTimeout?: number | undefined;
    enableHealthCheck?: any | undefined;
    ipAllowlistRegex?: string | undefined;
    ipDenylistRegex?: string | undefined;
    hecAPI: string;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    allowedIndexes?: Array<string> | undefined;
    hecAcks?: boolean | undefined;
    accessControlAllowOrigin?: Array<string> | undefined;
    accessControlAllowHeaders?: Array<string> | undefined;
    emitTokenMetrics?: boolean | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputZscalerHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputZscalerHecSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputZscalerHecSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputZscalerHecType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.lazy(() => InputZscalerHecAuthToken$outboundSchema))
      .optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.any().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    hecAPI: z.string(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedIndexes: z.array(z.string()).optional(),
    hecAcks: z.boolean().optional(),
    accessControlAllowOrigin: z.array(z.string()).optional(),
    accessControlAllowHeaders: z.array(z.string()).optional(),
    emitTokenMetrics: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputZscalerHecSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputZscalerHecSendToRoutesFalseWithConnectionsConstraint:
    InputZscalerHecSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputZscalerHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputZscalerHecSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputZscalerHecSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<InputZscalerHecAuthToken$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  hecAPI: string;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  hecAcks?: boolean | undefined;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputZscalerHecSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputZscalerHecSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputZscalerHecSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputZscalerHecType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.lazy(() => InputZscalerHecAuthToken$outboundSchema))
      .optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.any().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    hecAPI: z.string(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedIndexes: z.array(z.string()).optional(),
    hecAcks: z.boolean().optional(),
    accessControlAllowOrigin: z.array(z.string()).optional(),
    accessControlAllowHeaders: z.array(z.string()).optional(),
    emitTokenMetrics: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputZscalerHecSendToRoutesTrueConstraintToJSON(
  inputZscalerHecSendToRoutesTrueConstraint:
    InputZscalerHecSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputZscalerHecSendToRoutesTrueConstraint$outboundSchema.parse(
      inputZscalerHecSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputZscalerHec$Outbound =
  | InputZscalerHecSendToRoutesTrueConstraint$Outbound
  | InputZscalerHecSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputZscalerHecPqEnabledFalseConstraint$Outbound
  | InputZscalerHecPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputZscalerHec$outboundSchema: z.ZodType<
  InputZscalerHec$Outbound,
  z.ZodTypeDef,
  InputZscalerHec
> = z.union([
  z.lazy(() => InputZscalerHecSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputZscalerHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputZscalerHecPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputZscalerHecPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputZscalerHecToJSON(
  inputZscalerHec: InputZscalerHec,
): string {
  return JSON.stringify(InputZscalerHec$outboundSchema.parse(inputZscalerHec));
}

/** @internal */
export const InputSecurityLakeType$outboundSchema: z.ZodNativeEnum<
  typeof InputSecurityLakeType
> = z.nativeEnum(InputSecurityLakeType);

/** @internal */
export type InputSecurityLakePqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputSecurityLakePqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputSecurityLakePqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputSecurityLakePqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputSecurityLakeType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models
      .SignatureVersionOptionsS3CollectorConf$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    socketTimeout: z.number().optional(),
    skipOnError: z.boolean().optional(),
    includeSqsMetadata: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    enableSQSAssumeRole: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    parquetChunkSizeMB: z.number().optional(),
    parquetChunkDownloadTimeout: z.number().optional(),
    checkpointing: models.CheckpointingType$outboundSchema.optional(),
    pollTimeout: z.number().optional(),
    encoding: z.string().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
      .optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

export function inputSecurityLakePqEnabledTrueWithPqConstraintToJSON(
  inputSecurityLakePqEnabledTrueWithPqConstraint:
    InputSecurityLakePqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputSecurityLakePqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputSecurityLakePqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputSecurityLakePqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputSecurityLakePqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputSecurityLakePqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputSecurityLakePqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputSecurityLakeType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models
      .SignatureVersionOptionsS3CollectorConf$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    socketTimeout: z.number().optional(),
    skipOnError: z.boolean().optional(),
    includeSqsMetadata: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    enableSQSAssumeRole: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    parquetChunkSizeMB: z.number().optional(),
    parquetChunkDownloadTimeout: z.number().optional(),
    checkpointing: models.CheckpointingType$outboundSchema.optional(),
    pollTimeout: z.number().optional(),
    encoding: z.string().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
      .optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

export function inputSecurityLakePqEnabledFalseConstraintToJSON(
  inputSecurityLakePqEnabledFalseConstraint:
    InputSecurityLakePqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputSecurityLakePqEnabledFalseConstraint$outboundSchema.parse(
      inputSecurityLakePqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    queueName: string;
    fileFilter?: string | undefined;
    awsAccountId?: string | undefined;
    awsAuthenticationMethod?: string | undefined;
    awsSecretKey?: string | undefined;
    region?: string | undefined;
    endpoint?: string | undefined;
    signatureVersion?: string | undefined;
    reuseConnections?: boolean | undefined;
    rejectUnauthorized?: boolean | undefined;
    breakerRulesets?: Array<string> | undefined;
    staleChannelFlushMs?: number | undefined;
    maxMessages?: number | undefined;
    visibilityTimeout?: number | undefined;
    numReceivers?: number | undefined;
    socketTimeout?: number | undefined;
    skipOnError?: boolean | undefined;
    includeSqsMetadata?: boolean | undefined;
    enableAssumeRole?: boolean | undefined;
    assumeRoleArn?: string | undefined;
    assumeRoleExternalId?: string | undefined;
    durationSeconds?: number | undefined;
    enableSQSAssumeRole?: boolean | undefined;
    preprocess?:
      | models.PreprocessTypeSavedJobCollectionInput$Outbound
      | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    parquetChunkSizeMB?: number | undefined;
    parquetChunkDownloadTimeout?: number | undefined;
    checkpointing?: models.CheckpointingType$Outbound | undefined;
    pollTimeout?: number | undefined;
    encoding?: string | undefined;
    description?: string | undefined;
    awsApiKey?: string | undefined;
    awsSecret?: string | undefined;
    tagAfterProcessing?: string | undefined;
    processedTagKey?: string | undefined;
    processedTagValue?: string | undefined;
  };

/** @internal */
export const InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputSecurityLakeType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models
      .SignatureVersionOptionsS3CollectorConf$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    socketTimeout: z.number().optional(),
    skipOnError: z.boolean().optional(),
    includeSqsMetadata: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    enableSQSAssumeRole: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    parquetChunkSizeMB: z.number().optional(),
    parquetChunkDownloadTimeout: z.number().optional(),
    checkpointing: models.CheckpointingType$outboundSchema.optional(),
    pollTimeout: z.number().optional(),
    encoding: z.string().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
      .optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

export function inputSecurityLakeSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputSecurityLakeSendToRoutesFalseWithConnectionsConstraint:
    InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputSecurityLakeSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputSecurityLakeSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputSecurityLakeSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputSecurityLakeSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputSecurityLakeSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputSecurityLakeType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models
      .SignatureVersionOptionsS3CollectorConf$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    socketTimeout: z.number().optional(),
    skipOnError: z.boolean().optional(),
    includeSqsMetadata: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    enableSQSAssumeRole: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    parquetChunkSizeMB: z.number().optional(),
    parquetChunkDownloadTimeout: z.number().optional(),
    checkpointing: models.CheckpointingType$outboundSchema.optional(),
    pollTimeout: z.number().optional(),
    encoding: z.string().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
      .optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

export function inputSecurityLakeSendToRoutesTrueConstraintToJSON(
  inputSecurityLakeSendToRoutesTrueConstraint:
    InputSecurityLakeSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputSecurityLakeSendToRoutesTrueConstraint$outboundSchema.parse(
      inputSecurityLakeSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputSecurityLake$Outbound =
  | InputSecurityLakeSendToRoutesTrueConstraint$Outbound
  | InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputSecurityLakePqEnabledFalseConstraint$Outbound
  | InputSecurityLakePqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputSecurityLake$outboundSchema: z.ZodType<
  InputSecurityLake$Outbound,
  z.ZodTypeDef,
  InputSecurityLake
> = z.union([
  z.lazy(() => InputSecurityLakeSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputSecurityLakePqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputSecurityLakePqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputSecurityLakeToJSON(
  inputSecurityLake: InputSecurityLake,
): string {
  return JSON.stringify(
    InputSecurityLake$outboundSchema.parse(inputSecurityLake),
  );
}

/** @internal */
export const InputNetflowType$outboundSchema: z.ZodNativeEnum<
  typeof InputNetflowType
> = z.nativeEnum(InputNetflowType);

/** @internal */
export type InputNetflowPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  enablePassThrough?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  udpSocketRxBufSize?: number | undefined;
  templateCacheMinutes?: number | undefined;
  v5Enabled?: boolean | undefined;
  v9Enabled?: boolean | undefined;
  ipfixEnabled?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputNetflowPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputNetflowPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputNetflowPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputNetflowType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    enablePassThrough: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    udpSocketRxBufSize: z.number().optional(),
    templateCacheMinutes: z.number().optional(),
    v5Enabled: z.boolean().optional(),
    v9Enabled: z.boolean().optional(),
    ipfixEnabled: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputNetflowPqEnabledTrueWithPqConstraintToJSON(
  inputNetflowPqEnabledTrueWithPqConstraint:
    InputNetflowPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputNetflowPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputNetflowPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputNetflowPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  enablePassThrough?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  udpSocketRxBufSize?: number | undefined;
  templateCacheMinutes?: number | undefined;
  v5Enabled?: boolean | undefined;
  v9Enabled?: boolean | undefined;
  ipfixEnabled?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputNetflowPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputNetflowPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputNetflowPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputNetflowType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  enablePassThrough: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  udpSocketRxBufSize: z.number().optional(),
  templateCacheMinutes: z.number().optional(),
  v5Enabled: z.boolean().optional(),
  v9Enabled: z.boolean().optional(),
  ipfixEnabled: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputNetflowPqEnabledFalseConstraintToJSON(
  inputNetflowPqEnabledFalseConstraint: InputNetflowPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputNetflowPqEnabledFalseConstraint$outboundSchema.parse(
      inputNetflowPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputNetflowSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  enablePassThrough?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  udpSocketRxBufSize?: number | undefined;
  templateCacheMinutes?: number | undefined;
  v5Enabled?: boolean | undefined;
  v9Enabled?: boolean | undefined;
  ipfixEnabled?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputNetflowSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputNetflowSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputNetflowSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputNetflowType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    enablePassThrough: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    udpSocketRxBufSize: z.number().optional(),
    templateCacheMinutes: z.number().optional(),
    v5Enabled: z.boolean().optional(),
    v9Enabled: z.boolean().optional(),
    ipfixEnabled: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputNetflowSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputNetflowSendToRoutesFalseWithConnectionsConstraint:
    InputNetflowSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputNetflowSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputNetflowSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputNetflowSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  enablePassThrough?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  udpSocketRxBufSize?: number | undefined;
  templateCacheMinutes?: number | undefined;
  v5Enabled?: boolean | undefined;
  v9Enabled?: boolean | undefined;
  ipfixEnabled?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputNetflowSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputNetflowSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputNetflowSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputNetflowType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  enablePassThrough: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  udpSocketRxBufSize: z.number().optional(),
  templateCacheMinutes: z.number().optional(),
  v5Enabled: z.boolean().optional(),
  v9Enabled: z.boolean().optional(),
  ipfixEnabled: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputNetflowSendToRoutesTrueConstraintToJSON(
  inputNetflowSendToRoutesTrueConstraint:
    InputNetflowSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputNetflowSendToRoutesTrueConstraint$outboundSchema.parse(
      inputNetflowSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputNetflow$Outbound =
  | InputNetflowSendToRoutesTrueConstraint$Outbound
  | InputNetflowSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputNetflowPqEnabledFalseConstraint$Outbound
  | InputNetflowPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputNetflow$outboundSchema: z.ZodType<
  InputNetflow$Outbound,
  z.ZodTypeDef,
  InputNetflow
> = z.union([
  z.lazy(() => InputNetflowSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputNetflowSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputNetflowPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputNetflowPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputNetflowToJSON(inputNetflow: InputNetflow): string {
  return JSON.stringify(InputNetflow$outboundSchema.parse(inputNetflow));
}

/** @internal */
export const InputWizWebhookType$outboundSchema: z.ZodNativeEnum<
  typeof InputWizWebhookType
> = z.nativeEnum(InputWizWebhookType);

/** @internal */
export type InputWizWebhookPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedPaths?: Array<string> | undefined;
  allowedMethods?: Array<string> | undefined;
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputWizWebhookPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputWizWebhookPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputWizWebhookPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputWizWebhookType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedPaths: z.array(z.string()).optional(),
    allowedMethods: z.array(z.string()).optional(),
    authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputWizWebhookPqEnabledTrueWithPqConstraintToJSON(
  inputWizWebhookPqEnabledTrueWithPqConstraint:
    InputWizWebhookPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputWizWebhookPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputWizWebhookPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputWizWebhookPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedPaths?: Array<string> | undefined;
  allowedMethods?: Array<string> | undefined;
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputWizWebhookPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputWizWebhookPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputWizWebhookPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputWizWebhookType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  allowedPaths: z.array(z.string()).optional(),
  allowedMethods: z.array(z.string()).optional(),
  authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputWizWebhookPqEnabledFalseConstraintToJSON(
  inputWizWebhookPqEnabledFalseConstraint:
    InputWizWebhookPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputWizWebhookPqEnabledFalseConstraint$outboundSchema.parse(
      inputWizWebhookPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputWizWebhookSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    host: string;
    port: number;
    authTokens?: Array<string> | undefined;
    tls?: models.TlsSettingsServerSideType$Outbound | undefined;
    maxActiveReq?: number | undefined;
    maxRequestsPerSocket?: number | undefined;
    enableProxyHeader?: boolean | undefined;
    captureHeaders?: boolean | undefined;
    activityLogSampleRate?: number | undefined;
    requestTimeout?: number | undefined;
    socketTimeout?: number | undefined;
    keepAliveTimeout?: number | undefined;
    enableHealthCheck?: boolean | undefined;
    ipAllowlistRegex?: string | undefined;
    ipDenylistRegex?: string | undefined;
    breakerRulesets?: Array<string> | undefined;
    staleChannelFlushMs?: number | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    allowedPaths?: Array<string> | undefined;
    allowedMethods?: Array<string> | undefined;
    authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputWizWebhookSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputWizWebhookSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputWizWebhookSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputWizWebhookType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedPaths: z.array(z.string()).optional(),
    allowedMethods: z.array(z.string()).optional(),
    authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputWizWebhookSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputWizWebhookSendToRoutesFalseWithConnectionsConstraint:
    InputWizWebhookSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputWizWebhookSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputWizWebhookSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputWizWebhookSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedPaths?: Array<string> | undefined;
  allowedMethods?: Array<string> | undefined;
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputWizWebhookSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputWizWebhookSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputWizWebhookSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputWizWebhookType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedPaths: z.array(z.string()).optional(),
    allowedMethods: z.array(z.string()).optional(),
    authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputWizWebhookSendToRoutesTrueConstraintToJSON(
  inputWizWebhookSendToRoutesTrueConstraint:
    InputWizWebhookSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputWizWebhookSendToRoutesTrueConstraint$outboundSchema.parse(
      inputWizWebhookSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputWizWebhook$Outbound =
  | InputWizWebhookSendToRoutesTrueConstraint$Outbound
  | InputWizWebhookSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputWizWebhookPqEnabledFalseConstraint$Outbound
  | InputWizWebhookPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputWizWebhook$outboundSchema: z.ZodType<
  InputWizWebhook$Outbound,
  z.ZodTypeDef,
  InputWizWebhook
> = z.union([
  z.lazy(() => InputWizWebhookSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputWizWebhookSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputWizWebhookPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputWizWebhookPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputWizWebhookToJSON(
  inputWizWebhook: InputWizWebhook,
): string {
  return JSON.stringify(InputWizWebhook$outboundSchema.parse(inputWizWebhook));
}

/** @internal */
export const InputWizType$outboundSchema: z.ZodNativeEnum<typeof InputWizType> =
  z.nativeEnum(InputWizType);

/** @internal */
export type ManageState$Outbound = {};

/** @internal */
export const ManageState$outboundSchema: z.ZodType<
  ManageState$Outbound,
  z.ZodTypeDef,
  ManageState
> = z.object({});

export function manageStateToJSON(manageState: ManageState): string {
  return JSON.stringify(ManageState$outboundSchema.parse(manageState));
}

/** @internal */
export const InputWizLogLevel$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWizLogLevel
> = openEnums.outboundSchema(InputWizLogLevel);

/** @internal */
export type InputWizContentConfig$Outbound = {
  contentType: string;
  contentDescription?: string | undefined;
  enabled?: boolean | undefined;
  stateTracking?: boolean | undefined;
  stateUpdateExpression?: string | undefined;
  stateMergeExpression?: string | undefined;
  manageState?: ManageState$Outbound | undefined;
  contentQuery: string;
  cronSchedule: string;
  earliest: string;
  latest: string;
  jobTimeout?: string | undefined;
  logLevel?: string | undefined;
  maxPages?: number | undefined;
};

/** @internal */
export const InputWizContentConfig$outboundSchema: z.ZodType<
  InputWizContentConfig$Outbound,
  z.ZodTypeDef,
  InputWizContentConfig
> = z.object({
  contentType: z.string(),
  contentDescription: z.string().optional(),
  enabled: z.boolean().optional(),
  stateTracking: z.boolean().optional(),
  stateUpdateExpression: z.string().optional(),
  stateMergeExpression: z.string().optional(),
  manageState: z.lazy(() => ManageState$outboundSchema).optional(),
  contentQuery: z.string(),
  cronSchedule: z.string(),
  earliest: z.string(),
  latest: z.string(),
  jobTimeout: z.string().optional(),
  logLevel: InputWizLogLevel$outboundSchema.optional(),
  maxPages: z.number().optional(),
});

export function inputWizContentConfigToJSON(
  inputWizContentConfig: InputWizContentConfig,
): string {
  return JSON.stringify(
    InputWizContentConfig$outboundSchema.parse(inputWizContentConfig),
  );
}

/** @internal */
export type InputWizPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  endpoint: string;
  authUrl: string;
  authAudienceOverride?: string | undefined;
  clientId: string;
  contentConfig: Array<InputWizContentConfig$Outbound>;
  requestTimeout?: number | undefined;
  keepAliveTime?: number | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  retryRules?: models.RetryRulesType$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputWizPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputWizPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputWizPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputWizType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  endpoint: z.string(),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => InputWizContentConfig$outboundSchema)),
  requestTimeout: z.number().optional(),
  keepAliveTime: z.number().optional(),
  maxMissedKeepAlives: z.number().optional(),
  ttl: z.string().optional(),
  ignoreGroupJobsLimit: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  retryRules: models.RetryRulesType$outboundSchema.optional(),
  authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

export function inputWizPqEnabledTrueWithPqConstraintToJSON(
  inputWizPqEnabledTrueWithPqConstraint: InputWizPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputWizPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputWizPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputWizPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  endpoint: string;
  authUrl: string;
  authAudienceOverride?: string | undefined;
  clientId: string;
  contentConfig: Array<InputWizContentConfig$Outbound>;
  requestTimeout?: number | undefined;
  keepAliveTime?: number | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  retryRules?: models.RetryRulesType$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputWizPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputWizPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputWizPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputWizType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  endpoint: z.string(),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => InputWizContentConfig$outboundSchema)),
  requestTimeout: z.number().optional(),
  keepAliveTime: z.number().optional(),
  maxMissedKeepAlives: z.number().optional(),
  ttl: z.string().optional(),
  ignoreGroupJobsLimit: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  retryRules: models.RetryRulesType$outboundSchema.optional(),
  authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

export function inputWizPqEnabledFalseConstraintToJSON(
  inputWizPqEnabledFalseConstraint: InputWizPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputWizPqEnabledFalseConstraint$outboundSchema.parse(
      inputWizPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputWizSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  endpoint: string;
  authUrl: string;
  authAudienceOverride?: string | undefined;
  clientId: string;
  contentConfig: Array<InputWizContentConfig$Outbound>;
  requestTimeout?: number | undefined;
  keepAliveTime?: number | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  retryRules?: models.RetryRulesType$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputWizSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputWizSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputWizSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputWizType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    endpoint: z.string(),
    authUrl: z.string(),
    authAudienceOverride: z.string().optional(),
    clientId: z.string(),
    contentConfig: z.array(z.lazy(() => InputWizContentConfig$outboundSchema)),
    requestTimeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    retryRules: models.RetryRulesType$outboundSchema.optional(),
    authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
    description: z.string().optional(),
    clientSecret: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputWizSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputWizSendToRoutesFalseWithConnectionsConstraint:
    InputWizSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputWizSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputWizSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputWizSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  endpoint: string;
  authUrl: string;
  authAudienceOverride?: string | undefined;
  clientId: string;
  contentConfig: Array<InputWizContentConfig$Outbound>;
  requestTimeout?: number | undefined;
  keepAliveTime?: number | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  retryRules?: models.RetryRulesType$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputWizSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputWizSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputWizSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputWizType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  endpoint: z.string(),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => InputWizContentConfig$outboundSchema)),
  requestTimeout: z.number().optional(),
  keepAliveTime: z.number().optional(),
  maxMissedKeepAlives: z.number().optional(),
  ttl: z.string().optional(),
  ignoreGroupJobsLimit: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  retryRules: models.RetryRulesType$outboundSchema.optional(),
  authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

export function inputWizSendToRoutesTrueConstraintToJSON(
  inputWizSendToRoutesTrueConstraint: InputWizSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputWizSendToRoutesTrueConstraint$outboundSchema.parse(
      inputWizSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputWiz$Outbound =
  | InputWizSendToRoutesTrueConstraint$Outbound
  | InputWizSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputWizPqEnabledFalseConstraint$Outbound
  | InputWizPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputWiz$outboundSchema: z.ZodType<
  InputWiz$Outbound,
  z.ZodTypeDef,
  InputWiz
> = z.union([
  z.lazy(() => InputWizSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputWizSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputWizPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputWizPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputWizToJSON(inputWiz: InputWiz): string {
  return JSON.stringify(InputWiz$outboundSchema.parse(inputWiz));
}

/** @internal */
export const PqEnabledTrueWithPqConstraintInputJournalFilesType$outboundSchema:
  z.ZodNativeEnum<typeof PqEnabledTrueWithPqConstraintInputJournalFilesType> = z
    .nativeEnum(PqEnabledTrueWithPqConstraintInputJournalFilesType);

/** @internal */
export type PqEnabledTrueWithPqConstraintRule$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const PqEnabledTrueWithPqConstraintRule$outboundSchema: z.ZodType<
  PqEnabledTrueWithPqConstraintRule$Outbound,
  z.ZodTypeDef,
  PqEnabledTrueWithPqConstraintRule
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

export function pqEnabledTrueWithPqConstraintRuleToJSON(
  pqEnabledTrueWithPqConstraintRule: PqEnabledTrueWithPqConstraintRule,
): string {
  return JSON.stringify(
    PqEnabledTrueWithPqConstraintRule$outboundSchema.parse(
      pqEnabledTrueWithPqConstraintRule,
    ),
  );
}

/** @internal */
export type InputJournalFilesPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  path: string;
  interval?: number | undefined;
  journals: Array<string>;
  rules?: Array<PqEnabledTrueWithPqConstraintRule$Outbound> | undefined;
  currentBoot?: boolean | undefined;
  maxAgeDur?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputJournalFilesPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputJournalFilesPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputJournalFilesPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: PqEnabledTrueWithPqConstraintInputJournalFilesType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    path: z.string(),
    interval: z.number().optional(),
    journals: z.array(z.string()),
    rules: z.array(
      z.lazy(() => PqEnabledTrueWithPqConstraintRule$outboundSchema),
    ).optional(),
    currentBoot: z.boolean().optional(),
    maxAgeDur: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputJournalFilesPqEnabledTrueWithPqConstraintToJSON(
  inputJournalFilesPqEnabledTrueWithPqConstraint:
    InputJournalFilesPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputJournalFilesPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputJournalFilesPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export const PqEnabledFalseConstraintInputJournalFilesType$outboundSchema:
  z.ZodNativeEnum<typeof PqEnabledFalseConstraintInputJournalFilesType> = z
    .nativeEnum(PqEnabledFalseConstraintInputJournalFilesType);

/** @internal */
export type PqEnabledFalseConstraintRule$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const PqEnabledFalseConstraintRule$outboundSchema: z.ZodType<
  PqEnabledFalseConstraintRule$Outbound,
  z.ZodTypeDef,
  PqEnabledFalseConstraintRule
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

export function pqEnabledFalseConstraintRuleToJSON(
  pqEnabledFalseConstraintRule: PqEnabledFalseConstraintRule,
): string {
  return JSON.stringify(
    PqEnabledFalseConstraintRule$outboundSchema.parse(
      pqEnabledFalseConstraintRule,
    ),
  );
}

/** @internal */
export type InputJournalFilesPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  path: string;
  interval?: number | undefined;
  journals: Array<string>;
  rules?: Array<PqEnabledFalseConstraintRule$Outbound> | undefined;
  currentBoot?: boolean | undefined;
  maxAgeDur?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputJournalFilesPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputJournalFilesPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputJournalFilesPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: PqEnabledFalseConstraintInputJournalFilesType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    path: z.string(),
    interval: z.number().optional(),
    journals: z.array(z.string()),
    rules: z.array(z.lazy(() => PqEnabledFalseConstraintRule$outboundSchema))
      .optional(),
    currentBoot: z.boolean().optional(),
    maxAgeDur: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputJournalFilesPqEnabledFalseConstraintToJSON(
  inputJournalFilesPqEnabledFalseConstraint:
    InputJournalFilesPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputJournalFilesPqEnabledFalseConstraint$outboundSchema.parse(
      inputJournalFilesPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export const SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType$outboundSchema:
  z.ZodNativeEnum<
    typeof SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType
  > = z.nativeEnum(
    SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType,
  );

/** @internal */
export type SendToRoutesFalseWithConnectionsConstraintRule$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const SendToRoutesFalseWithConnectionsConstraintRule$outboundSchema:
  z.ZodType<
    SendToRoutesFalseWithConnectionsConstraintRule$Outbound,
    z.ZodTypeDef,
    SendToRoutesFalseWithConnectionsConstraintRule
  > = z.object({
    filter: z.string(),
    description: z.string().optional(),
  });

export function sendToRoutesFalseWithConnectionsConstraintRuleToJSON(
  sendToRoutesFalseWithConnectionsConstraintRule:
    SendToRoutesFalseWithConnectionsConstraintRule,
): string {
  return JSON.stringify(
    SendToRoutesFalseWithConnectionsConstraintRule$outboundSchema.parse(
      sendToRoutesFalseWithConnectionsConstraintRule,
    ),
  );
}

/** @internal */
export type InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    path: string;
    interval?: number | undefined;
    journals: Array<string>;
    rules?:
      | Array<SendToRoutesFalseWithConnectionsConstraintRule$Outbound>
      | undefined;
    currentBoot?: boolean | undefined;
    maxAgeDur?: string | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type:
      SendToRoutesFalseWithConnectionsConstraintInputJournalFilesType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    path: z.string(),
    interval: z.number().optional(),
    journals: z.array(z.string()),
    rules: z.array(
      z.lazy(() =>
        SendToRoutesFalseWithConnectionsConstraintRule$outboundSchema
      ),
    ).optional(),
    currentBoot: z.boolean().optional(),
    maxAgeDur: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputJournalFilesSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputJournalFilesSendToRoutesFalseWithConnectionsConstraint:
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputJournalFilesSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export const SendToRoutesTrueConstraintInputJournalFilesType$outboundSchema:
  z.ZodNativeEnum<typeof SendToRoutesTrueConstraintInputJournalFilesType> = z
    .nativeEnum(SendToRoutesTrueConstraintInputJournalFilesType);

/** @internal */
export type SendToRoutesTrueConstraintRule$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const SendToRoutesTrueConstraintRule$outboundSchema: z.ZodType<
  SendToRoutesTrueConstraintRule$Outbound,
  z.ZodTypeDef,
  SendToRoutesTrueConstraintRule
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

export function sendToRoutesTrueConstraintRuleToJSON(
  sendToRoutesTrueConstraintRule: SendToRoutesTrueConstraintRule,
): string {
  return JSON.stringify(
    SendToRoutesTrueConstraintRule$outboundSchema.parse(
      sendToRoutesTrueConstraintRule,
    ),
  );
}

/** @internal */
export type InputJournalFilesSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  path: string;
  interval?: number | undefined;
  journals: Array<string>;
  rules?: Array<SendToRoutesTrueConstraintRule$Outbound> | undefined;
  currentBoot?: boolean | undefined;
  maxAgeDur?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputJournalFilesSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputJournalFilesSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputJournalFilesSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: SendToRoutesTrueConstraintInputJournalFilesType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    path: z.string(),
    interval: z.number().optional(),
    journals: z.array(z.string()),
    rules: z.array(z.lazy(() => SendToRoutesTrueConstraintRule$outboundSchema))
      .optional(),
    currentBoot: z.boolean().optional(),
    maxAgeDur: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputJournalFilesSendToRoutesTrueConstraintToJSON(
  inputJournalFilesSendToRoutesTrueConstraint:
    InputJournalFilesSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputJournalFilesSendToRoutesTrueConstraint$outboundSchema.parse(
      inputJournalFilesSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputJournalFiles$Outbound =
  | InputJournalFilesSendToRoutesTrueConstraint$Outbound
  | InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputJournalFilesPqEnabledFalseConstraint$Outbound
  | InputJournalFilesPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputJournalFiles$outboundSchema: z.ZodType<
  InputJournalFiles$Outbound,
  z.ZodTypeDef,
  InputJournalFiles
> = z.union([
  z.lazy(() => InputJournalFilesSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputJournalFilesPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputJournalFilesPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputJournalFilesToJSON(
  inputJournalFiles: InputJournalFiles,
): string {
  return JSON.stringify(
    InputJournalFiles$outboundSchema.parse(inputJournalFiles),
  );
}

/** @internal */
export const InputRawUdpType$outboundSchema: z.ZodNativeEnum<
  typeof InputRawUdpType
> = z.nativeEnum(InputRawUdpType);

/** @internal */
export type InputRawUdpPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  singleMsgUdpPackets?: boolean | undefined;
  ingestRawBytes?: boolean | undefined;
  udpSocketRxBufSize?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputRawUdpPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputRawUdpPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputRawUdpPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputRawUdpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  host: z.string(),
  port: z.number(),
  maxBufferSize: z.number().optional(),
  ipWhitelistRegex: z.string().optional(),
  singleMsgUdpPackets: z.boolean().optional(),
  ingestRawBytes: z.boolean().optional(),
  udpSocketRxBufSize: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputRawUdpPqEnabledTrueWithPqConstraintToJSON(
  inputRawUdpPqEnabledTrueWithPqConstraint:
    InputRawUdpPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputRawUdpPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputRawUdpPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputRawUdpPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  singleMsgUdpPackets?: boolean | undefined;
  ingestRawBytes?: boolean | undefined;
  udpSocketRxBufSize?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputRawUdpPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputRawUdpPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputRawUdpPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputRawUdpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  maxBufferSize: z.number().optional(),
  ipWhitelistRegex: z.string().optional(),
  singleMsgUdpPackets: z.boolean().optional(),
  ingestRawBytes: z.boolean().optional(),
  udpSocketRxBufSize: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputRawUdpPqEnabledFalseConstraintToJSON(
  inputRawUdpPqEnabledFalseConstraint: InputRawUdpPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputRawUdpPqEnabledFalseConstraint$outboundSchema.parse(
      inputRawUdpPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputRawUdpSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  singleMsgUdpPackets?: boolean | undefined;
  ingestRawBytes?: boolean | undefined;
  udpSocketRxBufSize?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputRawUdpSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputRawUdpSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputRawUdpSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputRawUdpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    maxBufferSize: z.number().optional(),
    ipWhitelistRegex: z.string().optional(),
    singleMsgUdpPackets: z.boolean().optional(),
    ingestRawBytes: z.boolean().optional(),
    udpSocketRxBufSize: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputRawUdpSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputRawUdpSendToRoutesFalseWithConnectionsConstraint:
    InputRawUdpSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputRawUdpSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputRawUdpSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputRawUdpSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  singleMsgUdpPackets?: boolean | undefined;
  ingestRawBytes?: boolean | undefined;
  udpSocketRxBufSize?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputRawUdpSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputRawUdpSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputRawUdpSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputRawUdpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  maxBufferSize: z.number().optional(),
  ipWhitelistRegex: z.string().optional(),
  singleMsgUdpPackets: z.boolean().optional(),
  ingestRawBytes: z.boolean().optional(),
  udpSocketRxBufSize: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputRawUdpSendToRoutesTrueConstraintToJSON(
  inputRawUdpSendToRoutesTrueConstraint: InputRawUdpSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputRawUdpSendToRoutesTrueConstraint$outboundSchema.parse(
      inputRawUdpSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputRawUdp$Outbound =
  | InputRawUdpSendToRoutesTrueConstraint$Outbound
  | InputRawUdpSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputRawUdpPqEnabledFalseConstraint$Outbound
  | InputRawUdpPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputRawUdp$outboundSchema: z.ZodType<
  InputRawUdp$Outbound,
  z.ZodTypeDef,
  InputRawUdp
> = z.union([
  z.lazy(() => InputRawUdpSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputRawUdpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputRawUdpPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputRawUdpPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputRawUdpToJSON(inputRawUdp: InputRawUdp): string {
  return JSON.stringify(InputRawUdp$outboundSchema.parse(inputRawUdp));
}

/** @internal */
export const InputWinEventLogsType$outboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType
> = z.nativeEnum(InputWinEventLogsType);

/** @internal */
export const ReadMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ReadMode
> = openEnums.outboundSchema(ReadMode);

/** @internal */
export const EventFormat$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  EventFormat
> = openEnums.outboundSchema(EventFormat);

/** @internal */
export type InputWinEventLogsPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  logNames: Array<string>;
  readMode?: string | undefined;
  eventFormat?: string | undefined;
  disableNativeModule?: boolean | undefined;
  interval?: number | undefined;
  batchSize?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  disableJsonRendering?: boolean | undefined;
  disableXmlRendering?: boolean | undefined;
};

/** @internal */
export const InputWinEventLogsPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputWinEventLogsPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputWinEventLogsPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputWinEventLogsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    logNames: z.array(z.string()),
    readMode: ReadMode$outboundSchema.optional(),
    eventFormat: EventFormat$outboundSchema.optional(),
    disableNativeModule: z.boolean().optional(),
    interval: z.number().optional(),
    batchSize: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxEventBytes: z.number().optional(),
    description: z.string().optional(),
    disableJsonRendering: z.boolean().optional(),
    disableXmlRendering: z.boolean().optional(),
  });

export function inputWinEventLogsPqEnabledTrueWithPqConstraintToJSON(
  inputWinEventLogsPqEnabledTrueWithPqConstraint:
    InputWinEventLogsPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputWinEventLogsPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputWinEventLogsPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputWinEventLogsPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  logNames: Array<string>;
  readMode?: string | undefined;
  eventFormat?: string | undefined;
  disableNativeModule?: boolean | undefined;
  interval?: number | undefined;
  batchSize?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  disableJsonRendering?: boolean | undefined;
  disableXmlRendering?: boolean | undefined;
};

/** @internal */
export const InputWinEventLogsPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputWinEventLogsPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputWinEventLogsPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputWinEventLogsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    logNames: z.array(z.string()),
    readMode: ReadMode$outboundSchema.optional(),
    eventFormat: EventFormat$outboundSchema.optional(),
    disableNativeModule: z.boolean().optional(),
    interval: z.number().optional(),
    batchSize: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxEventBytes: z.number().optional(),
    description: z.string().optional(),
    disableJsonRendering: z.boolean().optional(),
    disableXmlRendering: z.boolean().optional(),
  });

export function inputWinEventLogsPqEnabledFalseConstraintToJSON(
  inputWinEventLogsPqEnabledFalseConstraint:
    InputWinEventLogsPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputWinEventLogsPqEnabledFalseConstraint$outboundSchema.parse(
      inputWinEventLogsPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    logNames: Array<string>;
    readMode?: string | undefined;
    eventFormat?: string | undefined;
    disableNativeModule?: boolean | undefined;
    interval?: number | undefined;
    batchSize?: number | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    maxEventBytes?: number | undefined;
    description?: string | undefined;
    disableJsonRendering?: boolean | undefined;
    disableXmlRendering?: boolean | undefined;
  };

/** @internal */
export const InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputWinEventLogsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    logNames: z.array(z.string()),
    readMode: ReadMode$outboundSchema.optional(),
    eventFormat: EventFormat$outboundSchema.optional(),
    disableNativeModule: z.boolean().optional(),
    interval: z.number().optional(),
    batchSize: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxEventBytes: z.number().optional(),
    description: z.string().optional(),
    disableJsonRendering: z.boolean().optional(),
    disableXmlRendering: z.boolean().optional(),
  });

export function inputWinEventLogsSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputWinEventLogsSendToRoutesFalseWithConnectionsConstraint:
    InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputWinEventLogsSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputWinEventLogsSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  logNames: Array<string>;
  readMode?: string | undefined;
  eventFormat?: string | undefined;
  disableNativeModule?: boolean | undefined;
  interval?: number | undefined;
  batchSize?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  disableJsonRendering?: boolean | undefined;
  disableXmlRendering?: boolean | undefined;
};

/** @internal */
export const InputWinEventLogsSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputWinEventLogsSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputWinEventLogsSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputWinEventLogsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    logNames: z.array(z.string()),
    readMode: ReadMode$outboundSchema.optional(),
    eventFormat: EventFormat$outboundSchema.optional(),
    disableNativeModule: z.boolean().optional(),
    interval: z.number().optional(),
    batchSize: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxEventBytes: z.number().optional(),
    description: z.string().optional(),
    disableJsonRendering: z.boolean().optional(),
    disableXmlRendering: z.boolean().optional(),
  });

export function inputWinEventLogsSendToRoutesTrueConstraintToJSON(
  inputWinEventLogsSendToRoutesTrueConstraint:
    InputWinEventLogsSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputWinEventLogsSendToRoutesTrueConstraint$outboundSchema.parse(
      inputWinEventLogsSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputWinEventLogs$Outbound =
  | InputWinEventLogsSendToRoutesTrueConstraint$Outbound
  | InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputWinEventLogsPqEnabledFalseConstraint$Outbound
  | InputWinEventLogsPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputWinEventLogs$outboundSchema: z.ZodType<
  InputWinEventLogs$Outbound,
  z.ZodTypeDef,
  InputWinEventLogs
> = z.union([
  z.lazy(() => InputWinEventLogsSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputWinEventLogsPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputWinEventLogsPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputWinEventLogsToJSON(
  inputWinEventLogs: InputWinEventLogs,
): string {
  return JSON.stringify(
    InputWinEventLogs$outboundSchema.parse(inputWinEventLogs),
  );
}

/** @internal */
export const InputWefType$outboundSchema: z.ZodNativeEnum<typeof InputWefType> =
  z.nativeEnum(InputWefType);

/** @internal */
export const InputWefAuthenticationMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWefAuthenticationMethod
> = openEnums.outboundSchema(InputWefAuthenticationMethod);

/** @internal */
export type MTLSSettings$Outbound = {
  disabled?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  requestCert?: boolean | undefined;
  certificateName?: string | undefined;
  privKeyPath: string;
  passphrase?: string | undefined;
  certPath: string;
  caPath: string;
  commonNameRegex?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
  ocspCheck?: boolean | undefined;
  keytab?: any | undefined;
  principal?: any | undefined;
  ocspCheckFailClose?: boolean | undefined;
};

/** @internal */
export const MTLSSettings$outboundSchema: z.ZodType<
  MTLSSettings$Outbound,
  z.ZodTypeDef,
  MTLSSettings
> = z.object({
  disabled: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  requestCert: z.boolean().optional(),
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
  caPath: z.string(),
  commonNameRegex: z.string().optional(),
  minVersion: models
    .MinimumTlsVersionOptionsKafkaSchemaRegistryTls$outboundSchema.optional(),
  maxVersion: models
    .MaximumTlsVersionOptionsKafkaSchemaRegistryTls$outboundSchema.optional(),
  ocspCheck: z.boolean().optional(),
  keytab: z.any().optional(),
  principal: z.any().optional(),
  ocspCheckFailClose: z.boolean().optional(),
});

export function mTLSSettingsToJSON(mtlsSettings: MTLSSettings): string {
  return JSON.stringify(MTLSSettings$outboundSchema.parse(mtlsSettings));
}

/** @internal */
export const CreateInputFormat$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CreateInputFormat
> = openEnums.outboundSchema(CreateInputFormat);

/** @internal */
export const QueryBuilderMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  QueryBuilderMode
> = openEnums.outboundSchema(QueryBuilderMode);

/** @internal */
export type Query$Outbound = {
  path: string;
  queryExpression: string;
};

/** @internal */
export const Query$outboundSchema: z.ZodType<
  Query$Outbound,
  z.ZodTypeDef,
  Query
> = z.object({
  path: z.string(),
  queryExpression: z.string(),
});

export function queryToJSON(query: Query): string {
  return JSON.stringify(Query$outboundSchema.parse(query));
}

/** @internal */
export type Subscription$Outbound = {
  subscriptionName: string;
  version?: string | undefined;
  contentFormat: string;
  heartbeatInterval: number;
  batchTimeout: number;
  readExistingEvents?: boolean | undefined;
  sendBookmarks?: boolean | undefined;
  compress?: boolean | undefined;
  targets: Array<string>;
  locale?: string | undefined;
  querySelector?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  queries?: Array<Query$Outbound> | undefined;
  xmlQuery?: string | undefined;
};

/** @internal */
export const Subscription$outboundSchema: z.ZodType<
  Subscription$Outbound,
  z.ZodTypeDef,
  Subscription
> = z.object({
  subscriptionName: z.string(),
  version: z.string().optional(),
  contentFormat: CreateInputFormat$outboundSchema,
  heartbeatInterval: z.number(),
  batchTimeout: z.number(),
  readExistingEvents: z.boolean().optional(),
  sendBookmarks: z.boolean().optional(),
  compress: z.boolean().optional(),
  targets: z.array(z.string()),
  locale: z.string().optional(),
  querySelector: QueryBuilderMode$outboundSchema.optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  queries: z.array(z.lazy(() => Query$outboundSchema)).optional(),
  xmlQuery: z.string().optional(),
});

export function subscriptionToJSON(subscription: Subscription): string {
  return JSON.stringify(Subscription$outboundSchema.parse(subscription));
}

/** @internal */
export type InputWefPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  authMethod?: string | undefined;
  tls?: MTLSSettings$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  socketTimeout?: number | undefined;
  caFingerprint?: string | undefined;
  keytab?: string | undefined;
  principal?: string | undefined;
  allowMachineIdMismatch?: boolean | undefined;
  subscriptions: Array<Subscription$Outbound>;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  logFingerprintMismatch?: boolean | undefined;
};

/** @internal */
export const InputWefPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputWefPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputWefPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputWefType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  host: z.string(),
  port: z.number(),
  authMethod: InputWefAuthenticationMethod$outboundSchema.optional(),
  tls: z.lazy(() => MTLSSettings$outboundSchema).optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  socketTimeout: z.number().optional(),
  caFingerprint: z.string().optional(),
  keytab: z.string().optional(),
  principal: z.string().optional(),
  allowMachineIdMismatch: z.boolean().optional(),
  subscriptions: z.array(z.lazy(() => Subscription$outboundSchema)),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
  logFingerprintMismatch: z.boolean().optional(),
});

export function inputWefPqEnabledTrueWithPqConstraintToJSON(
  inputWefPqEnabledTrueWithPqConstraint: InputWefPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputWefPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputWefPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputWefPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authMethod?: string | undefined;
  tls?: MTLSSettings$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  socketTimeout?: number | undefined;
  caFingerprint?: string | undefined;
  keytab?: string | undefined;
  principal?: string | undefined;
  allowMachineIdMismatch?: boolean | undefined;
  subscriptions: Array<Subscription$Outbound>;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  logFingerprintMismatch?: boolean | undefined;
};

/** @internal */
export const InputWefPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputWefPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputWefPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputWefType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authMethod: InputWefAuthenticationMethod$outboundSchema.optional(),
  tls: z.lazy(() => MTLSSettings$outboundSchema).optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  socketTimeout: z.number().optional(),
  caFingerprint: z.string().optional(),
  keytab: z.string().optional(),
  principal: z.string().optional(),
  allowMachineIdMismatch: z.boolean().optional(),
  subscriptions: z.array(z.lazy(() => Subscription$outboundSchema)),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
  logFingerprintMismatch: z.boolean().optional(),
});

export function inputWefPqEnabledFalseConstraintToJSON(
  inputWefPqEnabledFalseConstraint: InputWefPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputWefPqEnabledFalseConstraint$outboundSchema.parse(
      inputWefPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputWefSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authMethod?: string | undefined;
  tls?: MTLSSettings$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  socketTimeout?: number | undefined;
  caFingerprint?: string | undefined;
  keytab?: string | undefined;
  principal?: string | undefined;
  allowMachineIdMismatch?: boolean | undefined;
  subscriptions: Array<Subscription$Outbound>;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  logFingerprintMismatch?: boolean | undefined;
};

/** @internal */
export const InputWefSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputWefSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputWefSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputWefType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authMethod: InputWefAuthenticationMethod$outboundSchema.optional(),
    tls: z.lazy(() => MTLSSettings$outboundSchema).optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    socketTimeout: z.number().optional(),
    caFingerprint: z.string().optional(),
    keytab: z.string().optional(),
    principal: z.string().optional(),
    allowMachineIdMismatch: z.boolean().optional(),
    subscriptions: z.array(z.lazy(() => Subscription$outboundSchema)),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    logFingerprintMismatch: z.boolean().optional(),
  });

export function inputWefSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputWefSendToRoutesFalseWithConnectionsConstraint:
    InputWefSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputWefSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputWefSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputWefSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authMethod?: string | undefined;
  tls?: MTLSSettings$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  socketTimeout?: number | undefined;
  caFingerprint?: string | undefined;
  keytab?: string | undefined;
  principal?: string | undefined;
  allowMachineIdMismatch?: boolean | undefined;
  subscriptions: Array<Subscription$Outbound>;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  logFingerprintMismatch?: boolean | undefined;
};

/** @internal */
export const InputWefSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputWefSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputWefSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputWefType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authMethod: InputWefAuthenticationMethod$outboundSchema.optional(),
  tls: z.lazy(() => MTLSSettings$outboundSchema).optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  socketTimeout: z.number().optional(),
  caFingerprint: z.string().optional(),
  keytab: z.string().optional(),
  principal: z.string().optional(),
  allowMachineIdMismatch: z.boolean().optional(),
  subscriptions: z.array(z.lazy(() => Subscription$outboundSchema)),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
  logFingerprintMismatch: z.boolean().optional(),
});

export function inputWefSendToRoutesTrueConstraintToJSON(
  inputWefSendToRoutesTrueConstraint: InputWefSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputWefSendToRoutesTrueConstraint$outboundSchema.parse(
      inputWefSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputWef$Outbound =
  | InputWefSendToRoutesTrueConstraint$Outbound
  | InputWefSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputWefPqEnabledFalseConstraint$Outbound
  | InputWefPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputWef$outboundSchema: z.ZodType<
  InputWef$Outbound,
  z.ZodTypeDef,
  InputWef
> = z.union([
  z.lazy(() => InputWefSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputWefSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputWefPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputWefPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputWefToJSON(inputWef: InputWef): string {
  return JSON.stringify(InputWef$outboundSchema.parse(inputWef));
}

/** @internal */
export const InputAppscopeType$outboundSchema: z.ZodNativeEnum<
  typeof InputAppscopeType
> = z.nativeEnum(InputAppscopeType);

/** @internal */
export type Allow$Outbound = {
  procname: string;
  arg?: string | undefined;
  config: string;
};

/** @internal */
export const Allow$outboundSchema: z.ZodType<
  Allow$Outbound,
  z.ZodTypeDef,
  Allow
> = z.object({
  procname: z.string(),
  arg: z.string().optional(),
  config: z.string(),
});

export function allowToJSON(allow: Allow): string {
  return JSON.stringify(Allow$outboundSchema.parse(allow));
}

/** @internal */
export type InputAppscopeFilter$Outbound = {
  allow?: Array<Allow$Outbound> | undefined;
  transportURL?: string | undefined;
};

/** @internal */
export const InputAppscopeFilter$outboundSchema: z.ZodType<
  InputAppscopeFilter$Outbound,
  z.ZodTypeDef,
  InputAppscopeFilter
> = z.object({
  allow: z.array(z.lazy(() => Allow$outboundSchema)).optional(),
  transportURL: z.string().optional(),
});

export function inputAppscopeFilterToJSON(
  inputAppscopeFilter: InputAppscopeFilter,
): string {
  return JSON.stringify(
    InputAppscopeFilter$outboundSchema.parse(inputAppscopeFilter),
  );
}

/** @internal */
export type InputAppscopePersistence$Outbound = {
  enable?: boolean | undefined;
  timeWindow?: string | undefined;
  maxDataSize?: string | undefined;
  maxDataTime?: string | undefined;
  compress?: string | undefined;
  destPath?: string | undefined;
};

/** @internal */
export const InputAppscopePersistence$outboundSchema: z.ZodType<
  InputAppscopePersistence$Outbound,
  z.ZodTypeDef,
  InputAppscopePersistence
> = z.object({
  enable: z.boolean().optional(),
  timeWindow: z.string().optional(),
  maxDataSize: z.string().optional(),
  maxDataTime: z.string().optional(),
  compress: models.DataCompressionFormatOptionsPersistence$outboundSchema
    .optional(),
  destPath: z.string().optional(),
});

export function inputAppscopePersistenceToJSON(
  inputAppscopePersistence: InputAppscopePersistence,
): string {
  return JSON.stringify(
    InputAppscopePersistence$outboundSchema.parse(inputAppscopePersistence),
  );
}

/** @internal */
export type InputAppscopePqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter$Outbound | undefined;
  persistence?: InputAppscopePersistence$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  unixSocketPath?: string | undefined;
  unixSocketPerms?: string | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputAppscopePqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputAppscopePqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputAppscopePqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputAppscopeType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    ipWhitelistRegex: z.string().optional(),
    maxActiveCxn: z.number().optional(),
    socketIdleTimeout: z.number().optional(),
    socketEndingMaxWait: z.number().optional(),
    socketMaxLifespan: z.number().optional(),
    enableProxyHeader: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    enableUnixPath: z.boolean().optional(),
    filter: z.lazy(() => InputAppscopeFilter$outboundSchema).optional(),
    persistence: z.lazy(() => InputAppscopePersistence$outboundSchema)
      .optional(),
    authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
      .optional(),
    description: z.string().optional(),
    host: z.string().optional(),
    port: z.number().optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    unixSocketPath: z.string().optional(),
    unixSocketPerms: z.string().optional(),
    authToken: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputAppscopePqEnabledTrueWithPqConstraintToJSON(
  inputAppscopePqEnabledTrueWithPqConstraint:
    InputAppscopePqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputAppscopePqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputAppscopePqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputAppscopePqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter$Outbound | undefined;
  persistence?: InputAppscopePersistence$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  unixSocketPath?: string | undefined;
  unixSocketPerms?: string | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputAppscopePqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputAppscopePqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputAppscopePqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputAppscopeType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  enableUnixPath: z.boolean().optional(),
  filter: z.lazy(() => InputAppscopeFilter$outboundSchema).optional(),
  persistence: z.lazy(() => InputAppscopePersistence$outboundSchema).optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  unixSocketPath: z.string().optional(),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().optional(),
  textSecret: z.string().optional(),
});

export function inputAppscopePqEnabledFalseConstraintToJSON(
  inputAppscopePqEnabledFalseConstraint: InputAppscopePqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputAppscopePqEnabledFalseConstraint$outboundSchema.parse(
      inputAppscopePqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputAppscopeSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter$Outbound | undefined;
  persistence?: InputAppscopePersistence$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  unixSocketPath?: string | undefined;
  unixSocketPerms?: string | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputAppscopeSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputAppscopeSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputAppscopeSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputAppscopeType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    ipWhitelistRegex: z.string().optional(),
    maxActiveCxn: z.number().optional(),
    socketIdleTimeout: z.number().optional(),
    socketEndingMaxWait: z.number().optional(),
    socketMaxLifespan: z.number().optional(),
    enableProxyHeader: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    enableUnixPath: z.boolean().optional(),
    filter: z.lazy(() => InputAppscopeFilter$outboundSchema).optional(),
    persistence: z.lazy(() => InputAppscopePersistence$outboundSchema)
      .optional(),
    authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
      .optional(),
    description: z.string().optional(),
    host: z.string().optional(),
    port: z.number().optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    unixSocketPath: z.string().optional(),
    unixSocketPerms: z.string().optional(),
    authToken: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputAppscopeSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputAppscopeSendToRoutesFalseWithConnectionsConstraint:
    InputAppscopeSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputAppscopeSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputAppscopeSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputAppscopeSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableUnixPath?: boolean | undefined;
  filter?: InputAppscopeFilter$Outbound | undefined;
  persistence?: InputAppscopePersistence$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  host?: string | undefined;
  port?: number | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  unixSocketPath?: string | undefined;
  unixSocketPerms?: string | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputAppscopeSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputAppscopeSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputAppscopeSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputAppscopeType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  enableUnixPath: z.boolean().optional(),
  filter: z.lazy(() => InputAppscopeFilter$outboundSchema).optional(),
  persistence: z.lazy(() => InputAppscopePersistence$outboundSchema).optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  description: z.string().optional(),
  host: z.string().optional(),
  port: z.number().optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  unixSocketPath: z.string().optional(),
  unixSocketPerms: z.string().optional(),
  authToken: z.string().optional(),
  textSecret: z.string().optional(),
});

export function inputAppscopeSendToRoutesTrueConstraintToJSON(
  inputAppscopeSendToRoutesTrueConstraint:
    InputAppscopeSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputAppscopeSendToRoutesTrueConstraint$outboundSchema.parse(
      inputAppscopeSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputAppscope$Outbound =
  | InputAppscopeSendToRoutesTrueConstraint$Outbound
  | InputAppscopeSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputAppscopePqEnabledFalseConstraint$Outbound
  | InputAppscopePqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputAppscope$outboundSchema: z.ZodType<
  InputAppscope$Outbound,
  z.ZodTypeDef,
  InputAppscope
> = z.union([
  z.lazy(() => InputAppscopeSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputAppscopeSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputAppscopePqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputAppscopePqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputAppscopeToJSON(inputAppscope: InputAppscope): string {
  return JSON.stringify(InputAppscope$outboundSchema.parse(inputAppscope));
}

/** @internal */
export const InputTcpType$outboundSchema: z.ZodNativeEnum<typeof InputTcpType> =
  z.nativeEnum(InputTcpType);

/** @internal */
export type InputTcpPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableHeader?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  description?: string | undefined;
  authToken?: string | undefined;
  authType?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcpPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputTcpPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputTcpPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputTcpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  enableHeader: z.boolean().optional(),
  preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
    .optional(),
  description: z.string().optional(),
  authToken: z.string().optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  textSecret: z.string().optional(),
});

export function inputTcpPqEnabledTrueWithPqConstraintToJSON(
  inputTcpPqEnabledTrueWithPqConstraint: InputTcpPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputTcpPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputTcpPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputTcpPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableHeader?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  description?: string | undefined;
  authToken?: string | undefined;
  authType?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcpPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputTcpPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputTcpPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputTcpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  enableHeader: z.boolean().optional(),
  preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
    .optional(),
  description: z.string().optional(),
  authToken: z.string().optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  textSecret: z.string().optional(),
});

export function inputTcpPqEnabledFalseConstraintToJSON(
  inputTcpPqEnabledFalseConstraint: InputTcpPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputTcpPqEnabledFalseConstraint$outboundSchema.parse(
      inputTcpPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputTcpSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableHeader?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  description?: string | undefined;
  authToken?: string | undefined;
  authType?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcpSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputTcpSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputTcpSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputTcpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    ipWhitelistRegex: z.string().optional(),
    maxActiveCxn: z.number().optional(),
    socketIdleTimeout: z.number().optional(),
    socketEndingMaxWait: z.number().optional(),
    socketMaxLifespan: z.number().optional(),
    enableProxyHeader: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    enableHeader: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    description: z.string().optional(),
    authToken: z.string().optional(),
    authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
      .optional(),
    textSecret: z.string().optional(),
  });

export function inputTcpSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputTcpSendToRoutesFalseWithConnectionsConstraint:
    InputTcpSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputTcpSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputTcpSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputTcpSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableHeader?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  description?: string | undefined;
  authToken?: string | undefined;
  authType?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcpSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputTcpSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputTcpSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputTcpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  enableHeader: z.boolean().optional(),
  preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
    .optional(),
  description: z.string().optional(),
  authToken: z.string().optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  textSecret: z.string().optional(),
});

export function inputTcpSendToRoutesTrueConstraintToJSON(
  inputTcpSendToRoutesTrueConstraint: InputTcpSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputTcpSendToRoutesTrueConstraint$outboundSchema.parse(
      inputTcpSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputTcp$Outbound =
  | InputTcpSendToRoutesTrueConstraint$Outbound
  | InputTcpSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputTcpPqEnabledFalseConstraint$Outbound
  | InputTcpPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputTcp$outboundSchema: z.ZodType<
  InputTcp$Outbound,
  z.ZodTypeDef,
  InputTcp
> = z.union([
  z.lazy(() => InputTcpSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputTcpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputTcpPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputTcpPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputTcpToJSON(inputTcp: InputTcp): string {
  return JSON.stringify(InputTcp$outboundSchema.parse(inputTcp));
}

/** @internal */
export const PqEnabledTrueWithPqConstraintInputFileType$outboundSchema:
  z.ZodNativeEnum<typeof PqEnabledTrueWithPqConstraintInputFileType> = z
    .nativeEnum(PqEnabledTrueWithPqConstraintInputFileType);

/** @internal */
export const PqEnabledTrueWithPqConstraintMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PqEnabledTrueWithPqConstraintMode
> = openEnums.outboundSchema(PqEnabledTrueWithPqConstraintMode);

/** @internal */
export type InputFilePqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  mode?: string | undefined;
  interval?: number | undefined;
  filenames?: Array<string> | undefined;
  filterArchivedFiles?: boolean | undefined;
  tailOnly?: boolean | undefined;
  idleTimeout?: number | undefined;
  minAgeDur?: string | undefined;
  maxAgeDur?: string | undefined;
  checkFileModTime?: boolean | undefined;
  forceText?: boolean | undefined;
  hashLen?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  path?: string | undefined;
  depth?: number | undefined;
  suppressMissingPathErrors?: boolean | undefined;
  deleteFiles?: boolean | undefined;
  includeUnidentifiableBinary?: boolean | undefined;
};

/** @internal */
export const InputFilePqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputFilePqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputFilePqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: PqEnabledTrueWithPqConstraintInputFileType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  mode: PqEnabledTrueWithPqConstraintMode$outboundSchema.optional(),
  interval: z.number().optional(),
  filenames: z.array(z.string()).optional(),
  filterArchivedFiles: z.boolean().optional(),
  tailOnly: z.boolean().optional(),
  idleTimeout: z.number().optional(),
  minAgeDur: z.string().optional(),
  maxAgeDur: z.string().optional(),
  checkFileModTime: z.boolean().optional(),
  forceText: z.boolean().optional(),
  hashLen: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  description: z.string().optional(),
  path: z.string().optional(),
  depth: z.number().optional(),
  suppressMissingPathErrors: z.boolean().optional(),
  deleteFiles: z.boolean().optional(),
  includeUnidentifiableBinary: z.boolean().optional(),
});

export function inputFilePqEnabledTrueWithPqConstraintToJSON(
  inputFilePqEnabledTrueWithPqConstraint:
    InputFilePqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputFilePqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputFilePqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export const PqEnabledFalseConstraintInputFileType$outboundSchema:
  z.ZodNativeEnum<typeof PqEnabledFalseConstraintInputFileType> = z.nativeEnum(
    PqEnabledFalseConstraintInputFileType,
  );

/** @internal */
export const PqEnabledFalseConstraintMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PqEnabledFalseConstraintMode
> = openEnums.outboundSchema(PqEnabledFalseConstraintMode);

/** @internal */
export type InputFilePqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  mode?: string | undefined;
  interval?: number | undefined;
  filenames?: Array<string> | undefined;
  filterArchivedFiles?: boolean | undefined;
  tailOnly?: boolean | undefined;
  idleTimeout?: number | undefined;
  minAgeDur?: string | undefined;
  maxAgeDur?: string | undefined;
  checkFileModTime?: boolean | undefined;
  forceText?: boolean | undefined;
  hashLen?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  path?: string | undefined;
  depth?: number | undefined;
  suppressMissingPathErrors?: boolean | undefined;
  deleteFiles?: boolean | undefined;
  includeUnidentifiableBinary?: boolean | undefined;
};

/** @internal */
export const InputFilePqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputFilePqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputFilePqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: PqEnabledFalseConstraintInputFileType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  mode: PqEnabledFalseConstraintMode$outboundSchema.optional(),
  interval: z.number().optional(),
  filenames: z.array(z.string()).optional(),
  filterArchivedFiles: z.boolean().optional(),
  tailOnly: z.boolean().optional(),
  idleTimeout: z.number().optional(),
  minAgeDur: z.string().optional(),
  maxAgeDur: z.string().optional(),
  checkFileModTime: z.boolean().optional(),
  forceText: z.boolean().optional(),
  hashLen: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  description: z.string().optional(),
  path: z.string().optional(),
  depth: z.number().optional(),
  suppressMissingPathErrors: z.boolean().optional(),
  deleteFiles: z.boolean().optional(),
  includeUnidentifiableBinary: z.boolean().optional(),
});

export function inputFilePqEnabledFalseConstraintToJSON(
  inputFilePqEnabledFalseConstraint: InputFilePqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputFilePqEnabledFalseConstraint$outboundSchema.parse(
      inputFilePqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export const SendToRoutesFalseWithConnectionsConstraintInputFileType$outboundSchema:
  z.ZodNativeEnum<
    typeof SendToRoutesFalseWithConnectionsConstraintInputFileType
  > = z.nativeEnum(SendToRoutesFalseWithConnectionsConstraintInputFileType);

/** @internal */
export const SendToRoutesFalseWithConnectionsConstraintMode$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    SendToRoutesFalseWithConnectionsConstraintMode
  > = openEnums.outboundSchema(SendToRoutesFalseWithConnectionsConstraintMode);

/** @internal */
export type InputFileSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  mode?: string | undefined;
  interval?: number | undefined;
  filenames?: Array<string> | undefined;
  filterArchivedFiles?: boolean | undefined;
  tailOnly?: boolean | undefined;
  idleTimeout?: number | undefined;
  minAgeDur?: string | undefined;
  maxAgeDur?: string | undefined;
  checkFileModTime?: boolean | undefined;
  forceText?: boolean | undefined;
  hashLen?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  path?: string | undefined;
  depth?: number | undefined;
  suppressMissingPathErrors?: boolean | undefined;
  deleteFiles?: boolean | undefined;
  includeUnidentifiableBinary?: boolean | undefined;
};

/** @internal */
export const InputFileSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputFileSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputFileSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type:
      SendToRoutesFalseWithConnectionsConstraintInputFileType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    mode: SendToRoutesFalseWithConnectionsConstraintMode$outboundSchema
      .optional(),
    interval: z.number().optional(),
    filenames: z.array(z.string()).optional(),
    filterArchivedFiles: z.boolean().optional(),
    tailOnly: z.boolean().optional(),
    idleTimeout: z.number().optional(),
    minAgeDur: z.string().optional(),
    maxAgeDur: z.string().optional(),
    checkFileModTime: z.boolean().optional(),
    forceText: z.boolean().optional(),
    hashLen: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    description: z.string().optional(),
    path: z.string().optional(),
    depth: z.number().optional(),
    suppressMissingPathErrors: z.boolean().optional(),
    deleteFiles: z.boolean().optional(),
    includeUnidentifiableBinary: z.boolean().optional(),
  });

export function inputFileSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputFileSendToRoutesFalseWithConnectionsConstraint:
    InputFileSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputFileSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputFileSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export const SendToRoutesTrueConstraintInputFileType$outboundSchema:
  z.ZodNativeEnum<typeof SendToRoutesTrueConstraintInputFileType> = z
    .nativeEnum(SendToRoutesTrueConstraintInputFileType);

/** @internal */
export const SendToRoutesTrueConstraintMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  SendToRoutesTrueConstraintMode
> = openEnums.outboundSchema(SendToRoutesTrueConstraintMode);

/** @internal */
export type InputFileSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  mode?: string | undefined;
  interval?: number | undefined;
  filenames?: Array<string> | undefined;
  filterArchivedFiles?: boolean | undefined;
  tailOnly?: boolean | undefined;
  idleTimeout?: number | undefined;
  minAgeDur?: string | undefined;
  maxAgeDur?: string | undefined;
  checkFileModTime?: boolean | undefined;
  forceText?: boolean | undefined;
  hashLen?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  description?: string | undefined;
  path?: string | undefined;
  depth?: number | undefined;
  suppressMissingPathErrors?: boolean | undefined;
  deleteFiles?: boolean | undefined;
  includeUnidentifiableBinary?: boolean | undefined;
};

/** @internal */
export const InputFileSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputFileSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputFileSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: SendToRoutesTrueConstraintInputFileType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  mode: SendToRoutesTrueConstraintMode$outboundSchema.optional(),
  interval: z.number().optional(),
  filenames: z.array(z.string()).optional(),
  filterArchivedFiles: z.boolean().optional(),
  tailOnly: z.boolean().optional(),
  idleTimeout: z.number().optional(),
  minAgeDur: z.string().optional(),
  maxAgeDur: z.string().optional(),
  checkFileModTime: z.boolean().optional(),
  forceText: z.boolean().optional(),
  hashLen: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  description: z.string().optional(),
  path: z.string().optional(),
  depth: z.number().optional(),
  suppressMissingPathErrors: z.boolean().optional(),
  deleteFiles: z.boolean().optional(),
  includeUnidentifiableBinary: z.boolean().optional(),
});

export function inputFileSendToRoutesTrueConstraintToJSON(
  inputFileSendToRoutesTrueConstraint: InputFileSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputFileSendToRoutesTrueConstraint$outboundSchema.parse(
      inputFileSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputFile$Outbound =
  | InputFileSendToRoutesTrueConstraint$Outbound
  | InputFileSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputFilePqEnabledFalseConstraint$Outbound
  | InputFilePqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputFile$outboundSchema: z.ZodType<
  InputFile$Outbound,
  z.ZodTypeDef,
  InputFile
> = z.union([
  z.lazy(() => InputFileSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputFileSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputFilePqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputFilePqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputFileToJSON(inputFile: InputFile): string {
  return JSON.stringify(InputFile$outboundSchema.parse(inputFile));
}

/** @internal */
export const InputSyslogType2$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogType2
> = z.nativeEnum(InputSyslogType2);

/** @internal */
export type InputSyslogSyslog2$Outbound = {
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort: number;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  timestampTimezone?: string | undefined;
  singleMsgUdpPackets?: boolean | undefined;
  enableProxyHeader?: boolean | undefined;
  keepFieldsList?: Array<string> | undefined;
  octetCounting?: boolean | undefined;
  inferFraming?: boolean | undefined;
  strictlyInferOctetCounting?: boolean | undefined;
  allowNonStandardAppName?: boolean | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

/** @internal */
export const InputSyslogSyslog2$outboundSchema: z.ZodType<
  InputSyslogSyslog2$Outbound,
  z.ZodTypeDef,
  InputSyslogSyslog2
> = z.object({
  id: z.string(),
  type: InputSyslogType2$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  udpPort: z.number().optional(),
  tcpPort: z.number(),
  maxBufferSize: z.number().optional(),
  ipWhitelistRegex: z.string().optional(),
  timestampTimezone: z.string().optional(),
  singleMsgUdpPackets: z.boolean().optional(),
  enableProxyHeader: z.boolean().optional(),
  keepFieldsList: z.array(z.string()).optional(),
  octetCounting: z.boolean().optional(),
  inferFraming: z.boolean().optional(),
  strictlyInferOctetCounting: z.boolean().optional(),
  allowNonStandardAppName: z.boolean().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  enableLoadBalancing: z.boolean().optional(),
  description: z.string().optional(),
  enableEnhancedProxyHeaderParsing: z.boolean().optional(),
});

export function inputSyslogSyslog2ToJSON(
  inputSyslogSyslog2: InputSyslogSyslog2,
): string {
  return JSON.stringify(
    InputSyslogSyslog2$outboundSchema.parse(inputSyslogSyslog2),
  );
}

/** @internal */
export const InputSyslogType1$outboundSchema: z.ZodNativeEnum<
  typeof InputSyslogType1
> = z.nativeEnum(InputSyslogType1);

/** @internal */
export type InputSyslogSyslog1$Outbound = {
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  udpPort: number;
  tcpPort?: number | undefined;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  timestampTimezone?: string | undefined;
  singleMsgUdpPackets?: boolean | undefined;
  enableProxyHeader?: boolean | undefined;
  keepFieldsList?: Array<string> | undefined;
  octetCounting?: boolean | undefined;
  inferFraming?: boolean | undefined;
  strictlyInferOctetCounting?: boolean | undefined;
  allowNonStandardAppName?: boolean | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
  enableEnhancedProxyHeaderParsing?: boolean | undefined;
};

/** @internal */
export const InputSyslogSyslog1$outboundSchema: z.ZodType<
  InputSyslogSyslog1$Outbound,
  z.ZodTypeDef,
  InputSyslogSyslog1
> = z.object({
  id: z.string(),
  type: InputSyslogType1$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  udpPort: z.number(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().optional(),
  ipWhitelistRegex: z.string().optional(),
  timestampTimezone: z.string().optional(),
  singleMsgUdpPackets: z.boolean().optional(),
  enableProxyHeader: z.boolean().optional(),
  keepFieldsList: z.array(z.string()).optional(),
  octetCounting: z.boolean().optional(),
  inferFraming: z.boolean().optional(),
  strictlyInferOctetCounting: z.boolean().optional(),
  allowNonStandardAppName: z.boolean().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  enableLoadBalancing: z.boolean().optional(),
  description: z.string().optional(),
  enableEnhancedProxyHeaderParsing: z.boolean().optional(),
});

export function inputSyslogSyslog1ToJSON(
  inputSyslogSyslog1: InputSyslogSyslog1,
): string {
  return JSON.stringify(
    InputSyslogSyslog1$outboundSchema.parse(inputSyslogSyslog1),
  );
}

/** @internal */
export type InputSyslog$Outbound =
  | InputSyslogSyslog1$Outbound
  | InputSyslogSyslog2$Outbound;

/** @internal */
export const InputSyslog$outboundSchema: z.ZodType<
  InputSyslog$Outbound,
  z.ZodTypeDef,
  InputSyslog
> = z.union([
  z.lazy(() => InputSyslogSyslog1$outboundSchema),
  z.lazy(() => InputSyslogSyslog2$outboundSchema),
]);

export function inputSyslogToJSON(inputSyslog: InputSyslog): string {
  return JSON.stringify(InputSyslog$outboundSchema.parse(inputSyslog));
}

/** @internal */
export const InputSqsType$outboundSchema: z.ZodNativeEnum<typeof InputSqsType> =
  z.nativeEnum(InputSqsType);

/** @internal */
export const CreateInputQueueType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CreateInputQueueType
> = openEnums.outboundSchema(CreateInputQueueType);

/** @internal */
export type InputSqsPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  queueName: string;
  queueType: string;
  awsAccountId?: string | undefined;
  createQueue?: boolean | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  pollTimeout?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  numReceivers?: number | undefined;
};

/** @internal */
export const InputSqsPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputSqsPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputSqsPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputSqsType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  queueName: z.string(),
  queueType: CreateInputQueueType$outboundSchema,
  awsAccountId: z.string().optional(),
  createQueue: z.boolean().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptions3$outboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  maxMessages: z.number().optional(),
  visibilityTimeout: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  pollTimeout: z.number().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  numReceivers: z.number().optional(),
});

export function inputSqsPqEnabledTrueWithPqConstraintToJSON(
  inputSqsPqEnabledTrueWithPqConstraint: InputSqsPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputSqsPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputSqsPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputSqsPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  queueType: string;
  awsAccountId?: string | undefined;
  createQueue?: boolean | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  pollTimeout?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  numReceivers?: number | undefined;
};

/** @internal */
export const InputSqsPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputSqsPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputSqsPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputSqsType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  queueName: z.string(),
  queueType: CreateInputQueueType$outboundSchema,
  awsAccountId: z.string().optional(),
  createQueue: z.boolean().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptions3$outboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  maxMessages: z.number().optional(),
  visibilityTimeout: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  pollTimeout: z.number().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  numReceivers: z.number().optional(),
});

export function inputSqsPqEnabledFalseConstraintToJSON(
  inputSqsPqEnabledFalseConstraint: InputSqsPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputSqsPqEnabledFalseConstraint$outboundSchema.parse(
      inputSqsPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputSqsSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  queueType: string;
  awsAccountId?: string | undefined;
  createQueue?: boolean | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  pollTimeout?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  numReceivers?: number | undefined;
};

/** @internal */
export const InputSqsSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputSqsSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputSqsSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputSqsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    queueName: z.string(),
    queueType: CreateInputQueueType$outboundSchema,
    awsAccountId: z.string().optional(),
    createQueue: z.boolean().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models.SignatureVersionOptions3$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    pollTimeout: z.number().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    numReceivers: z.number().optional(),
  });

export function inputSqsSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputSqsSendToRoutesFalseWithConnectionsConstraint:
    InputSqsSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputSqsSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputSqsSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputSqsSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  queueType: string;
  awsAccountId?: string | undefined;
  createQueue?: boolean | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  pollTimeout?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  numReceivers?: number | undefined;
};

/** @internal */
export const InputSqsSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputSqsSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputSqsSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputSqsType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  queueName: z.string(),
  queueType: CreateInputQueueType$outboundSchema,
  awsAccountId: z.string().optional(),
  createQueue: z.boolean().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptions3$outboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  maxMessages: z.number().optional(),
  visibilityTimeout: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  pollTimeout: z.number().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  numReceivers: z.number().optional(),
});

export function inputSqsSendToRoutesTrueConstraintToJSON(
  inputSqsSendToRoutesTrueConstraint: InputSqsSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputSqsSendToRoutesTrueConstraint$outboundSchema.parse(
      inputSqsSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputSqs$Outbound =
  | InputSqsSendToRoutesTrueConstraint$Outbound
  | InputSqsSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputSqsPqEnabledFalseConstraint$Outbound
  | InputSqsPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputSqs$outboundSchema: z.ZodType<
  InputSqs$Outbound,
  z.ZodTypeDef,
  InputSqs
> = z.union([
  z.lazy(() => InputSqsSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputSqsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputSqsPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputSqsPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputSqsToJSON(inputSqs: InputSqs): string {
  return JSON.stringify(InputSqs$outboundSchema.parse(inputSqs));
}

/** @internal */
export const InputModelDrivenTelemetryType$outboundSchema: z.ZodNativeEnum<
  typeof InputModelDrivenTelemetryType
> = z.nativeEnum(InputModelDrivenTelemetryType);

/** @internal */
export type InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  maxActiveCxn?: number | undefined;
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputModelDrivenTelemetryType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxActiveCxn: z.number().optional(),
    shutdownTimeoutMs: z.number().optional(),
    description: z.string().optional(),
  });

export function inputModelDrivenTelemetryPqEnabledTrueWithPqConstraintToJSON(
  inputModelDrivenTelemetryPqEnabledTrueWithPqConstraint:
    InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputModelDrivenTelemetryPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputModelDrivenTelemetryPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  maxActiveCxn?: number | undefined;
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputModelDrivenTelemetryPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputModelDrivenTelemetryPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputModelDrivenTelemetryPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputModelDrivenTelemetryType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxActiveCxn: z.number().optional(),
    shutdownTimeoutMs: z.number().optional(),
    description: z.string().optional(),
  });

export function inputModelDrivenTelemetryPqEnabledFalseConstraintToJSON(
  inputModelDrivenTelemetryPqEnabledFalseConstraint:
    InputModelDrivenTelemetryPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetryPqEnabledFalseConstraint$outboundSchema.parse(
      inputModelDrivenTelemetryPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    host: string;
    port: number;
    tls?: models.TlsSettingsServerSideType$Outbound | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    maxActiveCxn?: number | undefined;
    shutdownTimeoutMs?: number | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputModelDrivenTelemetryType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxActiveCxn: z.number().optional(),
    shutdownTimeoutMs: z.number().optional(),
    description: z.string().optional(),
  });

export function inputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraintToJSON(
  inputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint:
    InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(
        inputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint,
      ),
  );
}

/** @internal */
export type InputModelDrivenTelemetrySendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  maxActiveCxn?: number | undefined;
  shutdownTimeoutMs?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputModelDrivenTelemetrySendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputModelDrivenTelemetrySendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputModelDrivenTelemetrySendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputModelDrivenTelemetryType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxActiveCxn: z.number().optional(),
    shutdownTimeoutMs: z.number().optional(),
    description: z.string().optional(),
  });

export function inputModelDrivenTelemetrySendToRoutesTrueConstraintToJSON(
  inputModelDrivenTelemetrySendToRoutesTrueConstraint:
    InputModelDrivenTelemetrySendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetrySendToRoutesTrueConstraint$outboundSchema.parse(
      inputModelDrivenTelemetrySendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputModelDrivenTelemetry$Outbound =
  | InputModelDrivenTelemetrySendToRoutesTrueConstraint$Outbound
  | InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputModelDrivenTelemetryPqEnabledFalseConstraint$Outbound
  | InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputModelDrivenTelemetry$outboundSchema: z.ZodType<
  InputModelDrivenTelemetry$Outbound,
  z.ZodTypeDef,
  InputModelDrivenTelemetry
> = z.union([
  z.lazy(() =>
    InputModelDrivenTelemetrySendToRoutesTrueConstraint$outboundSchema
  ),
  z.lazy(() =>
    InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() =>
    InputModelDrivenTelemetryPqEnabledFalseConstraint$outboundSchema
  ),
  z.lazy(() =>
    InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint$outboundSchema
  ),
]);

export function inputModelDrivenTelemetryToJSON(
  inputModelDrivenTelemetry: InputModelDrivenTelemetry,
): string {
  return JSON.stringify(
    InputModelDrivenTelemetry$outboundSchema.parse(inputModelDrivenTelemetry),
  );
}

/** @internal */
export const InputOpenTelemetryType$outboundSchema: z.ZodNativeEnum<
  typeof InputOpenTelemetryType
> = z.nativeEnum(InputOpenTelemetryType);

/** @internal */
export const CreateInputProtocol$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CreateInputProtocol
> = openEnums.outboundSchema(CreateInputProtocol);

/** @internal */
export const CreateInputOTLPVersion$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CreateInputOTLPVersion
> = openEnums.outboundSchema(CreateInputOTLPVersion);

/** @internal */
export type InputOpenTelemetryPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: any | undefined;
  captureHeaders?: any | undefined;
  activityLogSampleRate?: any | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  protocol?: string | undefined;
  extractSpans?: boolean | undefined;
  extractMetrics?: boolean | undefined;
  otlpVersion?: string | undefined;
  authType?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  maxActiveCxn?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
  extractLogs?: boolean | undefined;
};

/** @internal */
export const InputOpenTelemetryPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputOpenTelemetryPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputOpenTelemetryPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputOpenTelemetryType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.any().optional(),
    captureHeaders: z.any().optional(),
    activityLogSampleRate: z.any().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    protocol: CreateInputProtocol$outboundSchema.optional(),
    extractSpans: z.boolean().optional(),
    extractMetrics: z.boolean().optional(),
    otlpVersion: CreateInputOTLPVersion$outboundSchema.optional(),
    authType: models.AuthenticationTypeOptions$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxActiveCxn: z.number().optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
    extractLogs: z.boolean().optional(),
  });

export function inputOpenTelemetryPqEnabledTrueWithPqConstraintToJSON(
  inputOpenTelemetryPqEnabledTrueWithPqConstraint:
    InputOpenTelemetryPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputOpenTelemetryPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputOpenTelemetryPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputOpenTelemetryPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: any | undefined;
  captureHeaders?: any | undefined;
  activityLogSampleRate?: any | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  protocol?: string | undefined;
  extractSpans?: boolean | undefined;
  extractMetrics?: boolean | undefined;
  otlpVersion?: string | undefined;
  authType?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  maxActiveCxn?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
  extractLogs?: boolean | undefined;
};

/** @internal */
export const InputOpenTelemetryPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputOpenTelemetryPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputOpenTelemetryPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputOpenTelemetryType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.any().optional(),
    captureHeaders: z.any().optional(),
    activityLogSampleRate: z.any().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    protocol: CreateInputProtocol$outboundSchema.optional(),
    extractSpans: z.boolean().optional(),
    extractMetrics: z.boolean().optional(),
    otlpVersion: CreateInputOTLPVersion$outboundSchema.optional(),
    authType: models.AuthenticationTypeOptions$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxActiveCxn: z.number().optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
    extractLogs: z.boolean().optional(),
  });

export function inputOpenTelemetryPqEnabledFalseConstraintToJSON(
  inputOpenTelemetryPqEnabledFalseConstraint:
    InputOpenTelemetryPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputOpenTelemetryPqEnabledFalseConstraint$outboundSchema.parse(
      inputOpenTelemetryPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    host: string;
    port: number;
    tls?: models.TlsSettingsServerSideType$Outbound | undefined;
    maxActiveReq?: number | undefined;
    maxRequestsPerSocket?: number | undefined;
    enableProxyHeader?: any | undefined;
    captureHeaders?: any | undefined;
    activityLogSampleRate?: any | undefined;
    requestTimeout?: number | undefined;
    socketTimeout?: number | undefined;
    keepAliveTimeout?: number | undefined;
    enableHealthCheck?: boolean | undefined;
    ipAllowlistRegex?: string | undefined;
    ipDenylistRegex?: string | undefined;
    protocol?: string | undefined;
    extractSpans?: boolean | undefined;
    extractMetrics?: boolean | undefined;
    otlpVersion?: string | undefined;
    authType?: string | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    maxActiveCxn?: number | undefined;
    description?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    token?: string | undefined;
    credentialsSecret?: string | undefined;
    textSecret?: string | undefined;
    loginUrl?: string | undefined;
    secretParamName?: string | undefined;
    secret?: string | undefined;
    tokenAttributeName?: string | undefined;
    authHeaderExpr?: string | undefined;
    tokenTimeoutSecs?: number | undefined;
    oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
    oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
    extractLogs?: boolean | undefined;
  };

/** @internal */
export const InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputOpenTelemetryType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.any().optional(),
    captureHeaders: z.any().optional(),
    activityLogSampleRate: z.any().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    protocol: CreateInputProtocol$outboundSchema.optional(),
    extractSpans: z.boolean().optional(),
    extractMetrics: z.boolean().optional(),
    otlpVersion: CreateInputOTLPVersion$outboundSchema.optional(),
    authType: models.AuthenticationTypeOptions$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxActiveCxn: z.number().optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
    extractLogs: z.boolean().optional(),
  });

export function inputOpenTelemetrySendToRoutesFalseWithConnectionsConstraintToJSON(
  inputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint:
    InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputOpenTelemetrySendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: any | undefined;
  captureHeaders?: any | undefined;
  activityLogSampleRate?: any | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  protocol?: string | undefined;
  extractSpans?: boolean | undefined;
  extractMetrics?: boolean | undefined;
  otlpVersion?: string | undefined;
  authType?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  maxActiveCxn?: number | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
  extractLogs?: boolean | undefined;
};

/** @internal */
export const InputOpenTelemetrySendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputOpenTelemetrySendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputOpenTelemetrySendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputOpenTelemetryType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.any().optional(),
    captureHeaders: z.any().optional(),
    activityLogSampleRate: z.any().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    protocol: CreateInputProtocol$outboundSchema.optional(),
    extractSpans: z.boolean().optional(),
    extractMetrics: z.boolean().optional(),
    otlpVersion: CreateInputOTLPVersion$outboundSchema.optional(),
    authType: models.AuthenticationTypeOptions$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    maxActiveCxn: z.number().optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
    extractLogs: z.boolean().optional(),
  });

export function inputOpenTelemetrySendToRoutesTrueConstraintToJSON(
  inputOpenTelemetrySendToRoutesTrueConstraint:
    InputOpenTelemetrySendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputOpenTelemetrySendToRoutesTrueConstraint$outboundSchema.parse(
      inputOpenTelemetrySendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputOpenTelemetry$Outbound =
  | InputOpenTelemetrySendToRoutesTrueConstraint$Outbound
  | InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputOpenTelemetryPqEnabledFalseConstraint$Outbound
  | InputOpenTelemetryPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputOpenTelemetry$outboundSchema: z.ZodType<
  InputOpenTelemetry$Outbound,
  z.ZodTypeDef,
  InputOpenTelemetry
> = z.union([
  z.lazy(() => InputOpenTelemetrySendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputOpenTelemetryPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputOpenTelemetryPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputOpenTelemetryToJSON(
  inputOpenTelemetry: InputOpenTelemetry,
): string {
  return JSON.stringify(
    InputOpenTelemetry$outboundSchema.parse(inputOpenTelemetry),
  );
}

/** @internal */
export const InputSnmpType$outboundSchema: z.ZodNativeEnum<
  typeof InputSnmpType
> = z.nativeEnum(InputSnmpType);

/** @internal */
export const PrivacyProtocol$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PrivacyProtocol
> = openEnums.outboundSchema(PrivacyProtocol);

/** @internal */
export type V3User$Outbound = {
  name: string;
  authProtocol?: string | undefined;
  authKey?: string | undefined;
  privProtocol?: string | undefined;
  privKey?: string | undefined;
};

/** @internal */
export const V3User$outboundSchema: z.ZodType<
  V3User$Outbound,
  z.ZodTypeDef,
  V3User
> = z.object({
  name: z.string(),
  authProtocol: models.AuthenticationProtocolOptionsV3User$outboundSchema
    .optional(),
  authKey: z.string().optional(),
  privProtocol: PrivacyProtocol$outboundSchema.optional(),
  privKey: z.string().optional(),
});

export function v3UserToJSON(v3User: V3User): string {
  return JSON.stringify(V3User$outboundSchema.parse(v3User));
}

/** @internal */
export type SNMPv3Authentication$Outbound = {
  v3AuthEnabled: boolean;
  allowUnmatchedTrap?: boolean | undefined;
  v3Users?: Array<V3User$Outbound> | undefined;
};

/** @internal */
export const SNMPv3Authentication$outboundSchema: z.ZodType<
  SNMPv3Authentication$Outbound,
  z.ZodTypeDef,
  SNMPv3Authentication
> = z.object({
  v3AuthEnabled: z.boolean(),
  allowUnmatchedTrap: z.boolean().optional(),
  v3Users: z.array(z.lazy(() => V3User$outboundSchema)).optional(),
});

export function snmPv3AuthenticationToJSON(
  snmPv3Authentication: SNMPv3Authentication,
): string {
  return JSON.stringify(
    SNMPv3Authentication$outboundSchema.parse(snmPv3Authentication),
  );
}

/** @internal */
export type InputSnmpPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  snmpV3Auth?: SNMPv3Authentication$Outbound | undefined;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  varbindsWithTypes?: boolean | undefined;
  bestEffortParsing?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSnmpPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputSnmpPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputSnmpPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputSnmpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  host: z.string(),
  port: z.number(),
  snmpV3Auth: z.lazy(() => SNMPv3Authentication$outboundSchema).optional(),
  maxBufferSize: z.number().optional(),
  ipWhitelistRegex: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  varbindsWithTypes: z.boolean().optional(),
  bestEffortParsing: z.boolean().optional(),
  description: z.string().optional(),
});

export function inputSnmpPqEnabledTrueWithPqConstraintToJSON(
  inputSnmpPqEnabledTrueWithPqConstraint:
    InputSnmpPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputSnmpPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputSnmpPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputSnmpPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  snmpV3Auth?: SNMPv3Authentication$Outbound | undefined;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  varbindsWithTypes?: boolean | undefined;
  bestEffortParsing?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSnmpPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputSnmpPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputSnmpPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputSnmpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  snmpV3Auth: z.lazy(() => SNMPv3Authentication$outboundSchema).optional(),
  maxBufferSize: z.number().optional(),
  ipWhitelistRegex: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  varbindsWithTypes: z.boolean().optional(),
  bestEffortParsing: z.boolean().optional(),
  description: z.string().optional(),
});

export function inputSnmpPqEnabledFalseConstraintToJSON(
  inputSnmpPqEnabledFalseConstraint: InputSnmpPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputSnmpPqEnabledFalseConstraint$outboundSchema.parse(
      inputSnmpPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputSnmpSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  snmpV3Auth?: SNMPv3Authentication$Outbound | undefined;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  varbindsWithTypes?: boolean | undefined;
  bestEffortParsing?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSnmpSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputSnmpSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputSnmpSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputSnmpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    snmpV3Auth: z.lazy(() => SNMPv3Authentication$outboundSchema).optional(),
    maxBufferSize: z.number().optional(),
    ipWhitelistRegex: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    udpSocketRxBufSize: z.number().optional(),
    varbindsWithTypes: z.boolean().optional(),
    bestEffortParsing: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputSnmpSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputSnmpSendToRoutesFalseWithConnectionsConstraint:
    InputSnmpSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputSnmpSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputSnmpSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputSnmpSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  snmpV3Auth?: SNMPv3Authentication$Outbound | undefined;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  varbindsWithTypes?: boolean | undefined;
  bestEffortParsing?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSnmpSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputSnmpSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputSnmpSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputSnmpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  snmpV3Auth: z.lazy(() => SNMPv3Authentication$outboundSchema).optional(),
  maxBufferSize: z.number().optional(),
  ipWhitelistRegex: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  varbindsWithTypes: z.boolean().optional(),
  bestEffortParsing: z.boolean().optional(),
  description: z.string().optional(),
});

export function inputSnmpSendToRoutesTrueConstraintToJSON(
  inputSnmpSendToRoutesTrueConstraint: InputSnmpSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputSnmpSendToRoutesTrueConstraint$outboundSchema.parse(
      inputSnmpSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputSnmp$Outbound =
  | InputSnmpSendToRoutesTrueConstraint$Outbound
  | InputSnmpSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputSnmpPqEnabledFalseConstraint$Outbound
  | InputSnmpPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputSnmp$outboundSchema: z.ZodType<
  InputSnmp$Outbound,
  z.ZodTypeDef,
  InputSnmp
> = z.union([
  z.lazy(() => InputSnmpSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputSnmpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputSnmpPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputSnmpPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputSnmpToJSON(inputSnmp: InputSnmp): string {
  return JSON.stringify(InputSnmp$outboundSchema.parse(inputSnmp));
}

/** @internal */
export const InputS3InventoryType$outboundSchema: z.ZodNativeEnum<
  typeof InputS3InventoryType
> = z.nativeEnum(InputS3InventoryType);

/** @internal */
export type InputS3InventoryPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  checksumSuffix?: string | undefined;
  maxManifestSizeKB?: number | undefined;
  validateInventoryFiles?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputS3InventoryPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputS3InventoryPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputS3InventoryPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputS3InventoryType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models
      .SignatureVersionOptionsS3CollectorConf$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    socketTimeout: z.number().optional(),
    skipOnError: z.boolean().optional(),
    includeSqsMetadata: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    enableSQSAssumeRole: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    parquetChunkSizeMB: z.number().optional(),
    parquetChunkDownloadTimeout: z.number().optional(),
    checkpointing: models.CheckpointingType$outboundSchema.optional(),
    pollTimeout: z.number().optional(),
    checksumSuffix: z.string().optional(),
    maxManifestSizeKB: z.number().int().optional(),
    validateInventoryFiles: z.boolean().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
      .optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

export function inputS3InventoryPqEnabledTrueWithPqConstraintToJSON(
  inputS3InventoryPqEnabledTrueWithPqConstraint:
    InputS3InventoryPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputS3InventoryPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputS3InventoryPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputS3InventoryPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  checksumSuffix?: string | undefined;
  maxManifestSizeKB?: number | undefined;
  validateInventoryFiles?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputS3InventoryPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputS3InventoryPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputS3InventoryPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputS3InventoryType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  queueName: z.string(),
  fileFilter: z.string().optional(),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptionsS3CollectorConf$outboundSchema
    .optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  maxMessages: z.number().optional(),
  visibilityTimeout: z.number().optional(),
  numReceivers: z.number().optional(),
  socketTimeout: z.number().optional(),
  skipOnError: z.boolean().optional(),
  includeSqsMetadata: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  enableSQSAssumeRole: z.boolean().optional(),
  preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
    .optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  parquetChunkSizeMB: z.number().optional(),
  parquetChunkDownloadTimeout: z.number().optional(),
  checkpointing: models.CheckpointingType$outboundSchema.optional(),
  pollTimeout: z.number().optional(),
  checksumSuffix: z.string().optional(),
  maxManifestSizeKB: z.number().int().optional(),
  validateInventoryFiles: z.boolean().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
    .optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

export function inputS3InventoryPqEnabledFalseConstraintToJSON(
  inputS3InventoryPqEnabledFalseConstraint:
    InputS3InventoryPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputS3InventoryPqEnabledFalseConstraint$outboundSchema.parse(
      inputS3InventoryPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputS3InventorySendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    queueName: string;
    fileFilter?: string | undefined;
    awsAccountId?: string | undefined;
    awsAuthenticationMethod?: string | undefined;
    awsSecretKey?: string | undefined;
    region?: string | undefined;
    endpoint?: string | undefined;
    signatureVersion?: string | undefined;
    reuseConnections?: boolean | undefined;
    rejectUnauthorized?: boolean | undefined;
    breakerRulesets?: Array<string> | undefined;
    staleChannelFlushMs?: number | undefined;
    maxMessages?: number | undefined;
    visibilityTimeout?: number | undefined;
    numReceivers?: number | undefined;
    socketTimeout?: number | undefined;
    skipOnError?: boolean | undefined;
    includeSqsMetadata?: boolean | undefined;
    enableAssumeRole?: boolean | undefined;
    assumeRoleArn?: string | undefined;
    assumeRoleExternalId?: string | undefined;
    durationSeconds?: number | undefined;
    enableSQSAssumeRole?: boolean | undefined;
    preprocess?:
      | models.PreprocessTypeSavedJobCollectionInput$Outbound
      | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    parquetChunkSizeMB?: number | undefined;
    parquetChunkDownloadTimeout?: number | undefined;
    checkpointing?: models.CheckpointingType$Outbound | undefined;
    pollTimeout?: number | undefined;
    checksumSuffix?: string | undefined;
    maxManifestSizeKB?: number | undefined;
    validateInventoryFiles?: boolean | undefined;
    description?: string | undefined;
    awsApiKey?: string | undefined;
    awsSecret?: string | undefined;
    tagAfterProcessing?: string | undefined;
    processedTagKey?: string | undefined;
    processedTagValue?: string | undefined;
  };

/** @internal */
export const InputS3InventorySendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputS3InventorySendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputS3InventorySendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputS3InventoryType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models
      .SignatureVersionOptionsS3CollectorConf$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    socketTimeout: z.number().optional(),
    skipOnError: z.boolean().optional(),
    includeSqsMetadata: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    enableSQSAssumeRole: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    parquetChunkSizeMB: z.number().optional(),
    parquetChunkDownloadTimeout: z.number().optional(),
    checkpointing: models.CheckpointingType$outboundSchema.optional(),
    pollTimeout: z.number().optional(),
    checksumSuffix: z.string().optional(),
    maxManifestSizeKB: z.number().int().optional(),
    validateInventoryFiles: z.boolean().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
      .optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

export function inputS3InventorySendToRoutesFalseWithConnectionsConstraintToJSON(
  inputS3InventorySendToRoutesFalseWithConnectionsConstraint:
    InputS3InventorySendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputS3InventorySendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputS3InventorySendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputS3InventorySendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  checksumSuffix?: string | undefined;
  maxManifestSizeKB?: number | undefined;
  validateInventoryFiles?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputS3InventorySendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputS3InventorySendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputS3InventorySendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputS3InventoryType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models
      .SignatureVersionOptionsS3CollectorConf$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    socketTimeout: z.number().optional(),
    skipOnError: z.boolean().optional(),
    includeSqsMetadata: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    enableSQSAssumeRole: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    parquetChunkSizeMB: z.number().optional(),
    parquetChunkDownloadTimeout: z.number().optional(),
    checkpointing: models.CheckpointingType$outboundSchema.optional(),
    pollTimeout: z.number().optional(),
    checksumSuffix: z.string().optional(),
    maxManifestSizeKB: z.number().int().optional(),
    validateInventoryFiles: z.boolean().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
      .optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

export function inputS3InventorySendToRoutesTrueConstraintToJSON(
  inputS3InventorySendToRoutesTrueConstraint:
    InputS3InventorySendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputS3InventorySendToRoutesTrueConstraint$outboundSchema.parse(
      inputS3InventorySendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputS3Inventory$Outbound =
  | InputS3InventorySendToRoutesTrueConstraint$Outbound
  | InputS3InventorySendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputS3InventoryPqEnabledFalseConstraint$Outbound
  | InputS3InventoryPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputS3Inventory$outboundSchema: z.ZodType<
  InputS3Inventory$Outbound,
  z.ZodTypeDef,
  InputS3Inventory
> = z.union([
  z.lazy(() => InputS3InventorySendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputS3InventorySendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputS3InventoryPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputS3InventoryPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputS3InventoryToJSON(
  inputS3Inventory: InputS3Inventory,
): string {
  return JSON.stringify(
    InputS3Inventory$outboundSchema.parse(inputS3Inventory),
  );
}

/** @internal */
export const InputS3Type$outboundSchema: z.ZodNativeEnum<typeof InputS3Type> = z
  .nativeEnum(InputS3Type);

/** @internal */
export type InputS3PqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  encoding?: string | undefined;
  tagAfterProcessing?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputS3PqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputS3PqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputS3PqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputS3Type$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  queueName: z.string(),
  fileFilter: z.string().optional(),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptionsS3CollectorConf$outboundSchema
    .optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  maxMessages: z.number().optional(),
  visibilityTimeout: z.number().optional(),
  numReceivers: z.number().optional(),
  socketTimeout: z.number().optional(),
  skipOnError: z.boolean().optional(),
  includeSqsMetadata: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  enableSQSAssumeRole: z.boolean().optional(),
  preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
    .optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  parquetChunkSizeMB: z.number().optional(),
  parquetChunkDownloadTimeout: z.number().optional(),
  checkpointing: models.CheckpointingType$outboundSchema.optional(),
  pollTimeout: z.number().optional(),
  encoding: z.string().optional(),
  tagAfterProcessing: z.boolean().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

export function inputS3PqEnabledTrueWithPqConstraintToJSON(
  inputS3PqEnabledTrueWithPqConstraint: InputS3PqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputS3PqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputS3PqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputS3PqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  encoding?: string | undefined;
  tagAfterProcessing?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputS3PqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputS3PqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputS3PqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputS3Type$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  queueName: z.string(),
  fileFilter: z.string().optional(),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptionsS3CollectorConf$outboundSchema
    .optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  maxMessages: z.number().optional(),
  visibilityTimeout: z.number().optional(),
  numReceivers: z.number().optional(),
  socketTimeout: z.number().optional(),
  skipOnError: z.boolean().optional(),
  includeSqsMetadata: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  enableSQSAssumeRole: z.boolean().optional(),
  preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
    .optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  parquetChunkSizeMB: z.number().optional(),
  parquetChunkDownloadTimeout: z.number().optional(),
  checkpointing: models.CheckpointingType$outboundSchema.optional(),
  pollTimeout: z.number().optional(),
  encoding: z.string().optional(),
  tagAfterProcessing: z.boolean().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

export function inputS3PqEnabledFalseConstraintToJSON(
  inputS3PqEnabledFalseConstraint: InputS3PqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputS3PqEnabledFalseConstraint$outboundSchema.parse(
      inputS3PqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputS3SendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  encoding?: string | undefined;
  tagAfterProcessing?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputS3SendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputS3SendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputS3SendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputS3Type$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models
      .SignatureVersionOptionsS3CollectorConf$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    socketTimeout: z.number().optional(),
    skipOnError: z.boolean().optional(),
    includeSqsMetadata: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    enableSQSAssumeRole: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    parquetChunkSizeMB: z.number().optional(),
    parquetChunkDownloadTimeout: z.number().optional(),
    checkpointing: models.CheckpointingType$outboundSchema.optional(),
    pollTimeout: z.number().optional(),
    encoding: z.string().optional(),
    tagAfterProcessing: z.boolean().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

export function inputS3SendToRoutesFalseWithConnectionsConstraintToJSON(
  inputS3SendToRoutesFalseWithConnectionsConstraint:
    InputS3SendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputS3SendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputS3SendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputS3SendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  encoding?: string | undefined;
  tagAfterProcessing?: boolean | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputS3SendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputS3SendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputS3SendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputS3Type$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  queueName: z.string(),
  fileFilter: z.string().optional(),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptionsS3CollectorConf$outboundSchema
    .optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  maxMessages: z.number().optional(),
  visibilityTimeout: z.number().optional(),
  numReceivers: z.number().optional(),
  socketTimeout: z.number().optional(),
  skipOnError: z.boolean().optional(),
  includeSqsMetadata: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  enableSQSAssumeRole: z.boolean().optional(),
  preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
    .optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  parquetChunkSizeMB: z.number().optional(),
  parquetChunkDownloadTimeout: z.number().optional(),
  checkpointing: models.CheckpointingType$outboundSchema.optional(),
  pollTimeout: z.number().optional(),
  encoding: z.string().optional(),
  tagAfterProcessing: z.boolean().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

export function inputS3SendToRoutesTrueConstraintToJSON(
  inputS3SendToRoutesTrueConstraint: InputS3SendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputS3SendToRoutesTrueConstraint$outboundSchema.parse(
      inputS3SendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputS3$Outbound =
  | InputS3SendToRoutesTrueConstraint$Outbound
  | InputS3SendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputS3PqEnabledFalseConstraint$Outbound
  | InputS3PqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputS3$outboundSchema: z.ZodType<
  InputS3$Outbound,
  z.ZodTypeDef,
  InputS3
> = z.union([
  z.lazy(() => InputS3SendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputS3SendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputS3PqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputS3PqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputS3ToJSON(inputS3: InputS3): string {
  return JSON.stringify(InputS3$outboundSchema.parse(inputS3));
}

/** @internal */
export const InputMetricsType$outboundSchema: z.ZodNativeEnum<
  typeof InputMetricsType
> = z.nativeEnum(InputMetricsType);

/** @internal */
export type InputMetricsPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort?: number | undefined;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  enableProxyHeader?: boolean | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetricsPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputMetricsPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputMetricsPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    udpPort: z.number().optional(),
    tcpPort: z.number().optional(),
    maxBufferSize: z.number().optional(),
    ipWhitelistRegex: z.string().optional(),
    enableProxyHeader: z.boolean().optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    udpSocketRxBufSize: z.number().optional(),
    description: z.string().optional(),
  });

export function inputMetricsPqEnabledTrueWithPqConstraintToJSON(
  inputMetricsPqEnabledTrueWithPqConstraint:
    InputMetricsPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputMetricsPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputMetricsPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputMetricsPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort?: number | undefined;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  enableProxyHeader?: boolean | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetricsPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputMetricsPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputMetricsPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputMetricsType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().optional(),
  ipWhitelistRegex: z.string().optional(),
  enableProxyHeader: z.boolean().optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

export function inputMetricsPqEnabledFalseConstraintToJSON(
  inputMetricsPqEnabledFalseConstraint: InputMetricsPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputMetricsPqEnabledFalseConstraint$outboundSchema.parse(
      inputMetricsPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort?: number | undefined;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  enableProxyHeader?: boolean | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputMetricsSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    udpPort: z.number().optional(),
    tcpPort: z.number().optional(),
    maxBufferSize: z.number().optional(),
    ipWhitelistRegex: z.string().optional(),
    enableProxyHeader: z.boolean().optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    udpSocketRxBufSize: z.number().optional(),
    description: z.string().optional(),
  });

export function inputMetricsSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputMetricsSendToRoutesFalseWithConnectionsConstraint:
    InputMetricsSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputMetricsSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputMetricsSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort?: number | undefined;
  maxBufferSize?: number | undefined;
  ipWhitelistRegex?: string | undefined;
  enableProxyHeader?: boolean | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetricsSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputMetricsSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputMetricsSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputMetricsType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().optional(),
  ipWhitelistRegex: z.string().optional(),
  enableProxyHeader: z.boolean().optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

export function inputMetricsSendToRoutesTrueConstraintToJSON(
  inputMetricsSendToRoutesTrueConstraint:
    InputMetricsSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputMetricsSendToRoutesTrueConstraint$outboundSchema.parse(
      inputMetricsSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputMetrics$Outbound =
  | InputMetricsSendToRoutesTrueConstraint$Outbound
  | InputMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputMetricsPqEnabledFalseConstraint$Outbound
  | InputMetricsPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputMetrics$outboundSchema: z.ZodType<
  InputMetrics$Outbound,
  z.ZodTypeDef,
  InputMetrics
> = z.union([
  z.lazy(() => InputMetricsSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputMetricsPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputMetricsPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputMetricsToJSON(inputMetrics: InputMetrics): string {
  return JSON.stringify(InputMetrics$outboundSchema.parse(inputMetrics));
}

/** @internal */
export const InputCriblmetricsType$outboundSchema: z.ZodNativeEnum<
  typeof InputCriblmetricsType
> = z.nativeEnum(InputCriblmetricsType);

/** @internal */
export type InputCriblmetricsPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  prefix?: string | undefined;
  fullFidelity?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblmetricsPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputCriblmetricsPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblmetricsPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputCriblmetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    prefix: z.string().optional(),
    fullFidelity: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputCriblmetricsPqEnabledTrueWithPqConstraintToJSON(
  inputCriblmetricsPqEnabledTrueWithPqConstraint:
    InputCriblmetricsPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputCriblmetricsPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputCriblmetricsPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputCriblmetricsPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  prefix?: string | undefined;
  fullFidelity?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblmetricsPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputCriblmetricsPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblmetricsPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputCriblmetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    prefix: z.string().optional(),
    fullFidelity: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputCriblmetricsPqEnabledFalseConstraintToJSON(
  inputCriblmetricsPqEnabledFalseConstraint:
    InputCriblmetricsPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputCriblmetricsPqEnabledFalseConstraint$outboundSchema.parse(
      inputCriblmetricsPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    prefix?: string | undefined;
    fullFidelity?: boolean | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputCriblmetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    prefix: z.string().optional(),
    fullFidelity: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputCriblmetricsSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputCriblmetricsSendToRoutesFalseWithConnectionsConstraint:
    InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputCriblmetricsSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputCriblmetricsSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  prefix?: string | undefined;
  fullFidelity?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblmetricsSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputCriblmetricsSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblmetricsSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputCriblmetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    prefix: z.string().optional(),
    fullFidelity: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputCriblmetricsSendToRoutesTrueConstraintToJSON(
  inputCriblmetricsSendToRoutesTrueConstraint:
    InputCriblmetricsSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputCriblmetricsSendToRoutesTrueConstraint$outboundSchema.parse(
      inputCriblmetricsSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputCriblmetrics$Outbound =
  | InputCriblmetricsSendToRoutesTrueConstraint$Outbound
  | InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputCriblmetricsPqEnabledFalseConstraint$Outbound
  | InputCriblmetricsPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputCriblmetrics$outboundSchema: z.ZodType<
  InputCriblmetrics$Outbound,
  z.ZodTypeDef,
  InputCriblmetrics
> = z.union([
  z.lazy(() => InputCriblmetricsSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputCriblmetricsPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputCriblmetricsPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputCriblmetricsToJSON(
  inputCriblmetrics: InputCriblmetrics,
): string {
  return JSON.stringify(
    InputCriblmetrics$outboundSchema.parse(inputCriblmetrics),
  );
}

/** @internal */
export const InputKinesisType$outboundSchema: z.ZodNativeEnum<
  typeof InputKinesisType
> = z.nativeEnum(InputKinesisType);

/** @internal */
export const ShardIteratorStart$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ShardIteratorStart
> = openEnums.outboundSchema(ShardIteratorStart);

/** @internal */
export const RecordDataFormat$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RecordDataFormat
> = openEnums.outboundSchema(RecordDataFormat);

/** @internal */
export const ShardLoadBalancing$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ShardLoadBalancing
> = openEnums.outboundSchema(ShardLoadBalancing);

/** @internal */
export type InputKinesisPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  streamName: string;
  serviceInterval?: number | undefined;
  shardExpr?: string | undefined;
  shardIteratorType?: string | undefined;
  payloadFormat?: string | undefined;
  getRecordsLimit?: number | undefined;
  getRecordsLimitTotal?: number | undefined;
  loadBalancingAlgorithm?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  verifyKPLCheckSums?: boolean | undefined;
  avoidDuplicates?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesisPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputKinesisPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputKinesisPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputKinesisType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    streamName: z.string(),
    serviceInterval: z.number().optional(),
    shardExpr: z.string().optional(),
    shardIteratorType: ShardIteratorStart$outboundSchema.optional(),
    payloadFormat: RecordDataFormat$outboundSchema.optional(),
    getRecordsLimit: z.number().optional(),
    getRecordsLimitTotal: z.number().optional(),
    loadBalancingAlgorithm: ShardLoadBalancing$outboundSchema.optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string(),
    endpoint: z.string().optional(),
    signatureVersion: models.SignatureVersionOptions2$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    verifyKPLCheckSums: z.boolean().optional(),
    avoidDuplicates: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
  });

export function inputKinesisPqEnabledTrueWithPqConstraintToJSON(
  inputKinesisPqEnabledTrueWithPqConstraint:
    InputKinesisPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputKinesisPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputKinesisPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputKinesisPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  streamName: string;
  serviceInterval?: number | undefined;
  shardExpr?: string | undefined;
  shardIteratorType?: string | undefined;
  payloadFormat?: string | undefined;
  getRecordsLimit?: number | undefined;
  getRecordsLimitTotal?: number | undefined;
  loadBalancingAlgorithm?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  verifyKPLCheckSums?: boolean | undefined;
  avoidDuplicates?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesisPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputKinesisPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputKinesisPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputKinesisType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().optional(),
  shardExpr: z.string().optional(),
  shardIteratorType: ShardIteratorStart$outboundSchema.optional(),
  payloadFormat: RecordDataFormat$outboundSchema.optional(),
  getRecordsLimit: z.number().optional(),
  getRecordsLimitTotal: z.number().optional(),
  loadBalancingAlgorithm: ShardLoadBalancing$outboundSchema.optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptions2$outboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  verifyKPLCheckSums: z.boolean().optional(),
  avoidDuplicates: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

export function inputKinesisPqEnabledFalseConstraintToJSON(
  inputKinesisPqEnabledFalseConstraint: InputKinesisPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputKinesisPqEnabledFalseConstraint$outboundSchema.parse(
      inputKinesisPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputKinesisSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  streamName: string;
  serviceInterval?: number | undefined;
  shardExpr?: string | undefined;
  shardIteratorType?: string | undefined;
  payloadFormat?: string | undefined;
  getRecordsLimit?: number | undefined;
  getRecordsLimitTotal?: number | undefined;
  loadBalancingAlgorithm?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  verifyKPLCheckSums?: boolean | undefined;
  avoidDuplicates?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesisSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputKinesisSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputKinesisSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputKinesisType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    streamName: z.string(),
    serviceInterval: z.number().optional(),
    shardExpr: z.string().optional(),
    shardIteratorType: ShardIteratorStart$outboundSchema.optional(),
    payloadFormat: RecordDataFormat$outboundSchema.optional(),
    getRecordsLimit: z.number().optional(),
    getRecordsLimitTotal: z.number().optional(),
    loadBalancingAlgorithm: ShardLoadBalancing$outboundSchema.optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string(),
    endpoint: z.string().optional(),
    signatureVersion: models.SignatureVersionOptions2$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    verifyKPLCheckSums: z.boolean().optional(),
    avoidDuplicates: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
  });

export function inputKinesisSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputKinesisSendToRoutesFalseWithConnectionsConstraint:
    InputKinesisSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputKinesisSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputKinesisSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputKinesisSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  streamName: string;
  serviceInterval?: number | undefined;
  shardExpr?: string | undefined;
  shardIteratorType?: string | undefined;
  payloadFormat?: string | undefined;
  getRecordsLimit?: number | undefined;
  getRecordsLimitTotal?: number | undefined;
  loadBalancingAlgorithm?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  verifyKPLCheckSums?: boolean | undefined;
  avoidDuplicates?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesisSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputKinesisSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputKinesisSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputKinesisType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().optional(),
  shardExpr: z.string().optional(),
  shardIteratorType: ShardIteratorStart$outboundSchema.optional(),
  payloadFormat: RecordDataFormat$outboundSchema.optional(),
  getRecordsLimit: z.number().optional(),
  getRecordsLimitTotal: z.number().optional(),
  loadBalancingAlgorithm: ShardLoadBalancing$outboundSchema.optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptions2$outboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  verifyKPLCheckSums: z.boolean().optional(),
  avoidDuplicates: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

export function inputKinesisSendToRoutesTrueConstraintToJSON(
  inputKinesisSendToRoutesTrueConstraint:
    InputKinesisSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputKinesisSendToRoutesTrueConstraint$outboundSchema.parse(
      inputKinesisSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputKinesis$Outbound =
  | InputKinesisSendToRoutesTrueConstraint$Outbound
  | InputKinesisSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputKinesisPqEnabledFalseConstraint$Outbound
  | InputKinesisPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputKinesis$outboundSchema: z.ZodType<
  InputKinesis$Outbound,
  z.ZodTypeDef,
  InputKinesis
> = z.union([
  z.lazy(() => InputKinesisSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputKinesisSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputKinesisPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputKinesisPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputKinesisToJSON(inputKinesis: InputKinesis): string {
  return JSON.stringify(InputKinesis$outboundSchema.parse(inputKinesis));
}

/** @internal */
export const InputHttpRawType$outboundSchema: z.ZodNativeEnum<
  typeof InputHttpRawType
> = z.nativeEnum(InputHttpRawType);

/** @internal */
export type InputHttpRawPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedPaths?: Array<string> | undefined;
  allowedMethods?: Array<string> | undefined;
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttpRawPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputHttpRawPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputHttpRawPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputHttpRawType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedPaths: z.array(z.string()).optional(),
    allowedMethods: z.array(z.string()).optional(),
    authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputHttpRawPqEnabledTrueWithPqConstraintToJSON(
  inputHttpRawPqEnabledTrueWithPqConstraint:
    InputHttpRawPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputHttpRawPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputHttpRawPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputHttpRawPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedPaths?: Array<string> | undefined;
  allowedMethods?: Array<string> | undefined;
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttpRawPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputHttpRawPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputHttpRawPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputHttpRawType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  allowedPaths: z.array(z.string()).optional(),
  allowedMethods: z.array(z.string()).optional(),
  authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputHttpRawPqEnabledFalseConstraintToJSON(
  inputHttpRawPqEnabledFalseConstraint: InputHttpRawPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputHttpRawPqEnabledFalseConstraint$outboundSchema.parse(
      inputHttpRawPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputHttpRawSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedPaths?: Array<string> | undefined;
  allowedMethods?: Array<string> | undefined;
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttpRawSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputHttpRawSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputHttpRawSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputHttpRawType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedPaths: z.array(z.string()).optional(),
    allowedMethods: z.array(z.string()).optional(),
    authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputHttpRawSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputHttpRawSendToRoutesFalseWithConnectionsConstraint:
    InputHttpRawSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputHttpRawSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputHttpRawSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputHttpRawSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedPaths?: Array<string> | undefined;
  allowedMethods?: Array<string> | undefined;
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttpRawSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputHttpRawSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputHttpRawSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputHttpRawType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  allowedPaths: z.array(z.string()).optional(),
  allowedMethods: z.array(z.string()).optional(),
  authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputHttpRawSendToRoutesTrueConstraintToJSON(
  inputHttpRawSendToRoutesTrueConstraint:
    InputHttpRawSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputHttpRawSendToRoutesTrueConstraint$outboundSchema.parse(
      inputHttpRawSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputHttpRaw$Outbound =
  | InputHttpRawSendToRoutesTrueConstraint$Outbound
  | InputHttpRawSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputHttpRawPqEnabledFalseConstraint$Outbound
  | InputHttpRawPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputHttpRaw$outboundSchema: z.ZodType<
  InputHttpRaw$Outbound,
  z.ZodTypeDef,
  InputHttpRaw
> = z.union([
  z.lazy(() => InputHttpRawSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputHttpRawSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputHttpRawPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputHttpRawPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputHttpRawToJSON(inputHttpRaw: InputHttpRaw): string {
  return JSON.stringify(InputHttpRaw$outboundSchema.parse(inputHttpRaw));
}

/** @internal */
export const InputDatagenType$outboundSchema: z.ZodNativeEnum<
  typeof InputDatagenType
> = z.nativeEnum(InputDatagenType);

/** @internal */
export type Sample$Outbound = {
  sample: string;
  eventsPerSec: number;
};

/** @internal */
export const Sample$outboundSchema: z.ZodType<
  Sample$Outbound,
  z.ZodTypeDef,
  Sample
> = z.object({
  sample: z.string(),
  eventsPerSec: z.number(),
});

export function sampleToJSON(sample: Sample): string {
  return JSON.stringify(Sample$outboundSchema.parse(sample));
}

/** @internal */
export type InputDatagenPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  samples: Array<Sample$Outbound>;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatagenPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputDatagenPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputDatagenPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputDatagenType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    samples: z.array(z.lazy(() => Sample$outboundSchema)),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputDatagenPqEnabledTrueWithPqConstraintToJSON(
  inputDatagenPqEnabledTrueWithPqConstraint:
    InputDatagenPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputDatagenPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputDatagenPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputDatagenPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  samples: Array<Sample$Outbound>;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatagenPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputDatagenPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputDatagenPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputDatagenType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  samples: z.array(z.lazy(() => Sample$outboundSchema)),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputDatagenPqEnabledFalseConstraintToJSON(
  inputDatagenPqEnabledFalseConstraint: InputDatagenPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputDatagenPqEnabledFalseConstraint$outboundSchema.parse(
      inputDatagenPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputDatagenSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  samples: Array<Sample$Outbound>;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatagenSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputDatagenSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputDatagenSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputDatagenType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    samples: z.array(z.lazy(() => Sample$outboundSchema)),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputDatagenSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputDatagenSendToRoutesFalseWithConnectionsConstraint:
    InputDatagenSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputDatagenSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputDatagenSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputDatagenSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  samples: Array<Sample$Outbound>;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatagenSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputDatagenSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputDatagenSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputDatagenType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  samples: z.array(z.lazy(() => Sample$outboundSchema)),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputDatagenSendToRoutesTrueConstraintToJSON(
  inputDatagenSendToRoutesTrueConstraint:
    InputDatagenSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputDatagenSendToRoutesTrueConstraint$outboundSchema.parse(
      inputDatagenSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputDatagen$Outbound =
  | InputDatagenSendToRoutesTrueConstraint$Outbound
  | InputDatagenSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputDatagenPqEnabledFalseConstraint$Outbound
  | InputDatagenPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputDatagen$outboundSchema: z.ZodType<
  InputDatagen$Outbound,
  z.ZodTypeDef,
  InputDatagen
> = z.union([
  z.lazy(() => InputDatagenSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputDatagenSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputDatagenPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputDatagenPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputDatagenToJSON(inputDatagen: InputDatagen): string {
  return JSON.stringify(InputDatagen$outboundSchema.parse(inputDatagen));
}

/** @internal */
export const InputDatadogAgentType$outboundSchema: z.ZodNativeEnum<
  typeof InputDatadogAgentType
> = z.nativeEnum(InputDatadogAgentType);

/** @internal */
export type InputDatadogAgentProxyMode$Outbound = {
  enabled: boolean;
  rejectUnauthorized?: boolean | undefined;
};

/** @internal */
export const InputDatadogAgentProxyMode$outboundSchema: z.ZodType<
  InputDatadogAgentProxyMode$Outbound,
  z.ZodTypeDef,
  InputDatadogAgentProxyMode
> = z.object({
  enabled: z.boolean(),
  rejectUnauthorized: z.boolean().optional(),
});

export function inputDatadogAgentProxyModeToJSON(
  inputDatadogAgentProxyMode: InputDatadogAgentProxyMode,
): string {
  return JSON.stringify(
    InputDatadogAgentProxyMode$outboundSchema.parse(inputDatadogAgentProxyMode),
  );
}

/** @internal */
export type InputDatadogAgentPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  extractMetrics?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  proxyMode?: InputDatadogAgentProxyMode$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatadogAgentPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputDatadogAgentPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputDatadogAgentPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputDatadogAgentType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    extractMetrics: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    proxyMode: z.lazy(() => InputDatadogAgentProxyMode$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputDatadogAgentPqEnabledTrueWithPqConstraintToJSON(
  inputDatadogAgentPqEnabledTrueWithPqConstraint:
    InputDatadogAgentPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputDatadogAgentPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputDatadogAgentPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputDatadogAgentPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  extractMetrics?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  proxyMode?: InputDatadogAgentProxyMode$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatadogAgentPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputDatadogAgentPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputDatadogAgentPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputDatadogAgentType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    extractMetrics: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    proxyMode: z.lazy(() => InputDatadogAgentProxyMode$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputDatadogAgentPqEnabledFalseConstraintToJSON(
  inputDatadogAgentPqEnabledFalseConstraint:
    InputDatadogAgentPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputDatadogAgentPqEnabledFalseConstraint$outboundSchema.parse(
      inputDatadogAgentPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    host: string;
    port: number;
    tls?: models.TlsSettingsServerSideType$Outbound | undefined;
    maxActiveReq?: number | undefined;
    maxRequestsPerSocket?: number | undefined;
    enableProxyHeader?: boolean | undefined;
    captureHeaders?: boolean | undefined;
    activityLogSampleRate?: number | undefined;
    requestTimeout?: number | undefined;
    socketTimeout?: number | undefined;
    keepAliveTimeout?: number | undefined;
    enableHealthCheck?: boolean | undefined;
    ipAllowlistRegex?: string | undefined;
    ipDenylistRegex?: string | undefined;
    extractMetrics?: boolean | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    proxyMode?: InputDatadogAgentProxyMode$Outbound | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputDatadogAgentType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    extractMetrics: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    proxyMode: z.lazy(() => InputDatadogAgentProxyMode$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputDatadogAgentSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputDatadogAgentSendToRoutesFalseWithConnectionsConstraint:
    InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputDatadogAgentSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputDatadogAgentSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  extractMetrics?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  proxyMode?: InputDatadogAgentProxyMode$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatadogAgentSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputDatadogAgentSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputDatadogAgentSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputDatadogAgentType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    extractMetrics: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    proxyMode: z.lazy(() => InputDatadogAgentProxyMode$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputDatadogAgentSendToRoutesTrueConstraintToJSON(
  inputDatadogAgentSendToRoutesTrueConstraint:
    InputDatadogAgentSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputDatadogAgentSendToRoutesTrueConstraint$outboundSchema.parse(
      inputDatadogAgentSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputDatadogAgent$Outbound =
  | InputDatadogAgentSendToRoutesTrueConstraint$Outbound
  | InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputDatadogAgentPqEnabledFalseConstraint$Outbound
  | InputDatadogAgentPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputDatadogAgent$outboundSchema: z.ZodType<
  InputDatadogAgent$Outbound,
  z.ZodTypeDef,
  InputDatadogAgent
> = z.union([
  z.lazy(() => InputDatadogAgentSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputDatadogAgentPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputDatadogAgentPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputDatadogAgentToJSON(
  inputDatadogAgent: InputDatadogAgent,
): string {
  return JSON.stringify(
    InputDatadogAgent$outboundSchema.parse(inputDatadogAgent),
  );
}

/** @internal */
export const InputCrowdstrikeType$outboundSchema: z.ZodNativeEnum<
  typeof InputCrowdstrikeType
> = z.nativeEnum(InputCrowdstrikeType);

/** @internal */
export type InputCrowdstrikePqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputCrowdstrikePqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputCrowdstrikePqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputCrowdstrikePqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputCrowdstrikeType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models
      .SignatureVersionOptionsS3CollectorConf$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    socketTimeout: z.number().optional(),
    skipOnError: z.boolean().optional(),
    includeSqsMetadata: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    enableSQSAssumeRole: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    checkpointing: models.CheckpointingType$outboundSchema.optional(),
    pollTimeout: z.number().optional(),
    encoding: z.string().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
      .optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

export function inputCrowdstrikePqEnabledTrueWithPqConstraintToJSON(
  inputCrowdstrikePqEnabledTrueWithPqConstraint:
    InputCrowdstrikePqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputCrowdstrikePqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputCrowdstrikePqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputCrowdstrikePqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputCrowdstrikePqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputCrowdstrikePqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputCrowdstrikePqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputCrowdstrikeType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  queueName: z.string(),
  fileFilter: z.string().optional(),
  awsAccountId: z.string().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptionsS3CollectorConf$outboundSchema
    .optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  maxMessages: z.number().optional(),
  visibilityTimeout: z.number().optional(),
  numReceivers: z.number().optional(),
  socketTimeout: z.number().optional(),
  skipOnError: z.boolean().optional(),
  includeSqsMetadata: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  enableSQSAssumeRole: z.boolean().optional(),
  preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
    .optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  checkpointing: models.CheckpointingType$outboundSchema.optional(),
  pollTimeout: z.number().optional(),
  encoding: z.string().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
    .optional(),
  processedTagKey: z.string().optional(),
  processedTagValue: z.string().optional(),
});

export function inputCrowdstrikePqEnabledFalseConstraintToJSON(
  inputCrowdstrikePqEnabledFalseConstraint:
    InputCrowdstrikePqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputCrowdstrikePqEnabledFalseConstraint$outboundSchema.parse(
      inputCrowdstrikePqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    queueName: string;
    fileFilter?: string | undefined;
    awsAccountId?: string | undefined;
    awsAuthenticationMethod?: string | undefined;
    awsSecretKey?: string | undefined;
    region?: string | undefined;
    endpoint?: string | undefined;
    signatureVersion?: string | undefined;
    reuseConnections?: boolean | undefined;
    rejectUnauthorized?: boolean | undefined;
    breakerRulesets?: Array<string> | undefined;
    staleChannelFlushMs?: number | undefined;
    maxMessages?: number | undefined;
    visibilityTimeout?: number | undefined;
    numReceivers?: number | undefined;
    socketTimeout?: number | undefined;
    skipOnError?: boolean | undefined;
    includeSqsMetadata?: boolean | undefined;
    enableAssumeRole?: boolean | undefined;
    assumeRoleArn?: string | undefined;
    assumeRoleExternalId?: string | undefined;
    durationSeconds?: number | undefined;
    enableSQSAssumeRole?: boolean | undefined;
    preprocess?:
      | models.PreprocessTypeSavedJobCollectionInput$Outbound
      | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    checkpointing?: models.CheckpointingType$Outbound | undefined;
    pollTimeout?: number | undefined;
    encoding?: string | undefined;
    description?: string | undefined;
    awsApiKey?: string | undefined;
    awsSecret?: string | undefined;
    tagAfterProcessing?: string | undefined;
    processedTagKey?: string | undefined;
    processedTagValue?: string | undefined;
  };

/** @internal */
export const InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputCrowdstrikeType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models
      .SignatureVersionOptionsS3CollectorConf$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    socketTimeout: z.number().optional(),
    skipOnError: z.boolean().optional(),
    includeSqsMetadata: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    enableSQSAssumeRole: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    checkpointing: models.CheckpointingType$outboundSchema.optional(),
    pollTimeout: z.number().optional(),
    encoding: z.string().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
      .optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

export function inputCrowdstrikeSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint:
    InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputCrowdstrikeSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  awsAccountId?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  maxMessages?: number | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  socketTimeout?: number | undefined;
  skipOnError?: boolean | undefined;
  includeSqsMetadata?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  enableSQSAssumeRole?: boolean | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  checkpointing?: models.CheckpointingType$Outbound | undefined;
  pollTimeout?: number | undefined;
  encoding?: string | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  tagAfterProcessing?: string | undefined;
  processedTagKey?: string | undefined;
  processedTagValue?: string | undefined;
};

/** @internal */
export const InputCrowdstrikeSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputCrowdstrikeSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputCrowdstrikeSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputCrowdstrikeType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    awsAccountId: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models
      .SignatureVersionOptionsS3CollectorConf$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    maxMessages: z.number().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    socketTimeout: z.number().optional(),
    skipOnError: z.boolean().optional(),
    includeSqsMetadata: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    enableSQSAssumeRole: z.boolean().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    checkpointing: models.CheckpointingType$outboundSchema.optional(),
    pollTimeout: z.number().optional(),
    encoding: z.string().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    tagAfterProcessing: models.TagAfterProcessingOptions$outboundSchema
      .optional(),
    processedTagKey: z.string().optional(),
    processedTagValue: z.string().optional(),
  });

export function inputCrowdstrikeSendToRoutesTrueConstraintToJSON(
  inputCrowdstrikeSendToRoutesTrueConstraint:
    InputCrowdstrikeSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputCrowdstrikeSendToRoutesTrueConstraint$outboundSchema.parse(
      inputCrowdstrikeSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputCrowdstrike$Outbound =
  | InputCrowdstrikeSendToRoutesTrueConstraint$Outbound
  | InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputCrowdstrikePqEnabledFalseConstraint$Outbound
  | InputCrowdstrikePqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputCrowdstrike$outboundSchema: z.ZodType<
  InputCrowdstrike$Outbound,
  z.ZodTypeDef,
  InputCrowdstrike
> = z.union([
  z.lazy(() => InputCrowdstrikeSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputCrowdstrikePqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputCrowdstrikePqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputCrowdstrikeToJSON(
  inputCrowdstrike: InputCrowdstrike,
): string {
  return JSON.stringify(
    InputCrowdstrike$outboundSchema.parse(inputCrowdstrike),
  );
}

/** @internal */
export const InputWindowsMetricsType$outboundSchema: z.ZodNativeEnum<
  typeof InputWindowsMetricsType
> = z.nativeEnum(InputWindowsMetricsType);

/** @internal */
export const InputWindowsMetricsSystemMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsSystemMode
> = openEnums.outboundSchema(InputWindowsMetricsSystemMode);

/** @internal */
export type InputWindowsMetricsSystem$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
};

/** @internal */
export const InputWindowsMetricsSystem$outboundSchema: z.ZodType<
  InputWindowsMetricsSystem$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsSystem
> = z.object({
  mode: InputWindowsMetricsSystemMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
});

export function inputWindowsMetricsSystemToJSON(
  inputWindowsMetricsSystem: InputWindowsMetricsSystem,
): string {
  return JSON.stringify(
    InputWindowsMetricsSystem$outboundSchema.parse(inputWindowsMetricsSystem),
  );
}

/** @internal */
export const InputWindowsMetricsCpuMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsCpuMode
> = openEnums.outboundSchema(InputWindowsMetricsCpuMode);

/** @internal */
export type InputWindowsMetricsCpu$Outbound = {
  mode?: string | undefined;
  perCpu?: boolean | undefined;
  detail?: boolean | undefined;
  time?: boolean | undefined;
};

/** @internal */
export const InputWindowsMetricsCpu$outboundSchema: z.ZodType<
  InputWindowsMetricsCpu$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsCpu
> = z.object({
  mode: InputWindowsMetricsCpuMode$outboundSchema.optional(),
  perCpu: z.boolean().optional(),
  detail: z.boolean().optional(),
  time: z.boolean().optional(),
});

export function inputWindowsMetricsCpuToJSON(
  inputWindowsMetricsCpu: InputWindowsMetricsCpu,
): string {
  return JSON.stringify(
    InputWindowsMetricsCpu$outboundSchema.parse(inputWindowsMetricsCpu),
  );
}

/** @internal */
export const InputWindowsMetricsMemoryMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsMemoryMode
> = openEnums.outboundSchema(InputWindowsMetricsMemoryMode);

/** @internal */
export type InputWindowsMetricsMemory$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
};

/** @internal */
export const InputWindowsMetricsMemory$outboundSchema: z.ZodType<
  InputWindowsMetricsMemory$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsMemory
> = z.object({
  mode: InputWindowsMetricsMemoryMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
});

export function inputWindowsMetricsMemoryToJSON(
  inputWindowsMetricsMemory: InputWindowsMetricsMemory,
): string {
  return JSON.stringify(
    InputWindowsMetricsMemory$outboundSchema.parse(inputWindowsMetricsMemory),
  );
}

/** @internal */
export const InputWindowsMetricsNetworkMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsNetworkMode
> = openEnums.outboundSchema(InputWindowsMetricsNetworkMode);

/** @internal */
export type InputWindowsMetricsNetwork$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
  protocols?: boolean | undefined;
  devices?: Array<string> | undefined;
  perInterface?: boolean | undefined;
};

/** @internal */
export const InputWindowsMetricsNetwork$outboundSchema: z.ZodType<
  InputWindowsMetricsNetwork$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsNetwork
> = z.object({
  mode: InputWindowsMetricsNetworkMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
  protocols: z.boolean().optional(),
  devices: z.array(z.string()).optional(),
  perInterface: z.boolean().optional(),
});

export function inputWindowsMetricsNetworkToJSON(
  inputWindowsMetricsNetwork: InputWindowsMetricsNetwork,
): string {
  return JSON.stringify(
    InputWindowsMetricsNetwork$outboundSchema.parse(inputWindowsMetricsNetwork),
  );
}

/** @internal */
export const InputWindowsMetricsDiskMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsDiskMode
> = openEnums.outboundSchema(InputWindowsMetricsDiskMode);

/** @internal */
export type InputWindowsMetricsDisk$Outbound = {
  mode?: string | undefined;
  perVolume?: boolean | undefined;
  detail?: boolean | undefined;
  volumes?: Array<string> | undefined;
};

/** @internal */
export const InputWindowsMetricsDisk$outboundSchema: z.ZodType<
  InputWindowsMetricsDisk$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsDisk
> = z.object({
  mode: InputWindowsMetricsDiskMode$outboundSchema.optional(),
  perVolume: z.boolean().optional(),
  detail: z.boolean().optional(),
  volumes: z.array(z.string()).optional(),
});

export function inputWindowsMetricsDiskToJSON(
  inputWindowsMetricsDisk: InputWindowsMetricsDisk,
): string {
  return JSON.stringify(
    InputWindowsMetricsDisk$outboundSchema.parse(inputWindowsMetricsDisk),
  );
}

/** @internal */
export type InputWindowsMetricsCustom$Outbound = {
  system?: InputWindowsMetricsSystem$Outbound | undefined;
  cpu?: InputWindowsMetricsCpu$Outbound | undefined;
  memory?: InputWindowsMetricsMemory$Outbound | undefined;
  network?: InputWindowsMetricsNetwork$Outbound | undefined;
  disk?: InputWindowsMetricsDisk$Outbound | undefined;
};

/** @internal */
export const InputWindowsMetricsCustom$outboundSchema: z.ZodType<
  InputWindowsMetricsCustom$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsCustom
> = z.object({
  system: z.lazy(() => InputWindowsMetricsSystem$outboundSchema).optional(),
  cpu: z.lazy(() => InputWindowsMetricsCpu$outboundSchema).optional(),
  memory: z.lazy(() => InputWindowsMetricsMemory$outboundSchema).optional(),
  network: z.lazy(() => InputWindowsMetricsNetwork$outboundSchema).optional(),
  disk: z.lazy(() => InputWindowsMetricsDisk$outboundSchema).optional(),
});

export function inputWindowsMetricsCustomToJSON(
  inputWindowsMetricsCustom: InputWindowsMetricsCustom,
): string {
  return JSON.stringify(
    InputWindowsMetricsCustom$outboundSchema.parse(inputWindowsMetricsCustom),
  );
}

/** @internal */
export type InputWindowsMetricsHost$Outbound = {
  mode?: string | undefined;
  custom?: InputWindowsMetricsCustom$Outbound | undefined;
};

/** @internal */
export const InputWindowsMetricsHost$outboundSchema: z.ZodType<
  InputWindowsMetricsHost$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsHost
> = z.object({
  mode: models.ModeOptionsHost$outboundSchema.optional(),
  custom: z.lazy(() => InputWindowsMetricsCustom$outboundSchema).optional(),
});

export function inputWindowsMetricsHostToJSON(
  inputWindowsMetricsHost: InputWindowsMetricsHost,
): string {
  return JSON.stringify(
    InputWindowsMetricsHost$outboundSchema.parse(inputWindowsMetricsHost),
  );
}

/** @internal */
export type InputWindowsMetricsPersistence$Outbound = {
  enable?: boolean | undefined;
  timeWindow?: string | undefined;
  maxDataSize?: string | undefined;
  maxDataTime?: string | undefined;
  compress?: string | undefined;
  destPath?: string | undefined;
};

/** @internal */
export const InputWindowsMetricsPersistence$outboundSchema: z.ZodType<
  InputWindowsMetricsPersistence$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsPersistence
> = z.object({
  enable: z.boolean().optional(),
  timeWindow: z.string().optional(),
  maxDataSize: z.string().optional(),
  maxDataTime: z.string().optional(),
  compress: models.DataCompressionFormatOptionsPersistence$outboundSchema
    .optional(),
  destPath: z.string().optional(),
});

export function inputWindowsMetricsPersistenceToJSON(
  inputWindowsMetricsPersistence: InputWindowsMetricsPersistence,
): string {
  return JSON.stringify(
    InputWindowsMetricsPersistence$outboundSchema.parse(
      inputWindowsMetricsPersistence,
    ),
  );
}

/** @internal */
export type InputWindowsMetricsPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  interval?: number | undefined;
  host?: InputWindowsMetricsHost$Outbound | undefined;
  process?: models.ProcessType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputWindowsMetricsPersistence$Outbound | undefined;
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputWindowsMetricsPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputWindowsMetricsPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputWindowsMetricsPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputWindowsMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    interval: z.number().optional(),
    host: z.lazy(() => InputWindowsMetricsHost$outboundSchema).optional(),
    process: models.ProcessType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputWindowsMetricsPqEnabledTrueWithPqConstraintToJSON(
  inputWindowsMetricsPqEnabledTrueWithPqConstraint:
    InputWindowsMetricsPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputWindowsMetricsPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputWindowsMetricsPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputWindowsMetricsPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  interval?: number | undefined;
  host?: InputWindowsMetricsHost$Outbound | undefined;
  process?: models.ProcessType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputWindowsMetricsPersistence$Outbound | undefined;
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputWindowsMetricsPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputWindowsMetricsPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputWindowsMetricsPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputWindowsMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    interval: z.number().optional(),
    host: z.lazy(() => InputWindowsMetricsHost$outboundSchema).optional(),
    process: models.ProcessType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputWindowsMetricsPqEnabledFalseConstraintToJSON(
  inputWindowsMetricsPqEnabledFalseConstraint:
    InputWindowsMetricsPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputWindowsMetricsPqEnabledFalseConstraint$outboundSchema.parse(
      inputWindowsMetricsPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    interval?: number | undefined;
    host?: InputWindowsMetricsHost$Outbound | undefined;
    process?: models.ProcessType$Outbound | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    persistence?: InputWindowsMetricsPersistence$Outbound | undefined;
    disableNativeModule?: boolean | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputWindowsMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    interval: z.number().optional(),
    host: z.lazy(() => InputWindowsMetricsHost$outboundSchema).optional(),
    process: models.ProcessType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint:
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputWindowsMetricsSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  interval?: number | undefined;
  host?: InputWindowsMetricsHost$Outbound | undefined;
  process?: models.ProcessType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputWindowsMetricsPersistence$Outbound | undefined;
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputWindowsMetricsSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputWindowsMetricsSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputWindowsMetricsSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputWindowsMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    interval: z.number().optional(),
    host: z.lazy(() => InputWindowsMetricsHost$outboundSchema).optional(),
    process: models.ProcessType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputWindowsMetricsSendToRoutesTrueConstraintToJSON(
  inputWindowsMetricsSendToRoutesTrueConstraint:
    InputWindowsMetricsSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputWindowsMetricsSendToRoutesTrueConstraint$outboundSchema.parse(
      inputWindowsMetricsSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputWindowsMetrics$Outbound =
  | InputWindowsMetricsSendToRoutesTrueConstraint$Outbound
  | InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputWindowsMetricsPqEnabledFalseConstraint$Outbound
  | InputWindowsMetricsPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputWindowsMetrics$outboundSchema: z.ZodType<
  InputWindowsMetrics$Outbound,
  z.ZodTypeDef,
  InputWindowsMetrics
> = z.union([
  z.lazy(() => InputWindowsMetricsSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputWindowsMetricsPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputWindowsMetricsPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputWindowsMetricsToJSON(
  inputWindowsMetrics: InputWindowsMetrics,
): string {
  return JSON.stringify(
    InputWindowsMetrics$outboundSchema.parse(inputWindowsMetrics),
  );
}

/** @internal */
export const InputKubeEventsType$outboundSchema: z.ZodNativeEnum<
  typeof InputKubeEventsType
> = z.nativeEnum(InputKubeEventsType);

/** @internal */
export type InputKubeEventsPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  rules?: Array<models.ItemsTypeRules$Outbound> | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKubeEventsPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputKubeEventsPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputKubeEventsPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputKubeEventsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    rules: z.array(models.ItemsTypeRules$outboundSchema).optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputKubeEventsPqEnabledTrueWithPqConstraintToJSON(
  inputKubeEventsPqEnabledTrueWithPqConstraint:
    InputKubeEventsPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputKubeEventsPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputKubeEventsPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputKubeEventsPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  rules?: Array<models.ItemsTypeRules$Outbound> | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKubeEventsPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputKubeEventsPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputKubeEventsPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputKubeEventsType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  rules: z.array(models.ItemsTypeRules$outboundSchema).optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputKubeEventsPqEnabledFalseConstraintToJSON(
  inputKubeEventsPqEnabledFalseConstraint:
    InputKubeEventsPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputKubeEventsPqEnabledFalseConstraint$outboundSchema.parse(
      inputKubeEventsPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputKubeEventsSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    rules?: Array<models.ItemsTypeRules$Outbound> | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputKubeEventsSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputKubeEventsSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputKubeEventsSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputKubeEventsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    rules: z.array(models.ItemsTypeRules$outboundSchema).optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputKubeEventsSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputKubeEventsSendToRoutesFalseWithConnectionsConstraint:
    InputKubeEventsSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputKubeEventsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputKubeEventsSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputKubeEventsSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  rules?: Array<models.ItemsTypeRules$Outbound> | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKubeEventsSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputKubeEventsSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputKubeEventsSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputKubeEventsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    rules: z.array(models.ItemsTypeRules$outboundSchema).optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputKubeEventsSendToRoutesTrueConstraintToJSON(
  inputKubeEventsSendToRoutesTrueConstraint:
    InputKubeEventsSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputKubeEventsSendToRoutesTrueConstraint$outboundSchema.parse(
      inputKubeEventsSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputKubeEvents$Outbound =
  | InputKubeEventsSendToRoutesTrueConstraint$Outbound
  | InputKubeEventsSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputKubeEventsPqEnabledFalseConstraint$Outbound
  | InputKubeEventsPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputKubeEvents$outboundSchema: z.ZodType<
  InputKubeEvents$Outbound,
  z.ZodTypeDef,
  InputKubeEvents
> = z.union([
  z.lazy(() => InputKubeEventsSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputKubeEventsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputKubeEventsPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputKubeEventsPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputKubeEventsToJSON(
  inputKubeEvents: InputKubeEvents,
): string {
  return JSON.stringify(InputKubeEvents$outboundSchema.parse(inputKubeEvents));
}

/** @internal */
export const InputKubeLogsType$outboundSchema: z.ZodNativeEnum<
  typeof InputKubeLogsType
> = z.nativeEnum(InputKubeLogsType);

/** @internal */
export type InputKubeLogsRule$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const InputKubeLogsRule$outboundSchema: z.ZodType<
  InputKubeLogsRule$Outbound,
  z.ZodTypeDef,
  InputKubeLogsRule
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

export function inputKubeLogsRuleToJSON(
  inputKubeLogsRule: InputKubeLogsRule,
): string {
  return JSON.stringify(
    InputKubeLogsRule$outboundSchema.parse(inputKubeLogsRule),
  );
}

/** @internal */
export type InputKubeLogsPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  interval?: number | undefined;
  rules?: Array<InputKubeLogsRule$Outbound> | undefined;
  timestamps?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: models.DiskSpoolingType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKubeLogsPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputKubeLogsPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputKubeLogsPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputKubeLogsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    interval: z.number().optional(),
    rules: z.array(z.lazy(() => InputKubeLogsRule$outboundSchema)).optional(),
    timestamps: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: models.DiskSpoolingType$outboundSchema.optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    enableLoadBalancing: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputKubeLogsPqEnabledTrueWithPqConstraintToJSON(
  inputKubeLogsPqEnabledTrueWithPqConstraint:
    InputKubeLogsPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputKubeLogsPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputKubeLogsPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputKubeLogsPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  interval?: number | undefined;
  rules?: Array<InputKubeLogsRule$Outbound> | undefined;
  timestamps?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: models.DiskSpoolingType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKubeLogsPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputKubeLogsPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputKubeLogsPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputKubeLogsType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  interval: z.number().optional(),
  rules: z.array(z.lazy(() => InputKubeLogsRule$outboundSchema)).optional(),
  timestamps: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  persistence: models.DiskSpoolingType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  enableLoadBalancing: z.boolean().optional(),
  description: z.string().optional(),
});

export function inputKubeLogsPqEnabledFalseConstraintToJSON(
  inputKubeLogsPqEnabledFalseConstraint: InputKubeLogsPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputKubeLogsPqEnabledFalseConstraint$outboundSchema.parse(
      inputKubeLogsPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputKubeLogsSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  interval?: number | undefined;
  rules?: Array<InputKubeLogsRule$Outbound> | undefined;
  timestamps?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: models.DiskSpoolingType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKubeLogsSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputKubeLogsSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputKubeLogsSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputKubeLogsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    interval: z.number().optional(),
    rules: z.array(z.lazy(() => InputKubeLogsRule$outboundSchema)).optional(),
    timestamps: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: models.DiskSpoolingType$outboundSchema.optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    enableLoadBalancing: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputKubeLogsSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputKubeLogsSendToRoutesFalseWithConnectionsConstraint:
    InputKubeLogsSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputKubeLogsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputKubeLogsSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputKubeLogsSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  interval?: number | undefined;
  rules?: Array<InputKubeLogsRule$Outbound> | undefined;
  timestamps?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: models.DiskSpoolingType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  enableLoadBalancing?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKubeLogsSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputKubeLogsSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputKubeLogsSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputKubeLogsType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  interval: z.number().optional(),
  rules: z.array(z.lazy(() => InputKubeLogsRule$outboundSchema)).optional(),
  timestamps: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  persistence: models.DiskSpoolingType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  enableLoadBalancing: z.boolean().optional(),
  description: z.string().optional(),
});

export function inputKubeLogsSendToRoutesTrueConstraintToJSON(
  inputKubeLogsSendToRoutesTrueConstraint:
    InputKubeLogsSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputKubeLogsSendToRoutesTrueConstraint$outboundSchema.parse(
      inputKubeLogsSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputKubeLogs$Outbound =
  | InputKubeLogsSendToRoutesTrueConstraint$Outbound
  | InputKubeLogsSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputKubeLogsPqEnabledFalseConstraint$Outbound
  | InputKubeLogsPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputKubeLogs$outboundSchema: z.ZodType<
  InputKubeLogs$Outbound,
  z.ZodTypeDef,
  InputKubeLogs
> = z.union([
  z.lazy(() => InputKubeLogsSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputKubeLogsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputKubeLogsPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputKubeLogsPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputKubeLogsToJSON(inputKubeLogs: InputKubeLogs): string {
  return JSON.stringify(InputKubeLogs$outboundSchema.parse(inputKubeLogs));
}

/** @internal */
export const InputKubeMetricsType$outboundSchema: z.ZodNativeEnum<
  typeof InputKubeMetricsType
> = z.nativeEnum(InputKubeMetricsType);

/** @internal */
export type InputKubeMetricsPersistence$Outbound = {
  enable?: boolean | undefined;
  timeWindow?: string | undefined;
  maxDataSize?: string | undefined;
  maxDataTime?: string | undefined;
  compress?: string | undefined;
  destPath?: string | undefined;
};

/** @internal */
export const InputKubeMetricsPersistence$outboundSchema: z.ZodType<
  InputKubeMetricsPersistence$Outbound,
  z.ZodTypeDef,
  InputKubeMetricsPersistence
> = z.object({
  enable: z.boolean().optional(),
  timeWindow: z.string().optional(),
  maxDataSize: z.string().optional(),
  maxDataTime: z.string().optional(),
  compress: models.DataCompressionFormatOptionsPersistence$outboundSchema
    .optional(),
  destPath: z.string().optional(),
});

export function inputKubeMetricsPersistenceToJSON(
  inputKubeMetricsPersistence: InputKubeMetricsPersistence,
): string {
  return JSON.stringify(
    InputKubeMetricsPersistence$outboundSchema.parse(
      inputKubeMetricsPersistence,
    ),
  );
}

/** @internal */
export type InputKubeMetricsPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  interval?: number | undefined;
  rules?: Array<models.ItemsTypeRules$Outbound> | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputKubeMetricsPersistence$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKubeMetricsPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputKubeMetricsPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputKubeMetricsPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputKubeMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    interval: z.number().optional(),
    rules: z.array(models.ItemsTypeRules$outboundSchema).optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: z.lazy(() => InputKubeMetricsPersistence$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputKubeMetricsPqEnabledTrueWithPqConstraintToJSON(
  inputKubeMetricsPqEnabledTrueWithPqConstraint:
    InputKubeMetricsPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputKubeMetricsPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputKubeMetricsPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputKubeMetricsPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  interval?: number | undefined;
  rules?: Array<models.ItemsTypeRules$Outbound> | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputKubeMetricsPersistence$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKubeMetricsPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputKubeMetricsPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputKubeMetricsPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputKubeMetricsType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  interval: z.number().optional(),
  rules: z.array(models.ItemsTypeRules$outboundSchema).optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  persistence: z.lazy(() => InputKubeMetricsPersistence$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputKubeMetricsPqEnabledFalseConstraintToJSON(
  inputKubeMetricsPqEnabledFalseConstraint:
    InputKubeMetricsPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputKubeMetricsPqEnabledFalseConstraint$outboundSchema.parse(
      inputKubeMetricsPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    interval?: number | undefined;
    rules?: Array<models.ItemsTypeRules$Outbound> | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    persistence?: InputKubeMetricsPersistence$Outbound | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputKubeMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    interval: z.number().optional(),
    rules: z.array(models.ItemsTypeRules$outboundSchema).optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: z.lazy(() => InputKubeMetricsPersistence$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputKubeMetricsSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputKubeMetricsSendToRoutesFalseWithConnectionsConstraint:
    InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputKubeMetricsSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputKubeMetricsSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  interval?: number | undefined;
  rules?: Array<models.ItemsTypeRules$Outbound> | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputKubeMetricsPersistence$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKubeMetricsSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputKubeMetricsSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputKubeMetricsSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputKubeMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    interval: z.number().optional(),
    rules: z.array(models.ItemsTypeRules$outboundSchema).optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: z.lazy(() => InputKubeMetricsPersistence$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputKubeMetricsSendToRoutesTrueConstraintToJSON(
  inputKubeMetricsSendToRoutesTrueConstraint:
    InputKubeMetricsSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputKubeMetricsSendToRoutesTrueConstraint$outboundSchema.parse(
      inputKubeMetricsSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputKubeMetrics$Outbound =
  | InputKubeMetricsSendToRoutesTrueConstraint$Outbound
  | InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputKubeMetricsPqEnabledFalseConstraint$Outbound
  | InputKubeMetricsPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputKubeMetrics$outboundSchema: z.ZodType<
  InputKubeMetrics$Outbound,
  z.ZodTypeDef,
  InputKubeMetrics
> = z.union([
  z.lazy(() => InputKubeMetricsSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputKubeMetricsPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputKubeMetricsPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputKubeMetricsToJSON(
  inputKubeMetrics: InputKubeMetrics,
): string {
  return JSON.stringify(
    InputKubeMetrics$outboundSchema.parse(inputKubeMetrics),
  );
}

/** @internal */
export const InputSystemStateType$outboundSchema: z.ZodNativeEnum<
  typeof InputSystemStateType
> = z.nativeEnum(InputSystemStateType);

/** @internal */
export type HostsFile$Outbound = {
  enable?: boolean | undefined;
};

/** @internal */
export const HostsFile$outboundSchema: z.ZodType<
  HostsFile$Outbound,
  z.ZodTypeDef,
  HostsFile
> = z.object({
  enable: z.boolean().optional(),
});

export function hostsFileToJSON(hostsFile: HostsFile): string {
  return JSON.stringify(HostsFile$outboundSchema.parse(hostsFile));
}

/** @internal */
export type Interfaces$Outbound = {
  enable?: boolean | undefined;
};

/** @internal */
export const Interfaces$outboundSchema: z.ZodType<
  Interfaces$Outbound,
  z.ZodTypeDef,
  Interfaces
> = z.object({
  enable: z.boolean().optional(),
});

export function interfacesToJSON(interfaces: Interfaces): string {
  return JSON.stringify(Interfaces$outboundSchema.parse(interfaces));
}

/** @internal */
export type DisksAndFileSystems$Outbound = {
  enable?: boolean | undefined;
};

/** @internal */
export const DisksAndFileSystems$outboundSchema: z.ZodType<
  DisksAndFileSystems$Outbound,
  z.ZodTypeDef,
  DisksAndFileSystems
> = z.object({
  enable: z.boolean().optional(),
});

export function disksAndFileSystemsToJSON(
  disksAndFileSystems: DisksAndFileSystems,
): string {
  return JSON.stringify(
    DisksAndFileSystems$outboundSchema.parse(disksAndFileSystems),
  );
}

/** @internal */
export type HostInfo$Outbound = {
  enable?: boolean | undefined;
};

/** @internal */
export const HostInfo$outboundSchema: z.ZodType<
  HostInfo$Outbound,
  z.ZodTypeDef,
  HostInfo
> = z.object({
  enable: z.boolean().optional(),
});

export function hostInfoToJSON(hostInfo: HostInfo): string {
  return JSON.stringify(HostInfo$outboundSchema.parse(hostInfo));
}

/** @internal */
export type Routes$Outbound = {
  enable?: boolean | undefined;
};

/** @internal */
export const Routes$outboundSchema: z.ZodType<
  Routes$Outbound,
  z.ZodTypeDef,
  Routes
> = z.object({
  enable: z.boolean().optional(),
});

export function routesToJSON(routes: Routes): string {
  return JSON.stringify(Routes$outboundSchema.parse(routes));
}

/** @internal */
export type Dns$Outbound = {
  enable?: boolean | undefined;
};

/** @internal */
export const Dns$outboundSchema: z.ZodType<Dns$Outbound, z.ZodTypeDef, Dns> = z
  .object({
    enable: z.boolean().optional(),
  });

export function dnsToJSON(dns: Dns): string {
  return JSON.stringify(Dns$outboundSchema.parse(dns));
}

/** @internal */
export type UsersAndGroups$Outbound = {
  enable?: boolean | undefined;
};

/** @internal */
export const UsersAndGroups$outboundSchema: z.ZodType<
  UsersAndGroups$Outbound,
  z.ZodTypeDef,
  UsersAndGroups
> = z.object({
  enable: z.boolean().optional(),
});

export function usersAndGroupsToJSON(usersAndGroups: UsersAndGroups): string {
  return JSON.stringify(UsersAndGroups$outboundSchema.parse(usersAndGroups));
}

/** @internal */
export type Firewall$Outbound = {
  enable?: boolean | undefined;
};

/** @internal */
export const Firewall$outboundSchema: z.ZodType<
  Firewall$Outbound,
  z.ZodTypeDef,
  Firewall
> = z.object({
  enable: z.boolean().optional(),
});

export function firewallToJSON(firewall: Firewall): string {
  return JSON.stringify(Firewall$outboundSchema.parse(firewall));
}

/** @internal */
export type Services$Outbound = {
  enable?: boolean | undefined;
};

/** @internal */
export const Services$outboundSchema: z.ZodType<
  Services$Outbound,
  z.ZodTypeDef,
  Services
> = z.object({
  enable: z.boolean().optional(),
});

export function servicesToJSON(services: Services): string {
  return JSON.stringify(Services$outboundSchema.parse(services));
}

/** @internal */
export type ListeningPorts$Outbound = {
  enable?: boolean | undefined;
};

/** @internal */
export const ListeningPorts$outboundSchema: z.ZodType<
  ListeningPorts$Outbound,
  z.ZodTypeDef,
  ListeningPorts
> = z.object({
  enable: z.boolean().optional(),
});

export function listeningPortsToJSON(listeningPorts: ListeningPorts): string {
  return JSON.stringify(ListeningPorts$outboundSchema.parse(listeningPorts));
}

/** @internal */
export type LoggedInUsers$Outbound = {
  enable?: boolean | undefined;
};

/** @internal */
export const LoggedInUsers$outboundSchema: z.ZodType<
  LoggedInUsers$Outbound,
  z.ZodTypeDef,
  LoggedInUsers
> = z.object({
  enable: z.boolean().optional(),
});

export function loggedInUsersToJSON(loggedInUsers: LoggedInUsers): string {
  return JSON.stringify(LoggedInUsers$outboundSchema.parse(loggedInUsers));
}

/** @internal */
export type Collectors$Outbound = {
  hostsfile?: HostsFile$Outbound | undefined;
  interfaces?: Interfaces$Outbound | undefined;
  disk?: DisksAndFileSystems$Outbound | undefined;
  metadata?: HostInfo$Outbound | undefined;
  routes?: Routes$Outbound | undefined;
  dns?: Dns$Outbound | undefined;
  user?: UsersAndGroups$Outbound | undefined;
  firewall?: Firewall$Outbound | undefined;
  services?: Services$Outbound | undefined;
  ports?: ListeningPorts$Outbound | undefined;
  loginUsers?: LoggedInUsers$Outbound | undefined;
};

/** @internal */
export const Collectors$outboundSchema: z.ZodType<
  Collectors$Outbound,
  z.ZodTypeDef,
  Collectors
> = z.object({
  hostsfile: z.lazy(() => HostsFile$outboundSchema).optional(),
  interfaces: z.lazy(() => Interfaces$outboundSchema).optional(),
  disk: z.lazy(() => DisksAndFileSystems$outboundSchema).optional(),
  metadata: z.lazy(() => HostInfo$outboundSchema).optional(),
  routes: z.lazy(() => Routes$outboundSchema).optional(),
  dns: z.lazy(() => Dns$outboundSchema).optional(),
  user: z.lazy(() => UsersAndGroups$outboundSchema).optional(),
  firewall: z.lazy(() => Firewall$outboundSchema).optional(),
  services: z.lazy(() => Services$outboundSchema).optional(),
  ports: z.lazy(() => ListeningPorts$outboundSchema).optional(),
  loginUsers: z.lazy(() => LoggedInUsers$outboundSchema).optional(),
});

export function collectorsToJSON(collectors: Collectors): string {
  return JSON.stringify(Collectors$outboundSchema.parse(collectors));
}

/** @internal */
export type InputSystemStatePersistence$Outbound = {
  enable?: boolean | undefined;
  timeWindow?: string | undefined;
  maxDataSize?: string | undefined;
  maxDataTime?: string | undefined;
  compress?: string | undefined;
  destPath?: string | undefined;
};

/** @internal */
export const InputSystemStatePersistence$outboundSchema: z.ZodType<
  InputSystemStatePersistence$Outbound,
  z.ZodTypeDef,
  InputSystemStatePersistence
> = z.object({
  enable: z.boolean().optional(),
  timeWindow: z.string().optional(),
  maxDataSize: z.string().optional(),
  maxDataTime: z.string().optional(),
  compress: models.DataCompressionFormatOptionsPersistence$outboundSchema
    .optional(),
  destPath: z.string().optional(),
});

export function inputSystemStatePersistenceToJSON(
  inputSystemStatePersistence: InputSystemStatePersistence,
): string {
  return JSON.stringify(
    InputSystemStatePersistence$outboundSchema.parse(
      inputSystemStatePersistence,
    ),
  );
}

/** @internal */
export type InputSystemStatePqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  interval?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  collectors?: Collectors$Outbound | undefined;
  persistence?: InputSystemStatePersistence$Outbound | undefined;
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemStatePqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputSystemStatePqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputSystemStatePqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputSystemStateType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    interval: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    collectors: z.lazy(() => Collectors$outboundSchema).optional(),
    persistence: z.lazy(() => InputSystemStatePersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputSystemStatePqEnabledTrueWithPqConstraintToJSON(
  inputSystemStatePqEnabledTrueWithPqConstraint:
    InputSystemStatePqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputSystemStatePqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputSystemStatePqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputSystemStatePqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  interval?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  collectors?: Collectors$Outbound | undefined;
  persistence?: InputSystemStatePersistence$Outbound | undefined;
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemStatePqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputSystemStatePqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputSystemStatePqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputSystemStateType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  interval: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  collectors: z.lazy(() => Collectors$outboundSchema).optional(),
  persistence: z.lazy(() => InputSystemStatePersistence$outboundSchema)
    .optional(),
  disableNativeModule: z.boolean().optional(),
  description: z.string().optional(),
});

export function inputSystemStatePqEnabledFalseConstraintToJSON(
  inputSystemStatePqEnabledFalseConstraint:
    InputSystemStatePqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputSystemStatePqEnabledFalseConstraint$outboundSchema.parse(
      inputSystemStatePqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputSystemStateSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    interval?: number | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    collectors?: Collectors$Outbound | undefined;
    persistence?: InputSystemStatePersistence$Outbound | undefined;
    disableNativeModule?: boolean | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputSystemStateSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputSystemStateType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    interval: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    collectors: z.lazy(() => Collectors$outboundSchema).optional(),
    persistence: z.lazy(() => InputSystemStatePersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputSystemStateSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputSystemStateSendToRoutesFalseWithConnectionsConstraint:
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputSystemStateSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputSystemStateSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  interval?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  collectors?: Collectors$Outbound | undefined;
  persistence?: InputSystemStatePersistence$Outbound | undefined;
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemStateSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputSystemStateSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputSystemStateSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputSystemStateType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    interval: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    collectors: z.lazy(() => Collectors$outboundSchema).optional(),
    persistence: z.lazy(() => InputSystemStatePersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputSystemStateSendToRoutesTrueConstraintToJSON(
  inputSystemStateSendToRoutesTrueConstraint:
    InputSystemStateSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputSystemStateSendToRoutesTrueConstraint$outboundSchema.parse(
      inputSystemStateSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputSystemState$Outbound =
  | InputSystemStateSendToRoutesTrueConstraint$Outbound
  | InputSystemStateSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputSystemStatePqEnabledFalseConstraint$Outbound
  | InputSystemStatePqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputSystemState$outboundSchema: z.ZodType<
  InputSystemState$Outbound,
  z.ZodTypeDef,
  InputSystemState
> = z.union([
  z.lazy(() => InputSystemStateSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputSystemStatePqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputSystemStatePqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputSystemStateToJSON(
  inputSystemState: InputSystemState,
): string {
  return JSON.stringify(
    InputSystemState$outboundSchema.parse(inputSystemState),
  );
}

/** @internal */
export const InputSystemMetricsType$outboundSchema: z.ZodNativeEnum<
  typeof InputSystemMetricsType
> = z.nativeEnum(InputSystemMetricsType);

/** @internal */
export const InputSystemMetricsSystemMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsSystemMode
> = openEnums.outboundSchema(InputSystemMetricsSystemMode);

/** @internal */
export type InputSystemMetricsSystem$Outbound = {
  mode?: string | undefined;
  processes?: boolean | undefined;
};

/** @internal */
export const InputSystemMetricsSystem$outboundSchema: z.ZodType<
  InputSystemMetricsSystem$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsSystem
> = z.object({
  mode: InputSystemMetricsSystemMode$outboundSchema.optional(),
  processes: z.boolean().optional(),
});

export function inputSystemMetricsSystemToJSON(
  inputSystemMetricsSystem: InputSystemMetricsSystem,
): string {
  return JSON.stringify(
    InputSystemMetricsSystem$outboundSchema.parse(inputSystemMetricsSystem),
  );
}

/** @internal */
export const InputSystemMetricsCpuMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsCpuMode
> = openEnums.outboundSchema(InputSystemMetricsCpuMode);

/** @internal */
export type InputSystemMetricsCpu$Outbound = {
  mode?: string | undefined;
  perCpu?: boolean | undefined;
  detail?: boolean | undefined;
  time?: boolean | undefined;
};

/** @internal */
export const InputSystemMetricsCpu$outboundSchema: z.ZodType<
  InputSystemMetricsCpu$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsCpu
> = z.object({
  mode: InputSystemMetricsCpuMode$outboundSchema.optional(),
  perCpu: z.boolean().optional(),
  detail: z.boolean().optional(),
  time: z.boolean().optional(),
});

export function inputSystemMetricsCpuToJSON(
  inputSystemMetricsCpu: InputSystemMetricsCpu,
): string {
  return JSON.stringify(
    InputSystemMetricsCpu$outboundSchema.parse(inputSystemMetricsCpu),
  );
}

/** @internal */
export const InputSystemMetricsMemoryMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsMemoryMode
> = openEnums.outboundSchema(InputSystemMetricsMemoryMode);

/** @internal */
export type InputSystemMetricsMemory$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
};

/** @internal */
export const InputSystemMetricsMemory$outboundSchema: z.ZodType<
  InputSystemMetricsMemory$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsMemory
> = z.object({
  mode: InputSystemMetricsMemoryMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
});

export function inputSystemMetricsMemoryToJSON(
  inputSystemMetricsMemory: InputSystemMetricsMemory,
): string {
  return JSON.stringify(
    InputSystemMetricsMemory$outboundSchema.parse(inputSystemMetricsMemory),
  );
}

/** @internal */
export const InputSystemMetricsNetworkMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsNetworkMode
> = openEnums.outboundSchema(InputSystemMetricsNetworkMode);

/** @internal */
export type InputSystemMetricsNetwork$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
  protocols?: boolean | undefined;
  devices?: Array<string> | undefined;
  perInterface?: boolean | undefined;
};

/** @internal */
export const InputSystemMetricsNetwork$outboundSchema: z.ZodType<
  InputSystemMetricsNetwork$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsNetwork
> = z.object({
  mode: InputSystemMetricsNetworkMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
  protocols: z.boolean().optional(),
  devices: z.array(z.string()).optional(),
  perInterface: z.boolean().optional(),
});

export function inputSystemMetricsNetworkToJSON(
  inputSystemMetricsNetwork: InputSystemMetricsNetwork,
): string {
  return JSON.stringify(
    InputSystemMetricsNetwork$outboundSchema.parse(inputSystemMetricsNetwork),
  );
}

/** @internal */
export const InputSystemMetricsDiskMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsDiskMode
> = openEnums.outboundSchema(InputSystemMetricsDiskMode);

/** @internal */
export type InputSystemMetricsDisk$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
  inodes?: boolean | undefined;
  devices?: Array<string> | undefined;
  mountpoints?: Array<string> | undefined;
  fstypes?: Array<string> | undefined;
  perDevice?: boolean | undefined;
};

/** @internal */
export const InputSystemMetricsDisk$outboundSchema: z.ZodType<
  InputSystemMetricsDisk$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsDisk
> = z.object({
  mode: InputSystemMetricsDiskMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
  inodes: z.boolean().optional(),
  devices: z.array(z.string()).optional(),
  mountpoints: z.array(z.string()).optional(),
  fstypes: z.array(z.string()).optional(),
  perDevice: z.boolean().optional(),
});

export function inputSystemMetricsDiskToJSON(
  inputSystemMetricsDisk: InputSystemMetricsDisk,
): string {
  return JSON.stringify(
    InputSystemMetricsDisk$outboundSchema.parse(inputSystemMetricsDisk),
  );
}

/** @internal */
export type InputSystemMetricsCustom$Outbound = {
  system?: InputSystemMetricsSystem$Outbound | undefined;
  cpu?: InputSystemMetricsCpu$Outbound | undefined;
  memory?: InputSystemMetricsMemory$Outbound | undefined;
  network?: InputSystemMetricsNetwork$Outbound | undefined;
  disk?: InputSystemMetricsDisk$Outbound | undefined;
};

/** @internal */
export const InputSystemMetricsCustom$outboundSchema: z.ZodType<
  InputSystemMetricsCustom$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsCustom
> = z.object({
  system: z.lazy(() => InputSystemMetricsSystem$outboundSchema).optional(),
  cpu: z.lazy(() => InputSystemMetricsCpu$outboundSchema).optional(),
  memory: z.lazy(() => InputSystemMetricsMemory$outboundSchema).optional(),
  network: z.lazy(() => InputSystemMetricsNetwork$outboundSchema).optional(),
  disk: z.lazy(() => InputSystemMetricsDisk$outboundSchema).optional(),
});

export function inputSystemMetricsCustomToJSON(
  inputSystemMetricsCustom: InputSystemMetricsCustom,
): string {
  return JSON.stringify(
    InputSystemMetricsCustom$outboundSchema.parse(inputSystemMetricsCustom),
  );
}

/** @internal */
export type InputSystemMetricsHost$Outbound = {
  mode?: string | undefined;
  custom?: InputSystemMetricsCustom$Outbound | undefined;
};

/** @internal */
export const InputSystemMetricsHost$outboundSchema: z.ZodType<
  InputSystemMetricsHost$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsHost
> = z.object({
  mode: models.ModeOptionsHost$outboundSchema.optional(),
  custom: z.lazy(() => InputSystemMetricsCustom$outboundSchema).optional(),
});

export function inputSystemMetricsHostToJSON(
  inputSystemMetricsHost: InputSystemMetricsHost,
): string {
  return JSON.stringify(
    InputSystemMetricsHost$outboundSchema.parse(inputSystemMetricsHost),
  );
}

/** @internal */
export const ContainerMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ContainerMode
> = openEnums.outboundSchema(ContainerMode);

/** @internal */
export type InputSystemMetricsFilter$Outbound = {
  expr: string;
};

/** @internal */
export const InputSystemMetricsFilter$outboundSchema: z.ZodType<
  InputSystemMetricsFilter$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsFilter
> = z.object({
  expr: z.string(),
});

export function inputSystemMetricsFilterToJSON(
  inputSystemMetricsFilter: InputSystemMetricsFilter,
): string {
  return JSON.stringify(
    InputSystemMetricsFilter$outboundSchema.parse(inputSystemMetricsFilter),
  );
}

/** @internal */
export type Container$Outbound = {
  mode?: string | undefined;
  dockerSocket?: Array<string> | undefined;
  dockerTimeout?: number | undefined;
  filters?: Array<InputSystemMetricsFilter$Outbound> | undefined;
  allContainers?: boolean | undefined;
  perDevice?: boolean | undefined;
  detail?: boolean | undefined;
};

/** @internal */
export const Container$outboundSchema: z.ZodType<
  Container$Outbound,
  z.ZodTypeDef,
  Container
> = z.object({
  mode: ContainerMode$outboundSchema.optional(),
  dockerSocket: z.array(z.string()).optional(),
  dockerTimeout: z.number().optional(),
  filters: z.array(z.lazy(() => InputSystemMetricsFilter$outboundSchema))
    .optional(),
  allContainers: z.boolean().optional(),
  perDevice: z.boolean().optional(),
  detail: z.boolean().optional(),
});

export function containerToJSON(container: Container): string {
  return JSON.stringify(Container$outboundSchema.parse(container));
}

/** @internal */
export type InputSystemMetricsPersistence$Outbound = {
  enable?: boolean | undefined;
  timeWindow?: string | undefined;
  maxDataSize?: string | undefined;
  maxDataTime?: string | undefined;
  compress?: string | undefined;
  destPath?: string | undefined;
};

/** @internal */
export const InputSystemMetricsPersistence$outboundSchema: z.ZodType<
  InputSystemMetricsPersistence$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsPersistence
> = z.object({
  enable: z.boolean().optional(),
  timeWindow: z.string().optional(),
  maxDataSize: z.string().optional(),
  maxDataTime: z.string().optional(),
  compress: models.DataCompressionFormatOptionsPersistence$outboundSchema
    .optional(),
  destPath: z.string().optional(),
});

export function inputSystemMetricsPersistenceToJSON(
  inputSystemMetricsPersistence: InputSystemMetricsPersistence,
): string {
  return JSON.stringify(
    InputSystemMetricsPersistence$outboundSchema.parse(
      inputSystemMetricsPersistence,
    ),
  );
}

/** @internal */
export type InputSystemMetricsPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  interval?: number | undefined;
  host?: InputSystemMetricsHost$Outbound | undefined;
  process?: models.ProcessType$Outbound | undefined;
  container?: Container$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputSystemMetricsPersistence$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemMetricsPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputSystemMetricsPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputSystemMetricsPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputSystemMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    interval: z.number().optional(),
    host: z.lazy(() => InputSystemMetricsHost$outboundSchema).optional(),
    process: models.ProcessType$outboundSchema.optional(),
    container: z.lazy(() => Container$outboundSchema).optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: z.lazy(() => InputSystemMetricsPersistence$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputSystemMetricsPqEnabledTrueWithPqConstraintToJSON(
  inputSystemMetricsPqEnabledTrueWithPqConstraint:
    InputSystemMetricsPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputSystemMetricsPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputSystemMetricsPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputSystemMetricsPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  interval?: number | undefined;
  host?: InputSystemMetricsHost$Outbound | undefined;
  process?: models.ProcessType$Outbound | undefined;
  container?: Container$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputSystemMetricsPersistence$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemMetricsPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputSystemMetricsPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputSystemMetricsPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputSystemMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    interval: z.number().optional(),
    host: z.lazy(() => InputSystemMetricsHost$outboundSchema).optional(),
    process: models.ProcessType$outboundSchema.optional(),
    container: z.lazy(() => Container$outboundSchema).optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: z.lazy(() => InputSystemMetricsPersistence$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputSystemMetricsPqEnabledFalseConstraintToJSON(
  inputSystemMetricsPqEnabledFalseConstraint:
    InputSystemMetricsPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputSystemMetricsPqEnabledFalseConstraint$outboundSchema.parse(
      inputSystemMetricsPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    interval?: number | undefined;
    host?: InputSystemMetricsHost$Outbound | undefined;
    process?: models.ProcessType$Outbound | undefined;
    container?: Container$Outbound | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    persistence?: InputSystemMetricsPersistence$Outbound | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputSystemMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    interval: z.number().optional(),
    host: z.lazy(() => InputSystemMetricsHost$outboundSchema).optional(),
    process: models.ProcessType$outboundSchema.optional(),
    container: z.lazy(() => Container$outboundSchema).optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: z.lazy(() => InputSystemMetricsPersistence$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputSystemMetricsSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputSystemMetricsSendToRoutesFalseWithConnectionsConstraint:
    InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputSystemMetricsSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputSystemMetricsSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  interval?: number | undefined;
  host?: InputSystemMetricsHost$Outbound | undefined;
  process?: models.ProcessType$Outbound | undefined;
  container?: Container$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputSystemMetricsPersistence$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemMetricsSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputSystemMetricsSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputSystemMetricsSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputSystemMetricsType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    interval: z.number().optional(),
    host: z.lazy(() => InputSystemMetricsHost$outboundSchema).optional(),
    process: models.ProcessType$outboundSchema.optional(),
    container: z.lazy(() => Container$outboundSchema).optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    persistence: z.lazy(() => InputSystemMetricsPersistence$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputSystemMetricsSendToRoutesTrueConstraintToJSON(
  inputSystemMetricsSendToRoutesTrueConstraint:
    InputSystemMetricsSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputSystemMetricsSendToRoutesTrueConstraint$outboundSchema.parse(
      inputSystemMetricsSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputSystemMetrics$Outbound =
  | InputSystemMetricsSendToRoutesTrueConstraint$Outbound
  | InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputSystemMetricsPqEnabledFalseConstraint$Outbound
  | InputSystemMetricsPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputSystemMetrics$outboundSchema: z.ZodType<
  InputSystemMetrics$Outbound,
  z.ZodTypeDef,
  InputSystemMetrics
> = z.union([
  z.lazy(() => InputSystemMetricsSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputSystemMetricsPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputSystemMetricsPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputSystemMetricsToJSON(
  inputSystemMetrics: InputSystemMetrics,
): string {
  return JSON.stringify(
    InputSystemMetrics$outboundSchema.parse(inputSystemMetrics),
  );
}

/** @internal */
export const InputTcpjsonType$outboundSchema: z.ZodNativeEnum<
  typeof InputTcpjsonType
> = z.nativeEnum(InputTcpjsonType);

/** @internal */
export type InputTcpjsonPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  enableLoadBalancing?: boolean | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcpjsonPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputTcpjsonPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputTcpjsonPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputTcpjsonType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    ipWhitelistRegex: z.string().optional(),
    maxActiveCxn: z.number().optional(),
    socketIdleTimeout: z.number().optional(),
    socketEndingMaxWait: z.number().optional(),
    socketMaxLifespan: z.number().optional(),
    enableProxyHeader: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    enableLoadBalancing: z.boolean().optional(),
    authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
      .optional(),
    description: z.string().optional(),
    authToken: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputTcpjsonPqEnabledTrueWithPqConstraintToJSON(
  inputTcpjsonPqEnabledTrueWithPqConstraint:
    InputTcpjsonPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputTcpjsonPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputTcpjsonPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputTcpjsonPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  enableLoadBalancing?: boolean | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcpjsonPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputTcpjsonPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputTcpjsonPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputTcpjsonType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  enableLoadBalancing: z.boolean().optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  description: z.string().optional(),
  authToken: z.string().optional(),
  textSecret: z.string().optional(),
});

export function inputTcpjsonPqEnabledFalseConstraintToJSON(
  inputTcpjsonPqEnabledFalseConstraint: InputTcpjsonPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputTcpjsonPqEnabledFalseConstraint$outboundSchema.parse(
      inputTcpjsonPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputTcpjsonSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  enableLoadBalancing?: boolean | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcpjsonSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputTcpjsonSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputTcpjsonSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputTcpjsonType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    ipWhitelistRegex: z.string().optional(),
    maxActiveCxn: z.number().optional(),
    socketIdleTimeout: z.number().optional(),
    socketEndingMaxWait: z.number().optional(),
    socketMaxLifespan: z.number().optional(),
    enableProxyHeader: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    enableLoadBalancing: z.boolean().optional(),
    authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
      .optional(),
    description: z.string().optional(),
    authToken: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputTcpjsonSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputTcpjsonSendToRoutesFalseWithConnectionsConstraint:
    InputTcpjsonSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputTcpjsonSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputTcpjsonSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputTcpjsonSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  enableLoadBalancing?: boolean | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  authToken?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcpjsonSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputTcpjsonSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputTcpjsonSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputTcpjsonType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  enableLoadBalancing: z.boolean().optional(),
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  description: z.string().optional(),
  authToken: z.string().optional(),
  textSecret: z.string().optional(),
});

export function inputTcpjsonSendToRoutesTrueConstraintToJSON(
  inputTcpjsonSendToRoutesTrueConstraint:
    InputTcpjsonSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputTcpjsonSendToRoutesTrueConstraint$outboundSchema.parse(
      inputTcpjsonSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputTcpjson$Outbound =
  | InputTcpjsonSendToRoutesTrueConstraint$Outbound
  | InputTcpjsonSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputTcpjsonPqEnabledFalseConstraint$Outbound
  | InputTcpjsonPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputTcpjson$outboundSchema: z.ZodType<
  InputTcpjson$Outbound,
  z.ZodTypeDef,
  InputTcpjson
> = z.union([
  z.lazy(() => InputTcpjsonSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputTcpjsonSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputTcpjsonPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputTcpjsonPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputTcpjsonToJSON(inputTcpjson: InputTcpjson): string {
  return JSON.stringify(InputTcpjson$outboundSchema.parse(inputTcpjson));
}

/** @internal */
export const InputCriblLakeHttpType$outboundSchema: z.ZodNativeEnum<
  typeof InputCriblLakeHttpType
> = z.nativeEnum(InputCriblLakeHttpType);

/** @internal */
export type SplunkHecMetadata$Outbound = {
  enabled?: boolean | undefined;
  defaultDataset?: string | undefined;
  allowedIndexesAtToken?: Array<string> | undefined;
};

/** @internal */
export const SplunkHecMetadata$outboundSchema: z.ZodType<
  SplunkHecMetadata$Outbound,
  z.ZodTypeDef,
  SplunkHecMetadata
> = z.object({
  enabled: z.boolean().optional(),
  defaultDataset: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
});

export function splunkHecMetadataToJSON(
  splunkHecMetadata: SplunkHecMetadata,
): string {
  return JSON.stringify(
    SplunkHecMetadata$outboundSchema.parse(splunkHecMetadata),
  );
}

/** @internal */
export type ElasticsearchMetadata$Outbound = {
  enabled?: boolean | undefined;
  defaultDataset?: string | undefined;
};

/** @internal */
export const ElasticsearchMetadata$outboundSchema: z.ZodType<
  ElasticsearchMetadata$Outbound,
  z.ZodTypeDef,
  ElasticsearchMetadata
> = z.object({
  enabled: z.boolean().optional(),
  defaultDataset: z.string().optional(),
});

export function elasticsearchMetadataToJSON(
  elasticsearchMetadata: ElasticsearchMetadata,
): string {
  return JSON.stringify(
    ElasticsearchMetadata$outboundSchema.parse(elasticsearchMetadata),
  );
}

/** @internal */
export type AuthTokensExt$Outbound = {
  token: string;
  description?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  splunkHecMetadata?: SplunkHecMetadata$Outbound | undefined;
  elasticsearchMetadata?: ElasticsearchMetadata$Outbound | undefined;
};

/** @internal */
export const AuthTokensExt$outboundSchema: z.ZodType<
  AuthTokensExt$Outbound,
  z.ZodTypeDef,
  AuthTokensExt
> = z.object({
  token: z.string(),
  description: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  splunkHecMetadata: z.lazy(() => SplunkHecMetadata$outboundSchema).optional(),
  elasticsearchMetadata: z.lazy(() => ElasticsearchMetadata$outboundSchema)
    .optional(),
});

export function authTokensExtToJSON(authTokensExt: AuthTokensExt): string {
  return JSON.stringify(AuthTokensExt$outboundSchema.parse(authTokensExt));
}

/** @internal */
export type InputCriblLakeHttpPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  criblAPI?: string | undefined;
  elasticAPI?: string | undefined;
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authTokensExt?: Array<AuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblLakeHttpPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputCriblLakeHttpPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblLakeHttpPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputCriblLakeHttpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    criblAPI: z.string().optional(),
    elasticAPI: z.string().optional(),
    splunkHecAPI: z.string().optional(),
    splunkHecAcks: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authTokensExt: z.array(z.lazy(() => AuthTokensExt$outboundSchema))
      .optional(),
    description: z.string().optional(),
  });

export function inputCriblLakeHttpPqEnabledTrueWithPqConstraintToJSON(
  inputCriblLakeHttpPqEnabledTrueWithPqConstraint:
    InputCriblLakeHttpPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputCriblLakeHttpPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputCriblLakeHttpPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputCriblLakeHttpPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  criblAPI?: string | undefined;
  elasticAPI?: string | undefined;
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authTokensExt?: Array<AuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblLakeHttpPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputCriblLakeHttpPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblLakeHttpPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputCriblLakeHttpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    criblAPI: z.string().optional(),
    elasticAPI: z.string().optional(),
    splunkHecAPI: z.string().optional(),
    splunkHecAcks: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authTokensExt: z.array(z.lazy(() => AuthTokensExt$outboundSchema))
      .optional(),
    description: z.string().optional(),
  });

export function inputCriblLakeHttpPqEnabledFalseConstraintToJSON(
  inputCriblLakeHttpPqEnabledFalseConstraint:
    InputCriblLakeHttpPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputCriblLakeHttpPqEnabledFalseConstraint$outboundSchema.parse(
      inputCriblLakeHttpPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    host: string;
    port: number;
    authTokens?: Array<string> | undefined;
    tls?: models.TlsSettingsServerSideType$Outbound | undefined;
    maxActiveReq?: number | undefined;
    maxRequestsPerSocket?: number | undefined;
    enableProxyHeader?: boolean | undefined;
    captureHeaders?: boolean | undefined;
    activityLogSampleRate?: number | undefined;
    requestTimeout?: number | undefined;
    socketTimeout?: number | undefined;
    keepAliveTimeout?: number | undefined;
    enableHealthCheck?: boolean | undefined;
    ipAllowlistRegex?: string | undefined;
    ipDenylistRegex?: string | undefined;
    criblAPI?: string | undefined;
    elasticAPI?: string | undefined;
    splunkHecAPI?: string | undefined;
    splunkHecAcks?: boolean | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    authTokensExt?: Array<AuthTokensExt$Outbound> | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputCriblLakeHttpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    criblAPI: z.string().optional(),
    elasticAPI: z.string().optional(),
    splunkHecAPI: z.string().optional(),
    splunkHecAcks: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authTokensExt: z.array(z.lazy(() => AuthTokensExt$outboundSchema))
      .optional(),
    description: z.string().optional(),
  });

export function inputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint:
    InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputCriblLakeHttpSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  criblAPI?: string | undefined;
  elasticAPI?: string | undefined;
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authTokensExt?: Array<AuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblLakeHttpSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputCriblLakeHttpSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblLakeHttpSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputCriblLakeHttpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    criblAPI: z.string().optional(),
    elasticAPI: z.string().optional(),
    splunkHecAPI: z.string().optional(),
    splunkHecAcks: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authTokensExt: z.array(z.lazy(() => AuthTokensExt$outboundSchema))
      .optional(),
    description: z.string().optional(),
  });

export function inputCriblLakeHttpSendToRoutesTrueConstraintToJSON(
  inputCriblLakeHttpSendToRoutesTrueConstraint:
    InputCriblLakeHttpSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputCriblLakeHttpSendToRoutesTrueConstraint$outboundSchema.parse(
      inputCriblLakeHttpSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputCriblLakeHttp$Outbound =
  | InputCriblLakeHttpSendToRoutesTrueConstraint$Outbound
  | InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputCriblLakeHttpPqEnabledFalseConstraint$Outbound
  | InputCriblLakeHttpPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputCriblLakeHttp$outboundSchema: z.ZodType<
  InputCriblLakeHttp$Outbound,
  z.ZodTypeDef,
  InputCriblLakeHttp
> = z.union([
  z.lazy(() => InputCriblLakeHttpSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputCriblLakeHttpPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputCriblLakeHttpPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputCriblLakeHttpToJSON(
  inputCriblLakeHttp: InputCriblLakeHttp,
): string {
  return JSON.stringify(
    InputCriblLakeHttp$outboundSchema.parse(inputCriblLakeHttp),
  );
}

/** @internal */
export const InputCriblHttpType$outboundSchema: z.ZodNativeEnum<
  typeof InputCriblHttpType
> = z.nativeEnum(InputCriblHttpType);

/** @internal */
export type InputCriblHttpPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  authTokens?: Array<models.ItemsTypeAuthTokens$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblHttpPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputCriblHttpPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblHttpPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputCriblHttpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(models.ItemsTypeAuthTokens$outboundSchema).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputCriblHttpPqEnabledTrueWithPqConstraintToJSON(
  inputCriblHttpPqEnabledTrueWithPqConstraint:
    InputCriblHttpPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputCriblHttpPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputCriblHttpPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputCriblHttpPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<models.ItemsTypeAuthTokens$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblHttpPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputCriblHttpPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputCriblHttpPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputCriblHttpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(models.ItemsTypeAuthTokens$outboundSchema).optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputCriblHttpPqEnabledFalseConstraintToJSON(
  inputCriblHttpPqEnabledFalseConstraint:
    InputCriblHttpPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputCriblHttpPqEnabledFalseConstraint$outboundSchema.parse(
      inputCriblHttpPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputCriblHttpSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    host: string;
    port: number;
    authTokens?: Array<models.ItemsTypeAuthTokens$Outbound> | undefined;
    tls?: models.TlsSettingsServerSideType$Outbound | undefined;
    maxActiveReq?: number | undefined;
    maxRequestsPerSocket?: number | undefined;
    enableProxyHeader?: boolean | undefined;
    captureHeaders?: boolean | undefined;
    activityLogSampleRate?: number | undefined;
    requestTimeout?: number | undefined;
    socketTimeout?: number | undefined;
    keepAliveTimeout?: number | undefined;
    enableHealthCheck?: boolean | undefined;
    ipAllowlistRegex?: string | undefined;
    ipDenylistRegex?: string | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputCriblHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputCriblHttpSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblHttpSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputCriblHttpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(models.ItemsTypeAuthTokens$outboundSchema).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputCriblHttpSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputCriblHttpSendToRoutesFalseWithConnectionsConstraint:
    InputCriblHttpSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputCriblHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputCriblHttpSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputCriblHttpSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<models.ItemsTypeAuthTokens$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblHttpSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputCriblHttpSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputCriblHttpSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputCriblHttpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(models.ItemsTypeAuthTokens$outboundSchema).optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputCriblHttpSendToRoutesTrueConstraintToJSON(
  inputCriblHttpSendToRoutesTrueConstraint:
    InputCriblHttpSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputCriblHttpSendToRoutesTrueConstraint$outboundSchema.parse(
      inputCriblHttpSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputCriblHttp$Outbound =
  | InputCriblHttpSendToRoutesTrueConstraint$Outbound
  | InputCriblHttpSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputCriblHttpPqEnabledFalseConstraint$Outbound
  | InputCriblHttpPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputCriblHttp$outboundSchema: z.ZodType<
  InputCriblHttp$Outbound,
  z.ZodTypeDef,
  InputCriblHttp
> = z.union([
  z.lazy(() => InputCriblHttpSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputCriblHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputCriblHttpPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputCriblHttpPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputCriblHttpToJSON(inputCriblHttp: InputCriblHttp): string {
  return JSON.stringify(InputCriblHttp$outboundSchema.parse(inputCriblHttp));
}

/** @internal */
export const InputCriblTcpType$outboundSchema: z.ZodNativeEnum<
  typeof InputCriblTcpType
> = z.nativeEnum(InputCriblTcpType);

/** @internal */
export type InputCriblTcpPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  enableLoadBalancing?: boolean | undefined;
  authTokens?: Array<models.ItemsTypeAuthTokens$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblTcpPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputCriblTcpPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblTcpPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputCriblTcpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveCxn: z.number().optional(),
    socketIdleTimeout: z.number().optional(),
    socketEndingMaxWait: z.number().optional(),
    socketMaxLifespan: z.number().optional(),
    enableProxyHeader: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    enableLoadBalancing: z.boolean().optional(),
    authTokens: z.array(models.ItemsTypeAuthTokens$outboundSchema).optional(),
    description: z.string().optional(),
  });

export function inputCriblTcpPqEnabledTrueWithPqConstraintToJSON(
  inputCriblTcpPqEnabledTrueWithPqConstraint:
    InputCriblTcpPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputCriblTcpPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputCriblTcpPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputCriblTcpPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  enableLoadBalancing?: boolean | undefined;
  authTokens?: Array<models.ItemsTypeAuthTokens$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblTcpPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputCriblTcpPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputCriblTcpPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputCriblTcpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  enableLoadBalancing: z.boolean().optional(),
  authTokens: z.array(models.ItemsTypeAuthTokens$outboundSchema).optional(),
  description: z.string().optional(),
});

export function inputCriblTcpPqEnabledFalseConstraintToJSON(
  inputCriblTcpPqEnabledFalseConstraint: InputCriblTcpPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputCriblTcpPqEnabledFalseConstraint$outboundSchema.parse(
      inputCriblTcpPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputCriblTcpSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  enableLoadBalancing?: boolean | undefined;
  authTokens?: Array<models.ItemsTypeAuthTokens$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblTcpSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputCriblTcpSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblTcpSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputCriblTcpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveCxn: z.number().optional(),
    socketIdleTimeout: z.number().optional(),
    socketEndingMaxWait: z.number().optional(),
    socketMaxLifespan: z.number().optional(),
    enableProxyHeader: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    enableLoadBalancing: z.boolean().optional(),
    authTokens: z.array(models.ItemsTypeAuthTokens$outboundSchema).optional(),
    description: z.string().optional(),
  });

export function inputCriblTcpSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputCriblTcpSendToRoutesFalseWithConnectionsConstraint:
    InputCriblTcpSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputCriblTcpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputCriblTcpSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputCriblTcpSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  enableLoadBalancing?: boolean | undefined;
  authTokens?: Array<models.ItemsTypeAuthTokens$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblTcpSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputCriblTcpSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputCriblTcpSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputCriblTcpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  enableLoadBalancing: z.boolean().optional(),
  authTokens: z.array(models.ItemsTypeAuthTokens$outboundSchema).optional(),
  description: z.string().optional(),
});

export function inputCriblTcpSendToRoutesTrueConstraintToJSON(
  inputCriblTcpSendToRoutesTrueConstraint:
    InputCriblTcpSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputCriblTcpSendToRoutesTrueConstraint$outboundSchema.parse(
      inputCriblTcpSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputCriblTcp$Outbound =
  | InputCriblTcpSendToRoutesTrueConstraint$Outbound
  | InputCriblTcpSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputCriblTcpPqEnabledFalseConstraint$Outbound
  | InputCriblTcpPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputCriblTcp$outboundSchema: z.ZodType<
  InputCriblTcp$Outbound,
  z.ZodTypeDef,
  InputCriblTcp
> = z.union([
  z.lazy(() => InputCriblTcpSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputCriblTcpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputCriblTcpPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputCriblTcpPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputCriblTcpToJSON(inputCriblTcp: InputCriblTcp): string {
  return JSON.stringify(InputCriblTcp$outboundSchema.parse(inputCriblTcp));
}

/** @internal */
export const InputCriblType$outboundSchema: z.ZodNativeEnum<
  typeof InputCriblType
> = z.nativeEnum(InputCriblType);

/** @internal */
export type InputCriblPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  filter?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputCriblPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputCriblPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputCriblType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  filter: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputCriblPqEnabledTrueWithPqConstraintToJSON(
  inputCriblPqEnabledTrueWithPqConstraint:
    InputCriblPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputCriblPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputCriblPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputCriblPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  filter?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputCriblPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputCriblPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputCriblType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  filter: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputCriblPqEnabledFalseConstraintToJSON(
  inputCriblPqEnabledFalseConstraint: InputCriblPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputCriblPqEnabledFalseConstraint$outboundSchema.parse(
      inputCriblPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputCriblSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  filter?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputCriblSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputCriblSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputCriblType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    filter: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputCriblSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputCriblSendToRoutesFalseWithConnectionsConstraint:
    InputCriblSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputCriblSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputCriblSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputCriblSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  filter?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputCriblSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputCriblSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputCriblSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputCriblType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  filter: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputCriblSendToRoutesTrueConstraintToJSON(
  inputCriblSendToRoutesTrueConstraint: InputCriblSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputCriblSendToRoutesTrueConstraint$outboundSchema.parse(
      inputCriblSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputCribl$Outbound =
  | InputCriblSendToRoutesTrueConstraint$Outbound
  | InputCriblSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputCriblPqEnabledFalseConstraint$Outbound
  | InputCriblPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputCribl$outboundSchema: z.ZodType<
  InputCribl$Outbound,
  z.ZodTypeDef,
  InputCribl
> = z.union([
  z.lazy(() => InputCriblSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputCriblSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputCriblPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputCriblPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputCriblToJSON(inputCribl: InputCribl): string {
  return JSON.stringify(InputCribl$outboundSchema.parse(inputCribl));
}

/** @internal */
export const InputGooglePubsubType$outboundSchema: z.ZodNativeEnum<
  typeof InputGooglePubsubType
> = z.nativeEnum(InputGooglePubsubType);

/** @internal */
export type InputGooglePubsubPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  topicName: string;
  subscriptionName: string;
  monitorSubscription?: boolean | undefined;
  createTopic?: boolean | undefined;
  createSubscription?: boolean | undefined;
  region?: string | undefined;
  googleAuthMethod?: string | undefined;
  serviceAccountCredentials?: string | undefined;
  secret?: string | undefined;
  maxBacklog?: number | undefined;
  concurrency?: number | undefined;
  requestTimeout?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  orderedDelivery?: boolean | undefined;
};

/** @internal */
export const InputGooglePubsubPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputGooglePubsubPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputGooglePubsubPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputGooglePubsubType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    topicName: z.string(),
    subscriptionName: z.string(),
    monitorSubscription: z.boolean().optional(),
    createTopic: z.boolean().optional(),
    createSubscription: z.boolean().optional(),
    region: z.string().optional(),
    googleAuthMethod: models.GoogleAuthenticationMethodOptions$outboundSchema
      .optional(),
    serviceAccountCredentials: z.string().optional(),
    secret: z.string().optional(),
    maxBacklog: z.number().optional(),
    concurrency: z.number().optional(),
    requestTimeout: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    orderedDelivery: z.boolean().optional(),
  });

export function inputGooglePubsubPqEnabledTrueWithPqConstraintToJSON(
  inputGooglePubsubPqEnabledTrueWithPqConstraint:
    InputGooglePubsubPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputGooglePubsubPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputGooglePubsubPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputGooglePubsubPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  topicName: string;
  subscriptionName: string;
  monitorSubscription?: boolean | undefined;
  createTopic?: boolean | undefined;
  createSubscription?: boolean | undefined;
  region?: string | undefined;
  googleAuthMethod?: string | undefined;
  serviceAccountCredentials?: string | undefined;
  secret?: string | undefined;
  maxBacklog?: number | undefined;
  concurrency?: number | undefined;
  requestTimeout?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  orderedDelivery?: boolean | undefined;
};

/** @internal */
export const InputGooglePubsubPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputGooglePubsubPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputGooglePubsubPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputGooglePubsubType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    topicName: z.string(),
    subscriptionName: z.string(),
    monitorSubscription: z.boolean().optional(),
    createTopic: z.boolean().optional(),
    createSubscription: z.boolean().optional(),
    region: z.string().optional(),
    googleAuthMethod: models.GoogleAuthenticationMethodOptions$outboundSchema
      .optional(),
    serviceAccountCredentials: z.string().optional(),
    secret: z.string().optional(),
    maxBacklog: z.number().optional(),
    concurrency: z.number().optional(),
    requestTimeout: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    orderedDelivery: z.boolean().optional(),
  });

export function inputGooglePubsubPqEnabledFalseConstraintToJSON(
  inputGooglePubsubPqEnabledFalseConstraint:
    InputGooglePubsubPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputGooglePubsubPqEnabledFalseConstraint$outboundSchema.parse(
      inputGooglePubsubPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    topicName: string;
    subscriptionName: string;
    monitorSubscription?: boolean | undefined;
    createTopic?: boolean | undefined;
    createSubscription?: boolean | undefined;
    region?: string | undefined;
    googleAuthMethod?: string | undefined;
    serviceAccountCredentials?: string | undefined;
    secret?: string | undefined;
    maxBacklog?: number | undefined;
    concurrency?: number | undefined;
    requestTimeout?: number | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    description?: string | undefined;
    orderedDelivery?: boolean | undefined;
  };

/** @internal */
export const InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputGooglePubsubType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    topicName: z.string(),
    subscriptionName: z.string(),
    monitorSubscription: z.boolean().optional(),
    createTopic: z.boolean().optional(),
    createSubscription: z.boolean().optional(),
    region: z.string().optional(),
    googleAuthMethod: models.GoogleAuthenticationMethodOptions$outboundSchema
      .optional(),
    serviceAccountCredentials: z.string().optional(),
    secret: z.string().optional(),
    maxBacklog: z.number().optional(),
    concurrency: z.number().optional(),
    requestTimeout: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    orderedDelivery: z.boolean().optional(),
  });

export function inputGooglePubsubSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputGooglePubsubSendToRoutesFalseWithConnectionsConstraint:
    InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputGooglePubsubSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputGooglePubsubSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  topicName: string;
  subscriptionName: string;
  monitorSubscription?: boolean | undefined;
  createTopic?: boolean | undefined;
  createSubscription?: boolean | undefined;
  region?: string | undefined;
  googleAuthMethod?: string | undefined;
  serviceAccountCredentials?: string | undefined;
  secret?: string | undefined;
  maxBacklog?: number | undefined;
  concurrency?: number | undefined;
  requestTimeout?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  orderedDelivery?: boolean | undefined;
};

/** @internal */
export const InputGooglePubsubSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputGooglePubsubSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputGooglePubsubSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputGooglePubsubType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    topicName: z.string(),
    subscriptionName: z.string(),
    monitorSubscription: z.boolean().optional(),
    createTopic: z.boolean().optional(),
    createSubscription: z.boolean().optional(),
    region: z.string().optional(),
    googleAuthMethod: models.GoogleAuthenticationMethodOptions$outboundSchema
      .optional(),
    serviceAccountCredentials: z.string().optional(),
    secret: z.string().optional(),
    maxBacklog: z.number().optional(),
    concurrency: z.number().optional(),
    requestTimeout: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    orderedDelivery: z.boolean().optional(),
  });

export function inputGooglePubsubSendToRoutesTrueConstraintToJSON(
  inputGooglePubsubSendToRoutesTrueConstraint:
    InputGooglePubsubSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputGooglePubsubSendToRoutesTrueConstraint$outboundSchema.parse(
      inputGooglePubsubSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputGooglePubsub$Outbound =
  | InputGooglePubsubSendToRoutesTrueConstraint$Outbound
  | InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputGooglePubsubPqEnabledFalseConstraint$Outbound
  | InputGooglePubsubPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputGooglePubsub$outboundSchema: z.ZodType<
  InputGooglePubsub$Outbound,
  z.ZodTypeDef,
  InputGooglePubsub
> = z.union([
  z.lazy(() => InputGooglePubsubSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputGooglePubsubPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputGooglePubsubPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputGooglePubsubToJSON(
  inputGooglePubsub: InputGooglePubsub,
): string {
  return JSON.stringify(
    InputGooglePubsub$outboundSchema.parse(inputGooglePubsub),
  );
}

/** @internal */
export const InputFirehoseType$outboundSchema: z.ZodNativeEnum<
  typeof InputFirehoseType
> = z.nativeEnum(InputFirehoseType);

/** @internal */
export type InputFirehosePqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputFirehosePqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputFirehosePqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputFirehosePqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputFirehoseType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputFirehosePqEnabledTrueWithPqConstraintToJSON(
  inputFirehosePqEnabledTrueWithPqConstraint:
    InputFirehosePqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputFirehosePqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputFirehosePqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputFirehosePqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputFirehosePqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputFirehosePqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputFirehosePqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputFirehoseType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputFirehosePqEnabledFalseConstraintToJSON(
  inputFirehosePqEnabledFalseConstraint: InputFirehosePqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputFirehosePqEnabledFalseConstraint$outboundSchema.parse(
      inputFirehosePqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputFirehoseSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputFirehoseSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputFirehoseSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputFirehoseSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputFirehoseType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputFirehoseSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputFirehoseSendToRoutesFalseWithConnectionsConstraint:
    InputFirehoseSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputFirehoseSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputFirehoseSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputFirehoseSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputFirehoseSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputFirehoseSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputFirehoseSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputFirehoseType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputFirehoseSendToRoutesTrueConstraintToJSON(
  inputFirehoseSendToRoutesTrueConstraint:
    InputFirehoseSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputFirehoseSendToRoutesTrueConstraint$outboundSchema.parse(
      inputFirehoseSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputFirehose$Outbound =
  | InputFirehoseSendToRoutesTrueConstraint$Outbound
  | InputFirehoseSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputFirehosePqEnabledFalseConstraint$Outbound
  | InputFirehosePqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputFirehose$outboundSchema: z.ZodType<
  InputFirehose$Outbound,
  z.ZodTypeDef,
  InputFirehose
> = z.union([
  z.lazy(() => InputFirehoseSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputFirehoseSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputFirehosePqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputFirehosePqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputFirehoseToJSON(inputFirehose: InputFirehose): string {
  return JSON.stringify(InputFirehose$outboundSchema.parse(inputFirehose));
}

/** @internal */
export const PqEnabledTrueWithPqConstraintInputExecType$outboundSchema:
  z.ZodNativeEnum<typeof PqEnabledTrueWithPqConstraintInputExecType> = z
    .nativeEnum(PqEnabledTrueWithPqConstraintInputExecType);

/** @internal */
export const PqEnabledTrueWithPqConstraintScheduleType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, PqEnabledTrueWithPqConstraintScheduleType> =
    openEnums.outboundSchema(PqEnabledTrueWithPqConstraintScheduleType);

/** @internal */
export type InputExecPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  command: string;
  retries?: number | undefined;
  scheduleType?: string | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  interval?: number | undefined;
  cronSchedule?: string | undefined;
};

/** @internal */
export const InputExecPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputExecPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputExecPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: PqEnabledTrueWithPqConstraintInputExecType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  command: z.string(),
  retries: z.number().optional(),
  scheduleType: PqEnabledTrueWithPqConstraintScheduleType$outboundSchema
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  cronSchedule: z.string().optional(),
});

export function inputExecPqEnabledTrueWithPqConstraintToJSON(
  inputExecPqEnabledTrueWithPqConstraint:
    InputExecPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputExecPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputExecPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export const PqEnabledFalseConstraintInputExecType$outboundSchema:
  z.ZodNativeEnum<typeof PqEnabledFalseConstraintInputExecType> = z.nativeEnum(
    PqEnabledFalseConstraintInputExecType,
  );

/** @internal */
export const PqEnabledFalseConstraintScheduleType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  PqEnabledFalseConstraintScheduleType
> = openEnums.outboundSchema(PqEnabledFalseConstraintScheduleType);

/** @internal */
export type InputExecPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  command: string;
  retries?: number | undefined;
  scheduleType?: string | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  interval?: number | undefined;
  cronSchedule?: string | undefined;
};

/** @internal */
export const InputExecPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputExecPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputExecPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: PqEnabledFalseConstraintInputExecType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  command: z.string(),
  retries: z.number().optional(),
  scheduleType: PqEnabledFalseConstraintScheduleType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  cronSchedule: z.string().optional(),
});

export function inputExecPqEnabledFalseConstraintToJSON(
  inputExecPqEnabledFalseConstraint: InputExecPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputExecPqEnabledFalseConstraint$outboundSchema.parse(
      inputExecPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export const SendToRoutesFalseWithConnectionsConstraintInputExecType$outboundSchema:
  z.ZodNativeEnum<
    typeof SendToRoutesFalseWithConnectionsConstraintInputExecType
  > = z.nativeEnum(SendToRoutesFalseWithConnectionsConstraintInputExecType);

/** @internal */
export const SendToRoutesFalseWithConnectionsConstraintScheduleType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    SendToRoutesFalseWithConnectionsConstraintScheduleType
  > = openEnums.outboundSchema(
    SendToRoutesFalseWithConnectionsConstraintScheduleType,
  );

/** @internal */
export type InputExecSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  command: string;
  retries?: number | undefined;
  scheduleType?: string | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  interval?: number | undefined;
  cronSchedule?: string | undefined;
};

/** @internal */
export const InputExecSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputExecSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputExecSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type:
      SendToRoutesFalseWithConnectionsConstraintInputExecType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    command: z.string(),
    retries: z.number().optional(),
    scheduleType:
      SendToRoutesFalseWithConnectionsConstraintScheduleType$outboundSchema
        .optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    interval: z.number().optional(),
    cronSchedule: z.string().optional(),
  });

export function inputExecSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputExecSendToRoutesFalseWithConnectionsConstraint:
    InputExecSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputExecSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputExecSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export const SendToRoutesTrueConstraintInputExecType$outboundSchema:
  z.ZodNativeEnum<typeof SendToRoutesTrueConstraintInputExecType> = z
    .nativeEnum(SendToRoutesTrueConstraintInputExecType);

/** @internal */
export const SendToRoutesTrueConstraintScheduleType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  SendToRoutesTrueConstraintScheduleType
> = openEnums.outboundSchema(SendToRoutesTrueConstraintScheduleType);

/** @internal */
export type InputExecSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  command: string;
  retries?: number | undefined;
  scheduleType?: string | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  interval?: number | undefined;
  cronSchedule?: string | undefined;
};

/** @internal */
export const InputExecSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputExecSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputExecSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: SendToRoutesTrueConstraintInputExecType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  command: z.string(),
  retries: z.number().optional(),
  scheduleType: SendToRoutesTrueConstraintScheduleType$outboundSchema
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  cronSchedule: z.string().optional(),
});

export function inputExecSendToRoutesTrueConstraintToJSON(
  inputExecSendToRoutesTrueConstraint: InputExecSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputExecSendToRoutesTrueConstraint$outboundSchema.parse(
      inputExecSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputExec$Outbound =
  | InputExecSendToRoutesTrueConstraint$Outbound
  | InputExecSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputExecPqEnabledFalseConstraint$Outbound
  | InputExecPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputExec$outboundSchema: z.ZodType<
  InputExec$Outbound,
  z.ZodTypeDef,
  InputExec
> = z.union([
  z.lazy(() => InputExecSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputExecSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputExecPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputExecPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputExecToJSON(inputExec: InputExec): string {
  return JSON.stringify(InputExec$outboundSchema.parse(inputExec));
}

/** @internal */
export const InputEventhubType$outboundSchema: z.ZodNativeEnum<
  typeof InputEventhubType
> = z.nativeEnum(InputEventhubType);

/** @internal */
export type InputEventhubPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  sasl?: models.AuthenticationType1$Outbound | undefined;
  tls?: models.TlsSettingsClientSideType$Outbound | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  minimizeDuplicates?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputEventhubPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputEventhubPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputEventhubPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputEventhubType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    brokers: z.array(z.string()),
    topics: z.array(z.string()),
    groupId: z.string().optional(),
    fromBeginning: z.boolean().optional(),
    connectionTimeout: z.number().optional(),
    requestTimeout: z.number().optional(),
    maxRetries: z.number().optional(),
    maxBackOff: z.number().optional(),
    initialBackoff: z.number().optional(),
    backoffRate: z.number().optional(),
    authenticationTimeout: z.number().optional(),
    reauthenticationThreshold: z.number().optional(),
    sasl: models.AuthenticationType1$outboundSchema.optional(),
    tls: models.TlsSettingsClientSideType$outboundSchema.optional(),
    sessionTimeout: z.number().optional(),
    rebalanceTimeout: z.number().optional(),
    heartbeatInterval: z.number().optional(),
    autoCommitInterval: z.number().optional(),
    autoCommitThreshold: z.number().optional(),
    maxBytesPerPartition: z.number().optional(),
    maxBytes: z.number().optional(),
    maxSocketErrors: z.number().optional(),
    minimizeDuplicates: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputEventhubPqEnabledTrueWithPqConstraintToJSON(
  inputEventhubPqEnabledTrueWithPqConstraint:
    InputEventhubPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputEventhubPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputEventhubPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputEventhubPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  sasl?: models.AuthenticationType1$Outbound | undefined;
  tls?: models.TlsSettingsClientSideType$Outbound | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  minimizeDuplicates?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputEventhubPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputEventhubPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputEventhubPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputEventhubType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().optional(),
  fromBeginning: z.boolean().optional(),
  connectionTimeout: z.number().optional(),
  requestTimeout: z.number().optional(),
  maxRetries: z.number().optional(),
  maxBackOff: z.number().optional(),
  initialBackoff: z.number().optional(),
  backoffRate: z.number().optional(),
  authenticationTimeout: z.number().optional(),
  reauthenticationThreshold: z.number().optional(),
  sasl: models.AuthenticationType1$outboundSchema.optional(),
  tls: models.TlsSettingsClientSideType$outboundSchema.optional(),
  sessionTimeout: z.number().optional(),
  rebalanceTimeout: z.number().optional(),
  heartbeatInterval: z.number().optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().optional(),
  maxBytes: z.number().optional(),
  maxSocketErrors: z.number().optional(),
  minimizeDuplicates: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputEventhubPqEnabledFalseConstraintToJSON(
  inputEventhubPqEnabledFalseConstraint: InputEventhubPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputEventhubPqEnabledFalseConstraint$outboundSchema.parse(
      inputEventhubPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputEventhubSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  sasl?: models.AuthenticationType1$Outbound | undefined;
  tls?: models.TlsSettingsClientSideType$Outbound | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  minimizeDuplicates?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputEventhubSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputEventhubSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputEventhubSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputEventhubType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    brokers: z.array(z.string()),
    topics: z.array(z.string()),
    groupId: z.string().optional(),
    fromBeginning: z.boolean().optional(),
    connectionTimeout: z.number().optional(),
    requestTimeout: z.number().optional(),
    maxRetries: z.number().optional(),
    maxBackOff: z.number().optional(),
    initialBackoff: z.number().optional(),
    backoffRate: z.number().optional(),
    authenticationTimeout: z.number().optional(),
    reauthenticationThreshold: z.number().optional(),
    sasl: models.AuthenticationType1$outboundSchema.optional(),
    tls: models.TlsSettingsClientSideType$outboundSchema.optional(),
    sessionTimeout: z.number().optional(),
    rebalanceTimeout: z.number().optional(),
    heartbeatInterval: z.number().optional(),
    autoCommitInterval: z.number().optional(),
    autoCommitThreshold: z.number().optional(),
    maxBytesPerPartition: z.number().optional(),
    maxBytes: z.number().optional(),
    maxSocketErrors: z.number().optional(),
    minimizeDuplicates: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputEventhubSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputEventhubSendToRoutesFalseWithConnectionsConstraint:
    InputEventhubSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputEventhubSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputEventhubSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputEventhubSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  sasl?: models.AuthenticationType1$Outbound | undefined;
  tls?: models.TlsSettingsClientSideType$Outbound | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  minimizeDuplicates?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputEventhubSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputEventhubSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputEventhubSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputEventhubType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().optional(),
  fromBeginning: z.boolean().optional(),
  connectionTimeout: z.number().optional(),
  requestTimeout: z.number().optional(),
  maxRetries: z.number().optional(),
  maxBackOff: z.number().optional(),
  initialBackoff: z.number().optional(),
  backoffRate: z.number().optional(),
  authenticationTimeout: z.number().optional(),
  reauthenticationThreshold: z.number().optional(),
  sasl: models.AuthenticationType1$outboundSchema.optional(),
  tls: models.TlsSettingsClientSideType$outboundSchema.optional(),
  sessionTimeout: z.number().optional(),
  rebalanceTimeout: z.number().optional(),
  heartbeatInterval: z.number().optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().optional(),
  maxBytes: z.number().optional(),
  maxSocketErrors: z.number().optional(),
  minimizeDuplicates: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputEventhubSendToRoutesTrueConstraintToJSON(
  inputEventhubSendToRoutesTrueConstraint:
    InputEventhubSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputEventhubSendToRoutesTrueConstraint$outboundSchema.parse(
      inputEventhubSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputEventhub$Outbound =
  | InputEventhubSendToRoutesTrueConstraint$Outbound
  | InputEventhubSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputEventhubPqEnabledFalseConstraint$Outbound
  | InputEventhubPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputEventhub$outboundSchema: z.ZodType<
  InputEventhub$Outbound,
  z.ZodTypeDef,
  InputEventhub
> = z.union([
  z.lazy(() => InputEventhubSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputEventhubSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputEventhubPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputEventhubPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputEventhubToJSON(inputEventhub: InputEventhub): string {
  return JSON.stringify(InputEventhub$outboundSchema.parse(inputEventhub));
}

/** @internal */
export const InputOffice365MsgTraceType$outboundSchema: z.ZodNativeEnum<
  typeof InputOffice365MsgTraceType
> = z.nativeEnum(InputOffice365MsgTraceType);

/** @internal */
export const InputOffice365MsgTraceAuthenticationMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, InputOffice365MsgTraceAuthenticationMethod> =
    openEnums.outboundSchema(InputOffice365MsgTraceAuthenticationMethod);

/** @internal */
export const InputOffice365MsgTraceLogLevel$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputOffice365MsgTraceLogLevel
> = openEnums.outboundSchema(InputOffice365MsgTraceLogLevel);

/** @internal */
export type CertOptions$Outbound = {
  certificateName?: string | undefined;
  privKeyPath: string;
  passphrase?: string | undefined;
  certPath: string;
};

/** @internal */
export const CertOptions$outboundSchema: z.ZodType<
  CertOptions$Outbound,
  z.ZodTypeDef,
  CertOptions
> = z.object({
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
});

export function certOptionsToJSON(certOptions: CertOptions): string {
  return JSON.stringify(CertOptions$outboundSchema.parse(certOptions));
}

/** @internal */
export type InputOffice365MsgTracePqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  url: string;
  interval: number;
  startDate?: string | undefined;
  endDate?: string | undefined;
  timeout?: number | undefined;
  disableTimeFilter?: boolean | undefined;
  authType?: string | undefined;
  rescheduleDroppedTasks?: boolean | undefined;
  maxTaskReschedule?: number | undefined;
  logLevel?: string | undefined;
  jobTimeout?: string | undefined;
  keepAliveTime?: number | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  retryRules?: models.RetryRulesType1$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  clientSecret?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  resource?: string | undefined;
  planType?: string | undefined;
  textSecret?: string | undefined;
  certOptions?: CertOptions$Outbound | undefined;
};

/** @internal */
export const InputOffice365MsgTracePqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputOffice365MsgTracePqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365MsgTracePqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputOffice365MsgTraceType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    url: z.string(),
    interval: z.number(),
    startDate: z.string().optional(),
    endDate: z.string().optional(),
    timeout: z.number().optional(),
    disableTimeFilter: z.boolean().optional(),
    authType: InputOffice365MsgTraceAuthenticationMethod$outboundSchema
      .optional(),
    rescheduleDroppedTasks: z.boolean().optional(),
    maxTaskReschedule: z.number().optional(),
    logLevel: InputOffice365MsgTraceLogLevel$outboundSchema.optional(),
    jobTimeout: z.string().optional(),
    keepAliveTime: z.number().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
    clientSecret: z.string().optional(),
    tenantId: z.string().optional(),
    clientId: z.string().optional(),
    resource: z.string().optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema.optional(),
    textSecret: z.string().optional(),
    certOptions: z.lazy(() => CertOptions$outboundSchema).optional(),
  });

export function inputOffice365MsgTracePqEnabledTrueWithPqConstraintToJSON(
  inputOffice365MsgTracePqEnabledTrueWithPqConstraint:
    InputOffice365MsgTracePqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputOffice365MsgTracePqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputOffice365MsgTracePqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputOffice365MsgTracePqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  url: string;
  interval: number;
  startDate?: string | undefined;
  endDate?: string | undefined;
  timeout?: number | undefined;
  disableTimeFilter?: boolean | undefined;
  authType?: string | undefined;
  rescheduleDroppedTasks?: boolean | undefined;
  maxTaskReschedule?: number | undefined;
  logLevel?: string | undefined;
  jobTimeout?: string | undefined;
  keepAliveTime?: number | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  retryRules?: models.RetryRulesType1$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  clientSecret?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  resource?: string | undefined;
  planType?: string | undefined;
  textSecret?: string | undefined;
  certOptions?: CertOptions$Outbound | undefined;
};

/** @internal */
export const InputOffice365MsgTracePqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputOffice365MsgTracePqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365MsgTracePqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputOffice365MsgTraceType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    url: z.string(),
    interval: z.number(),
    startDate: z.string().optional(),
    endDate: z.string().optional(),
    timeout: z.number().optional(),
    disableTimeFilter: z.boolean().optional(),
    authType: InputOffice365MsgTraceAuthenticationMethod$outboundSchema
      .optional(),
    rescheduleDroppedTasks: z.boolean().optional(),
    maxTaskReschedule: z.number().optional(),
    logLevel: InputOffice365MsgTraceLogLevel$outboundSchema.optional(),
    jobTimeout: z.string().optional(),
    keepAliveTime: z.number().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
    clientSecret: z.string().optional(),
    tenantId: z.string().optional(),
    clientId: z.string().optional(),
    resource: z.string().optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema.optional(),
    textSecret: z.string().optional(),
    certOptions: z.lazy(() => CertOptions$outboundSchema).optional(),
  });

export function inputOffice365MsgTracePqEnabledFalseConstraintToJSON(
  inputOffice365MsgTracePqEnabledFalseConstraint:
    InputOffice365MsgTracePqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputOffice365MsgTracePqEnabledFalseConstraint$outboundSchema.parse(
      inputOffice365MsgTracePqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    url: string;
    interval: number;
    startDate?: string | undefined;
    endDate?: string | undefined;
    timeout?: number | undefined;
    disableTimeFilter?: boolean | undefined;
    authType?: string | undefined;
    rescheduleDroppedTasks?: boolean | undefined;
    maxTaskReschedule?: number | undefined;
    logLevel?: string | undefined;
    jobTimeout?: string | undefined;
    keepAliveTime?: number | undefined;
    maxMissedKeepAlives?: number | undefined;
    ttl?: string | undefined;
    ignoreGroupJobsLimit?: boolean | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    retryRules?: models.RetryRulesType1$Outbound | undefined;
    description?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    credentialsSecret?: string | undefined;
    clientSecret?: string | undefined;
    tenantId?: string | undefined;
    clientId?: string | undefined;
    resource?: string | undefined;
    planType?: string | undefined;
    textSecret?: string | undefined;
    certOptions?: CertOptions$Outbound | undefined;
  };

/** @internal */
export const InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputOffice365MsgTraceType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    url: z.string(),
    interval: z.number(),
    startDate: z.string().optional(),
    endDate: z.string().optional(),
    timeout: z.number().optional(),
    disableTimeFilter: z.boolean().optional(),
    authType: InputOffice365MsgTraceAuthenticationMethod$outboundSchema
      .optional(),
    rescheduleDroppedTasks: z.boolean().optional(),
    maxTaskReschedule: z.number().optional(),
    logLevel: InputOffice365MsgTraceLogLevel$outboundSchema.optional(),
    jobTimeout: z.string().optional(),
    keepAliveTime: z.number().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
    clientSecret: z.string().optional(),
    tenantId: z.string().optional(),
    clientId: z.string().optional(),
    resource: z.string().optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema.optional(),
    textSecret: z.string().optional(),
    certOptions: z.lazy(() => CertOptions$outboundSchema).optional(),
  });

export function inputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint:
    InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputOffice365MsgTraceSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  url: string;
  interval: number;
  startDate?: string | undefined;
  endDate?: string | undefined;
  timeout?: number | undefined;
  disableTimeFilter?: boolean | undefined;
  authType?: string | undefined;
  rescheduleDroppedTasks?: boolean | undefined;
  maxTaskReschedule?: number | undefined;
  logLevel?: string | undefined;
  jobTimeout?: string | undefined;
  keepAliveTime?: number | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  retryRules?: models.RetryRulesType1$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  clientSecret?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  resource?: string | undefined;
  planType?: string | undefined;
  textSecret?: string | undefined;
  certOptions?: CertOptions$Outbound | undefined;
};

/** @internal */
export const InputOffice365MsgTraceSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputOffice365MsgTraceSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365MsgTraceSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputOffice365MsgTraceType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    url: z.string(),
    interval: z.number(),
    startDate: z.string().optional(),
    endDate: z.string().optional(),
    timeout: z.number().optional(),
    disableTimeFilter: z.boolean().optional(),
    authType: InputOffice365MsgTraceAuthenticationMethod$outboundSchema
      .optional(),
    rescheduleDroppedTasks: z.boolean().optional(),
    maxTaskReschedule: z.number().optional(),
    logLevel: InputOffice365MsgTraceLogLevel$outboundSchema.optional(),
    jobTimeout: z.string().optional(),
    keepAliveTime: z.number().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
    clientSecret: z.string().optional(),
    tenantId: z.string().optional(),
    clientId: z.string().optional(),
    resource: z.string().optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema.optional(),
    textSecret: z.string().optional(),
    certOptions: z.lazy(() => CertOptions$outboundSchema).optional(),
  });

export function inputOffice365MsgTraceSendToRoutesTrueConstraintToJSON(
  inputOffice365MsgTraceSendToRoutesTrueConstraint:
    InputOffice365MsgTraceSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputOffice365MsgTraceSendToRoutesTrueConstraint$outboundSchema.parse(
      inputOffice365MsgTraceSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputOffice365MsgTrace$Outbound =
  | InputOffice365MsgTraceSendToRoutesTrueConstraint$Outbound
  | InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputOffice365MsgTracePqEnabledFalseConstraint$Outbound
  | InputOffice365MsgTracePqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputOffice365MsgTrace$outboundSchema: z.ZodType<
  InputOffice365MsgTrace$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTrace
> = z.union([
  z.lazy(() => InputOffice365MsgTraceSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputOffice365MsgTracePqEnabledFalseConstraint$outboundSchema),
  z.lazy(() =>
    InputOffice365MsgTracePqEnabledTrueWithPqConstraint$outboundSchema
  ),
]);

export function inputOffice365MsgTraceToJSON(
  inputOffice365MsgTrace: InputOffice365MsgTrace,
): string {
  return JSON.stringify(
    InputOffice365MsgTrace$outboundSchema.parse(inputOffice365MsgTrace),
  );
}

/** @internal */
export const InputOffice365ServiceType$outboundSchema: z.ZodNativeEnum<
  typeof InputOffice365ServiceType
> = z.nativeEnum(InputOffice365ServiceType);

/** @internal */
export type InputOffice365ServiceContentConfig$Outbound = {
  contentType?: string | undefined;
  description?: string | undefined;
  interval?: number | undefined;
  logLevel?: string | undefined;
  enabled?: boolean | undefined;
};

/** @internal */
export const InputOffice365ServiceContentConfig$outboundSchema: z.ZodType<
  InputOffice365ServiceContentConfig$Outbound,
  z.ZodTypeDef,
  InputOffice365ServiceContentConfig
> = z.object({
  contentType: z.string().optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  logLevel: models.LogLevelOptionsContentConfigItems$outboundSchema.optional(),
  enabled: z.boolean().optional(),
});

export function inputOffice365ServiceContentConfigToJSON(
  inputOffice365ServiceContentConfig: InputOffice365ServiceContentConfig,
): string {
  return JSON.stringify(
    InputOffice365ServiceContentConfig$outboundSchema.parse(
      inputOffice365ServiceContentConfig,
    ),
  );
}

/** @internal */
export type InputOffice365ServicePqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  planType?: string | undefined;
  tenantId: string;
  appId: string;
  timeout?: number | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  contentConfig?:
    | Array<InputOffice365ServiceContentConfig$Outbound>
    | undefined;
  retryRules?: models.RetryRulesType1$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputOffice365ServicePqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputOffice365ServicePqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365ServicePqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputOffice365ServiceType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema.optional(),
    tenantId: z.string(),
    appId: z.string(),
    timeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    contentConfig: z.array(
      z.lazy(() => InputOffice365ServiceContentConfig$outboundSchema),
    ).optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
    description: z.string().optional(),
    clientSecret: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputOffice365ServicePqEnabledTrueWithPqConstraintToJSON(
  inputOffice365ServicePqEnabledTrueWithPqConstraint:
    InputOffice365ServicePqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputOffice365ServicePqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputOffice365ServicePqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputOffice365ServicePqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  planType?: string | undefined;
  tenantId: string;
  appId: string;
  timeout?: number | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  contentConfig?:
    | Array<InputOffice365ServiceContentConfig$Outbound>
    | undefined;
  retryRules?: models.RetryRulesType1$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputOffice365ServicePqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputOffice365ServicePqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365ServicePqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputOffice365ServiceType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema.optional(),
    tenantId: z.string(),
    appId: z.string(),
    timeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    contentConfig: z.array(
      z.lazy(() => InputOffice365ServiceContentConfig$outboundSchema),
    ).optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
    description: z.string().optional(),
    clientSecret: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputOffice365ServicePqEnabledFalseConstraintToJSON(
  inputOffice365ServicePqEnabledFalseConstraint:
    InputOffice365ServicePqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputOffice365ServicePqEnabledFalseConstraint$outboundSchema.parse(
      inputOffice365ServicePqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    planType?: string | undefined;
    tenantId: string;
    appId: string;
    timeout?: number | undefined;
    keepAliveTime?: number | undefined;
    jobTimeout?: string | undefined;
    maxMissedKeepAlives?: number | undefined;
    ttl?: string | undefined;
    ignoreGroupJobsLimit?: boolean | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    contentConfig?:
      | Array<InputOffice365ServiceContentConfig$Outbound>
      | undefined;
    retryRules?: models.RetryRulesType1$Outbound | undefined;
    authType?: string | undefined;
    description?: string | undefined;
    clientSecret?: string | undefined;
    textSecret?: string | undefined;
  };

/** @internal */
export const InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputOffice365ServiceType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema.optional(),
    tenantId: z.string(),
    appId: z.string(),
    timeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    contentConfig: z.array(
      z.lazy(() => InputOffice365ServiceContentConfig$outboundSchema),
    ).optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
    description: z.string().optional(),
    clientSecret: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputOffice365ServiceSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint:
    InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputOffice365ServiceSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  planType?: string | undefined;
  tenantId: string;
  appId: string;
  timeout?: number | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  contentConfig?:
    | Array<InputOffice365ServiceContentConfig$Outbound>
    | undefined;
  retryRules?: models.RetryRulesType1$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputOffice365ServiceSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputOffice365ServiceSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365ServiceSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputOffice365ServiceType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema.optional(),
    tenantId: z.string(),
    appId: z.string(),
    timeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    contentConfig: z.array(
      z.lazy(() => InputOffice365ServiceContentConfig$outboundSchema),
    ).optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
    description: z.string().optional(),
    clientSecret: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputOffice365ServiceSendToRoutesTrueConstraintToJSON(
  inputOffice365ServiceSendToRoutesTrueConstraint:
    InputOffice365ServiceSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputOffice365ServiceSendToRoutesTrueConstraint$outboundSchema.parse(
      inputOffice365ServiceSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputOffice365Service$Outbound =
  | InputOffice365ServiceSendToRoutesTrueConstraint$Outbound
  | InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputOffice365ServicePqEnabledFalseConstraint$Outbound
  | InputOffice365ServicePqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputOffice365Service$outboundSchema: z.ZodType<
  InputOffice365Service$Outbound,
  z.ZodTypeDef,
  InputOffice365Service
> = z.union([
  z.lazy(() => InputOffice365ServiceSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputOffice365ServicePqEnabledFalseConstraint$outboundSchema),
  z.lazy(() =>
    InputOffice365ServicePqEnabledTrueWithPqConstraint$outboundSchema
  ),
]);

export function inputOffice365ServiceToJSON(
  inputOffice365Service: InputOffice365Service,
): string {
  return JSON.stringify(
    InputOffice365Service$outboundSchema.parse(inputOffice365Service),
  );
}

/** @internal */
export const InputOffice365MgmtType$outboundSchema: z.ZodNativeEnum<
  typeof InputOffice365MgmtType
> = z.nativeEnum(InputOffice365MgmtType);

/** @internal */
export type InputOffice365MgmtContentConfig$Outbound = {
  contentType?: string | undefined;
  description?: string | undefined;
  interval?: number | undefined;
  logLevel?: string | undefined;
  enabled?: boolean | undefined;
};

/** @internal */
export const InputOffice365MgmtContentConfig$outboundSchema: z.ZodType<
  InputOffice365MgmtContentConfig$Outbound,
  z.ZodTypeDef,
  InputOffice365MgmtContentConfig
> = z.object({
  contentType: z.string().optional(),
  description: z.string().optional(),
  interval: z.number().optional(),
  logLevel: models.LogLevelOptionsContentConfigItems$outboundSchema.optional(),
  enabled: z.boolean().optional(),
});

export function inputOffice365MgmtContentConfigToJSON(
  inputOffice365MgmtContentConfig: InputOffice365MgmtContentConfig,
): string {
  return JSON.stringify(
    InputOffice365MgmtContentConfig$outboundSchema.parse(
      inputOffice365MgmtContentConfig,
    ),
  );
}

/** @internal */
export type InputOffice365MgmtPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  planType: string;
  tenantId: string;
  appId: string;
  timeout?: number | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  publisherIdentifier?: string | undefined;
  contentConfig?: Array<InputOffice365MgmtContentConfig$Outbound> | undefined;
  ingestionLag?: number | undefined;
  retryRules?: models.RetryRulesType1$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputOffice365MgmtPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputOffice365MgmtPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365MgmtPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputOffice365MgmtType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema,
    tenantId: z.string(),
    appId: z.string(),
    timeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    publisherIdentifier: z.string().optional(),
    contentConfig: z.array(
      z.lazy(() => InputOffice365MgmtContentConfig$outboundSchema),
    ).optional(),
    ingestionLag: z.number().optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
    description: z.string().optional(),
    clientSecret: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputOffice365MgmtPqEnabledTrueWithPqConstraintToJSON(
  inputOffice365MgmtPqEnabledTrueWithPqConstraint:
    InputOffice365MgmtPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputOffice365MgmtPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputOffice365MgmtPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputOffice365MgmtPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  planType: string;
  tenantId: string;
  appId: string;
  timeout?: number | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  publisherIdentifier?: string | undefined;
  contentConfig?: Array<InputOffice365MgmtContentConfig$Outbound> | undefined;
  ingestionLag?: number | undefined;
  retryRules?: models.RetryRulesType1$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputOffice365MgmtPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputOffice365MgmtPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365MgmtPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputOffice365MgmtType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema,
    tenantId: z.string(),
    appId: z.string(),
    timeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    publisherIdentifier: z.string().optional(),
    contentConfig: z.array(
      z.lazy(() => InputOffice365MgmtContentConfig$outboundSchema),
    ).optional(),
    ingestionLag: z.number().optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
    description: z.string().optional(),
    clientSecret: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputOffice365MgmtPqEnabledFalseConstraintToJSON(
  inputOffice365MgmtPqEnabledFalseConstraint:
    InputOffice365MgmtPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputOffice365MgmtPqEnabledFalseConstraint$outboundSchema.parse(
      inputOffice365MgmtPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    planType: string;
    tenantId: string;
    appId: string;
    timeout?: number | undefined;
    keepAliveTime?: number | undefined;
    jobTimeout?: string | undefined;
    maxMissedKeepAlives?: number | undefined;
    ttl?: string | undefined;
    ignoreGroupJobsLimit?: boolean | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    publisherIdentifier?: string | undefined;
    contentConfig?: Array<InputOffice365MgmtContentConfig$Outbound> | undefined;
    ingestionLag?: number | undefined;
    retryRules?: models.RetryRulesType1$Outbound | undefined;
    authType?: string | undefined;
    description?: string | undefined;
    clientSecret?: string | undefined;
    textSecret?: string | undefined;
  };

/** @internal */
export const InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputOffice365MgmtType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema,
    tenantId: z.string(),
    appId: z.string(),
    timeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    publisherIdentifier: z.string().optional(),
    contentConfig: z.array(
      z.lazy(() => InputOffice365MgmtContentConfig$outboundSchema),
    ).optional(),
    ingestionLag: z.number().optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
    description: z.string().optional(),
    clientSecret: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputOffice365MgmtSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint:
    InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputOffice365MgmtSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  planType: string;
  tenantId: string;
  appId: string;
  timeout?: number | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  publisherIdentifier?: string | undefined;
  contentConfig?: Array<InputOffice365MgmtContentConfig$Outbound> | undefined;
  ingestionLag?: number | undefined;
  retryRules?: models.RetryRulesType1$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputOffice365MgmtSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputOffice365MgmtSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputOffice365MgmtSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputOffice365MgmtType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    planType: models.SubscriptionPlanOptions$outboundSchema,
    tenantId: z.string(),
    appId: z.string(),
    timeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    publisherIdentifier: z.string().optional(),
    contentConfig: z.array(
      z.lazy(() => InputOffice365MgmtContentConfig$outboundSchema),
    ).optional(),
    ingestionLag: z.number().optional(),
    retryRules: models.RetryRulesType1$outboundSchema.optional(),
    authType: models.AuthenticationMethodOptions1$outboundSchema.optional(),
    description: z.string().optional(),
    clientSecret: z.string().optional(),
    textSecret: z.string().optional(),
  });

export function inputOffice365MgmtSendToRoutesTrueConstraintToJSON(
  inputOffice365MgmtSendToRoutesTrueConstraint:
    InputOffice365MgmtSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputOffice365MgmtSendToRoutesTrueConstraint$outboundSchema.parse(
      inputOffice365MgmtSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputOffice365Mgmt$Outbound =
  | InputOffice365MgmtSendToRoutesTrueConstraint$Outbound
  | InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputOffice365MgmtPqEnabledFalseConstraint$Outbound
  | InputOffice365MgmtPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputOffice365Mgmt$outboundSchema: z.ZodType<
  InputOffice365Mgmt$Outbound,
  z.ZodTypeDef,
  InputOffice365Mgmt
> = z.union([
  z.lazy(() => InputOffice365MgmtSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputOffice365MgmtPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputOffice365MgmtPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputOffice365MgmtToJSON(
  inputOffice365Mgmt: InputOffice365Mgmt,
): string {
  return JSON.stringify(
    InputOffice365Mgmt$outboundSchema.parse(inputOffice365Mgmt),
  );
}

/** @internal */
export const InputEdgePrometheusType$outboundSchema: z.ZodNativeEnum<
  typeof InputEdgePrometheusType
> = z.nativeEnum(InputEdgePrometheusType);

/** @internal */
export const InputEdgePrometheusDiscoveryType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputEdgePrometheusDiscoveryType
> = openEnums.outboundSchema(InputEdgePrometheusDiscoveryType);

/** @internal */
export const InputEdgePrometheusAuthenticationMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputEdgePrometheusAuthenticationMethod
> = openEnums.outboundSchema(InputEdgePrometheusAuthenticationMethod);

/** @internal */
export type Target$Outbound = {
  protocol?: string | undefined;
  host: string;
  port?: number | undefined;
  path?: string | undefined;
};

/** @internal */
export const Target$outboundSchema: z.ZodType<
  Target$Outbound,
  z.ZodTypeDef,
  Target
> = z.object({
  protocol: models.ProtocolOptionsTargetsItems$outboundSchema.optional(),
  host: z.string(),
  port: z.number().optional(),
  path: z.string().optional(),
});

export function targetToJSON(target: Target): string {
  return JSON.stringify(Target$outboundSchema.parse(target));
}

/** @internal */
export type PodFilter$Outbound = {
  filter: string;
  description?: string | undefined;
};

/** @internal */
export const PodFilter$outboundSchema: z.ZodType<
  PodFilter$Outbound,
  z.ZodTypeDef,
  PodFilter
> = z.object({
  filter: z.string(),
  description: z.string().optional(),
});

export function podFilterToJSON(podFilter: PodFilter): string {
  return JSON.stringify(PodFilter$outboundSchema.parse(podFilter));
}

/** @internal */
export type InputEdgePrometheusPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  timeout?: number | undefined;
  persistence?: models.DiskSpoolingType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  targets?: Array<Target$Outbound> | undefined;
  recordType?: string | undefined;
  scrapePort?: number | undefined;
  nameList?: Array<string> | undefined;
  scrapeProtocol?: string | undefined;
  scrapePath?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp?: boolean | undefined;
  searchFilter?: Array<models.ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  scrapeProtocolExpr?: string | undefined;
  scrapePortExpr?: string | undefined;
  scrapePathExpr?: string | undefined;
  podFilter?: Array<PodFilter$Outbound> | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputEdgePrometheusPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputEdgePrometheusPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputEdgePrometheusPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputEdgePrometheusType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$outboundSchema,
    interval: z.number(),
    timeout: z.number().optional(),
    persistence: models.DiskSpoolingType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authType: InputEdgePrometheusAuthenticationMethod$outboundSchema.optional(),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$outboundSchema)).optional(),
    recordType: models.RecordTypeOptions$outboundSchema.optional(),
    scrapePort: z.number().optional(),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: models.ProtocolOptionsTargetsItems$outboundSchema
      .optional(),
    scrapePath: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().optional(),
    searchFilter: z.array(models.ItemsTypeSearchFilter$outboundSchema)
      .optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models.SignatureVersionOptions1$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    scrapeProtocolExpr: z.string().optional(),
    scrapePortExpr: z.string().optional(),
    scrapePathExpr: z.string().optional(),
    podFilter: z.array(z.lazy(() => PodFilter$outboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });

export function inputEdgePrometheusPqEnabledTrueWithPqConstraintToJSON(
  inputEdgePrometheusPqEnabledTrueWithPqConstraint:
    InputEdgePrometheusPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputEdgePrometheusPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputEdgePrometheusPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputEdgePrometheusPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  timeout?: number | undefined;
  persistence?: models.DiskSpoolingType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  targets?: Array<Target$Outbound> | undefined;
  recordType?: string | undefined;
  scrapePort?: number | undefined;
  nameList?: Array<string> | undefined;
  scrapeProtocol?: string | undefined;
  scrapePath?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp?: boolean | undefined;
  searchFilter?: Array<models.ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  scrapeProtocolExpr?: string | undefined;
  scrapePortExpr?: string | undefined;
  scrapePathExpr?: string | undefined;
  podFilter?: Array<PodFilter$Outbound> | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputEdgePrometheusPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputEdgePrometheusPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputEdgePrometheusPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputEdgePrometheusType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$outboundSchema,
    interval: z.number(),
    timeout: z.number().optional(),
    persistence: models.DiskSpoolingType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authType: InputEdgePrometheusAuthenticationMethod$outboundSchema.optional(),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$outboundSchema)).optional(),
    recordType: models.RecordTypeOptions$outboundSchema.optional(),
    scrapePort: z.number().optional(),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: models.ProtocolOptionsTargetsItems$outboundSchema
      .optional(),
    scrapePath: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().optional(),
    searchFilter: z.array(models.ItemsTypeSearchFilter$outboundSchema)
      .optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models.SignatureVersionOptions1$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    scrapeProtocolExpr: z.string().optional(),
    scrapePortExpr: z.string().optional(),
    scrapePathExpr: z.string().optional(),
    podFilter: z.array(z.lazy(() => PodFilter$outboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });

export function inputEdgePrometheusPqEnabledFalseConstraintToJSON(
  inputEdgePrometheusPqEnabledFalseConstraint:
    InputEdgePrometheusPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputEdgePrometheusPqEnabledFalseConstraint$outboundSchema.parse(
      inputEdgePrometheusPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    dimensionList?: Array<string> | undefined;
    discoveryType: string;
    interval: number;
    timeout?: number | undefined;
    persistence?: models.DiskSpoolingType$Outbound | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    authType?: string | undefined;
    description?: string | undefined;
    targets?: Array<Target$Outbound> | undefined;
    recordType?: string | undefined;
    scrapePort?: number | undefined;
    nameList?: Array<string> | undefined;
    scrapeProtocol?: string | undefined;
    scrapePath?: string | undefined;
    awsAuthenticationMethod?: string | undefined;
    awsApiKey?: string | undefined;
    awsSecret?: string | undefined;
    usePublicIp?: boolean | undefined;
    searchFilter?: Array<models.ItemsTypeSearchFilter$Outbound> | undefined;
    awsSecretKey?: string | undefined;
    region?: string | undefined;
    endpoint?: string | undefined;
    signatureVersion?: string | undefined;
    reuseConnections?: boolean | undefined;
    rejectUnauthorized?: boolean | undefined;
    enableAssumeRole?: boolean | undefined;
    assumeRoleArn?: string | undefined;
    assumeRoleExternalId?: string | undefined;
    durationSeconds?: number | undefined;
    scrapeProtocolExpr?: string | undefined;
    scrapePortExpr?: string | undefined;
    scrapePathExpr?: string | undefined;
    podFilter?: Array<PodFilter$Outbound> | undefined;
    username?: string | undefined;
    password?: string | undefined;
    credentialsSecret?: string | undefined;
  };

/** @internal */
export const InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputEdgePrometheusType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$outboundSchema,
    interval: z.number(),
    timeout: z.number().optional(),
    persistence: models.DiskSpoolingType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authType: InputEdgePrometheusAuthenticationMethod$outboundSchema.optional(),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$outboundSchema)).optional(),
    recordType: models.RecordTypeOptions$outboundSchema.optional(),
    scrapePort: z.number().optional(),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: models.ProtocolOptionsTargetsItems$outboundSchema
      .optional(),
    scrapePath: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().optional(),
    searchFilter: z.array(models.ItemsTypeSearchFilter$outboundSchema)
      .optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models.SignatureVersionOptions1$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    scrapeProtocolExpr: z.string().optional(),
    scrapePortExpr: z.string().optional(),
    scrapePathExpr: z.string().optional(),
    podFilter: z.array(z.lazy(() => PodFilter$outboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });

export function inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint:
    InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputEdgePrometheusSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  timeout?: number | undefined;
  persistence?: models.DiskSpoolingType$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  targets?: Array<Target$Outbound> | undefined;
  recordType?: string | undefined;
  scrapePort?: number | undefined;
  nameList?: Array<string> | undefined;
  scrapeProtocol?: string | undefined;
  scrapePath?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp?: boolean | undefined;
  searchFilter?: Array<models.ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  scrapeProtocolExpr?: string | undefined;
  scrapePortExpr?: string | undefined;
  scrapePathExpr?: string | undefined;
  podFilter?: Array<PodFilter$Outbound> | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputEdgePrometheusSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputEdgePrometheusSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputEdgePrometheusSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputEdgePrometheusType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputEdgePrometheusDiscoveryType$outboundSchema,
    interval: z.number(),
    timeout: z.number().optional(),
    persistence: models.DiskSpoolingType$outboundSchema.optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authType: InputEdgePrometheusAuthenticationMethod$outboundSchema.optional(),
    description: z.string().optional(),
    targets: z.array(z.lazy(() => Target$outboundSchema)).optional(),
    recordType: models.RecordTypeOptions$outboundSchema.optional(),
    scrapePort: z.number().optional(),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: models.ProtocolOptionsTargetsItems$outboundSchema
      .optional(),
    scrapePath: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().optional(),
    searchFilter: z.array(models.ItemsTypeSearchFilter$outboundSchema)
      .optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models.SignatureVersionOptions1$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    scrapeProtocolExpr: z.string().optional(),
    scrapePortExpr: z.string().optional(),
    scrapePathExpr: z.string().optional(),
    podFilter: z.array(z.lazy(() => PodFilter$outboundSchema)).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });

export function inputEdgePrometheusSendToRoutesTrueConstraintToJSON(
  inputEdgePrometheusSendToRoutesTrueConstraint:
    InputEdgePrometheusSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputEdgePrometheusSendToRoutesTrueConstraint$outboundSchema.parse(
      inputEdgePrometheusSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputEdgePrometheus$Outbound =
  | InputEdgePrometheusSendToRoutesTrueConstraint$Outbound
  | InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputEdgePrometheusPqEnabledFalseConstraint$Outbound
  | InputEdgePrometheusPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputEdgePrometheus$outboundSchema: z.ZodType<
  InputEdgePrometheus$Outbound,
  z.ZodTypeDef,
  InputEdgePrometheus
> = z.union([
  z.lazy(() => InputEdgePrometheusSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputEdgePrometheusPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputEdgePrometheusPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputEdgePrometheusToJSON(
  inputEdgePrometheus: InputEdgePrometheus,
): string {
  return JSON.stringify(
    InputEdgePrometheus$outboundSchema.parse(inputEdgePrometheus),
  );
}

/** @internal */
export const InputPrometheusType$outboundSchema: z.ZodNativeEnum<
  typeof InputPrometheusType
> = z.nativeEnum(InputPrometheusType);

/** @internal */
export const InputPrometheusDiscoveryType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType
> = openEnums.outboundSchema(InputPrometheusDiscoveryType);

/** @internal */
export const InputPrometheusLogLevel$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputPrometheusLogLevel
> = openEnums.outboundSchema(InputPrometheusLogLevel);

/** @internal */
export const MetricsProtocol$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  MetricsProtocol
> = openEnums.outboundSchema(MetricsProtocol);

/** @internal */
export type InputPrometheusPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType?: string | undefined;
  interval: number;
  logLevel: string;
  rejectUnauthorized?: boolean | undefined;
  timeout?: number | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType?: string | undefined;
  scrapePort?: number | undefined;
  nameList?: Array<string> | undefined;
  scrapeProtocol?: string | undefined;
  scrapePath?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp?: boolean | undefined;
  searchFilter?: Array<models.ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputPrometheusPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputPrometheusPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputPrometheusType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputPrometheusDiscoveryType$outboundSchema.optional(),
    interval: z.number(),
    logLevel: InputPrometheusLogLevel$outboundSchema,
    rejectUnauthorized: z.boolean().optional(),
    timeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authType: models.AuthenticationMethodOptionsSasl$outboundSchema.optional(),
    description: z.string().optional(),
    targetList: z.array(z.string()).optional(),
    recordType: models.RecordTypeOptions$outboundSchema.optional(),
    scrapePort: z.number().optional(),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: MetricsProtocol$outboundSchema.optional(),
    scrapePath: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().optional(),
    searchFilter: z.array(models.ItemsTypeSearchFilter$outboundSchema)
      .optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models.SignatureVersionOptions1$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });

export function inputPrometheusPqEnabledTrueWithPqConstraintToJSON(
  inputPrometheusPqEnabledTrueWithPqConstraint:
    InputPrometheusPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputPrometheusPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputPrometheusPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputPrometheusPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType?: string | undefined;
  interval: number;
  logLevel: string;
  rejectUnauthorized?: boolean | undefined;
  timeout?: number | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType?: string | undefined;
  scrapePort?: number | undefined;
  nameList?: Array<string> | undefined;
  scrapeProtocol?: string | undefined;
  scrapePath?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp?: boolean | undefined;
  searchFilter?: Array<models.ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputPrometheusPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputPrometheusPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputPrometheusType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType$outboundSchema.optional(),
  interval: z.number(),
  logLevel: InputPrometheusLogLevel$outboundSchema,
  rejectUnauthorized: z.boolean().optional(),
  timeout: z.number().optional(),
  keepAliveTime: z.number().optional(),
  jobTimeout: z.string().optional(),
  maxMissedKeepAlives: z.number().optional(),
  ttl: z.string().optional(),
  ignoreGroupJobsLimit: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  authType: models.AuthenticationMethodOptionsSasl$outboundSchema.optional(),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: models.RecordTypeOptions$outboundSchema.optional(),
  scrapePort: z.number().optional(),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: MetricsProtocol$outboundSchema.optional(),
  scrapePath: z.string().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().optional(),
  searchFilter: z.array(models.ItemsTypeSearchFilter$outboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptions1$outboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

export function inputPrometheusPqEnabledFalseConstraintToJSON(
  inputPrometheusPqEnabledFalseConstraint:
    InputPrometheusPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputPrometheusPqEnabledFalseConstraint$outboundSchema.parse(
      inputPrometheusPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputPrometheusSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    dimensionList?: Array<string> | undefined;
    discoveryType?: string | undefined;
    interval: number;
    logLevel: string;
    rejectUnauthorized?: boolean | undefined;
    timeout?: number | undefined;
    keepAliveTime?: number | undefined;
    jobTimeout?: string | undefined;
    maxMissedKeepAlives?: number | undefined;
    ttl?: string | undefined;
    ignoreGroupJobsLimit?: boolean | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    authType?: string | undefined;
    description?: string | undefined;
    targetList?: Array<string> | undefined;
    recordType?: string | undefined;
    scrapePort?: number | undefined;
    nameList?: Array<string> | undefined;
    scrapeProtocol?: string | undefined;
    scrapePath?: string | undefined;
    awsAuthenticationMethod?: string | undefined;
    awsApiKey?: string | undefined;
    awsSecret?: string | undefined;
    usePublicIp?: boolean | undefined;
    searchFilter?: Array<models.ItemsTypeSearchFilter$Outbound> | undefined;
    awsSecretKey?: string | undefined;
    region?: string | undefined;
    endpoint?: string | undefined;
    signatureVersion?: string | undefined;
    reuseConnections?: boolean | undefined;
    enableAssumeRole?: boolean | undefined;
    assumeRoleArn?: string | undefined;
    assumeRoleExternalId?: string | undefined;
    durationSeconds?: number | undefined;
    username?: string | undefined;
    password?: string | undefined;
    credentialsSecret?: string | undefined;
  };

/** @internal */
export const InputPrometheusSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputPrometheusSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputPrometheusSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputPrometheusType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputPrometheusDiscoveryType$outboundSchema.optional(),
    interval: z.number(),
    logLevel: InputPrometheusLogLevel$outboundSchema,
    rejectUnauthorized: z.boolean().optional(),
    timeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authType: models.AuthenticationMethodOptionsSasl$outboundSchema.optional(),
    description: z.string().optional(),
    targetList: z.array(z.string()).optional(),
    recordType: models.RecordTypeOptions$outboundSchema.optional(),
    scrapePort: z.number().optional(),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: MetricsProtocol$outboundSchema.optional(),
    scrapePath: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().optional(),
    searchFilter: z.array(models.ItemsTypeSearchFilter$outboundSchema)
      .optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models.SignatureVersionOptions1$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });

export function inputPrometheusSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputPrometheusSendToRoutesFalseWithConnectionsConstraint:
    InputPrometheusSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputPrometheusSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputPrometheusSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputPrometheusSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType?: string | undefined;
  interval: number;
  logLevel: string;
  rejectUnauthorized?: boolean | undefined;
  timeout?: number | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType?: string | undefined;
  scrapePort?: number | undefined;
  nameList?: Array<string> | undefined;
  scrapeProtocol?: string | undefined;
  scrapePath?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp?: boolean | undefined;
  searchFilter?: Array<models.ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputPrometheusSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputPrometheusSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputPrometheusType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    dimensionList: z.array(z.string()).optional(),
    discoveryType: InputPrometheusDiscoveryType$outboundSchema.optional(),
    interval: z.number(),
    logLevel: InputPrometheusLogLevel$outboundSchema,
    rejectUnauthorized: z.boolean().optional(),
    timeout: z.number().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authType: models.AuthenticationMethodOptionsSasl$outboundSchema.optional(),
    description: z.string().optional(),
    targetList: z.array(z.string()).optional(),
    recordType: models.RecordTypeOptions$outboundSchema.optional(),
    scrapePort: z.number().optional(),
    nameList: z.array(z.string()).optional(),
    scrapeProtocol: MetricsProtocol$outboundSchema.optional(),
    scrapePath: z.string().optional(),
    awsAuthenticationMethod: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
    usePublicIp: z.boolean().optional(),
    searchFilter: z.array(models.ItemsTypeSearchFilter$outboundSchema)
      .optional(),
    awsSecretKey: z.string().optional(),
    region: z.string().optional(),
    endpoint: z.string().optional(),
    signatureVersion: models.SignatureVersionOptions1$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
  });

export function inputPrometheusSendToRoutesTrueConstraintToJSON(
  inputPrometheusSendToRoutesTrueConstraint:
    InputPrometheusSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputPrometheusSendToRoutesTrueConstraint$outboundSchema.parse(
      inputPrometheusSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputPrometheus$Outbound =
  | InputPrometheusSendToRoutesTrueConstraint$Outbound
  | InputPrometheusSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputPrometheusPqEnabledFalseConstraint$Outbound
  | InputPrometheusPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputPrometheus$outboundSchema: z.ZodType<
  InputPrometheus$Outbound,
  z.ZodTypeDef,
  InputPrometheus
> = z.union([
  z.lazy(() => InputPrometheusSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputPrometheusSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputPrometheusPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputPrometheusPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputPrometheusToJSON(
  inputPrometheus: InputPrometheus,
): string {
  return JSON.stringify(InputPrometheus$outboundSchema.parse(inputPrometheus));
}

/** @internal */
export const InputPrometheusRwType$outboundSchema: z.ZodNativeEnum<
  typeof InputPrometheusRwType
> = z.nativeEnum(InputPrometheusRwType);

/** @internal */
export type InputPrometheusRwPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  prometheusAPI: string;
  authType?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const InputPrometheusRwPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputPrometheusRwPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputPrometheusRwPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputPrometheusRwType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    prometheusAPI: z.string(),
    authType: models.AuthenticationTypeOptionsPrometheusAuth$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
  });

export function inputPrometheusRwPqEnabledTrueWithPqConstraintToJSON(
  inputPrometheusRwPqEnabledTrueWithPqConstraint:
    InputPrometheusRwPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputPrometheusRwPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputPrometheusRwPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputPrometheusRwPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  prometheusAPI: string;
  authType?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const InputPrometheusRwPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputPrometheusRwPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputPrometheusRwPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputPrometheusRwType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    prometheusAPI: z.string(),
    authType: models.AuthenticationTypeOptionsPrometheusAuth$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
  });

export function inputPrometheusRwPqEnabledFalseConstraintToJSON(
  inputPrometheusRwPqEnabledFalseConstraint:
    InputPrometheusRwPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputPrometheusRwPqEnabledFalseConstraint$outboundSchema.parse(
      inputPrometheusRwPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    host: string;
    port: number;
    tls?: models.TlsSettingsServerSideType$Outbound | undefined;
    maxActiveReq?: number | undefined;
    maxRequestsPerSocket?: number | undefined;
    enableProxyHeader?: boolean | undefined;
    captureHeaders?: boolean | undefined;
    activityLogSampleRate?: number | undefined;
    requestTimeout?: number | undefined;
    socketTimeout?: number | undefined;
    keepAliveTimeout?: number | undefined;
    enableHealthCheck?: boolean | undefined;
    ipAllowlistRegex?: string | undefined;
    ipDenylistRegex?: string | undefined;
    prometheusAPI: string;
    authType?: string | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    description?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    token?: string | undefined;
    credentialsSecret?: string | undefined;
    textSecret?: string | undefined;
    loginUrl?: string | undefined;
    secretParamName?: string | undefined;
    secret?: string | undefined;
    tokenAttributeName?: string | undefined;
    authHeaderExpr?: string | undefined;
    tokenTimeoutSecs?: number | undefined;
    oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
    oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
  };

/** @internal */
export const InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputPrometheusRwType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    prometheusAPI: z.string(),
    authType: models.AuthenticationTypeOptionsPrometheusAuth$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
  });

export function inputPrometheusRwSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputPrometheusRwSendToRoutesFalseWithConnectionsConstraint:
    InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputPrometheusRwSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputPrometheusRwSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  prometheusAPI: string;
  authType?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const InputPrometheusRwSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputPrometheusRwSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputPrometheusRwSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputPrometheusRwType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    prometheusAPI: z.string(),
    authType: models.AuthenticationTypeOptionsPrometheusAuth$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
  });

export function inputPrometheusRwSendToRoutesTrueConstraintToJSON(
  inputPrometheusRwSendToRoutesTrueConstraint:
    InputPrometheusRwSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputPrometheusRwSendToRoutesTrueConstraint$outboundSchema.parse(
      inputPrometheusRwSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputPrometheusRw$Outbound =
  | InputPrometheusRwSendToRoutesTrueConstraint$Outbound
  | InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputPrometheusRwPqEnabledFalseConstraint$Outbound
  | InputPrometheusRwPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputPrometheusRw$outboundSchema: z.ZodType<
  InputPrometheusRw$Outbound,
  z.ZodTypeDef,
  InputPrometheusRw
> = z.union([
  z.lazy(() => InputPrometheusRwSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputPrometheusRwPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputPrometheusRwPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputPrometheusRwToJSON(
  inputPrometheusRw: InputPrometheusRw,
): string {
  return JSON.stringify(
    InputPrometheusRw$outboundSchema.parse(inputPrometheusRw),
  );
}

/** @internal */
export const InputLokiType$outboundSchema: z.ZodNativeEnum<
  typeof InputLokiType
> = z.nativeEnum(InputLokiType);

/** @internal */
export type InputLokiPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  lokiAPI: string;
  authType?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const InputLokiPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputLokiPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputLokiPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputLokiType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  lokiAPI: z.string(),
  authType: models.AuthenticationTypeOptionsLokiAuth$outboundSchema.optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().optional(),
  tokenTimeoutSecs: z.number().optional(),
  oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
  oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema).optional(),
});

export function inputLokiPqEnabledTrueWithPqConstraintToJSON(
  inputLokiPqEnabledTrueWithPqConstraint:
    InputLokiPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputLokiPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputLokiPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputLokiPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  lokiAPI: string;
  authType?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const InputLokiPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputLokiPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputLokiPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputLokiType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  lokiAPI: z.string(),
  authType: models.AuthenticationTypeOptionsLokiAuth$outboundSchema.optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().optional(),
  tokenTimeoutSecs: z.number().optional(),
  oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
  oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema).optional(),
});

export function inputLokiPqEnabledFalseConstraintToJSON(
  inputLokiPqEnabledFalseConstraint: InputLokiPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputLokiPqEnabledFalseConstraint$outboundSchema.parse(
      inputLokiPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputLokiSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  lokiAPI: string;
  authType?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const InputLokiSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputLokiSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputLokiSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputLokiType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    lokiAPI: z.string(),
    authType: models.AuthenticationTypeOptionsLokiAuth$outboundSchema
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
  });

export function inputLokiSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputLokiSendToRoutesFalseWithConnectionsConstraint:
    InputLokiSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputLokiSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputLokiSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputLokiSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  lokiAPI: string;
  authType?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const InputLokiSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputLokiSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputLokiSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputLokiType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  lokiAPI: z.string(),
  authType: models.AuthenticationTypeOptionsLokiAuth$outboundSchema.optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().optional(),
  tokenTimeoutSecs: z.number().optional(),
  oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
  oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema).optional(),
});

export function inputLokiSendToRoutesTrueConstraintToJSON(
  inputLokiSendToRoutesTrueConstraint: InputLokiSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputLokiSendToRoutesTrueConstraint$outboundSchema.parse(
      inputLokiSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputLoki$Outbound =
  | InputLokiSendToRoutesTrueConstraint$Outbound
  | InputLokiSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputLokiPqEnabledFalseConstraint$Outbound
  | InputLokiPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputLoki$outboundSchema: z.ZodType<
  InputLoki$Outbound,
  z.ZodTypeDef,
  InputLoki
> = z.union([
  z.lazy(() => InputLokiSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputLokiSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputLokiPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputLokiPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputLokiToJSON(inputLoki: InputLoki): string {
  return JSON.stringify(InputLoki$outboundSchema.parse(inputLoki));
}

/** @internal */
export const InputGrafanaType2$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaType2
> = z.nativeEnum(InputGrafanaType2);

/** @internal */
export type PrometheusAuth2$Outbound = {
  authType?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const PrometheusAuth2$outboundSchema: z.ZodType<
  PrometheusAuth2$Outbound,
  z.ZodTypeDef,
  PrometheusAuth2
> = z.object({
  authType: models.AuthenticationTypeOptionsPrometheusAuth$outboundSchema
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().optional(),
  tokenTimeoutSecs: z.number().optional(),
  oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
  oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema).optional(),
});

export function prometheusAuth2ToJSON(
  prometheusAuth2: PrometheusAuth2,
): string {
  return JSON.stringify(PrometheusAuth2$outboundSchema.parse(prometheusAuth2));
}

/** @internal */
export type LokiAuth2$Outbound = {
  authType?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const LokiAuth2$outboundSchema: z.ZodType<
  LokiAuth2$Outbound,
  z.ZodTypeDef,
  LokiAuth2
> = z.object({
  authType: models.AuthenticationTypeOptionsLokiAuth$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().optional(),
  tokenTimeoutSecs: z.number().optional(),
  oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
  oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema).optional(),
});

export function lokiAuth2ToJSON(lokiAuth2: LokiAuth2): string {
  return JSON.stringify(LokiAuth2$outboundSchema.parse(lokiAuth2));
}

/** @internal */
export type InputGrafanaGrafana2$Outbound = {
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  prometheusAPI?: string | undefined;
  lokiAPI: string;
  prometheusAuth?: PrometheusAuth2$Outbound | undefined;
  lokiAuth?: LokiAuth2$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputGrafanaGrafana2$outboundSchema: z.ZodType<
  InputGrafanaGrafana2$Outbound,
  z.ZodTypeDef,
  InputGrafanaGrafana2
> = z.object({
  id: z.string(),
  type: InputGrafanaType2$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  prometheusAPI: z.string().optional(),
  lokiAPI: z.string(),
  prometheusAuth: z.lazy(() => PrometheusAuth2$outboundSchema).optional(),
  lokiAuth: z.lazy(() => LokiAuth2$outboundSchema).optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputGrafanaGrafana2ToJSON(
  inputGrafanaGrafana2: InputGrafanaGrafana2,
): string {
  return JSON.stringify(
    InputGrafanaGrafana2$outboundSchema.parse(inputGrafanaGrafana2),
  );
}

/** @internal */
export const InputGrafanaType1$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaType1
> = z.nativeEnum(InputGrafanaType1);

/** @internal */
export type PrometheusAuth1$Outbound = {
  authType?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const PrometheusAuth1$outboundSchema: z.ZodType<
  PrometheusAuth1$Outbound,
  z.ZodTypeDef,
  PrometheusAuth1
> = z.object({
  authType: models.AuthenticationTypeOptionsPrometheusAuth$outboundSchema
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().optional(),
  tokenTimeoutSecs: z.number().optional(),
  oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
  oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema).optional(),
});

export function prometheusAuth1ToJSON(
  prometheusAuth1: PrometheusAuth1,
): string {
  return JSON.stringify(PrometheusAuth1$outboundSchema.parse(prometheusAuth1));
}

/** @internal */
export type LokiAuth1$Outbound = {
  authType?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const LokiAuth1$outboundSchema: z.ZodType<
  LokiAuth1$Outbound,
  z.ZodTypeDef,
  LokiAuth1
> = z.object({
  authType: models.AuthenticationTypeOptionsLokiAuth$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().optional(),
  tokenTimeoutSecs: z.number().optional(),
  oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
  oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema).optional(),
});

export function lokiAuth1ToJSON(lokiAuth1: LokiAuth1): string {
  return JSON.stringify(LokiAuth1$outboundSchema.parse(lokiAuth1));
}

/** @internal */
export type InputGrafanaGrafana1$Outbound = {
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  prometheusAPI: string;
  lokiAPI?: string | undefined;
  prometheusAuth?: PrometheusAuth1$Outbound | undefined;
  lokiAuth?: LokiAuth1$Outbound | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputGrafanaGrafana1$outboundSchema: z.ZodType<
  InputGrafanaGrafana1$Outbound,
  z.ZodTypeDef,
  InputGrafanaGrafana1
> = z.object({
  id: z.string(),
  type: InputGrafanaType1$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  prometheusAPI: z.string(),
  lokiAPI: z.string().optional(),
  prometheusAuth: z.lazy(() => PrometheusAuth1$outboundSchema).optional(),
  lokiAuth: z.lazy(() => LokiAuth1$outboundSchema).optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputGrafanaGrafana1ToJSON(
  inputGrafanaGrafana1: InputGrafanaGrafana1,
): string {
  return JSON.stringify(
    InputGrafanaGrafana1$outboundSchema.parse(inputGrafanaGrafana1),
  );
}

/** @internal */
export type InputGrafana$Outbound =
  | InputGrafanaGrafana1$Outbound
  | InputGrafanaGrafana2$Outbound;

/** @internal */
export const InputGrafana$outboundSchema: z.ZodType<
  InputGrafana$Outbound,
  z.ZodTypeDef,
  InputGrafana
> = z.union([
  z.lazy(() => InputGrafanaGrafana1$outboundSchema),
  z.lazy(() => InputGrafanaGrafana2$outboundSchema),
]);

export function inputGrafanaToJSON(inputGrafana: InputGrafana): string {
  return JSON.stringify(InputGrafana$outboundSchema.parse(inputGrafana));
}

/** @internal */
export const InputConfluentCloudType$outboundSchema: z.ZodNativeEnum<
  typeof InputConfluentCloudType
> = z.nativeEnum(InputConfluentCloudType);

/** @internal */
export type InputConfluentCloudPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  brokers: Array<string>;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  sasl?: models.AuthenticationType$Outbound | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputConfluentCloudPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputConfluentCloudPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputConfluentCloudPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputConfluentCloudType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    brokers: z.array(z.string()),
    tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
      .optional(),
    topics: z.array(z.string()),
    groupId: z.string().optional(),
    fromBeginning: z.boolean().optional(),
    kafkaSchemaRegistry: models
      .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
    connectionTimeout: z.number().optional(),
    requestTimeout: z.number().optional(),
    maxRetries: z.number().optional(),
    maxBackOff: z.number().optional(),
    initialBackoff: z.number().optional(),
    backoffRate: z.number().optional(),
    authenticationTimeout: z.number().optional(),
    reauthenticationThreshold: z.number().optional(),
    sasl: models.AuthenticationType$outboundSchema.optional(),
    sessionTimeout: z.number().optional(),
    rebalanceTimeout: z.number().optional(),
    heartbeatInterval: z.number().optional(),
    autoCommitInterval: z.number().optional(),
    autoCommitThreshold: z.number().optional(),
    maxBytesPerPartition: z.number().optional(),
    maxBytes: z.number().optional(),
    maxSocketErrors: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputConfluentCloudPqEnabledTrueWithPqConstraintToJSON(
  inputConfluentCloudPqEnabledTrueWithPqConstraint:
    InputConfluentCloudPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputConfluentCloudPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputConfluentCloudPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputConfluentCloudPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  brokers: Array<string>;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  sasl?: models.AuthenticationType$Outbound | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputConfluentCloudPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputConfluentCloudPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputConfluentCloudPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputConfluentCloudType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    brokers: z.array(z.string()),
    tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
      .optional(),
    topics: z.array(z.string()),
    groupId: z.string().optional(),
    fromBeginning: z.boolean().optional(),
    kafkaSchemaRegistry: models
      .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
    connectionTimeout: z.number().optional(),
    requestTimeout: z.number().optional(),
    maxRetries: z.number().optional(),
    maxBackOff: z.number().optional(),
    initialBackoff: z.number().optional(),
    backoffRate: z.number().optional(),
    authenticationTimeout: z.number().optional(),
    reauthenticationThreshold: z.number().optional(),
    sasl: models.AuthenticationType$outboundSchema.optional(),
    sessionTimeout: z.number().optional(),
    rebalanceTimeout: z.number().optional(),
    heartbeatInterval: z.number().optional(),
    autoCommitInterval: z.number().optional(),
    autoCommitThreshold: z.number().optional(),
    maxBytesPerPartition: z.number().optional(),
    maxBytes: z.number().optional(),
    maxSocketErrors: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputConfluentCloudPqEnabledFalseConstraintToJSON(
  inputConfluentCloudPqEnabledFalseConstraint:
    InputConfluentCloudPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputConfluentCloudPqEnabledFalseConstraint$outboundSchema.parse(
      inputConfluentCloudPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    brokers: Array<string>;
    tls?:
      | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
      | undefined;
    topics: Array<string>;
    groupId?: string | undefined;
    fromBeginning?: boolean | undefined;
    kafkaSchemaRegistry?:
      | models.KafkaSchemaRegistryAuthenticationType$Outbound
      | undefined;
    connectionTimeout?: number | undefined;
    requestTimeout?: number | undefined;
    maxRetries?: number | undefined;
    maxBackOff?: number | undefined;
    initialBackoff?: number | undefined;
    backoffRate?: number | undefined;
    authenticationTimeout?: number | undefined;
    reauthenticationThreshold?: number | undefined;
    sasl?: models.AuthenticationType$Outbound | undefined;
    sessionTimeout?: number | undefined;
    rebalanceTimeout?: number | undefined;
    heartbeatInterval?: number | undefined;
    autoCommitInterval?: number | undefined;
    autoCommitThreshold?: number | undefined;
    maxBytesPerPartition?: number | undefined;
    maxBytes?: number | undefined;
    maxSocketErrors?: number | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputConfluentCloudType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    brokers: z.array(z.string()),
    tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
      .optional(),
    topics: z.array(z.string()),
    groupId: z.string().optional(),
    fromBeginning: z.boolean().optional(),
    kafkaSchemaRegistry: models
      .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
    connectionTimeout: z.number().optional(),
    requestTimeout: z.number().optional(),
    maxRetries: z.number().optional(),
    maxBackOff: z.number().optional(),
    initialBackoff: z.number().optional(),
    backoffRate: z.number().optional(),
    authenticationTimeout: z.number().optional(),
    reauthenticationThreshold: z.number().optional(),
    sasl: models.AuthenticationType$outboundSchema.optional(),
    sessionTimeout: z.number().optional(),
    rebalanceTimeout: z.number().optional(),
    heartbeatInterval: z.number().optional(),
    autoCommitInterval: z.number().optional(),
    autoCommitThreshold: z.number().optional(),
    maxBytesPerPartition: z.number().optional(),
    maxBytes: z.number().optional(),
    maxSocketErrors: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputConfluentCloudSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputConfluentCloudSendToRoutesFalseWithConnectionsConstraint:
    InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputConfluentCloudSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputConfluentCloudSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  brokers: Array<string>;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  sasl?: models.AuthenticationType$Outbound | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputConfluentCloudSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputConfluentCloudSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputConfluentCloudSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputConfluentCloudType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    brokers: z.array(z.string()),
    tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
      .optional(),
    topics: z.array(z.string()),
    groupId: z.string().optional(),
    fromBeginning: z.boolean().optional(),
    kafkaSchemaRegistry: models
      .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
    connectionTimeout: z.number().optional(),
    requestTimeout: z.number().optional(),
    maxRetries: z.number().optional(),
    maxBackOff: z.number().optional(),
    initialBackoff: z.number().optional(),
    backoffRate: z.number().optional(),
    authenticationTimeout: z.number().optional(),
    reauthenticationThreshold: z.number().optional(),
    sasl: models.AuthenticationType$outboundSchema.optional(),
    sessionTimeout: z.number().optional(),
    rebalanceTimeout: z.number().optional(),
    heartbeatInterval: z.number().optional(),
    autoCommitInterval: z.number().optional(),
    autoCommitThreshold: z.number().optional(),
    maxBytesPerPartition: z.number().optional(),
    maxBytes: z.number().optional(),
    maxSocketErrors: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputConfluentCloudSendToRoutesTrueConstraintToJSON(
  inputConfluentCloudSendToRoutesTrueConstraint:
    InputConfluentCloudSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputConfluentCloudSendToRoutesTrueConstraint$outboundSchema.parse(
      inputConfluentCloudSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputConfluentCloud$Outbound =
  | InputConfluentCloudSendToRoutesTrueConstraint$Outbound
  | InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputConfluentCloudPqEnabledFalseConstraint$Outbound
  | InputConfluentCloudPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputConfluentCloud$outboundSchema: z.ZodType<
  InputConfluentCloud$Outbound,
  z.ZodTypeDef,
  InputConfluentCloud
> = z.union([
  z.lazy(() => InputConfluentCloudSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputConfluentCloudPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputConfluentCloudPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputConfluentCloudToJSON(
  inputConfluentCloud: InputConfluentCloud,
): string {
  return JSON.stringify(
    InputConfluentCloud$outboundSchema.parse(inputConfluentCloud),
  );
}

/** @internal */
export const InputElasticType$outboundSchema: z.ZodNativeEnum<
  typeof InputElasticType
> = z.nativeEnum(InputElasticType);

/** @internal */
export const InputElasticAuthenticationType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputElasticAuthenticationType
> = openEnums.outboundSchema(InputElasticAuthenticationType);

/** @internal */
export const CreateInputAPIVersion$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CreateInputAPIVersion
> = openEnums.outboundSchema(CreateInputAPIVersion);

/** @internal */
export const InputElasticAuthenticationMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputElasticAuthenticationMethod
> = openEnums.outboundSchema(InputElasticAuthenticationMethod);

/** @internal */
export type InputElasticProxyMode$Outbound = {
  enabled: boolean;
  authType?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  url?: string | undefined;
  rejectUnauthorized?: boolean | undefined;
  removeHeaders?: Array<string> | undefined;
  timeoutSec?: number | undefined;
};

/** @internal */
export const InputElasticProxyMode$outboundSchema: z.ZodType<
  InputElasticProxyMode$Outbound,
  z.ZodTypeDef,
  InputElasticProxyMode
> = z.object({
  enabled: z.boolean(),
  authType: InputElasticAuthenticationMethod$outboundSchema.optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  url: z.string().optional(),
  rejectUnauthorized: z.boolean().optional(),
  removeHeaders: z.array(z.string()).optional(),
  timeoutSec: z.number().optional(),
});

export function inputElasticProxyModeToJSON(
  inputElasticProxyMode: InputElasticProxyMode,
): string {
  return JSON.stringify(
    InputElasticProxyMode$outboundSchema.parse(inputElasticProxyMode),
  );
}

/** @internal */
export type InputElasticPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  elasticAPI: string;
  authType?: string | undefined;
  apiVersion?: string | undefined;
  extraHttpHeaders?:
    | Array<models.ItemsTypeExtraHttpHeaders$Outbound>
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  proxyMode?: InputElasticProxyMode$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  authTokens?: Array<string> | undefined;
  customAPIVersion?: string | undefined;
};

/** @internal */
export const InputElasticPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputElasticPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputElasticPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputElasticType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    elasticAPI: z.string(),
    authType: InputElasticAuthenticationType$outboundSchema.optional(),
    apiVersion: CreateInputAPIVersion$outboundSchema.optional(),
    extraHttpHeaders: z.array(models.ItemsTypeExtraHttpHeaders$outboundSchema)
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    proxyMode: z.lazy(() => InputElasticProxyMode$outboundSchema).optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
    authTokens: z.array(z.string()).optional(),
    customAPIVersion: z.string().optional(),
  });

export function inputElasticPqEnabledTrueWithPqConstraintToJSON(
  inputElasticPqEnabledTrueWithPqConstraint:
    InputElasticPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputElasticPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputElasticPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputElasticPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  elasticAPI: string;
  authType?: string | undefined;
  apiVersion?: string | undefined;
  extraHttpHeaders?:
    | Array<models.ItemsTypeExtraHttpHeaders$Outbound>
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  proxyMode?: InputElasticProxyMode$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  authTokens?: Array<string> | undefined;
  customAPIVersion?: string | undefined;
};

/** @internal */
export const InputElasticPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputElasticPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputElasticPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputElasticType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  elasticAPI: z.string(),
  authType: InputElasticAuthenticationType$outboundSchema.optional(),
  apiVersion: CreateInputAPIVersion$outboundSchema.optional(),
  extraHttpHeaders: z.array(models.ItemsTypeExtraHttpHeaders$outboundSchema)
    .optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  proxyMode: z.lazy(() => InputElasticProxyMode$outboundSchema).optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  authTokens: z.array(z.string()).optional(),
  customAPIVersion: z.string().optional(),
});

export function inputElasticPqEnabledFalseConstraintToJSON(
  inputElasticPqEnabledFalseConstraint: InputElasticPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputElasticPqEnabledFalseConstraint$outboundSchema.parse(
      inputElasticPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputElasticSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  elasticAPI: string;
  authType?: string | undefined;
  apiVersion?: string | undefined;
  extraHttpHeaders?:
    | Array<models.ItemsTypeExtraHttpHeaders$Outbound>
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  proxyMode?: InputElasticProxyMode$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  authTokens?: Array<string> | undefined;
  customAPIVersion?: string | undefined;
};

/** @internal */
export const InputElasticSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputElasticSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputElasticSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputElasticType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    elasticAPI: z.string(),
    authType: InputElasticAuthenticationType$outboundSchema.optional(),
    apiVersion: CreateInputAPIVersion$outboundSchema.optional(),
    extraHttpHeaders: z.array(models.ItemsTypeExtraHttpHeaders$outboundSchema)
      .optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    proxyMode: z.lazy(() => InputElasticProxyMode$outboundSchema).optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
    authTokens: z.array(z.string()).optional(),
    customAPIVersion: z.string().optional(),
  });

export function inputElasticSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputElasticSendToRoutesFalseWithConnectionsConstraint:
    InputElasticSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputElasticSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputElasticSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputElasticSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  elasticAPI: string;
  authType?: string | undefined;
  apiVersion?: string | undefined;
  extraHttpHeaders?:
    | Array<models.ItemsTypeExtraHttpHeaders$Outbound>
    | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  proxyMode?: InputElasticProxyMode$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  authTokens?: Array<string> | undefined;
  customAPIVersion?: string | undefined;
};

/** @internal */
export const InputElasticSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputElasticSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputElasticSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputElasticType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  elasticAPI: z.string(),
  authType: InputElasticAuthenticationType$outboundSchema.optional(),
  apiVersion: CreateInputAPIVersion$outboundSchema.optional(),
  extraHttpHeaders: z.array(models.ItemsTypeExtraHttpHeaders$outboundSchema)
    .optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  proxyMode: z.lazy(() => InputElasticProxyMode$outboundSchema).optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  authTokens: z.array(z.string()).optional(),
  customAPIVersion: z.string().optional(),
});

export function inputElasticSendToRoutesTrueConstraintToJSON(
  inputElasticSendToRoutesTrueConstraint:
    InputElasticSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputElasticSendToRoutesTrueConstraint$outboundSchema.parse(
      inputElasticSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputElastic$Outbound =
  | InputElasticSendToRoutesTrueConstraint$Outbound
  | InputElasticSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputElasticPqEnabledFalseConstraint$Outbound
  | InputElasticPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputElastic$outboundSchema: z.ZodType<
  InputElastic$Outbound,
  z.ZodTypeDef,
  InputElastic
> = z.union([
  z.lazy(() => InputElasticSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputElasticSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputElasticPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputElasticPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputElasticToJSON(inputElastic: InputElastic): string {
  return JSON.stringify(InputElastic$outboundSchema.parse(inputElastic));
}

/** @internal */
export const InputAzureBlobType$outboundSchema: z.ZodNativeEnum<
  typeof InputAzureBlobType
> = z.nativeEnum(InputAzureBlobType);

/** @internal */
export type InputAzureBlobPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  maxMessages?: number | undefined;
  servicePeriodSecs?: number | undefined;
  skipOnError?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  connectionString?: string | undefined;
  textSecret?: string | undefined;
  storageAccountName?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  azureCloud?: string | undefined;
  endpointSuffix?: string | undefined;
  clientTextSecret?: string | undefined;
  certificate?:
    | models.CertificateTypeAzureBlobAuthTypeClientCert$Outbound
    | undefined;
};

/** @internal */
export const InputAzureBlobPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputAzureBlobPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputAzureBlobPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputAzureBlobType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    maxMessages: z.number().optional(),
    servicePeriodSecs: z.number().optional(),
    skipOnError: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    parquetChunkSizeMB: z.number().optional(),
    parquetChunkDownloadTimeout: z.number().optional(),
    authType: models.AuthenticationMethodOptions$outboundSchema.optional(),
    description: z.string().optional(),
    connectionString: z.string().optional(),
    textSecret: z.string().optional(),
    storageAccountName: z.string().optional(),
    tenantId: z.string().optional(),
    clientId: z.string().optional(),
    azureCloud: z.string().optional(),
    endpointSuffix: z.string().optional(),
    clientTextSecret: z.string().optional(),
    certificate: models
      .CertificateTypeAzureBlobAuthTypeClientCert$outboundSchema.optional(),
  });

export function inputAzureBlobPqEnabledTrueWithPqConstraintToJSON(
  inputAzureBlobPqEnabledTrueWithPqConstraint:
    InputAzureBlobPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputAzureBlobPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputAzureBlobPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputAzureBlobPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  maxMessages?: number | undefined;
  servicePeriodSecs?: number | undefined;
  skipOnError?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  connectionString?: string | undefined;
  textSecret?: string | undefined;
  storageAccountName?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  azureCloud?: string | undefined;
  endpointSuffix?: string | undefined;
  clientTextSecret?: string | undefined;
  certificate?:
    | models.CertificateTypeAzureBlobAuthTypeClientCert$Outbound
    | undefined;
};

/** @internal */
export const InputAzureBlobPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputAzureBlobPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputAzureBlobPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputAzureBlobType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  queueName: z.string(),
  fileFilter: z.string().optional(),
  visibilityTimeout: z.number().optional(),
  numReceivers: z.number().optional(),
  maxMessages: z.number().optional(),
  servicePeriodSecs: z.number().optional(),
  skipOnError: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  parquetChunkSizeMB: z.number().optional(),
  parquetChunkDownloadTimeout: z.number().optional(),
  authType: models.AuthenticationMethodOptions$outboundSchema.optional(),
  description: z.string().optional(),
  connectionString: z.string().optional(),
  textSecret: z.string().optional(),
  storageAccountName: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  clientTextSecret: z.string().optional(),
  certificate: models.CertificateTypeAzureBlobAuthTypeClientCert$outboundSchema
    .optional(),
});

export function inputAzureBlobPqEnabledFalseConstraintToJSON(
  inputAzureBlobPqEnabledFalseConstraint:
    InputAzureBlobPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputAzureBlobPqEnabledFalseConstraint$outboundSchema.parse(
      inputAzureBlobPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputAzureBlobSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    queueName: string;
    fileFilter?: string | undefined;
    visibilityTimeout?: number | undefined;
    numReceivers?: number | undefined;
    maxMessages?: number | undefined;
    servicePeriodSecs?: number | undefined;
    skipOnError?: boolean | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    breakerRulesets?: Array<string> | undefined;
    staleChannelFlushMs?: number | undefined;
    parquetChunkSizeMB?: number | undefined;
    parquetChunkDownloadTimeout?: number | undefined;
    authType?: string | undefined;
    description?: string | undefined;
    connectionString?: string | undefined;
    textSecret?: string | undefined;
    storageAccountName?: string | undefined;
    tenantId?: string | undefined;
    clientId?: string | undefined;
    azureCloud?: string | undefined;
    endpointSuffix?: string | undefined;
    clientTextSecret?: string | undefined;
    certificate?:
      | models.CertificateTypeAzureBlobAuthTypeClientCert$Outbound
      | undefined;
  };

/** @internal */
export const InputAzureBlobSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputAzureBlobSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputAzureBlobSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputAzureBlobType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    queueName: z.string(),
    fileFilter: z.string().optional(),
    visibilityTimeout: z.number().optional(),
    numReceivers: z.number().optional(),
    maxMessages: z.number().optional(),
    servicePeriodSecs: z.number().optional(),
    skipOnError: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    parquetChunkSizeMB: z.number().optional(),
    parquetChunkDownloadTimeout: z.number().optional(),
    authType: models.AuthenticationMethodOptions$outboundSchema.optional(),
    description: z.string().optional(),
    connectionString: z.string().optional(),
    textSecret: z.string().optional(),
    storageAccountName: z.string().optional(),
    tenantId: z.string().optional(),
    clientId: z.string().optional(),
    azureCloud: z.string().optional(),
    endpointSuffix: z.string().optional(),
    clientTextSecret: z.string().optional(),
    certificate: models
      .CertificateTypeAzureBlobAuthTypeClientCert$outboundSchema.optional(),
  });

export function inputAzureBlobSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputAzureBlobSendToRoutesFalseWithConnectionsConstraint:
    InputAzureBlobSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputAzureBlobSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputAzureBlobSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputAzureBlobSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  queueName: string;
  fileFilter?: string | undefined;
  visibilityTimeout?: number | undefined;
  numReceivers?: number | undefined;
  maxMessages?: number | undefined;
  servicePeriodSecs?: number | undefined;
  skipOnError?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  parquetChunkSizeMB?: number | undefined;
  parquetChunkDownloadTimeout?: number | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  connectionString?: string | undefined;
  textSecret?: string | undefined;
  storageAccountName?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  azureCloud?: string | undefined;
  endpointSuffix?: string | undefined;
  clientTextSecret?: string | undefined;
  certificate?:
    | models.CertificateTypeAzureBlobAuthTypeClientCert$Outbound
    | undefined;
};

/** @internal */
export const InputAzureBlobSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputAzureBlobSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputAzureBlobSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputAzureBlobType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  queueName: z.string(),
  fileFilter: z.string().optional(),
  visibilityTimeout: z.number().optional(),
  numReceivers: z.number().optional(),
  maxMessages: z.number().optional(),
  servicePeriodSecs: z.number().optional(),
  skipOnError: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  parquetChunkSizeMB: z.number().optional(),
  parquetChunkDownloadTimeout: z.number().optional(),
  authType: models.AuthenticationMethodOptions$outboundSchema.optional(),
  description: z.string().optional(),
  connectionString: z.string().optional(),
  textSecret: z.string().optional(),
  storageAccountName: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  azureCloud: z.string().optional(),
  endpointSuffix: z.string().optional(),
  clientTextSecret: z.string().optional(),
  certificate: models.CertificateTypeAzureBlobAuthTypeClientCert$outboundSchema
    .optional(),
});

export function inputAzureBlobSendToRoutesTrueConstraintToJSON(
  inputAzureBlobSendToRoutesTrueConstraint:
    InputAzureBlobSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputAzureBlobSendToRoutesTrueConstraint$outboundSchema.parse(
      inputAzureBlobSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputAzureBlob$Outbound =
  | InputAzureBlobSendToRoutesTrueConstraint$Outbound
  | InputAzureBlobSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputAzureBlobPqEnabledFalseConstraint$Outbound
  | InputAzureBlobPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputAzureBlob$outboundSchema: z.ZodType<
  InputAzureBlob$Outbound,
  z.ZodTypeDef,
  InputAzureBlob
> = z.union([
  z.lazy(() => InputAzureBlobSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputAzureBlobSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputAzureBlobPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputAzureBlobPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputAzureBlobToJSON(inputAzureBlob: InputAzureBlob): string {
  return JSON.stringify(InputAzureBlob$outboundSchema.parse(inputAzureBlob));
}

/** @internal */
export const InputSplunkHecType$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkHecType
> = z.nativeEnum(InputSplunkHecType);

/** @internal */
export type InputSplunkHecAuthToken$Outbound = {
  authType?: string | undefined;
  tokenSecret?: string | undefined;
  token: string;
  enabled?: boolean | undefined;
  description?: string | undefined;
  allowedIndexesAtToken?: Array<string> | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
};

/** @internal */
export const InputSplunkHecAuthToken$outboundSchema: z.ZodType<
  InputSplunkHecAuthToken$Outbound,
  z.ZodTypeDef,
  InputSplunkHecAuthToken
> = z.object({
  authType: models.AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  tokenSecret: z.string().optional(),
  token: z.string(),
  enabled: z.boolean().optional(),
  description: z.string().optional(),
  allowedIndexesAtToken: z.array(z.string()).optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
});

export function inputSplunkHecAuthTokenToJSON(
  inputSplunkHecAuthToken: InputSplunkHecAuthToken,
): string {
  return JSON.stringify(
    InputSplunkHecAuthToken$outboundSchema.parse(inputSplunkHecAuthToken),
  );
}

/** @internal */
export type InputSplunkHecPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  authTokens?: Array<InputSplunkHecAuthToken$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  splunkHecAPI: string;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  splunkHecAcks?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  useFwdTimezone?: boolean | undefined;
  dropControlFields?: boolean | undefined;
  extractMetrics?: boolean | undefined;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSplunkHecPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputSplunkHecPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputSplunkHecPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputSplunkHecType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.lazy(() => InputSplunkHecAuthToken$outboundSchema))
      .optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.any().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    splunkHecAPI: z.string(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedIndexes: z.array(z.string()).optional(),
    splunkHecAcks: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    useFwdTimezone: z.boolean().optional(),
    dropControlFields: z.boolean().optional(),
    extractMetrics: z.boolean().optional(),
    accessControlAllowOrigin: z.array(z.string()).optional(),
    accessControlAllowHeaders: z.array(z.string()).optional(),
    emitTokenMetrics: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputSplunkHecPqEnabledTrueWithPqConstraintToJSON(
  inputSplunkHecPqEnabledTrueWithPqConstraint:
    InputSplunkHecPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputSplunkHecPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputSplunkHecPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputSplunkHecPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<InputSplunkHecAuthToken$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  splunkHecAPI: string;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  splunkHecAcks?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  useFwdTimezone?: boolean | undefined;
  dropControlFields?: boolean | undefined;
  extractMetrics?: boolean | undefined;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSplunkHecPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputSplunkHecPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputSplunkHecPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputSplunkHecType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(z.lazy(() => InputSplunkHecAuthToken$outboundSchema))
    .optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.any().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  splunkHecAPI: z.string(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  allowedIndexes: z.array(z.string()).optional(),
  splunkHecAcks: z.boolean().optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  useFwdTimezone: z.boolean().optional(),
  dropControlFields: z.boolean().optional(),
  extractMetrics: z.boolean().optional(),
  accessControlAllowOrigin: z.array(z.string()).optional(),
  accessControlAllowHeaders: z.array(z.string()).optional(),
  emitTokenMetrics: z.boolean().optional(),
  description: z.string().optional(),
});

export function inputSplunkHecPqEnabledFalseConstraintToJSON(
  inputSplunkHecPqEnabledFalseConstraint:
    InputSplunkHecPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputSplunkHecPqEnabledFalseConstraint$outboundSchema.parse(
      inputSplunkHecPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputSplunkHecSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    host: string;
    port: number;
    authTokens?: Array<InputSplunkHecAuthToken$Outbound> | undefined;
    tls?: models.TlsSettingsServerSideType$Outbound | undefined;
    maxActiveReq?: number | undefined;
    maxRequestsPerSocket?: number | undefined;
    enableProxyHeader?: boolean | undefined;
    captureHeaders?: boolean | undefined;
    activityLogSampleRate?: number | undefined;
    requestTimeout?: number | undefined;
    socketTimeout?: number | undefined;
    keepAliveTimeout?: number | undefined;
    enableHealthCheck?: any | undefined;
    ipAllowlistRegex?: string | undefined;
    ipDenylistRegex?: string | undefined;
    splunkHecAPI: string;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    allowedIndexes?: Array<string> | undefined;
    splunkHecAcks?: boolean | undefined;
    breakerRulesets?: Array<string> | undefined;
    staleChannelFlushMs?: number | undefined;
    useFwdTimezone?: boolean | undefined;
    dropControlFields?: boolean | undefined;
    extractMetrics?: boolean | undefined;
    accessControlAllowOrigin?: Array<string> | undefined;
    accessControlAllowHeaders?: Array<string> | undefined;
    emitTokenMetrics?: boolean | undefined;
    description?: string | undefined;
  };

/** @internal */
export const InputSplunkHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputSplunkHecSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputSplunkHecSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputSplunkHecType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.lazy(() => InputSplunkHecAuthToken$outboundSchema))
      .optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.any().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    splunkHecAPI: z.string(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    allowedIndexes: z.array(z.string()).optional(),
    splunkHecAcks: z.boolean().optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    useFwdTimezone: z.boolean().optional(),
    dropControlFields: z.boolean().optional(),
    extractMetrics: z.boolean().optional(),
    accessControlAllowOrigin: z.array(z.string()).optional(),
    accessControlAllowHeaders: z.array(z.string()).optional(),
    emitTokenMetrics: z.boolean().optional(),
    description: z.string().optional(),
  });

export function inputSplunkHecSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputSplunkHecSendToRoutesFalseWithConnectionsConstraint:
    InputSplunkHecSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputSplunkHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputSplunkHecSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputSplunkHecSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<InputSplunkHecAuthToken$Outbound> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: any | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  splunkHecAPI: string;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  allowedIndexes?: Array<string> | undefined;
  splunkHecAcks?: boolean | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  useFwdTimezone?: boolean | undefined;
  dropControlFields?: boolean | undefined;
  extractMetrics?: boolean | undefined;
  accessControlAllowOrigin?: Array<string> | undefined;
  accessControlAllowHeaders?: Array<string> | undefined;
  emitTokenMetrics?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSplunkHecSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputSplunkHecSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputSplunkHecSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputSplunkHecType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(z.lazy(() => InputSplunkHecAuthToken$outboundSchema))
    .optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.any().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  splunkHecAPI: z.string(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  allowedIndexes: z.array(z.string()).optional(),
  splunkHecAcks: z.boolean().optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  useFwdTimezone: z.boolean().optional(),
  dropControlFields: z.boolean().optional(),
  extractMetrics: z.boolean().optional(),
  accessControlAllowOrigin: z.array(z.string()).optional(),
  accessControlAllowHeaders: z.array(z.string()).optional(),
  emitTokenMetrics: z.boolean().optional(),
  description: z.string().optional(),
});

export function inputSplunkHecSendToRoutesTrueConstraintToJSON(
  inputSplunkHecSendToRoutesTrueConstraint:
    InputSplunkHecSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputSplunkHecSendToRoutesTrueConstraint$outboundSchema.parse(
      inputSplunkHecSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputSplunkHec$Outbound =
  | InputSplunkHecSendToRoutesTrueConstraint$Outbound
  | InputSplunkHecSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputSplunkHecPqEnabledFalseConstraint$Outbound
  | InputSplunkHecPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputSplunkHec$outboundSchema: z.ZodType<
  InputSplunkHec$Outbound,
  z.ZodTypeDef,
  InputSplunkHec
> = z.union([
  z.lazy(() => InputSplunkHecSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputSplunkHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputSplunkHecPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputSplunkHecPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputSplunkHecToJSON(inputSplunkHec: InputSplunkHec): string {
  return JSON.stringify(InputSplunkHec$outboundSchema.parse(inputSplunkHec));
}

/** @internal */
export const InputSplunkSearchType$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkSearchType
> = z.nativeEnum(InputSplunkSearchType);

/** @internal */
export type EndpointParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const EndpointParam$outboundSchema: z.ZodType<
  EndpointParam$Outbound,
  z.ZodTypeDef,
  EndpointParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function endpointParamToJSON(endpointParam: EndpointParam): string {
  return JSON.stringify(EndpointParam$outboundSchema.parse(endpointParam));
}

/** @internal */
export type EndpointHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const EndpointHeader$outboundSchema: z.ZodType<
  EndpointHeader$Outbound,
  z.ZodTypeDef,
  EndpointHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function endpointHeaderToJSON(endpointHeader: EndpointHeader): string {
  return JSON.stringify(EndpointHeader$outboundSchema.parse(endpointHeader));
}

/** @internal */
export const InputSplunkSearchLogLevel$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSplunkSearchLogLevel
> = openEnums.outboundSchema(InputSplunkSearchLogLevel);

/** @internal */
export const InputSplunkSearchAuthenticationType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSplunkSearchAuthenticationType
> = openEnums.outboundSchema(InputSplunkSearchAuthenticationType);

/** @internal */
export type InputSplunkSearchPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<EndpointParam$Outbound> | undefined;
  endpointHeaders?: Array<EndpointHeader$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  encoding?: string | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  retryRules?: models.RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputSplunkSearchPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputSplunkSearchPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputSplunkSearchType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    searchHead: z.string(),
    search: z.string(),
    earliest: z.string().optional(),
    latest: z.string().optional(),
    cronSchedule: z.string(),
    endpoint: z.string(),
    outputMode: models.OutputModeOptionsSplunkCollectorConf$outboundSchema,
    endpointParams: z.array(z.lazy(() => EndpointParam$outboundSchema))
      .optional(),
    endpointHeaders: z.array(z.lazy(() => EndpointHeader$outboundSchema))
      .optional(),
    logLevel: InputSplunkSearchLogLevel$outboundSchema.optional(),
    requestTimeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    encoding: z.string().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    retryRules: models.RetryRulesType$outboundSchema.optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    authType: InputSplunkSearchAuthenticationType$outboundSchema.optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
  });

export function inputSplunkSearchPqEnabledTrueWithPqConstraintToJSON(
  inputSplunkSearchPqEnabledTrueWithPqConstraint:
    InputSplunkSearchPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputSplunkSearchPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputSplunkSearchPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputSplunkSearchPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<EndpointParam$Outbound> | undefined;
  endpointHeaders?: Array<EndpointHeader$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  encoding?: string | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  retryRules?: models.RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputSplunkSearchPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputSplunkSearchPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    id: z.string(),
    type: InputSplunkSearchType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    searchHead: z.string(),
    search: z.string(),
    earliest: z.string().optional(),
    latest: z.string().optional(),
    cronSchedule: z.string(),
    endpoint: z.string(),
    outputMode: models.OutputModeOptionsSplunkCollectorConf$outboundSchema,
    endpointParams: z.array(z.lazy(() => EndpointParam$outboundSchema))
      .optional(),
    endpointHeaders: z.array(z.lazy(() => EndpointHeader$outboundSchema))
      .optional(),
    logLevel: InputSplunkSearchLogLevel$outboundSchema.optional(),
    requestTimeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    encoding: z.string().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    retryRules: models.RetryRulesType$outboundSchema.optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    authType: InputSplunkSearchAuthenticationType$outboundSchema.optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
  });

export function inputSplunkSearchPqEnabledFalseConstraintToJSON(
  inputSplunkSearchPqEnabledFalseConstraint:
    InputSplunkSearchPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputSplunkSearchPqEnabledFalseConstraint$outboundSchema.parse(
      inputSplunkSearchPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    searchHead: string;
    search: string;
    earliest?: string | undefined;
    latest?: string | undefined;
    cronSchedule: string;
    endpoint: string;
    outputMode: string;
    endpointParams?: Array<EndpointParam$Outbound> | undefined;
    endpointHeaders?: Array<EndpointHeader$Outbound> | undefined;
    logLevel?: string | undefined;
    requestTimeout?: number | undefined;
    useRoundRobinDns?: boolean | undefined;
    rejectUnauthorized?: boolean | undefined;
    encoding?: string | undefined;
    keepAliveTime?: number | undefined;
    jobTimeout?: string | undefined;
    maxMissedKeepAlives?: number | undefined;
    ttl?: string | undefined;
    ignoreGroupJobsLimit?: boolean | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    retryRules?: models.RetryRulesType$Outbound | undefined;
    breakerRulesets?: Array<string> | undefined;
    staleChannelFlushMs?: number | undefined;
    authType?: string | undefined;
    description?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    token?: string | undefined;
    credentialsSecret?: string | undefined;
    textSecret?: string | undefined;
    loginUrl?: string | undefined;
    secretParamName?: string | undefined;
    secret?: string | undefined;
    tokenAttributeName?: string | undefined;
    authHeaderExpr?: string | undefined;
    tokenTimeoutSecs?: number | undefined;
    oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
    oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
  };

/** @internal */
export const InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputSplunkSearchType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    searchHead: z.string(),
    search: z.string(),
    earliest: z.string().optional(),
    latest: z.string().optional(),
    cronSchedule: z.string(),
    endpoint: z.string(),
    outputMode: models.OutputModeOptionsSplunkCollectorConf$outboundSchema,
    endpointParams: z.array(z.lazy(() => EndpointParam$outboundSchema))
      .optional(),
    endpointHeaders: z.array(z.lazy(() => EndpointHeader$outboundSchema))
      .optional(),
    logLevel: InputSplunkSearchLogLevel$outboundSchema.optional(),
    requestTimeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    encoding: z.string().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    retryRules: models.RetryRulesType$outboundSchema.optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    authType: InputSplunkSearchAuthenticationType$outboundSchema.optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
  });

export function inputSplunkSearchSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputSplunkSearchSendToRoutesFalseWithConnectionsConstraint:
    InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputSplunkSearchSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputSplunkSearchSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  cronSchedule: string;
  endpoint: string;
  outputMode: string;
  endpointParams?: Array<EndpointParam$Outbound> | undefined;
  endpointHeaders?: Array<EndpointHeader$Outbound> | undefined;
  logLevel?: string | undefined;
  requestTimeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  encoding?: string | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  retryRules?: models.RetryRulesType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr?: string | undefined;
  tokenTimeoutSecs?: number | undefined;
  oauthParams?: Array<models.ItemsTypeOauthParams$Outbound> | undefined;
  oauthHeaders?: Array<models.ItemsTypeOauthHeaders$Outbound> | undefined;
};

/** @internal */
export const InputSplunkSearchSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputSplunkSearchSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputSplunkSearchSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputSplunkSearchType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    searchHead: z.string(),
    search: z.string(),
    earliest: z.string().optional(),
    latest: z.string().optional(),
    cronSchedule: z.string(),
    endpoint: z.string(),
    outputMode: models.OutputModeOptionsSplunkCollectorConf$outboundSchema,
    endpointParams: z.array(z.lazy(() => EndpointParam$outboundSchema))
      .optional(),
    endpointHeaders: z.array(z.lazy(() => EndpointHeader$outboundSchema))
      .optional(),
    logLevel: InputSplunkSearchLogLevel$outboundSchema.optional(),
    requestTimeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    encoding: z.string().optional(),
    keepAliveTime: z.number().optional(),
    jobTimeout: z.string().optional(),
    maxMissedKeepAlives: z.number().optional(),
    ttl: z.string().optional(),
    ignoreGroupJobsLimit: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    retryRules: models.RetryRulesType$outboundSchema.optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    authType: InputSplunkSearchAuthenticationType$outboundSchema.optional(),
    description: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    credentialsSecret: z.string().optional(),
    textSecret: z.string().optional(),
    loginUrl: z.string().optional(),
    secretParamName: z.string().optional(),
    secret: z.string().optional(),
    tokenAttributeName: z.string().optional(),
    authHeaderExpr: z.string().optional(),
    tokenTimeoutSecs: z.number().optional(),
    oauthParams: z.array(models.ItemsTypeOauthParams$outboundSchema).optional(),
    oauthHeaders: z.array(models.ItemsTypeOauthHeaders$outboundSchema)
      .optional(),
  });

export function inputSplunkSearchSendToRoutesTrueConstraintToJSON(
  inputSplunkSearchSendToRoutesTrueConstraint:
    InputSplunkSearchSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputSplunkSearchSendToRoutesTrueConstraint$outboundSchema.parse(
      inputSplunkSearchSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputSplunkSearch$Outbound =
  | InputSplunkSearchSendToRoutesTrueConstraint$Outbound
  | InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputSplunkSearchPqEnabledFalseConstraint$Outbound
  | InputSplunkSearchPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputSplunkSearch$outboundSchema: z.ZodType<
  InputSplunkSearch$Outbound,
  z.ZodTypeDef,
  InputSplunkSearch
> = z.union([
  z.lazy(() => InputSplunkSearchSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputSplunkSearchPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputSplunkSearchPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputSplunkSearchToJSON(
  inputSplunkSearch: InputSplunkSearch,
): string {
  return JSON.stringify(
    InputSplunkSearch$outboundSchema.parse(inputSplunkSearch),
  );
}

/** @internal */
export const InputSplunkType$outboundSchema: z.ZodNativeEnum<
  typeof InputSplunkType
> = z.nativeEnum(InputSplunkType);

/** @internal */
export type InputSplunkAuthToken$Outbound = {
  token: string;
  description?: string | undefined;
};

/** @internal */
export const InputSplunkAuthToken$outboundSchema: z.ZodType<
  InputSplunkAuthToken$Outbound,
  z.ZodTypeDef,
  InputSplunkAuthToken
> = z.object({
  token: z.string(),
  description: z.string().optional(),
});

export function inputSplunkAuthTokenToJSON(
  inputSplunkAuthToken: InputSplunkAuthToken,
): string {
  return JSON.stringify(
    InputSplunkAuthToken$outboundSchema.parse(inputSplunkAuthToken),
  );
}

/** @internal */
export const MaxS2SVersion$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  MaxS2SVersion
> = openEnums.outboundSchema(MaxS2SVersion);

/** @internal */
export const CreateInputCompression$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CreateInputCompression
> = openEnums.outboundSchema(CreateInputCompression);

/** @internal */
export type InputSplunkPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  authTokens?: Array<InputSplunkAuthToken$Outbound> | undefined;
  maxS2Sversion?: string | undefined;
  description?: string | undefined;
  useFwdTimezone?: boolean | undefined;
  dropControlFields?: boolean | undefined;
  extractMetrics?: boolean | undefined;
  compress?: string | undefined;
};

/** @internal */
export const InputSplunkPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputSplunkPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputSplunkPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputSplunkType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  authTokens: z.array(z.lazy(() => InputSplunkAuthToken$outboundSchema))
    .optional(),
  maxS2Sversion: MaxS2SVersion$outboundSchema.optional(),
  description: z.string().optional(),
  useFwdTimezone: z.boolean().optional(),
  dropControlFields: z.boolean().optional(),
  extractMetrics: z.boolean().optional(),
  compress: CreateInputCompression$outboundSchema.optional(),
});

export function inputSplunkPqEnabledTrueWithPqConstraintToJSON(
  inputSplunkPqEnabledTrueWithPqConstraint:
    InputSplunkPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputSplunkPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputSplunkPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputSplunkPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  authTokens?: Array<InputSplunkAuthToken$Outbound> | undefined;
  maxS2Sversion?: string | undefined;
  description?: string | undefined;
  useFwdTimezone?: boolean | undefined;
  dropControlFields?: boolean | undefined;
  extractMetrics?: boolean | undefined;
  compress?: string | undefined;
};

/** @internal */
export const InputSplunkPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputSplunkPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputSplunkPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputSplunkType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  authTokens: z.array(z.lazy(() => InputSplunkAuthToken$outboundSchema))
    .optional(),
  maxS2Sversion: MaxS2SVersion$outboundSchema.optional(),
  description: z.string().optional(),
  useFwdTimezone: z.boolean().optional(),
  dropControlFields: z.boolean().optional(),
  extractMetrics: z.boolean().optional(),
  compress: CreateInputCompression$outboundSchema.optional(),
});

export function inputSplunkPqEnabledFalseConstraintToJSON(
  inputSplunkPqEnabledFalseConstraint: InputSplunkPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputSplunkPqEnabledFalseConstraint$outboundSchema.parse(
      inputSplunkPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputSplunkSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  authTokens?: Array<InputSplunkAuthToken$Outbound> | undefined;
  maxS2Sversion?: string | undefined;
  description?: string | undefined;
  useFwdTimezone?: boolean | undefined;
  dropControlFields?: boolean | undefined;
  extractMetrics?: boolean | undefined;
  compress?: string | undefined;
};

/** @internal */
export const InputSplunkSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputSplunkSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputSplunkSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputSplunkType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    ipWhitelistRegex: z.string().optional(),
    maxActiveCxn: z.number().optional(),
    socketIdleTimeout: z.number().optional(),
    socketEndingMaxWait: z.number().optional(),
    socketMaxLifespan: z.number().optional(),
    enableProxyHeader: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    authTokens: z.array(z.lazy(() => InputSplunkAuthToken$outboundSchema))
      .optional(),
    maxS2Sversion: MaxS2SVersion$outboundSchema.optional(),
    description: z.string().optional(),
    useFwdTimezone: z.boolean().optional(),
    dropControlFields: z.boolean().optional(),
    extractMetrics: z.boolean().optional(),
    compress: CreateInputCompression$outboundSchema.optional(),
  });

export function inputSplunkSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputSplunkSendToRoutesFalseWithConnectionsConstraint:
    InputSplunkSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputSplunkSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputSplunkSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputSplunkSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  ipWhitelistRegex?: string | undefined;
  maxActiveCxn?: number | undefined;
  socketIdleTimeout?: number | undefined;
  socketEndingMaxWait?: number | undefined;
  socketMaxLifespan?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  authTokens?: Array<InputSplunkAuthToken$Outbound> | undefined;
  maxS2Sversion?: string | undefined;
  description?: string | undefined;
  useFwdTimezone?: boolean | undefined;
  dropControlFields?: boolean | undefined;
  extractMetrics?: boolean | undefined;
  compress?: string | undefined;
};

/** @internal */
export const InputSplunkSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputSplunkSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputSplunkSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputSplunkType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  ipWhitelistRegex: z.string().optional(),
  maxActiveCxn: z.number().optional(),
  socketIdleTimeout: z.number().optional(),
  socketEndingMaxWait: z.number().optional(),
  socketMaxLifespan: z.number().optional(),
  enableProxyHeader: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  authTokens: z.array(z.lazy(() => InputSplunkAuthToken$outboundSchema))
    .optional(),
  maxS2Sversion: MaxS2SVersion$outboundSchema.optional(),
  description: z.string().optional(),
  useFwdTimezone: z.boolean().optional(),
  dropControlFields: z.boolean().optional(),
  extractMetrics: z.boolean().optional(),
  compress: CreateInputCompression$outboundSchema.optional(),
});

export function inputSplunkSendToRoutesTrueConstraintToJSON(
  inputSplunkSendToRoutesTrueConstraint: InputSplunkSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputSplunkSendToRoutesTrueConstraint$outboundSchema.parse(
      inputSplunkSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputSplunk$Outbound =
  | InputSplunkSendToRoutesTrueConstraint$Outbound
  | InputSplunkSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputSplunkPqEnabledFalseConstraint$Outbound
  | InputSplunkPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputSplunk$outboundSchema: z.ZodType<
  InputSplunk$Outbound,
  z.ZodTypeDef,
  InputSplunk
> = z.union([
  z.lazy(() => InputSplunkSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputSplunkSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputSplunkPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputSplunkPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputSplunkToJSON(inputSplunk: InputSplunk): string {
  return JSON.stringify(InputSplunk$outboundSchema.parse(inputSplunk));
}

/** @internal */
export const InputHttpType$outboundSchema: z.ZodNativeEnum<
  typeof InputHttpType
> = z.nativeEnum(InputHttpType);

/** @internal */
export type InputHttpPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  criblAPI?: string | undefined;
  elasticAPI?: string | undefined;
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttpPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputHttpPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputHttpPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputHttpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  criblAPI: z.string().optional(),
  elasticAPI: z.string().optional(),
  splunkHecAPI: z.string().optional(),
  splunkHecAcks: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputHttpPqEnabledTrueWithPqConstraintToJSON(
  inputHttpPqEnabledTrueWithPqConstraint:
    InputHttpPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputHttpPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputHttpPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputHttpPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  criblAPI?: string | undefined;
  elasticAPI?: string | undefined;
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttpPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputHttpPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputHttpPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputHttpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  criblAPI: z.string().optional(),
  elasticAPI: z.string().optional(),
  splunkHecAPI: z.string().optional(),
  splunkHecAcks: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputHttpPqEnabledFalseConstraintToJSON(
  inputHttpPqEnabledFalseConstraint: InputHttpPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputHttpPqEnabledFalseConstraint$outboundSchema.parse(
      inputHttpPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputHttpSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  criblAPI?: string | undefined;
  elasticAPI?: string | undefined;
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputHttpSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputHttpSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputHttpType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    host: z.string(),
    port: z.number(),
    authTokens: z.array(z.string()).optional(),
    tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
    maxActiveReq: z.number().optional(),
    maxRequestsPerSocket: z.number().int().optional(),
    enableProxyHeader: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    activityLogSampleRate: z.number().optional(),
    requestTimeout: z.number().optional(),
    socketTimeout: z.number().optional(),
    keepAliveTimeout: z.number().optional(),
    enableHealthCheck: z.boolean().optional(),
    ipAllowlistRegex: z.string().optional(),
    ipDenylistRegex: z.string().optional(),
    criblAPI: z.string().optional(),
    elasticAPI: z.string().optional(),
    splunkHecAPI: z.string().optional(),
    splunkHecAcks: z.boolean().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputHttpSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputHttpSendToRoutesFalseWithConnectionsConstraint:
    InputHttpSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputHttpSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputHttpSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  host: string;
  port: number;
  authTokens?: Array<string> | undefined;
  tls?: models.TlsSettingsServerSideType$Outbound | undefined;
  maxActiveReq?: number | undefined;
  maxRequestsPerSocket?: number | undefined;
  enableProxyHeader?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  activityLogSampleRate?: number | undefined;
  requestTimeout?: number | undefined;
  socketTimeout?: number | undefined;
  keepAliveTimeout?: number | undefined;
  enableHealthCheck?: boolean | undefined;
  ipAllowlistRegex?: string | undefined;
  ipDenylistRegex?: string | undefined;
  criblAPI?: string | undefined;
  elasticAPI?: string | undefined;
  splunkHecAPI?: string | undefined;
  splunkHecAcks?: boolean | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  authTokensExt?: Array<models.ItemsTypeAuthTokensExt$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputHttpSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputHttpSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputHttpSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputHttpType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  host: z.string(),
  port: z.number(),
  authTokens: z.array(z.string()).optional(),
  tls: models.TlsSettingsServerSideType$outboundSchema.optional(),
  maxActiveReq: z.number().optional(),
  maxRequestsPerSocket: z.number().int().optional(),
  enableProxyHeader: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  activityLogSampleRate: z.number().optional(),
  requestTimeout: z.number().optional(),
  socketTimeout: z.number().optional(),
  keepAliveTimeout: z.number().optional(),
  enableHealthCheck: z.boolean().optional(),
  ipAllowlistRegex: z.string().optional(),
  ipDenylistRegex: z.string().optional(),
  criblAPI: z.string().optional(),
  elasticAPI: z.string().optional(),
  splunkHecAPI: z.string().optional(),
  splunkHecAcks: z.boolean().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  authTokensExt: z.array(models.ItemsTypeAuthTokensExt$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputHttpSendToRoutesTrueConstraintToJSON(
  inputHttpSendToRoutesTrueConstraint: InputHttpSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputHttpSendToRoutesTrueConstraint$outboundSchema.parse(
      inputHttpSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputHttp$Outbound =
  | InputHttpSendToRoutesTrueConstraint$Outbound
  | InputHttpSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputHttpPqEnabledFalseConstraint$Outbound
  | InputHttpPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputHttp$outboundSchema: z.ZodType<
  InputHttp$Outbound,
  z.ZodTypeDef,
  InputHttp
> = z.union([
  z.lazy(() => InputHttpSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputHttpPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputHttpPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputHttpToJSON(inputHttp: InputHttp): string {
  return JSON.stringify(InputHttp$outboundSchema.parse(inputHttp));
}

/** @internal */
export const InputMskType$outboundSchema: z.ZodNativeEnum<typeof InputMskType> =
  z.nativeEnum(InputMskType);

/** @internal */
export type InputMskPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputMskPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputMskPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputMskPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputMskType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().optional(),
  fromBeginning: z.boolean().optional(),
  sessionTimeout: z.number().optional(),
  rebalanceTimeout: z.number().optional(),
  heartbeatInterval: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  kafkaSchemaRegistry: models
    .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
  connectionTimeout: z.number().optional(),
  requestTimeout: z.number().optional(),
  maxRetries: z.number().optional(),
  maxBackOff: z.number().optional(),
  initialBackoff: z.number().optional(),
  backoffRate: z.number().optional(),
  authenticationTimeout: z.number().optional(),
  reauthenticationThreshold: z.number().optional(),
  awsAuthenticationMethod: z.string(),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptions$outboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
    .optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().optional(),
  maxBytes: z.number().optional(),
  maxSocketErrors: z.number().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

export function inputMskPqEnabledTrueWithPqConstraintToJSON(
  inputMskPqEnabledTrueWithPqConstraint: InputMskPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputMskPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputMskPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputMskPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputMskPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputMskPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputMskPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputMskType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().optional(),
  fromBeginning: z.boolean().optional(),
  sessionTimeout: z.number().optional(),
  rebalanceTimeout: z.number().optional(),
  heartbeatInterval: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  kafkaSchemaRegistry: models
    .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
  connectionTimeout: z.number().optional(),
  requestTimeout: z.number().optional(),
  maxRetries: z.number().optional(),
  maxBackOff: z.number().optional(),
  initialBackoff: z.number().optional(),
  backoffRate: z.number().optional(),
  authenticationTimeout: z.number().optional(),
  reauthenticationThreshold: z.number().optional(),
  awsAuthenticationMethod: z.string(),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptions$outboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
    .optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().optional(),
  maxBytes: z.number().optional(),
  maxSocketErrors: z.number().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

export function inputMskPqEnabledFalseConstraintToJSON(
  inputMskPqEnabledFalseConstraint: InputMskPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputMskPqEnabledFalseConstraint$outboundSchema.parse(
      inputMskPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputMskSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputMskSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputMskSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputMskSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputMskType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    brokers: z.array(z.string()),
    topics: z.array(z.string()),
    groupId: z.string().optional(),
    fromBeginning: z.boolean().optional(),
    sessionTimeout: z.number().optional(),
    rebalanceTimeout: z.number().optional(),
    heartbeatInterval: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    kafkaSchemaRegistry: models
      .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
    connectionTimeout: z.number().optional(),
    requestTimeout: z.number().optional(),
    maxRetries: z.number().optional(),
    maxBackOff: z.number().optional(),
    initialBackoff: z.number().optional(),
    backoffRate: z.number().optional(),
    authenticationTimeout: z.number().optional(),
    reauthenticationThreshold: z.number().optional(),
    awsAuthenticationMethod: z.string(),
    awsSecretKey: z.string().optional(),
    region: z.string(),
    endpoint: z.string().optional(),
    signatureVersion: models.SignatureVersionOptions$outboundSchema.optional(),
    reuseConnections: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    enableAssumeRole: z.boolean().optional(),
    assumeRoleArn: z.string().optional(),
    assumeRoleExternalId: z.string().optional(),
    durationSeconds: z.number().optional(),
    tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
      .optional(),
    autoCommitInterval: z.number().optional(),
    autoCommitThreshold: z.number().optional(),
    maxBytesPerPartition: z.number().optional(),
    maxBytes: z.number().optional(),
    maxSocketErrors: z.number().optional(),
    description: z.string().optional(),
    awsApiKey: z.string().optional(),
    awsSecret: z.string().optional(),
  });

export function inputMskSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputMskSendToRoutesFalseWithConnectionsConstraint:
    InputMskSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputMskSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputMskSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputMskSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputMskSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputMskSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputMskSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputMskType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().optional(),
  fromBeginning: z.boolean().optional(),
  sessionTimeout: z.number().optional(),
  rebalanceTimeout: z.number().optional(),
  heartbeatInterval: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  kafkaSchemaRegistry: models
    .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
  connectionTimeout: z.number().optional(),
  requestTimeout: z.number().optional(),
  maxRetries: z.number().optional(),
  maxBackOff: z.number().optional(),
  initialBackoff: z.number().optional(),
  backoffRate: z.number().optional(),
  authenticationTimeout: z.number().optional(),
  reauthenticationThreshold: z.number().optional(),
  awsAuthenticationMethod: z.string(),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: models.SignatureVersionOptions$outboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
    .optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().optional(),
  maxBytes: z.number().optional(),
  maxSocketErrors: z.number().optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

export function inputMskSendToRoutesTrueConstraintToJSON(
  inputMskSendToRoutesTrueConstraint: InputMskSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputMskSendToRoutesTrueConstraint$outboundSchema.parse(
      inputMskSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputMsk$Outbound =
  | InputMskSendToRoutesTrueConstraint$Outbound
  | InputMskSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputMskPqEnabledFalseConstraint$Outbound
  | InputMskPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputMsk$outboundSchema: z.ZodType<
  InputMsk$Outbound,
  z.ZodTypeDef,
  InputMsk
> = z.union([
  z.lazy(() => InputMskSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputMskSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputMskPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputMskPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputMskToJSON(inputMsk: InputMsk): string {
  return JSON.stringify(InputMsk$outboundSchema.parse(inputMsk));
}

/** @internal */
export const InputKafkaType$outboundSchema: z.ZodNativeEnum<
  typeof InputKafkaType
> = z.nativeEnum(InputKafkaType);

/** @internal */
export type InputKafkaPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  sasl?: models.AuthenticationType$Outbound | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKafkaPqEnabledTrueWithPqConstraint$outboundSchema: z.ZodType<
  InputKafkaPqEnabledTrueWithPqConstraint$Outbound,
  z.ZodTypeDef,
  InputKafkaPqEnabledTrueWithPqConstraint
> = z.object({
  pqEnabled: z.boolean(),
  pq: models.PqType$outboundSchema.optional(),
  id: z.string(),
  type: InputKafkaType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().optional(),
  fromBeginning: z.boolean().optional(),
  kafkaSchemaRegistry: models
    .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
  connectionTimeout: z.number().optional(),
  requestTimeout: z.number().optional(),
  maxRetries: z.number().optional(),
  maxBackOff: z.number().optional(),
  initialBackoff: z.number().optional(),
  backoffRate: z.number().optional(),
  authenticationTimeout: z.number().optional(),
  reauthenticationThreshold: z.number().optional(),
  sasl: models.AuthenticationType$outboundSchema.optional(),
  tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
    .optional(),
  sessionTimeout: z.number().optional(),
  rebalanceTimeout: z.number().optional(),
  heartbeatInterval: z.number().optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().optional(),
  maxBytes: z.number().optional(),
  maxSocketErrors: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputKafkaPqEnabledTrueWithPqConstraintToJSON(
  inputKafkaPqEnabledTrueWithPqConstraint:
    InputKafkaPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputKafkaPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputKafkaPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputKafkaPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  sasl?: models.AuthenticationType$Outbound | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKafkaPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputKafkaPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputKafkaPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputKafkaType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().optional(),
  fromBeginning: z.boolean().optional(),
  kafkaSchemaRegistry: models
    .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
  connectionTimeout: z.number().optional(),
  requestTimeout: z.number().optional(),
  maxRetries: z.number().optional(),
  maxBackOff: z.number().optional(),
  initialBackoff: z.number().optional(),
  backoffRate: z.number().optional(),
  authenticationTimeout: z.number().optional(),
  reauthenticationThreshold: z.number().optional(),
  sasl: models.AuthenticationType$outboundSchema.optional(),
  tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
    .optional(),
  sessionTimeout: z.number().optional(),
  rebalanceTimeout: z.number().optional(),
  heartbeatInterval: z.number().optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().optional(),
  maxBytes: z.number().optional(),
  maxSocketErrors: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputKafkaPqEnabledFalseConstraintToJSON(
  inputKafkaPqEnabledFalseConstraint: InputKafkaPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputKafkaPqEnabledFalseConstraint$outboundSchema.parse(
      inputKafkaPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputKafkaSendToRoutesFalseWithConnectionsConstraint$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  pq?: models.PqType$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  sasl?: models.AuthenticationType$Outbound | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKafkaSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputKafkaSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputKafkaSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputKafkaType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    brokers: z.array(z.string()),
    topics: z.array(z.string()),
    groupId: z.string().optional(),
    fromBeginning: z.boolean().optional(),
    kafkaSchemaRegistry: models
      .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
    connectionTimeout: z.number().optional(),
    requestTimeout: z.number().optional(),
    maxRetries: z.number().optional(),
    maxBackOff: z.number().optional(),
    initialBackoff: z.number().optional(),
    backoffRate: z.number().optional(),
    authenticationTimeout: z.number().optional(),
    reauthenticationThreshold: z.number().optional(),
    sasl: models.AuthenticationType$outboundSchema.optional(),
    tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
      .optional(),
    sessionTimeout: z.number().optional(),
    rebalanceTimeout: z.number().optional(),
    heartbeatInterval: z.number().optional(),
    autoCommitInterval: z.number().optional(),
    autoCommitThreshold: z.number().optional(),
    maxBytesPerPartition: z.number().optional(),
    maxBytes: z.number().optional(),
    maxSocketErrors: z.number().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputKafkaSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputKafkaSendToRoutesFalseWithConnectionsConstraint:
    InputKafkaSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputKafkaSendToRoutesFalseWithConnectionsConstraint$outboundSchema.parse(
      inputKafkaSendToRoutesFalseWithConnectionsConstraint,
    ),
  );
}

/** @internal */
export type InputKafkaSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  brokers: Array<string>;
  topics: Array<string>;
  groupId?: string | undefined;
  fromBeginning?: boolean | undefined;
  kafkaSchemaRegistry?:
    | models.KafkaSchemaRegistryAuthenticationType$Outbound
    | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  maxBackOff?: number | undefined;
  initialBackoff?: number | undefined;
  backoffRate?: number | undefined;
  authenticationTimeout?: number | undefined;
  reauthenticationThreshold?: number | undefined;
  sasl?: models.AuthenticationType$Outbound | undefined;
  tls?:
    | models.TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound
    | undefined;
  sessionTimeout?: number | undefined;
  rebalanceTimeout?: number | undefined;
  heartbeatInterval?: number | undefined;
  autoCommitInterval?: number | undefined;
  autoCommitThreshold?: number | undefined;
  maxBytesPerPartition?: number | undefined;
  maxBytes?: number | undefined;
  maxSocketErrors?: number | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputKafkaSendToRoutesTrueConstraint$outboundSchema: z.ZodType<
  InputKafkaSendToRoutesTrueConstraint$Outbound,
  z.ZodTypeDef,
  InputKafkaSendToRoutesTrueConstraint
> = z.object({
  sendToRoutes: z.boolean(),
  id: z.string(),
  type: InputKafkaType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  brokers: z.array(z.string()),
  topics: z.array(z.string()),
  groupId: z.string().optional(),
  fromBeginning: z.boolean().optional(),
  kafkaSchemaRegistry: models
    .KafkaSchemaRegistryAuthenticationType$outboundSchema.optional(),
  connectionTimeout: z.number().optional(),
  requestTimeout: z.number().optional(),
  maxRetries: z.number().optional(),
  maxBackOff: z.number().optional(),
  initialBackoff: z.number().optional(),
  backoffRate: z.number().optional(),
  authenticationTimeout: z.number().optional(),
  reauthenticationThreshold: z.number().optional(),
  sasl: models.AuthenticationType$outboundSchema.optional(),
  tls: models.TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema
    .optional(),
  sessionTimeout: z.number().optional(),
  rebalanceTimeout: z.number().optional(),
  heartbeatInterval: z.number().optional(),
  autoCommitInterval: z.number().optional(),
  autoCommitThreshold: z.number().optional(),
  maxBytesPerPartition: z.number().optional(),
  maxBytes: z.number().optional(),
  maxSocketErrors: z.number().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputKafkaSendToRoutesTrueConstraintToJSON(
  inputKafkaSendToRoutesTrueConstraint: InputKafkaSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputKafkaSendToRoutesTrueConstraint$outboundSchema.parse(
      inputKafkaSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputKafka$Outbound =
  | InputKafkaSendToRoutesTrueConstraint$Outbound
  | InputKafkaSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputKafkaPqEnabledFalseConstraint$Outbound
  | InputKafkaPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputKafka$outboundSchema: z.ZodType<
  InputKafka$Outbound,
  z.ZodTypeDef,
  InputKafka
> = z.union([
  z.lazy(() => InputKafkaSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputKafkaSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputKafkaPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputKafkaPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputKafkaToJSON(inputKafka: InputKafka): string {
  return JSON.stringify(InputKafka$outboundSchema.parse(inputKafka));
}

/** @internal */
export const InputCollectionType$outboundSchema: z.ZodNativeEnum<
  typeof InputCollectionType
> = z.nativeEnum(InputCollectionType);

/** @internal */
export type InputCollectionPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: models.PqType$Outbound | undefined;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  throttleRatePerSec?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  output?: string | undefined;
};

/** @internal */
export const InputCollectionPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputCollectionPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputCollectionPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean(),
    pq: models.PqType$outboundSchema.optional(),
    id: z.string(),
    type: InputCollectionType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().optional(),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    throttleRatePerSec: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    output: z.string().optional(),
  });

export function inputCollectionPqEnabledTrueWithPqConstraintToJSON(
  inputCollectionPqEnabledTrueWithPqConstraint:
    InputCollectionPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputCollectionPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputCollectionPqEnabledTrueWithPqConstraint,
    ),
  );
}

/** @internal */
export type InputCollectionPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  throttleRatePerSec?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  output?: string | undefined;
};

/** @internal */
export const InputCollectionPqEnabledFalseConstraint$outboundSchema: z.ZodType<
  InputCollectionPqEnabledFalseConstraint$Outbound,
  z.ZodTypeDef,
  InputCollectionPqEnabledFalseConstraint
> = z.object({
  pqEnabled: z.boolean(),
  id: z.string(),
  type: InputCollectionType$outboundSchema,
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
    .optional(),
  pq: models.PqType$outboundSchema.optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().optional(),
  preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
    .optional(),
  throttleRatePerSec: z.string().optional(),
  metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
    .optional(),
  output: z.string().optional(),
});

export function inputCollectionPqEnabledFalseConstraintToJSON(
  inputCollectionPqEnabledFalseConstraint:
    InputCollectionPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputCollectionPqEnabledFalseConstraint$outboundSchema.parse(
      inputCollectionPqEnabledFalseConstraint,
    ),
  );
}

/** @internal */
export type InputCollectionSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?:
      | Array<models.ItemsTypeConnectionsOptional$Outbound>
      | undefined;
    id: string;
    type: string;
    disabled?: boolean | undefined;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled?: boolean | undefined;
    streamtags?: Array<string> | undefined;
    pq?: models.PqType$Outbound | undefined;
    breakerRulesets?: Array<string> | undefined;
    staleChannelFlushMs?: number | undefined;
    preprocess?:
      | models.PreprocessTypeSavedJobCollectionInput$Outbound
      | undefined;
    throttleRatePerSec?: string | undefined;
    metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
    output?: string | undefined;
  };

/** @internal */
export const InputCollectionSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputCollectionSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputCollectionSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string(),
    type: InputCollectionType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    pq: models.PqType$outboundSchema.optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    throttleRatePerSec: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    output: z.string().optional(),
  });

export function inputCollectionSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputCollectionSendToRoutesFalseWithConnectionsConstraint:
    InputCollectionSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputCollectionSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputCollectionSendToRoutesFalseWithConnectionsConstraint),
  );
}

/** @internal */
export type InputCollectionSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id: string;
  type: string;
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<models.ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: models.PqType$Outbound | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs?: number | undefined;
  preprocess?:
    | models.PreprocessTypeSavedJobCollectionInput$Outbound
    | undefined;
  throttleRatePerSec?: string | undefined;
  metadata?: Array<models.ItemsTypeNotificationMetadata$Outbound> | undefined;
  output?: string | undefined;
};

/** @internal */
export const InputCollectionSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputCollectionSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputCollectionSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean(),
    id: z.string(),
    type: InputCollectionType$outboundSchema,
    disabled: z.boolean().optional(),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(models.ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: models.PqType$outboundSchema.optional(),
    breakerRulesets: z.array(z.string()).optional(),
    staleChannelFlushMs: z.number().optional(),
    preprocess: models.PreprocessTypeSavedJobCollectionInput$outboundSchema
      .optional(),
    throttleRatePerSec: z.string().optional(),
    metadata: z.array(models.ItemsTypeNotificationMetadata$outboundSchema)
      .optional(),
    output: z.string().optional(),
  });

export function inputCollectionSendToRoutesTrueConstraintToJSON(
  inputCollectionSendToRoutesTrueConstraint:
    InputCollectionSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputCollectionSendToRoutesTrueConstraint$outboundSchema.parse(
      inputCollectionSendToRoutesTrueConstraint,
    ),
  );
}

/** @internal */
export type InputCollection$Outbound =
  | InputCollectionSendToRoutesTrueConstraint$Outbound
  | InputCollectionSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputCollectionPqEnabledFalseConstraint$Outbound
  | InputCollectionPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputCollection$outboundSchema: z.ZodType<
  InputCollection$Outbound,
  z.ZodTypeDef,
  InputCollection
> = z.union([
  z.lazy(() => InputCollectionSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputCollectionSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputCollectionPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputCollectionPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputCollectionToJSON(
  inputCollection: InputCollection,
): string {
  return JSON.stringify(InputCollection$outboundSchema.parse(inputCollection));
}

/** @internal */
export type CreateInputRequest$Outbound =
  | (
    | InputCollectionSendToRoutesTrueConstraint$Outbound
    | InputCollectionSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputCollectionPqEnabledFalseConstraint$Outbound
    | InputCollectionPqEnabledTrueWithPqConstraint$Outbound & {
      type: "collection";
    }
  )
  | (
    | InputKafkaSendToRoutesTrueConstraint$Outbound
    | InputKafkaSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputKafkaPqEnabledFalseConstraint$Outbound
    | InputKafkaPqEnabledTrueWithPqConstraint$Outbound & { type: "kafka" }
  )
  | (
    | InputMskSendToRoutesTrueConstraint$Outbound
    | InputMskSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputMskPqEnabledFalseConstraint$Outbound
    | InputMskPqEnabledTrueWithPqConstraint$Outbound & { type: "msk" }
  )
  | (
    | InputHttpSendToRoutesTrueConstraint$Outbound
    | InputHttpSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputHttpPqEnabledFalseConstraint$Outbound
    | InputHttpPqEnabledTrueWithPqConstraint$Outbound & { type: "http" }
  )
  | (
    | InputSplunkSendToRoutesTrueConstraint$Outbound
    | InputSplunkSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputSplunkPqEnabledFalseConstraint$Outbound
    | InputSplunkPqEnabledTrueWithPqConstraint$Outbound & { type: "splunk" }
  )
  | (
    | InputSplunkSearchSendToRoutesTrueConstraint$Outbound
    | InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputSplunkSearchPqEnabledFalseConstraint$Outbound
    | InputSplunkSearchPqEnabledTrueWithPqConstraint$Outbound & {
      type: "splunk_search";
    }
  )
  | (
    | InputSplunkHecSendToRoutesTrueConstraint$Outbound
    | InputSplunkHecSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputSplunkHecPqEnabledFalseConstraint$Outbound
    | InputSplunkHecPqEnabledTrueWithPqConstraint$Outbound & {
      type: "splunk_hec";
    }
  )
  | (
    | InputAzureBlobSendToRoutesTrueConstraint$Outbound
    | InputAzureBlobSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputAzureBlobPqEnabledFalseConstraint$Outbound
    | InputAzureBlobPqEnabledTrueWithPqConstraint$Outbound & {
      type: "azure_blob";
    }
  )
  | (
    | InputElasticSendToRoutesTrueConstraint$Outbound
    | InputElasticSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputElasticPqEnabledFalseConstraint$Outbound
    | InputElasticPqEnabledTrueWithPqConstraint$Outbound & { type: "elastic" }
  )
  | (
    | InputConfluentCloudSendToRoutesTrueConstraint$Outbound
    | InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputConfluentCloudPqEnabledFalseConstraint$Outbound
    | InputConfluentCloudPqEnabledTrueWithPqConstraint$Outbound & {
      type: "confluent_cloud";
    }
  )
  | (
    | InputGrafanaGrafana1$Outbound
    | InputGrafanaGrafana2$Outbound & { type: "grafana" }
  )
  | (
    | InputLokiSendToRoutesTrueConstraint$Outbound
    | InputLokiSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputLokiPqEnabledFalseConstraint$Outbound
    | InputLokiPqEnabledTrueWithPqConstraint$Outbound & { type: "loki" }
  )
  | (
    | InputPrometheusRwSendToRoutesTrueConstraint$Outbound
    | InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputPrometheusRwPqEnabledFalseConstraint$Outbound
    | InputPrometheusRwPqEnabledTrueWithPqConstraint$Outbound & {
      type: "prometheus_rw";
    }
  )
  | (
    | InputPrometheusSendToRoutesTrueConstraint$Outbound
    | InputPrometheusSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputPrometheusPqEnabledFalseConstraint$Outbound
    | InputPrometheusPqEnabledTrueWithPqConstraint$Outbound & {
      type: "prometheus";
    }
  )
  | (
    | InputEdgePrometheusSendToRoutesTrueConstraint$Outbound
    | InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputEdgePrometheusPqEnabledFalseConstraint$Outbound
    | InputEdgePrometheusPqEnabledTrueWithPqConstraint$Outbound & {
      type: "edge_prometheus";
    }
  )
  | (
    | InputOffice365MgmtSendToRoutesTrueConstraint$Outbound
    | InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputOffice365MgmtPqEnabledFalseConstraint$Outbound
    | InputOffice365MgmtPqEnabledTrueWithPqConstraint$Outbound & {
      type: "office365_mgmt";
    }
  )
  | (
    | InputOffice365ServiceSendToRoutesTrueConstraint$Outbound
    | InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputOffice365ServicePqEnabledFalseConstraint$Outbound
    | InputOffice365ServicePqEnabledTrueWithPqConstraint$Outbound & {
      type: "office365_service";
    }
  )
  | (
    | InputOffice365MsgTraceSendToRoutesTrueConstraint$Outbound
    | InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputOffice365MsgTracePqEnabledFalseConstraint$Outbound
    | InputOffice365MsgTracePqEnabledTrueWithPqConstraint$Outbound & {
      type: "office365_msg_trace";
    }
  )
  | (
    | InputEventhubSendToRoutesTrueConstraint$Outbound
    | InputEventhubSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputEventhubPqEnabledFalseConstraint$Outbound
    | InputEventhubPqEnabledTrueWithPqConstraint$Outbound & { type: "eventhub" }
  )
  | (
    | InputExecSendToRoutesTrueConstraint$Outbound
    | InputExecSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputExecPqEnabledFalseConstraint$Outbound
    | InputExecPqEnabledTrueWithPqConstraint$Outbound & { type: "exec" }
  )
  | (
    | InputFirehoseSendToRoutesTrueConstraint$Outbound
    | InputFirehoseSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputFirehosePqEnabledFalseConstraint$Outbound
    | InputFirehosePqEnabledTrueWithPqConstraint$Outbound & { type: "firehose" }
  )
  | (
    | InputGooglePubsubSendToRoutesTrueConstraint$Outbound
    | InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputGooglePubsubPqEnabledFalseConstraint$Outbound
    | InputGooglePubsubPqEnabledTrueWithPqConstraint$Outbound & {
      type: "google_pubsub";
    }
  )
  | (
    | InputCriblSendToRoutesTrueConstraint$Outbound
    | InputCriblSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputCriblPqEnabledFalseConstraint$Outbound
    | InputCriblPqEnabledTrueWithPqConstraint$Outbound & { type: "cribl" }
  )
  | (
    | InputCriblTcpSendToRoutesTrueConstraint$Outbound
    | InputCriblTcpSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputCriblTcpPqEnabledFalseConstraint$Outbound
    | InputCriblTcpPqEnabledTrueWithPqConstraint$Outbound & {
      type: "cribl_tcp";
    }
  )
  | (
    | InputCriblHttpSendToRoutesTrueConstraint$Outbound
    | InputCriblHttpSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputCriblHttpPqEnabledFalseConstraint$Outbound
    | InputCriblHttpPqEnabledTrueWithPqConstraint$Outbound & {
      type: "cribl_http";
    }
  )
  | (
    | InputCriblLakeHttpSendToRoutesTrueConstraint$Outbound
    | InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputCriblLakeHttpPqEnabledFalseConstraint$Outbound
    | InputCriblLakeHttpPqEnabledTrueWithPqConstraint$Outbound & {
      type: "cribl_lake_http";
    }
  )
  | (
    | InputTcpjsonSendToRoutesTrueConstraint$Outbound
    | InputTcpjsonSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputTcpjsonPqEnabledFalseConstraint$Outbound
    | InputTcpjsonPqEnabledTrueWithPqConstraint$Outbound & { type: "tcpjson" }
  )
  | (
    | InputSystemMetricsSendToRoutesTrueConstraint$Outbound
    | InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputSystemMetricsPqEnabledFalseConstraint$Outbound
    | InputSystemMetricsPqEnabledTrueWithPqConstraint$Outbound & {
      type: "system_metrics";
    }
  )
  | (
    | InputSystemStateSendToRoutesTrueConstraint$Outbound
    | InputSystemStateSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputSystemStatePqEnabledFalseConstraint$Outbound
    | InputSystemStatePqEnabledTrueWithPqConstraint$Outbound & {
      type: "system_state";
    }
  )
  | (
    | InputKubeMetricsSendToRoutesTrueConstraint$Outbound
    | InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputKubeMetricsPqEnabledFalseConstraint$Outbound
    | InputKubeMetricsPqEnabledTrueWithPqConstraint$Outbound & {
      type: "kube_metrics";
    }
  )
  | (
    | InputKubeLogsSendToRoutesTrueConstraint$Outbound
    | InputKubeLogsSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputKubeLogsPqEnabledFalseConstraint$Outbound
    | InputKubeLogsPqEnabledTrueWithPqConstraint$Outbound & {
      type: "kube_logs";
    }
  )
  | (
    | InputKubeEventsSendToRoutesTrueConstraint$Outbound
    | InputKubeEventsSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputKubeEventsPqEnabledFalseConstraint$Outbound
    | InputKubeEventsPqEnabledTrueWithPqConstraint$Outbound & {
      type: "kube_events";
    }
  )
  | (
    | InputWindowsMetricsSendToRoutesTrueConstraint$Outbound
    | InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputWindowsMetricsPqEnabledFalseConstraint$Outbound
    | InputWindowsMetricsPqEnabledTrueWithPqConstraint$Outbound & {
      type: "windows_metrics";
    }
  )
  | (
    | InputCrowdstrikeSendToRoutesTrueConstraint$Outbound
    | InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputCrowdstrikePqEnabledFalseConstraint$Outbound
    | InputCrowdstrikePqEnabledTrueWithPqConstraint$Outbound & {
      type: "crowdstrike";
    }
  )
  | (
    | InputDatadogAgentSendToRoutesTrueConstraint$Outbound
    | InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputDatadogAgentPqEnabledFalseConstraint$Outbound
    | InputDatadogAgentPqEnabledTrueWithPqConstraint$Outbound & {
      type: "datadog_agent";
    }
  )
  | (
    | InputDatagenSendToRoutesTrueConstraint$Outbound
    | InputDatagenSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputDatagenPqEnabledFalseConstraint$Outbound
    | InputDatagenPqEnabledTrueWithPqConstraint$Outbound & { type: "datagen" }
  )
  | (
    | InputHttpRawSendToRoutesTrueConstraint$Outbound
    | InputHttpRawSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputHttpRawPqEnabledFalseConstraint$Outbound
    | InputHttpRawPqEnabledTrueWithPqConstraint$Outbound & { type: "http_raw" }
  )
  | (
    | InputKinesisSendToRoutesTrueConstraint$Outbound
    | InputKinesisSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputKinesisPqEnabledFalseConstraint$Outbound
    | InputKinesisPqEnabledTrueWithPqConstraint$Outbound & { type: "kinesis" }
  )
  | (
    | InputCriblmetricsSendToRoutesTrueConstraint$Outbound
    | InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputCriblmetricsPqEnabledFalseConstraint$Outbound
    | InputCriblmetricsPqEnabledTrueWithPqConstraint$Outbound & {
      type: "criblmetrics";
    }
  )
  | (
    | InputMetricsSendToRoutesTrueConstraint$Outbound
    | InputMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputMetricsPqEnabledFalseConstraint$Outbound
    | InputMetricsPqEnabledTrueWithPqConstraint$Outbound & { type: "metrics" }
  )
  | (
    | InputS3SendToRoutesTrueConstraint$Outbound
    | InputS3SendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputS3PqEnabledFalseConstraint$Outbound
    | InputS3PqEnabledTrueWithPqConstraint$Outbound & { type: "s3" }
  )
  | (
    | InputS3InventorySendToRoutesTrueConstraint$Outbound
    | InputS3InventorySendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputS3InventoryPqEnabledFalseConstraint$Outbound
    | InputS3InventoryPqEnabledTrueWithPqConstraint$Outbound & {
      type: "s3_inventory";
    }
  )
  | (
    | InputSnmpSendToRoutesTrueConstraint$Outbound
    | InputSnmpSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputSnmpPqEnabledFalseConstraint$Outbound
    | InputSnmpPqEnabledTrueWithPqConstraint$Outbound & { type: "snmp" }
  )
  | (
    | InputOpenTelemetrySendToRoutesTrueConstraint$Outbound
    | InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputOpenTelemetryPqEnabledFalseConstraint$Outbound
    | InputOpenTelemetryPqEnabledTrueWithPqConstraint$Outbound & {
      type: "open_telemetry";
    }
  )
  | (
    | InputModelDrivenTelemetrySendToRoutesTrueConstraint$Outbound
    | InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputModelDrivenTelemetryPqEnabledFalseConstraint$Outbound
    | InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint$Outbound & {
      type: "model_driven_telemetry";
    }
  )
  | (
    | InputSqsSendToRoutesTrueConstraint$Outbound
    | InputSqsSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputSqsPqEnabledFalseConstraint$Outbound
    | InputSqsPqEnabledTrueWithPqConstraint$Outbound & { type: "sqs" }
  )
  | (
    | InputSyslogSyslog1$Outbound
    | InputSyslogSyslog2$Outbound & { type: "syslog" }
  )
  | (
    | InputFileSendToRoutesTrueConstraint$Outbound
    | InputFileSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputFilePqEnabledFalseConstraint$Outbound
    | InputFilePqEnabledTrueWithPqConstraint$Outbound & { type: "file" }
  )
  | (
    | InputTcpSendToRoutesTrueConstraint$Outbound
    | InputTcpSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputTcpPqEnabledFalseConstraint$Outbound
    | InputTcpPqEnabledTrueWithPqConstraint$Outbound & { type: "tcp" }
  )
  | (
    | InputAppscopeSendToRoutesTrueConstraint$Outbound
    | InputAppscopeSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputAppscopePqEnabledFalseConstraint$Outbound
    | InputAppscopePqEnabledTrueWithPqConstraint$Outbound & { type: "appscope" }
  )
  | (
    | InputWefSendToRoutesTrueConstraint$Outbound
    | InputWefSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputWefPqEnabledFalseConstraint$Outbound
    | InputWefPqEnabledTrueWithPqConstraint$Outbound & { type: "wef" }
  )
  | (
    | InputWinEventLogsSendToRoutesTrueConstraint$Outbound
    | InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputWinEventLogsPqEnabledFalseConstraint$Outbound
    | InputWinEventLogsPqEnabledTrueWithPqConstraint$Outbound & {
      type: "win_event_logs";
    }
  )
  | (
    | InputRawUdpSendToRoutesTrueConstraint$Outbound
    | InputRawUdpSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputRawUdpPqEnabledFalseConstraint$Outbound
    | InputRawUdpPqEnabledTrueWithPqConstraint$Outbound & { type: "raw_udp" }
  )
  | (
    | InputJournalFilesSendToRoutesTrueConstraint$Outbound
    | InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputJournalFilesPqEnabledFalseConstraint$Outbound
    | InputJournalFilesPqEnabledTrueWithPqConstraint$Outbound & {
      type: "journal_files";
    }
  )
  | (
    | InputWizSendToRoutesTrueConstraint$Outbound
    | InputWizSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputWizPqEnabledFalseConstraint$Outbound
    | InputWizPqEnabledTrueWithPqConstraint$Outbound & { type: "wiz" }
  )
  | (
    | InputWizWebhookSendToRoutesTrueConstraint$Outbound
    | InputWizWebhookSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputWizWebhookPqEnabledFalseConstraint$Outbound
    | InputWizWebhookPqEnabledTrueWithPqConstraint$Outbound & {
      type: "wiz_webhook";
    }
  )
  | (
    | InputNetflowSendToRoutesTrueConstraint$Outbound
    | InputNetflowSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputNetflowPqEnabledFalseConstraint$Outbound
    | InputNetflowPqEnabledTrueWithPqConstraint$Outbound & { type: "netflow" }
  )
  | (
    | InputSecurityLakeSendToRoutesTrueConstraint$Outbound
    | InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputSecurityLakePqEnabledFalseConstraint$Outbound
    | InputSecurityLakePqEnabledTrueWithPqConstraint$Outbound & {
      type: "security_lake";
    }
  )
  | (
    | InputZscalerHecSendToRoutesTrueConstraint$Outbound
    | InputZscalerHecSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputZscalerHecPqEnabledFalseConstraint$Outbound
    | InputZscalerHecPqEnabledTrueWithPqConstraint$Outbound & {
      type: "zscaler_hec";
    }
  )
  | (
    | InputCloudflareHecSendToRoutesTrueConstraint$Outbound
    | InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint$Outbound
    | InputCloudflareHecPqEnabledFalseConstraint$Outbound
    | InputCloudflareHecPqEnabledTrueWithPqConstraint$Outbound & {
      type: "cloudflare_hec";
    }
  );

/** @internal */
export const CreateInputRequest$outboundSchema: z.ZodType<
  CreateInputRequest$Outbound,
  z.ZodTypeDef,
  CreateInputRequest
> = z.union([
  z.union([
    z.lazy(() => InputCollectionSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputCollectionSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputCollectionPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputCollectionPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("collection") })),
  z.union([
    z.lazy(() => InputKafkaSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputKafkaSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputKafkaPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputKafkaPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("kafka") })),
  z.union([
    z.lazy(() => InputMskSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputMskSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputMskPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputMskPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("msk") })),
  z.union([
    z.lazy(() => InputHttpSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputHttpPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputHttpPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("http") })),
  z.union([
    z.lazy(() => InputSplunkSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputSplunkSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputSplunkPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputSplunkPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("splunk") })),
  z.union([
    z.lazy(() => InputSplunkSearchSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputSplunkSearchSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputSplunkSearchPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputSplunkSearchPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("splunk_search") })),
  z.union([
    z.lazy(() => InputSplunkHecSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputSplunkHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputSplunkHecPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputSplunkHecPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("splunk_hec") })),
  z.union([
    z.lazy(() => InputAzureBlobSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputAzureBlobSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputAzureBlobPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputAzureBlobPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("azure_blob") })),
  z.union([
    z.lazy(() => InputElasticSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputElasticSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputElasticPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputElasticPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("elastic") })),
  z.union([
    z.lazy(() => InputConfluentCloudSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputConfluentCloudSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputConfluentCloudPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() =>
      InputConfluentCloudPqEnabledTrueWithPqConstraint$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("confluent_cloud") })),
  z.union([
    z.lazy(() => InputGrafanaGrafana1$outboundSchema),
    z.lazy(() => InputGrafanaGrafana2$outboundSchema),
  ]).and(z.object({ type: z.literal("grafana") })),
  z.union([
    z.lazy(() => InputLokiSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputLokiSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputLokiPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputLokiPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("loki") })),
  z.union([
    z.lazy(() => InputPrometheusRwSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputPrometheusRwSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputPrometheusRwPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputPrometheusRwPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("prometheus_rw") })),
  z.union([
    z.lazy(() => InputPrometheusSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputPrometheusSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputPrometheusPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputPrometheusPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("prometheus") })),
  z.union([
    z.lazy(() => InputEdgePrometheusSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputEdgePrometheusSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputEdgePrometheusPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() =>
      InputEdgePrometheusPqEnabledTrueWithPqConstraint$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("edge_prometheus") })),
  z.union([
    z.lazy(() => InputOffice365MgmtSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputOffice365MgmtSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputOffice365MgmtPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() =>
      InputOffice365MgmtPqEnabledTrueWithPqConstraint$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("office365_mgmt") })),
  z.union([
    z.lazy(() =>
      InputOffice365ServiceSendToRoutesTrueConstraint$outboundSchema
    ),
    z.lazy(() =>
      InputOffice365ServiceSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputOffice365ServicePqEnabledFalseConstraint$outboundSchema),
    z.lazy(() =>
      InputOffice365ServicePqEnabledTrueWithPqConstraint$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("office365_service") })),
  z.union([
    z.lazy(() =>
      InputOffice365MsgTraceSendToRoutesTrueConstraint$outboundSchema
    ),
    z.lazy(() =>
      InputOffice365MsgTraceSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputOffice365MsgTracePqEnabledFalseConstraint$outboundSchema),
    z.lazy(() =>
      InputOffice365MsgTracePqEnabledTrueWithPqConstraint$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("office365_msg_trace") })),
  z.union([
    z.lazy(() => InputEventhubSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputEventhubSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputEventhubPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputEventhubPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("eventhub") })),
  z.union([
    z.lazy(() => InputExecSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputExecSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputExecPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputExecPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("exec") })),
  z.union([
    z.lazy(() => InputFirehoseSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputFirehoseSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputFirehosePqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputFirehosePqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("firehose") })),
  z.union([
    z.lazy(() => InputGooglePubsubSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputGooglePubsubSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputGooglePubsubPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputGooglePubsubPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("google_pubsub") })),
  z.union([
    z.lazy(() => InputCriblSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputCriblSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputCriblPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputCriblPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("cribl") })),
  z.union([
    z.lazy(() => InputCriblTcpSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputCriblTcpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputCriblTcpPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputCriblTcpPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("cribl_tcp") })),
  z.union([
    z.lazy(() => InputCriblHttpSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputCriblHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputCriblHttpPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputCriblHttpPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("cribl_http") })),
  z.union([
    z.lazy(() => InputCriblLakeHttpSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputCriblLakeHttpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputCriblLakeHttpPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() =>
      InputCriblLakeHttpPqEnabledTrueWithPqConstraint$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("cribl_lake_http") })),
  z.union([
    z.lazy(() => InputTcpjsonSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputTcpjsonSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputTcpjsonPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputTcpjsonPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("tcpjson") })),
  z.union([
    z.lazy(() => InputSystemMetricsSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputSystemMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputSystemMetricsPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() =>
      InputSystemMetricsPqEnabledTrueWithPqConstraint$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("system_metrics") })),
  z.union([
    z.lazy(() => InputSystemStateSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputSystemStateSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputSystemStatePqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputSystemStatePqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("system_state") })),
  z.union([
    z.lazy(() => InputKubeMetricsSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputKubeMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputKubeMetricsPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputKubeMetricsPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("kube_metrics") })),
  z.union([
    z.lazy(() => InputKubeLogsSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputKubeLogsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputKubeLogsPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputKubeLogsPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("kube_logs") })),
  z.union([
    z.lazy(() => InputKubeEventsSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputKubeEventsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputKubeEventsPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputKubeEventsPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("kube_events") })),
  z.union([
    z.lazy(() => InputWindowsMetricsSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputWindowsMetricsPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() =>
      InputWindowsMetricsPqEnabledTrueWithPqConstraint$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("windows_metrics") })),
  z.union([
    z.lazy(() => InputCrowdstrikeSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputCrowdstrikeSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputCrowdstrikePqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputCrowdstrikePqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("crowdstrike") })),
  z.union([
    z.lazy(() => InputDatadogAgentSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputDatadogAgentSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputDatadogAgentPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputDatadogAgentPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("datadog_agent") })),
  z.union([
    z.lazy(() => InputDatagenSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputDatagenSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputDatagenPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputDatagenPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("datagen") })),
  z.union([
    z.lazy(() => InputHttpRawSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputHttpRawSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputHttpRawPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputHttpRawPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("http_raw") })),
  z.union([
    z.lazy(() => InputKinesisSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputKinesisSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputKinesisPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputKinesisPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("kinesis") })),
  z.union([
    z.lazy(() => InputCriblmetricsSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputCriblmetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputCriblmetricsPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputCriblmetricsPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("criblmetrics") })),
  z.union([
    z.lazy(() => InputMetricsSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputMetricsPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputMetricsPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("metrics") })),
  z.union([
    z.lazy(() => InputS3SendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputS3SendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputS3PqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputS3PqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("s3") })),
  z.union([
    z.lazy(() => InputS3InventorySendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputS3InventorySendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputS3InventoryPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputS3InventoryPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("s3_inventory") })),
  z.union([
    z.lazy(() => InputSnmpSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputSnmpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputSnmpPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputSnmpPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("snmp") })),
  z.union([
    z.lazy(() => InputOpenTelemetrySendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputOpenTelemetrySendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputOpenTelemetryPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() =>
      InputOpenTelemetryPqEnabledTrueWithPqConstraint$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("open_telemetry") })),
  z.union([
    z.lazy(() =>
      InputModelDrivenTelemetrySendToRoutesTrueConstraint$outboundSchema
    ),
    z.lazy(() =>
      InputModelDrivenTelemetrySendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() =>
      InputModelDrivenTelemetryPqEnabledFalseConstraint$outboundSchema
    ),
    z.lazy(() =>
      InputModelDrivenTelemetryPqEnabledTrueWithPqConstraint$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("model_driven_telemetry") })),
  z.union([
    z.lazy(() => InputSqsSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputSqsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputSqsPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputSqsPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("sqs") })),
  z.union([
    z.lazy(() => InputSyslogSyslog1$outboundSchema),
    z.lazy(() => InputSyslogSyslog2$outboundSchema),
  ]).and(z.object({ type: z.literal("syslog") })),
  z.union([
    z.lazy(() => InputFileSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputFileSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputFilePqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputFilePqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("file") })),
  z.union([
    z.lazy(() => InputTcpSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputTcpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputTcpPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputTcpPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("tcp") })),
  z.union([
    z.lazy(() => InputAppscopeSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputAppscopeSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputAppscopePqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputAppscopePqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("appscope") })),
  z.union([
    z.lazy(() => InputWefSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputWefSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputWefPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputWefPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("wef") })),
  z.union([
    z.lazy(() => InputWinEventLogsSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputWinEventLogsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputWinEventLogsPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputWinEventLogsPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("win_event_logs") })),
  z.union([
    z.lazy(() => InputRawUdpSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputRawUdpSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputRawUdpPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputRawUdpPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("raw_udp") })),
  z.union([
    z.lazy(() => InputJournalFilesSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputJournalFilesSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputJournalFilesPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputJournalFilesPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("journal_files") })),
  z.union([
    z.lazy(() => InputWizSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputWizSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputWizPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputWizPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("wiz") })),
  z.union([
    z.lazy(() => InputWizWebhookSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputWizWebhookSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputWizWebhookPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputWizWebhookPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("wiz_webhook") })),
  z.union([
    z.lazy(() => InputNetflowSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputNetflowSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputNetflowPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputNetflowPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("netflow") })),
  z.union([
    z.lazy(() => InputSecurityLakeSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputSecurityLakeSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputSecurityLakePqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputSecurityLakePqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("security_lake") })),
  z.union([
    z.lazy(() => InputZscalerHecSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputZscalerHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputZscalerHecPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() => InputZscalerHecPqEnabledTrueWithPqConstraint$outboundSchema),
  ]).and(z.object({ type: z.literal("zscaler_hec") })),
  z.union([
    z.lazy(() => InputCloudflareHecSendToRoutesTrueConstraint$outboundSchema),
    z.lazy(() =>
      InputCloudflareHecSendToRoutesFalseWithConnectionsConstraint$outboundSchema
    ),
    z.lazy(() => InputCloudflareHecPqEnabledFalseConstraint$outboundSchema),
    z.lazy(() =>
      InputCloudflareHecPqEnabledTrueWithPqConstraint$outboundSchema
    ),
  ]).and(z.object({ type: z.literal("cloudflare_hec") })),
]);

export function createInputRequestToJSON(
  createInputRequest: CreateInputRequest,
): string {
  return JSON.stringify(
    CreateInputRequest$outboundSchema.parse(createInputRequest),
  );
}
