/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  AuthenticationMethodOptionsSasl,
  AuthenticationMethodOptionsSasl$inboundSchema,
  AuthenticationMethodOptionsSasl$outboundSchema,
} from "./authenticationmethodoptionssasl.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeSaslOauthParams,
  ItemsTypeSaslOauthParams$inboundSchema,
  ItemsTypeSaslOauthParams$Outbound,
  ItemsTypeSaslOauthParams$outboundSchema,
} from "./itemstypesasloauthparams.js";
import {
  ItemsTypeSaslSaslExtensions,
  ItemsTypeSaslSaslExtensions$inboundSchema,
  ItemsTypeSaslSaslExtensions$Outbound,
  ItemsTypeSaslSaslExtensions$outboundSchema,
} from "./itemstypesaslsaslextensions.js";
import {
  SaslMechanismOptionsSasl,
  SaslMechanismOptionsSasl$inboundSchema,
  SaslMechanismOptionsSasl$outboundSchema,
} from "./saslmechanismoptionssasl.js";

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type AuthenticationType = {
  disabled: boolean;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthenticationMethodOptionsSasl | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  mechanism?: SaslMechanismOptionsSasl | undefined;
  /**
   * Location of keytab file for authentication principal
   */
  keytabLocation?: string | undefined;
  /**
   * Authentication principal, such as `kafka_user@example.com`
   */
  principal?: string | undefined;
  /**
   * Kerberos service class for Kafka brokers, such as `kafka`
   */
  brokerServiceClass?: string | undefined;
  /**
   * Enable OAuth authentication
   */
  oauthEnabled?: boolean | undefined;
  /**
   * URL of the token endpoint to use for OAuth authentication
   */
  tokenUrl?: string | undefined;
  /**
   * Client ID to use for OAuth authentication
   */
  clientId?: string | undefined;
  oauthSecretType?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  clientTextSecret?: string | undefined;
  /**
   * Additional fields to send to the token endpoint, such as scope or audience
   */
  oauthParams?: Array<ItemsTypeSaslOauthParams> | undefined;
  /**
   * Additional SASL extension fields, such as Confluent's logicalCluster or identityPoolId
   */
  saslExtensions?: Array<ItemsTypeSaslSaslExtensions> | undefined;
};

/** @internal */
export const AuthenticationType$inboundSchema: z.ZodType<
  AuthenticationType,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: types.boolean(),
  username: types.optional(types.string()),
  password: types.optional(types.string()),
  authType: types.optional(AuthenticationMethodOptionsSasl$inboundSchema),
  credentialsSecret: types.optional(types.string()),
  mechanism: types.optional(SaslMechanismOptionsSasl$inboundSchema),
  keytabLocation: types.optional(types.string()),
  principal: types.optional(types.string()),
  brokerServiceClass: types.optional(types.string()),
  oauthEnabled: types.optional(types.boolean()),
  tokenUrl: types.optional(types.string()),
  clientId: types.optional(types.string()),
  oauthSecretType: types.optional(types.string()),
  clientTextSecret: types.optional(types.string()),
  oauthParams: types.optional(z.array(ItemsTypeSaslOauthParams$inboundSchema)),
  saslExtensions: types.optional(
    z.array(ItemsTypeSaslSaslExtensions$inboundSchema),
  ),
});
/** @internal */
export type AuthenticationType$Outbound = {
  disabled: boolean;
  username?: string | undefined;
  password?: string | undefined;
  authType?: string | undefined;
  credentialsSecret?: string | undefined;
  mechanism?: string | undefined;
  keytabLocation?: string | undefined;
  principal?: string | undefined;
  brokerServiceClass?: string | undefined;
  oauthEnabled?: boolean | undefined;
  tokenUrl?: string | undefined;
  clientId?: string | undefined;
  oauthSecretType?: string | undefined;
  clientTextSecret?: string | undefined;
  oauthParams?: Array<ItemsTypeSaslOauthParams$Outbound> | undefined;
  saslExtensions?: Array<ItemsTypeSaslSaslExtensions$Outbound> | undefined;
};

/** @internal */
export const AuthenticationType$outboundSchema: z.ZodType<
  AuthenticationType$Outbound,
  z.ZodTypeDef,
  AuthenticationType
> = z.object({
  disabled: z.boolean(),
  username: z.string().optional(),
  password: z.string().optional(),
  authType: AuthenticationMethodOptionsSasl$outboundSchema.optional(),
  credentialsSecret: z.string().optional(),
  mechanism: SaslMechanismOptionsSasl$outboundSchema.optional(),
  keytabLocation: z.string().optional(),
  principal: z.string().optional(),
  brokerServiceClass: z.string().optional(),
  oauthEnabled: z.boolean().optional(),
  tokenUrl: z.string().optional(),
  clientId: z.string().optional(),
  oauthSecretType: z.string().optional(),
  clientTextSecret: z.string().optional(),
  oauthParams: z.array(ItemsTypeSaslOauthParams$outboundSchema).optional(),
  saslExtensions: z.array(ItemsTypeSaslSaslExtensions$outboundSchema)
    .optional(),
});

export function authenticationTypeToJSON(
  authenticationType: AuthenticationType,
): string {
  return JSON.stringify(
    AuthenticationType$outboundSchema.parse(authenticationType),
  );
}
export function authenticationTypeFromJSON(
  jsonString: string,
): SafeParseResult<AuthenticationType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthenticationType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthenticationType' from JSON`,
  );
}
