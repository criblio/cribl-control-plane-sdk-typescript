/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  TypeOptions,
  TypeOptions$inboundSchema,
  TypeOptions$outboundSchema,
} from "./typeoptions.js";

/**
 * Extract creates new fields. Reserialize extracts and filters fields, and then reserializes.
 */
export const OperationMode = {
  /**
   * Extract
   */
  Extract: "extract",
  /**
   * Reserialize
   */
  Reserialize: "reserialize",
} as const;
/**
 * Extract creates new fields. Reserialize extracts and filters fields, and then reserializes.
 */
export type OperationMode = OpenEnum<typeof OperationMode>;

export type FunctionConfSchemaSerde = {
  /**
   * Extract creates new fields. Reserialize extracts and filters fields, and then reserializes.
   */
  mode?: OperationMode | undefined;
  /**
   * Parser or formatter type to use
   */
  type?: TypeOptions | undefined;
  delimChar?: any | undefined;
  quoteChar?: any | undefined;
  escapeChar?: any | undefined;
  nullValue?: any | undefined;
  /**
   * Field containing text to be parsed
   */
  srcField?: string | undefined;
  /**
   * Name of the field to add fields to. Extract mode only.
   */
  dstField?: string | undefined;
  cleanFields?: any | undefined;
};

/** @internal */
export const OperationMode$inboundSchema: z.ZodType<
  OperationMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(OperationMode);
/** @internal */
export const OperationMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  OperationMode
> = openEnums.outboundSchema(OperationMode);

/** @internal */
export const FunctionConfSchemaSerde$inboundSchema: z.ZodType<
  FunctionConfSchemaSerde,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: OperationMode$inboundSchema.optional(),
  type: TypeOptions$inboundSchema.optional(),
  delimChar: z.any().optional(),
  quoteChar: z.any().optional(),
  escapeChar: z.any().optional(),
  nullValue: z.any().optional(),
  srcField: z.string().optional(),
  dstField: z.string().optional(),
  cleanFields: z.any().optional(),
});
/** @internal */
export type FunctionConfSchemaSerde$Outbound = {
  mode?: string | undefined;
  type?: string | undefined;
  delimChar?: any | undefined;
  quoteChar?: any | undefined;
  escapeChar?: any | undefined;
  nullValue?: any | undefined;
  srcField?: string | undefined;
  dstField?: string | undefined;
  cleanFields?: any | undefined;
};

/** @internal */
export const FunctionConfSchemaSerde$outboundSchema: z.ZodType<
  FunctionConfSchemaSerde$Outbound,
  z.ZodTypeDef,
  FunctionConfSchemaSerde
> = z.object({
  mode: OperationMode$outboundSchema.optional(),
  type: TypeOptions$outboundSchema.optional(),
  delimChar: z.any().optional(),
  quoteChar: z.any().optional(),
  escapeChar: z.any().optional(),
  nullValue: z.any().optional(),
  srcField: z.string().optional(),
  dstField: z.string().optional(),
  cleanFields: z.any().optional(),
});

export function functionConfSchemaSerdeToJSON(
  functionConfSchemaSerde: FunctionConfSchemaSerde,
): string {
  return JSON.stringify(
    FunctionConfSchemaSerde$outboundSchema.parse(functionConfSchemaSerde),
  );
}
export function functionConfSchemaSerdeFromJSON(
  jsonString: string,
): SafeParseResult<FunctionConfSchemaSerde, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionConfSchemaSerde$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionConfSchemaSerde' from JSON`,
  );
}
