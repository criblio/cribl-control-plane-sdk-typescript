/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeRestCollectMethodGetCollectRequestParams,
  ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound,
  ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
} from "./itemstyperestcollectmethodgetcollectrequestparams.js";
import {
  RestAuthenticationOauthCollectMethod,
  RestAuthenticationOauthCollectMethod$inboundSchema,
  RestAuthenticationOauthCollectMethod$outboundSchema,
  RestAuthenticationOauthDiscovery,
  RestAuthenticationOauthDiscovery$inboundSchema,
  RestAuthenticationOauthDiscovery$Outbound,
  RestAuthenticationOauthDiscovery$outboundSchema,
  RestAuthenticationOauthRestPaginationTypeRequestOffset,
  RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema,
  RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound,
  RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema,
  RestAuthenticationOauthRestPaginationTypeRequestPage,
  RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema,
  RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound,
  RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema,
  RestAuthenticationOauthRestPaginationTypeResponseHeader,
  RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema,
  RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound,
  RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema,
  RestAuthenticationOauthRestPaginationTypeResponseHeaderLink,
  RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema,
  RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound,
  RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema,
} from "./restauthenticationoauthrestpaginationtyperesponseheader.js";

export type RestAuthenticationOauthRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationOauthRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationOauthPaginationUnion =
  | RestAuthenticationOauthRestPaginationTypeNone
  | RestAuthenticationOauthRestPaginationTypeResponseBody
  | RestAuthenticationOauthRestPaginationTypeResponseHeader
  | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink
  | RestAuthenticationOauthRestPaginationTypeRequestOffset
  | RestAuthenticationOauthRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationOauthRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationOauthRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationOauthRetryRules =
  | RestAuthenticationOauthRestRetryRulesTypeNone
  | RestAuthenticationOauthRestRetryRulesTypeStatic
  | RestAuthenticationOauthRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationOauthStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationOauthScheduling = {
  stateTracking?: RestAuthenticationOauthStateTracking | undefined;
};

export type RestAuthenticationOauth = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "oauth";
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  /**
   * Defaults to 'client_secret'. Automatically added to request parameters using the value specified.
   */
  clientSecretParamName: string;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Value is stored encrypted on disk and automatically added to request parameters.
   */
  clientSecretParamValue: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?: RestAuthenticationOauthDiscovery | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationOauthCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationOauthRestPaginationTypeNone
    | RestAuthenticationOauthRestPaginationTypeResponseBody
    | RestAuthenticationOauthRestPaginationTypeResponseHeader
    | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink
    | RestAuthenticationOauthRestPaginationTypeRequestOffset
    | RestAuthenticationOauthRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthRestRetryRulesTypeNone
    | RestAuthenticationOauthRestRetryRulesTypeStatic
    | RestAuthenticationOauthRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationOauthScheduling | undefined;
};

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationLoginSecretDiscovery =
  | (
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationLoginSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationLoginSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationLoginSecretCollectMethod
>;

export type RestAuthenticationLoginSecretRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationLoginSecretRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginSecretRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationLoginSecretRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationLoginSecretRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationLoginSecretPaginationUnion =
  | RestAuthenticationLoginSecretRestPaginationTypeNone
  | RestAuthenticationLoginSecretRestPaginationTypeResponseBody
  | RestAuthenticationLoginSecretRestPaginationTypeResponseHeader
  | RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink
  | RestAuthenticationLoginSecretRestPaginationTypeRequestOffset
  | RestAuthenticationLoginSecretRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginSecretRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationLoginSecretRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationLoginSecretRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationLoginSecretRetryRules =
  | RestAuthenticationLoginSecretRestRetryRulesTypeNone
  | RestAuthenticationLoginSecretRestRetryRulesTypeStatic
  | RestAuthenticationLoginSecretRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationLoginSecretScheduling = {
  stateTracking?: RestAuthenticationLoginSecretStateTracking | undefined;
};

export type RestAuthenticationLoginSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "loginSecret";
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationLoginSecretCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginSecretRestPaginationTypeNone
    | RestAuthenticationLoginSecretRestPaginationTypeResponseBody
    | RestAuthenticationLoginSecretRestPaginationTypeResponseHeader
    | RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink
    | RestAuthenticationLoginSecretRestPaginationTypeRequestOffset
    | RestAuthenticationLoginSecretRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginSecretRestRetryRulesTypeNone
    | RestAuthenticationLoginSecretRestRetryRulesTypeStatic
    | RestAuthenticationLoginSecretRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationLoginSecretScheduling | undefined;
};

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationLoginDiscovery =
  | (
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeJson
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeList
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationLoginCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationLoginCollectMethod = OpenEnum<
  typeof RestAuthenticationLoginCollectMethod
>;

export type RestAuthenticationLoginRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationLoginRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationLoginRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationLoginRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationLoginRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationLoginRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationLoginPaginationUnion =
  | RestAuthenticationLoginRestPaginationTypeNone
  | RestAuthenticationLoginRestPaginationTypeResponseBody
  | RestAuthenticationLoginRestPaginationTypeResponseHeader
  | RestAuthenticationLoginRestPaginationTypeResponseHeaderLink
  | RestAuthenticationLoginRestPaginationTypeRequestOffset
  | RestAuthenticationLoginRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationLoginRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationLoginRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationLoginRetryRules =
  | RestAuthenticationLoginRestRetryRulesTypeNone
  | RestAuthenticationLoginRestRetryRulesTypeStatic
  | RestAuthenticationLoginRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationLoginScheduling = {
  stateTracking?: RestAuthenticationLoginStateTracking | undefined;
};

export type RestAuthenticationLogin = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "login";
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  username: string;
  password: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeJson
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeList
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationLoginCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginRestPaginationTypeNone
    | RestAuthenticationLoginRestPaginationTypeResponseBody
    | RestAuthenticationLoginRestPaginationTypeResponseHeader
    | RestAuthenticationLoginRestPaginationTypeResponseHeaderLink
    | RestAuthenticationLoginRestPaginationTypeRequestOffset
    | RestAuthenticationLoginRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginRestRetryRulesTypeNone
    | RestAuthenticationLoginRestRetryRulesTypeStatic
    | RestAuthenticationLoginRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationLoginScheduling | undefined;
};

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationBasicSecretDiscovery =
  | (
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationBasicSecretCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationBasicSecretCollectMethod = OpenEnum<
  typeof RestAuthenticationBasicSecretCollectMethod
>;

export type RestAuthenticationBasicSecretRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationBasicSecretRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationBasicSecretRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationBasicSecretRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationBasicSecretRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationBasicSecretPaginationUnion =
  | RestAuthenticationBasicSecretRestPaginationTypeNone
  | RestAuthenticationBasicSecretRestPaginationTypeResponseBody
  | RestAuthenticationBasicSecretRestPaginationTypeResponseHeader
  | RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink
  | RestAuthenticationBasicSecretRestPaginationTypeRequestOffset
  | RestAuthenticationBasicSecretRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationBasicSecretRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationBasicSecretRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationBasicSecretRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationBasicSecretRetryRules =
  | RestAuthenticationBasicSecretRestRetryRulesTypeNone
  | RestAuthenticationBasicSecretRestRetryRulesTypeStatic
  | RestAuthenticationBasicSecretRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationBasicSecretStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationBasicSecretScheduling = {
  stateTracking?: RestAuthenticationBasicSecretStateTracking | undefined;
};

export type RestAuthenticationBasicSecret = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "basicSecret";
  /**
   * Select or create a stored secret that references your credentials
   */
  credentialsSecret: string;
  discovery?:
    | (
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationBasicSecretCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationBasicSecretRestPaginationTypeNone
    | RestAuthenticationBasicSecretRestPaginationTypeResponseBody
    | RestAuthenticationBasicSecretRestPaginationTypeResponseHeader
    | RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink
    | RestAuthenticationBasicSecretRestPaginationTypeRequestOffset
    | RestAuthenticationBasicSecretRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationBasicSecretRestRetryRulesTypeNone
    | RestAuthenticationBasicSecretRestRetryRulesTypeStatic
    | RestAuthenticationBasicSecretRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationBasicSecretScheduling | undefined;
};

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationBasicDiscovery =
  | (
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeJson
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeList
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationBasicCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationBasicCollectMethod = OpenEnum<
  typeof RestAuthenticationBasicCollectMethod
>;

export type RestAuthenticationBasicRestPaginationTypeRequestPage = {
  type: "request_page";
  /**
   * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  pageField: string;
  /**
   * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
   */
  page?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
   */
  sizeField: string;
  /**
   * Maximum number of records to collect per page
   */
  size: number;
  /**
   * Name of the attribute in the response that contains the total number of pages for the query
   */
  totalPageField?: string | undefined;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationBasicRestPaginationTypeRequestOffset = {
  type: "request_offset";
  /**
   * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  offsetField: string;
  /**
   * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
   */
  offset?: number | undefined;
  /**
   * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
   */
  limitField: string;
  /**
   * Maximum number of records to collect per request
   */
  limit: number;
  /**
   * Name of the attribute in the response that contains the total number of records for the query
   */
  totalRecordField?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
   */
  zeroIndexed: boolean;
};

export type RestAuthenticationBasicRestPaginationTypeResponseHeaderLink = {
  type: "response_header_link";
  /**
   * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
   */
  nextRelationAttribute: string;
  /**
   * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
   */
  curRelationAttribute?: string | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationBasicRestPaginationTypeResponseHeader = {
  type: "response_header";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
};

export type RestAuthenticationBasicRestPaginationTypeResponseBody = {
  type: "response_body";
  /**
   * Names of attributes within the response that contain next-page information
   */
  attribute: Array<string>;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
   */
  maxPages: number;
  /**
   * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
   */
  lastPageExpr?: string | undefined;
};

export type RestAuthenticationBasicRestPaginationTypeNone = {
  type: "none";
};

export type RestAuthenticationBasicPaginationUnion =
  | RestAuthenticationBasicRestPaginationTypeNone
  | RestAuthenticationBasicRestPaginationTypeResponseBody
  | RestAuthenticationBasicRestPaginationTypeResponseHeader
  | RestAuthenticationBasicRestPaginationTypeResponseHeaderLink
  | RestAuthenticationBasicRestPaginationTypeRequestOffset
  | RestAuthenticationBasicRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationBasicRestRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationBasicRestRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

export type RestAuthenticationBasicRestRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type RestAuthenticationBasicRetryRules =
  | RestAuthenticationBasicRestRetryRulesTypeNone
  | RestAuthenticationBasicRestRetryRulesTypeStatic
  | RestAuthenticationBasicRestRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationBasicStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationBasicScheduling = {
  stateTracking?: RestAuthenticationBasicStateTracking | undefined;
};

export type RestAuthenticationBasic = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication: "basic";
  username: string;
  password: string;
  discovery?:
    | (
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeJson
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeList
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationBasicCollectMethod;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationBasicRestPaginationTypeNone
    | RestAuthenticationBasicRestPaginationTypeResponseBody
    | RestAuthenticationBasicRestPaginationTypeResponseHeader
    | RestAuthenticationBasicRestPaginationTypeResponseHeaderLink
    | RestAuthenticationBasicRestPaginationTypeRequestOffset
    | RestAuthenticationBasicRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationBasicRestRetryRulesTypeNone
    | RestAuthenticationBasicRestRetryRulesTypeStatic
    | RestAuthenticationBasicRestRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?: RestAuthenticationBasicScheduling | undefined;
};

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeNone = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "none";
};

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeList = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "list";
  /**
   * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
   */
  itemList: Array<string>;
};

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeJson = {
  /**
   * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
   */
  discoverType: "json";
  /**
   * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
   */
  manualDiscoverResult: string;
  /**
   * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
   */
  discoverDataField?: string | undefined;
};

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationOauthRestPaginationTypeResponseBodyToJSON(
  restAuthenticationOauthRestPaginationTypeResponseBody:
    RestAuthenticationOauthRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeResponseBody,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationOauthRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationOauthRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationOauthRestPaginationTypeNoneToJSON(
  restAuthenticationOauthRestPaginationTypeNone:
    RestAuthenticationOauthRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationOauthRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationOauthRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthPaginationUnion$inboundSchema: z.ZodType<
  RestAuthenticationOauthPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header:
    RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema,
  response_header_link:
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema,
  request_offset:
    RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema,
  request_page:
    RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema,
});
/** @internal */
export type RestAuthenticationOauthPaginationUnion$Outbound =
  | RestAuthenticationOauthRestPaginationTypeNone$Outbound
  | RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationOauthPaginationUnion$outboundSchema: z.ZodType<
  RestAuthenticationOauthPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthPaginationUnion
> = z.union([
  z.lazy(() => RestAuthenticationOauthRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema
  ),
  RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema,
  RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema,
  RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema,
  RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema,
]);

export function restAuthenticationOauthPaginationUnionToJSON(
  restAuthenticationOauthPaginationUnion:
    RestAuthenticationOauthPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationOauthPaginationUnion$outboundSchema.parse(
      restAuthenticationOauthPaginationUnion,
    ),
  );
}
export function restAuthenticationOauthPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeBackoffToJSON(
  restAuthenticationOauthRestRetryRulesTypeBackoff:
    RestAuthenticationOauthRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationOauthRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeStaticToJSON(
  restAuthenticationOauthRestRetryRulesTypeStatic:
    RestAuthenticationOauthRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationOauthRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationOauthRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationOauthRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationOauthRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationOauthRestRetryRulesTypeNoneToJSON(
  restAuthenticationOauthRestRetryRulesTypeNone:
    RestAuthenticationOauthRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationOauthRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationOauthRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationOauthRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationOauthRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationOauthRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    RestAuthenticationOauthRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestAuthenticationOauthRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationOauthRetryRules$Outbound =
  | RestAuthenticationOauthRestRetryRulesTypeNone$Outbound
  | RestAuthenticationOauthRestRetryRulesTypeStatic$Outbound
  | RestAuthenticationOauthRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestAuthenticationOauthRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationOauthRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthRetryRules
> = z.union([
  z.lazy(() => RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema),
  z.lazy(() => RestAuthenticationOauthRestRetryRulesTypeStatic$outboundSchema),
  z.lazy(() => RestAuthenticationOauthRestRetryRulesTypeBackoff$outboundSchema),
]);

export function restAuthenticationOauthRetryRulesToJSON(
  restAuthenticationOauthRetryRules: RestAuthenticationOauthRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationOauthRetryRules$outboundSchema.parse(
      restAuthenticationOauthRetryRules,
    ),
  );
}
export function restAuthenticationOauthRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationOauthStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestAuthenticationOauthStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationOauthStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationOauthStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationOauthStateTrackingToJSON(
  restAuthenticationOauthStateTracking: RestAuthenticationOauthStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationOauthStateTracking$outboundSchema.parse(
      restAuthenticationOauthStateTracking,
    ),
  );
}
export function restAuthenticationOauthStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationOauthStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauthScheduling$inboundSchema: z.ZodType<
  RestAuthenticationOauthScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationOauthStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauthScheduling$Outbound = {
  stateTracking?: RestAuthenticationOauthStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauthScheduling$outboundSchema: z.ZodType<
  RestAuthenticationOauthScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauthScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationOauthStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationOauthSchedulingToJSON(
  restAuthenticationOauthScheduling: RestAuthenticationOauthScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationOauthScheduling$outboundSchema.parse(
      restAuthenticationOauthScheduling,
    ),
  );
}
export function restAuthenticationOauthSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauthScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauthScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauthScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationOauth$inboundSchema: z.ZodType<
  RestAuthenticationOauth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("oauth"),
  loginUrl: types.string(),
  tokenRespAttribute: types.optional(types.string()),
  authHeaderKey: types.optional(types.string()),
  authHeaderExpr: types.string(),
  clientSecretParamName: types.string(),
  clientSecretParamValue: types.string(),
  authRequestParams: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  authRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(RestAuthenticationOauthDiscovery$inboundSchema),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationOauthCollectMethod$inboundSchema,
  collectVerb: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header:
      RestAuthenticationOauthRestPaginationTypeResponseHeader$inboundSchema,
    response_header_link:
      RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$inboundSchema,
    request_offset:
      RestAuthenticationOauthRestPaginationTypeRequestOffset$inboundSchema,
    request_page:
      RestAuthenticationOauthRestPaginationTypeRequestPage$inboundSchema,
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationOauthScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationOauth$Outbound = {
  authentication: "oauth";
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  clientSecretParamValue: string;
  authRequestParams?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?: RestAuthenticationOauthDiscovery$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationOauthRestPaginationTypeNone$Outbound
    | RestAuthenticationOauthRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationOauthRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationOauthRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationOauthRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationOauthRestRetryRulesTypeNone$Outbound
    | RestAuthenticationOauthRestRetryRulesTypeStatic$Outbound
    | RestAuthenticationOauthRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestAuthenticationOauthScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationOauth$outboundSchema: z.ZodType<
  RestAuthenticationOauth$Outbound,
  z.ZodTypeDef,
  RestAuthenticationOauth
> = z.object({
  authentication: z.literal("oauth"),
  loginUrl: z.string(),
  tokenRespAttribute: z.string().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  clientSecretParamName: z.string(),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: RestAuthenticationOauthDiscovery$outboundSchema.optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationOauthCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestAuthenticationOauthRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationOauthRestPaginationTypeResponseBody$outboundSchema
    ),
    RestAuthenticationOauthRestPaginationTypeResponseHeader$outboundSchema,
    RestAuthenticationOauthRestPaginationTypeResponseHeaderLink$outboundSchema,
    RestAuthenticationOauthRestPaginationTypeRequestOffset$outboundSchema,
    RestAuthenticationOauthRestPaginationTypeRequestPage$outboundSchema,
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestAuthenticationOauthRestRetryRulesTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationOauthRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() => RestAuthenticationOauthScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationOauthToJSON(
  restAuthenticationOauth: RestAuthenticationOauth,
): string {
  return JSON.stringify(
    RestAuthenticationOauth$outboundSchema.parse(restAuthenticationOauth),
  );
}
export function restAuthenticationOauthFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationOauth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationOauth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationOauth' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeList:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restAuthenticationLoginSecretRestDiscoveryDiscoverTypeList),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp),
  );
}
export function restAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecretDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationLoginSecretDiscovery$Outbound =
  | (
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecretDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecretDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationLoginSecretDiscoveryToJSON(
  restAuthenticationLoginSecretDiscovery:
    RestAuthenticationLoginSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretDiscovery$outboundSchema.parse(
      restAuthenticationLoginSecretDiscovery,
    ),
  );
}
export function restAuthenticationLoginSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginSecretDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationLoginSecretCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationLoginSecretCollectMethod);
/** @internal */
export const RestAuthenticationLoginSecretCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationLoginSecretCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationLoginSecretCollectMethod);

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginSecretRestPaginationTypeRequestPageToJSON(
  restAuthenticationLoginSecretRestPaginationTypeRequestPage:
    RestAuthenticationLoginSecretRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestPaginationTypeRequestPage$outboundSchema
      .parse(restAuthenticationLoginSecretRestPaginationTypeRequestPage),
  );
}
export function restAuthenticationLoginSecretRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginSecretRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationLoginSecretRestPaginationTypeRequestOffset:
    RestAuthenticationLoginSecretRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$outboundSchema
      .parse(restAuthenticationLoginSecretRestPaginationTypeRequestOffset),
  );
}
export function restAuthenticationLoginSecretRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationLoginSecretRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink:
    RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationLoginSecretRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationLoginSecretRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationLoginSecretRestPaginationTypeResponseHeader:
    RestAuthenticationLoginSecretRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationLoginSecretRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationLoginSecretRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationLoginSecretRestPaginationTypeResponseBodyToJSON(
  restAuthenticationLoginSecretRestPaginationTypeResponseBody:
    RestAuthenticationLoginSecretRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestPaginationTypeResponseBody$outboundSchema
      .parse(restAuthenticationLoginSecretRestPaginationTypeResponseBody),
  );
}
export function restAuthenticationLoginSecretRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationLoginSecretRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginSecretRestPaginationTypeNoneToJSON(
  restAuthenticationLoginSecretRestPaginationTypeNone:
    RestAuthenticationLoginSecretRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationLoginSecretRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationLoginSecretRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginSecretRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretPaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretPaginationUnion$Outbound =
  | RestAuthenticationLoginSecretRestPaginationTypeNone$Outbound
  | RestAuthenticationLoginSecretRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationLoginSecretRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretPaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretPaginationUnionToJSON(
  restAuthenticationLoginSecretPaginationUnion:
    RestAuthenticationLoginSecretPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretPaginationUnion$outboundSchema.parse(
      restAuthenticationLoginSecretPaginationUnion,
    ),
  );
}
export function restAuthenticationLoginSecretPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginSecretPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginSecretRestRetryRulesTypeBackoffToJSON(
  restAuthenticationLoginSecretRestRetryRulesTypeBackoff:
    RestAuthenticationLoginSecretRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationLoginSecretRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationLoginSecretRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecretRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationLoginSecretRestRetryRulesTypeStaticToJSON(
  restAuthenticationLoginSecretRestRetryRulesTypeStatic:
    RestAuthenticationLoginSecretRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationLoginSecretRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationLoginSecretRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginSecretRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginSecretRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecretRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginSecretRestRetryRulesTypeNoneToJSON(
  restAuthenticationLoginSecretRestRetryRulesTypeNone:
    RestAuthenticationLoginSecretRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationLoginSecretRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationLoginSecretRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginSecretRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationLoginSecretRestRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    RestAuthenticationLoginSecretRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationLoginSecretRetryRules$Outbound =
  | RestAuthenticationLoginSecretRestRetryRulesTypeNone$Outbound
  | RestAuthenticationLoginSecretRestRetryRulesTypeStatic$Outbound
  | RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecretRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecretRetryRules
> = z.union([
  z.lazy(() =>
    RestAuthenticationLoginSecretRestRetryRulesTypeNone$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginSecretRestRetryRulesTypeStatic$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$outboundSchema
  ),
]);

export function restAuthenticationLoginSecretRetryRulesToJSON(
  restAuthenticationLoginSecretRetryRules:
    RestAuthenticationLoginSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretRetryRules$outboundSchema.parse(
      restAuthenticationLoginSecretRetryRules,
    ),
  );
}
export function restAuthenticationLoginSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationLoginSecretStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestAuthenticationLoginSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretStateTrackingToJSON(
  restAuthenticationLoginSecretStateTracking:
    RestAuthenticationLoginSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretStateTracking$outboundSchema.parse(
      restAuthenticationLoginSecretStateTracking,
    ),
  );
}
export function restAuthenticationLoginSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretScheduling$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecretScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationLoginSecretStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationLoginSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationLoginSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecretScheduling$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecretScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecretScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationLoginSecretStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationLoginSecretSchedulingToJSON(
  restAuthenticationLoginSecretScheduling:
    RestAuthenticationLoginSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretScheduling$outboundSchema.parse(
      restAuthenticationLoginSecretScheduling,
    ),
  );
}
export function restAuthenticationLoginSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecret$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("loginSecret"),
  loginUrl: types.string(),
  credentialsSecret: types.string(),
  loginBody: types.string(),
  getAuthTokenFromHeader: types.optional(types.boolean()),
  authHeaderKey: types.optional(types.string()),
  authHeaderExpr: types.string(),
  authRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationLoginSecretCollectMethod$inboundSchema,
  collectVerb: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginSecretRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestAuthenticationLoginSecretRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationLoginSecretScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationLoginSecret$Outbound = {
  authentication: "loginSecret";
  loginUrl: string;
  credentialsSecret: string;
  loginBody: string;
  getAuthTokenFromHeader?: boolean | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationLoginSecretRestPaginationTypeNone$Outbound
    | RestAuthenticationLoginSecretRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationLoginSecretRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginSecretRestRetryRulesTypeNone$Outbound
    | RestAuthenticationLoginSecretRestRetryRulesTypeStatic$Outbound
    | RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestAuthenticationLoginSecretScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecret$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecret
> = z.object({
  authentication: z.literal("loginSecret"),
  loginUrl: z.string(),
  credentialsSecret: z.string(),
  loginBody: z.string(),
  getAuthTokenFromHeader: z.boolean().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationLoginSecretCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretRestRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationLoginSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationLoginSecretToJSON(
  restAuthenticationLoginSecret: RestAuthenticationLoginSecret,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecret$outboundSchema.parse(
      restAuthenticationLoginSecret,
    ),
  );
}
export function restAuthenticationLoginSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationLoginRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeNone:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restAuthenticationLoginRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationLoginRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeList:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restAuthenticationLoginRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationLoginRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeJson:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restAuthenticationLoginRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationLoginRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restAuthenticationLoginRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restAuthenticationLoginRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationLoginDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationLoginRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationLoginDiscovery$Outbound =
  | (
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationLoginDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationLoginDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationLoginDiscoveryToJSON(
  restAuthenticationLoginDiscovery: RestAuthenticationLoginDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginDiscovery$outboundSchema.parse(
      restAuthenticationLoginDiscovery,
    ),
  );
}
export function restAuthenticationLoginDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationLoginCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationLoginCollectMethod);
/** @internal */
export const RestAuthenticationLoginCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationLoginCollectMethod
> = openEnums.outboundSchema(RestAuthenticationLoginCollectMethod);

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginRestPaginationTypeRequestPageToJSON(
  restAuthenticationLoginRestPaginationTypeRequestPage:
    RestAuthenticationLoginRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestPaginationTypeRequestPage$outboundSchema.parse(
      restAuthenticationLoginRestPaginationTypeRequestPage,
    ),
  );
}
export function restAuthenticationLoginRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationLoginRestPaginationTypeRequestOffset:
    RestAuthenticationLoginRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestPaginationTypeRequestOffset$outboundSchema.parse(
      restAuthenticationLoginRestPaginationTypeRequestOffset,
    ),
  );
}
export function restAuthenticationLoginRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationLoginRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationLoginRestPaginationTypeResponseHeaderLink:
    RestAuthenticationLoginRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationLoginRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationLoginRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationLoginRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationLoginRestPaginationTypeResponseHeader:
    RestAuthenticationLoginRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationLoginRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationLoginRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationLoginRestPaginationTypeResponseBodyToJSON(
  restAuthenticationLoginRestPaginationTypeResponseBody:
    RestAuthenticationLoginRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestPaginationTypeResponseBody$outboundSchema.parse(
      restAuthenticationLoginRestPaginationTypeResponseBody,
    ),
  );
}
export function restAuthenticationLoginRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationLoginRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginRestPaginationTypeNoneToJSON(
  restAuthenticationLoginRestPaginationTypeNone:
    RestAuthenticationLoginRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationLoginRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationLoginRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginPaginationUnion$inboundSchema: z.ZodType<
  RestAuthenticationLoginPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationLoginRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestAuthenticationLoginRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestAuthenticationLoginRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestAuthenticationLoginRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestAuthenticationLoginRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationLoginPaginationUnion$Outbound =
  | RestAuthenticationLoginRestPaginationTypeNone$Outbound
  | RestAuthenticationLoginRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationLoginRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationLoginRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationLoginRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationLoginPaginationUnion$outboundSchema: z.ZodType<
  RestAuthenticationLoginPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginPaginationUnion
> = z.union([
  z.lazy(() => RestAuthenticationLoginRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestAuthenticationLoginRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restAuthenticationLoginPaginationUnionToJSON(
  restAuthenticationLoginPaginationUnion:
    RestAuthenticationLoginPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationLoginPaginationUnion$outboundSchema.parse(
      restAuthenticationLoginPaginationUnion,
    ),
  );
}
export function restAuthenticationLoginPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationLoginRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginRestRetryRulesTypeBackoffToJSON(
  restAuthenticationLoginRestRetryRulesTypeBackoff:
    RestAuthenticationLoginRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationLoginRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationLoginRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestAuthenticationLoginRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationLoginRestRetryRulesTypeStaticToJSON(
  restAuthenticationLoginRestRetryRulesTypeStatic:
    RestAuthenticationLoginRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationLoginRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationLoginRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationLoginRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationLoginRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationLoginRestRetryRulesTypeNoneToJSON(
  restAuthenticationLoginRestRetryRulesTypeNone:
    RestAuthenticationLoginRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationLoginRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationLoginRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationLoginRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationLoginRestRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    RestAuthenticationLoginRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestAuthenticationLoginRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationLoginRetryRules$Outbound =
  | RestAuthenticationLoginRestRetryRulesTypeNone$Outbound
  | RestAuthenticationLoginRestRetryRulesTypeStatic$Outbound
  | RestAuthenticationLoginRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestAuthenticationLoginRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationLoginRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginRetryRules
> = z.union([
  z.lazy(() => RestAuthenticationLoginRestRetryRulesTypeNone$outboundSchema),
  z.lazy(() => RestAuthenticationLoginRestRetryRulesTypeStatic$outboundSchema),
  z.lazy(() => RestAuthenticationLoginRestRetryRulesTypeBackoff$outboundSchema),
]);

export function restAuthenticationLoginRetryRulesToJSON(
  restAuthenticationLoginRetryRules: RestAuthenticationLoginRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginRetryRules$outboundSchema.parse(
      restAuthenticationLoginRetryRules,
    ),
  );
}
export function restAuthenticationLoginRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationLoginStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestAuthenticationLoginStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationLoginStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationLoginStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationLoginStateTrackingToJSON(
  restAuthenticationLoginStateTracking: RestAuthenticationLoginStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginStateTracking$outboundSchema.parse(
      restAuthenticationLoginStateTracking,
    ),
  );
}
export function restAuthenticationLoginStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginScheduling$inboundSchema: z.ZodType<
  RestAuthenticationLoginScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationLoginStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationLoginScheduling$Outbound = {
  stateTracking?: RestAuthenticationLoginStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationLoginScheduling$outboundSchema: z.ZodType<
  RestAuthenticationLoginScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationLoginStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationLoginSchedulingToJSON(
  restAuthenticationLoginScheduling: RestAuthenticationLoginScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginScheduling$outboundSchema.parse(
      restAuthenticationLoginScheduling,
    ),
  );
}
export function restAuthenticationLoginSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLogin$inboundSchema: z.ZodType<
  RestAuthenticationLogin,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("login"),
  loginUrl: types.string(),
  username: types.string(),
  password: types.string(),
  loginBody: types.string(),
  getAuthTokenFromHeader: types.optional(types.boolean()),
  authHeaderKey: types.optional(types.string()),
  authHeaderExpr: types.string(),
  authRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationLoginCollectMethod$inboundSchema,
  collectVerb: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationLoginRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationLoginRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationLoginRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationLoginRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestAuthenticationLoginRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestAuthenticationLoginRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationLoginScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationLogin$Outbound = {
  authentication: "login";
  loginUrl: string;
  username: string;
  password: string;
  loginBody: string;
  getAuthTokenFromHeader?: boolean | undefined;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationLoginRestPaginationTypeNone$Outbound
    | RestAuthenticationLoginRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationLoginRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationLoginRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationLoginRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginRestRetryRulesTypeNone$Outbound
    | RestAuthenticationLoginRestRetryRulesTypeStatic$Outbound
    | RestAuthenticationLoginRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestAuthenticationLoginScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationLogin$outboundSchema: z.ZodType<
  RestAuthenticationLogin$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLogin
> = z.object({
  authentication: z.literal("login"),
  loginUrl: z.string(),
  username: z.string(),
  password: z.string(),
  loginBody: z.string(),
  getAuthTokenFromHeader: z.boolean().optional(),
  authHeaderKey: z.string().optional(),
  authHeaderExpr: z.string(),
  authRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationLoginCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestAuthenticationLoginRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationLoginRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestAuthenticationLoginRestRetryRulesTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationLoginRestRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() => RestAuthenticationLoginScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationLoginToJSON(
  restAuthenticationLogin: RestAuthenticationLogin,
): string {
  return JSON.stringify(
    RestAuthenticationLogin$outboundSchema.parse(restAuthenticationLogin),
  );
}
export function restAuthenticationLoginFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLogin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLogin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLogin' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(restAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeList:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(restAuthenticationBasicSecretRestDiscoveryDiscoverTypeList),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(restAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp),
  );
}
export function restAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationBasicSecretDiscovery$Outbound =
  | (
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationBasicSecretDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationBasicSecretDiscoveryToJSON(
  restAuthenticationBasicSecretDiscovery:
    RestAuthenticationBasicSecretDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretDiscovery$outboundSchema.parse(
      restAuthenticationBasicSecretDiscovery,
    ),
  );
}
export function restAuthenticationBasicSecretDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicSecretDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretCollectMethod$inboundSchema:
  z.ZodType<RestAuthenticationBasicSecretCollectMethod, z.ZodTypeDef, unknown> =
    openEnums.inboundSchema(RestAuthenticationBasicSecretCollectMethod);
/** @internal */
export const RestAuthenticationBasicSecretCollectMethod$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, RestAuthenticationBasicSecretCollectMethod> =
    openEnums.outboundSchema(RestAuthenticationBasicSecretCollectMethod);

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationBasicSecretRestPaginationTypeRequestPageToJSON(
  restAuthenticationBasicSecretRestPaginationTypeRequestPage:
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeRequestPage$outboundSchema
      .parse(restAuthenticationBasicSecretRestPaginationTypeRequestPage),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationBasicSecretRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationBasicSecretRestPaginationTypeRequestOffset:
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$outboundSchema
      .parse(restAuthenticationBasicSecretRestPaginationTypeRequestOffset),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationBasicSecretRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink:
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationBasicSecretRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationBasicSecretRestPaginationTypeResponseHeader:
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationBasicSecretRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationBasicSecretRestPaginationTypeResponseBodyToJSON(
  restAuthenticationBasicSecretRestPaginationTypeResponseBody:
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeResponseBody$outboundSchema
      .parse(restAuthenticationBasicSecretRestPaginationTypeResponseBody),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationBasicSecretRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationBasicSecretRestPaginationTypeNoneToJSON(
  restAuthenticationBasicSecretRestPaginationTypeNone:
    RestAuthenticationBasicSecretRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationBasicSecretRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationBasicSecretRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretPaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretPaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationBasicSecretPaginationUnion$Outbound =
  | RestAuthenticationBasicSecretRestPaginationTypeNone$Outbound
  | RestAuthenticationBasicSecretRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationBasicSecretRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationBasicSecretPaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretPaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretPaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationBasicSecretPaginationUnionToJSON(
  restAuthenticationBasicSecretPaginationUnion:
    RestAuthenticationBasicSecretPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretPaginationUnion$outboundSchema.parse(
      restAuthenticationBasicSecretPaginationUnion,
    ),
  );
}
export function restAuthenticationBasicSecretPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretPaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretPaginationUnion$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationBasicSecretRestRetryRulesTypeBackoffToJSON(
  restAuthenticationBasicSecretRestRetryRulesTypeBackoff:
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationBasicSecretRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationBasicSecretRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecretRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationBasicSecretRestRetryRulesTypeStaticToJSON(
  restAuthenticationBasicSecretRestRetryRulesTypeStatic:
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationBasicSecretRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationBasicSecretRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicSecretRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationBasicSecretRestRetryRulesTypeNoneToJSON(
  restAuthenticationBasicSecretRestRetryRulesTypeNone:
    RestAuthenticationBasicSecretRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationBasicSecretRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationBasicSecretRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationBasicSecretRestRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationBasicSecretRetryRules$Outbound =
  | RestAuthenticationBasicSecretRestRetryRulesTypeNone$Outbound
  | RestAuthenticationBasicSecretRestRetryRulesTypeStatic$Outbound
  | RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestAuthenticationBasicSecretRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretRetryRules
> = z.union([
  z.lazy(() =>
    RestAuthenticationBasicSecretRestRetryRulesTypeNone$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicSecretRestRetryRulesTypeStatic$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$outboundSchema
  ),
]);

export function restAuthenticationBasicSecretRetryRulesToJSON(
  restAuthenticationBasicSecretRetryRules:
    RestAuthenticationBasicSecretRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretRetryRules$outboundSchema.parse(
      restAuthenticationBasicSecretRetryRules,
    ),
  );
}
export function restAuthenticationBasicSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretStateTracking$inboundSchema:
  z.ZodType<RestAuthenticationBasicSecretStateTracking, z.ZodTypeDef, unknown> =
    z.object({
      enabled: types.optional(types.boolean()),
    });
/** @internal */
export type RestAuthenticationBasicSecretStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicSecretStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicSecretStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationBasicSecretStateTrackingToJSON(
  restAuthenticationBasicSecretStateTracking:
    RestAuthenticationBasicSecretStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretStateTracking$outboundSchema.parse(
      restAuthenticationBasicSecretStateTracking,
    ),
  );
}
export function restAuthenticationBasicSecretStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretStateTracking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecretScheduling$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecretScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationBasicSecretStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationBasicSecretScheduling$Outbound = {
  stateTracking?:
    | RestAuthenticationBasicSecretStateTracking$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecretScheduling$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecretScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecretScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicSecretStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSecretSchedulingToJSON(
  restAuthenticationBasicSecretScheduling:
    RestAuthenticationBasicSecretScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecretScheduling$outboundSchema.parse(
      restAuthenticationBasicSecretScheduling,
    ),
  );
}
export function restAuthenticationBasicSecretSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicSecretScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicSecretScheduling$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicSecretScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicSecret$inboundSchema: z.ZodType<
  RestAuthenticationBasicSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("basicSecret"),
  credentialsSecret: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationBasicSecretCollectMethod$inboundSchema,
  collectVerb: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationBasicSecretScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationBasicSecret$Outbound = {
  authentication: "basicSecret";
  credentialsSecret: string;
  discovery?:
    | (
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationBasicSecretRestPaginationTypeNone$Outbound
    | RestAuthenticationBasicSecretRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationBasicSecretRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationBasicSecretRestRetryRulesTypeNone$Outbound
    | RestAuthenticationBasicSecretRestRetryRulesTypeStatic$Outbound
    | RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestAuthenticationBasicSecretScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasicSecret$outboundSchema: z.ZodType<
  RestAuthenticationBasicSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicSecret
> = z.object({
  authentication: z.literal("basicSecret"),
  credentialsSecret: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicSecretCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicSecretRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() =>
    RestAuthenticationBasicSecretScheduling$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSecretToJSON(
  restAuthenticationBasicSecret: RestAuthenticationBasicSecret,
): string {
  return JSON.stringify(
    RestAuthenticationBasicSecret$outboundSchema.parse(
      restAuthenticationBasicSecret,
    ),
  );
}
export function restAuthenticationBasicSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeNone:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restAuthenticationBasicRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeList:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restAuthenticationBasicRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeJson:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restAuthenticationBasicRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationBasicRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$outboundSchema.parse(
      restAuthenticationBasicRestDiscoveryDiscoverTypeHttp,
    ),
  );
}
export function restAuthenticationBasicRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicDiscovery$inboundSchema: z.ZodType<
  RestAuthenticationBasicDiscovery,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("discoverType", {
  http: discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  }).and(z.object({ discoverType: z.literal("http") })),
  json: z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$inboundSchema
  ),
  list: z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList$inboundSchema
  ),
  none: z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationBasicDiscovery$Outbound =
  | (
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationBasicDiscovery$outboundSchema: z.ZodType<
  RestAuthenticationBasicDiscovery$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicDiscovery
> = z.union([
  z.union([
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]).and(z.object({ discoverType: z.literal("http") })),
  z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeList$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$outboundSchema
  ),
]);

export function restAuthenticationBasicDiscoveryToJSON(
  restAuthenticationBasicDiscovery: RestAuthenticationBasicDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationBasicDiscovery$outboundSchema.parse(
      restAuthenticationBasicDiscovery,
    ),
  );
}
export function restAuthenticationBasicDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicDiscovery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicDiscovery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicCollectMethod$inboundSchema: z.ZodType<
  RestAuthenticationBasicCollectMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RestAuthenticationBasicCollectMethod);
/** @internal */
export const RestAuthenticationBasicCollectMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RestAuthenticationBasicCollectMethod
> = openEnums.outboundSchema(RestAuthenticationBasicCollectMethod);

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeRequestPage$Outbound = {
  type: "request_page";
  pageField: string;
  page?: number | undefined;
  sizeField: string;
  size: number;
  totalPageField?: string | undefined;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationBasicRestPaginationTypeRequestPageToJSON(
  restAuthenticationBasicRestPaginationTypeRequestPage:
    RestAuthenticationBasicRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeRequestPage$outboundSchema.parse(
      restAuthenticationBasicRestPaginationTypeRequestPage,
    ),
  );
}
export function restAuthenticationBasicRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeRequestPage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeRequestOffset$Outbound = {
  type: "request_offset";
  offsetField: string;
  offset?: number | undefined;
  limitField: string;
  limit: number;
  totalRecordField?: string | undefined;
  maxPages: number;
  zeroIndexed: boolean;
};

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationBasicRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationBasicRestPaginationTypeRequestOffset:
    RestAuthenticationBasicRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeRequestOffset$outboundSchema.parse(
      restAuthenticationBasicRestPaginationTypeRequestOffset,
    ),
  );
}
export function restAuthenticationBasicRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationBasicRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationBasicRestPaginationTypeResponseHeaderLink:
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(restAuthenticationBasicRestPaginationTypeResponseHeaderLink),
  );
}
export function restAuthenticationBasicRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeResponseHeader$Outbound = {
  type: "response_header";
  attribute: Array<string>;
  maxPages: number;
};

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationBasicRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationBasicRestPaginationTypeResponseHeader:
    RestAuthenticationBasicRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeResponseHeader$outboundSchema
      .parse(restAuthenticationBasicRestPaginationTypeResponseHeader),
  );
}
export function restAuthenticationBasicRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeResponseBody$Outbound = {
  type: "response_body";
  attribute: Array<string>;
  maxPages: number;
  lastPageExpr?: string | undefined;
};

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationBasicRestPaginationTypeResponseBodyToJSON(
  restAuthenticationBasicRestPaginationTypeResponseBody:
    RestAuthenticationBasicRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeResponseBody$outboundSchema.parse(
      restAuthenticationBasicRestPaginationTypeResponseBody,
    ),
  );
}
export function restAuthenticationBasicRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationBasicRestPaginationTypeNone$Outbound = {
  type: "none";
};

/** @internal */
export const RestAuthenticationBasicRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationBasicRestPaginationTypeNoneToJSON(
  restAuthenticationBasicRestPaginationTypeNone:
    RestAuthenticationBasicRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestPaginationTypeNone$outboundSchema.parse(
      restAuthenticationBasicRestPaginationTypeNone,
    ),
  );
}
export function restAuthenticationBasicRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestPaginationTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicPaginationUnion$inboundSchema: z.ZodType<
  RestAuthenticationBasicPaginationUnion,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeNone$inboundSchema
  ),
  response_body: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseBody$inboundSchema
  ),
  response_header: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseHeader$inboundSchema
  ),
  response_header_link: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$inboundSchema
  ),
  request_offset: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeRequestOffset$inboundSchema
  ),
  request_page: z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeRequestPage$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationBasicPaginationUnion$Outbound =
  | RestAuthenticationBasicRestPaginationTypeNone$Outbound
  | RestAuthenticationBasicRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationBasicRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationBasicRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationBasicRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationBasicPaginationUnion$outboundSchema: z.ZodType<
  RestAuthenticationBasicPaginationUnion$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicPaginationUnion
> = z.union([
  z.lazy(() => RestAuthenticationBasicRestPaginationTypeNone$outboundSchema),
  z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseBody$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseHeader$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeRequestOffset$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationBasicRestPaginationTypeRequestPage$outboundSchema
  ),
]);

export function restAuthenticationBasicPaginationUnionToJSON(
  restAuthenticationBasicPaginationUnion:
    RestAuthenticationBasicPaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationBasicPaginationUnion$outboundSchema.parse(
      restAuthenticationBasicPaginationUnion,
    ),
  );
}
export function restAuthenticationBasicPaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicPaginationUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicPaginationUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicPaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicRestRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationBasicRestRetryRulesTypeBackoffToJSON(
  restAuthenticationBasicRestRetryRulesTypeBackoff:
    RestAuthenticationBasicRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestRetryRulesTypeBackoff$outboundSchema.parse(
      restAuthenticationBasicRestRetryRulesTypeBackoff,
    ),
  );
}
export function restAuthenticationBasicRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicRestRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
  });

export function restAuthenticationBasicRestRetryRulesTypeStaticToJSON(
  restAuthenticationBasicRestRetryRulesTypeStatic:
    RestAuthenticationBasicRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestRetryRulesTypeStatic$outboundSchema.parse(
      restAuthenticationBasicRestRetryRulesTypeStatic,
    ),
  );
}
export function restAuthenticationBasicRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    maxIntervalMs: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type RestAuthenticationBasicRestRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  maxIntervalMs?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RestAuthenticationBasicRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationBasicRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationBasicRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    maxIntervalMs: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function restAuthenticationBasicRestRetryRulesTypeNoneToJSON(
  restAuthenticationBasicRestRetryRulesTypeNone:
    RestAuthenticationBasicRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRestRetryRulesTypeNone$outboundSchema.parse(
      restAuthenticationBasicRestRetryRulesTypeNone,
    ),
  );
}
export function restAuthenticationBasicRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationBasicRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicRestRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationBasicRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicRetryRules$inboundSchema: z.ZodType<
  RestAuthenticationBasicRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    RestAuthenticationBasicRestRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    RestAuthenticationBasicRestRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    RestAuthenticationBasicRestRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type RestAuthenticationBasicRetryRules$Outbound =
  | RestAuthenticationBasicRestRetryRulesTypeNone$Outbound
  | RestAuthenticationBasicRestRetryRulesTypeStatic$Outbound
  | RestAuthenticationBasicRestRetryRulesTypeBackoff$Outbound;

/** @internal */
export const RestAuthenticationBasicRetryRules$outboundSchema: z.ZodType<
  RestAuthenticationBasicRetryRules$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicRetryRules
> = z.union([
  z.lazy(() => RestAuthenticationBasicRestRetryRulesTypeNone$outboundSchema),
  z.lazy(() => RestAuthenticationBasicRestRetryRulesTypeStatic$outboundSchema),
  z.lazy(() => RestAuthenticationBasicRestRetryRulesTypeBackoff$outboundSchema),
]);

export function restAuthenticationBasicRetryRulesToJSON(
  restAuthenticationBasicRetryRules: RestAuthenticationBasicRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationBasicRetryRules$outboundSchema.parse(
      restAuthenticationBasicRetryRules,
    ),
  );
}
export function restAuthenticationBasicRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicStateTracking$inboundSchema: z.ZodType<
  RestAuthenticationBasicStateTracking,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RestAuthenticationBasicStateTracking$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RestAuthenticationBasicStateTracking$outboundSchema: z.ZodType<
  RestAuthenticationBasicStateTracking$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicStateTracking
> = z.object({
  enabled: z.boolean().optional(),
});

export function restAuthenticationBasicStateTrackingToJSON(
  restAuthenticationBasicStateTracking: RestAuthenticationBasicStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationBasicStateTracking$outboundSchema.parse(
      restAuthenticationBasicStateTracking,
    ),
  );
}
export function restAuthenticationBasicStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicStateTracking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationBasicStateTracking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasicScheduling$inboundSchema: z.ZodType<
  RestAuthenticationBasicScheduling,
  z.ZodTypeDef,
  unknown
> = z.object({
  stateTracking: types.optional(
    z.lazy(() => RestAuthenticationBasicStateTracking$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationBasicScheduling$Outbound = {
  stateTracking?: RestAuthenticationBasicStateTracking$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasicScheduling$outboundSchema: z.ZodType<
  RestAuthenticationBasicScheduling$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasicScheduling
> = z.object({
  stateTracking: z.lazy(() =>
    RestAuthenticationBasicStateTracking$outboundSchema
  ).optional(),
});

export function restAuthenticationBasicSchedulingToJSON(
  restAuthenticationBasicScheduling: RestAuthenticationBasicScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationBasicScheduling$outboundSchema.parse(
      restAuthenticationBasicScheduling,
    ),
  );
}
export function restAuthenticationBasicSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasicScheduling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasicScheduling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasicScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationBasic$inboundSchema: z.ZodType<
  RestAuthenticationBasic,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("basic"),
  username: types.string(),
  password: types.string(),
  discovery: types.optional(discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  })),
  collectUrl: types.string(),
  collectMethod: RestAuthenticationBasicCollectMethod$inboundSchema,
  collectVerb: types.optional(z.any()),
  collectRequestParams: types.optional(z.any()),
  collectBody: types.optional(z.any()),
  collectRequestHeaders: types.optional(
    z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
  ),
  pagination: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeRequestPage$inboundSchema
    ),
  })),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  decodeUrl: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  captureHeaders: types.optional(types.boolean()),
  stopOnEmptyResults: types.optional(types.boolean()),
  safeHeaders: types.optional(z.array(types.string())),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeBackoff$inboundSchema
    ),
  })),
  __scheduling: types.optional(
    z.lazy(() => RestAuthenticationBasicScheduling$inboundSchema),
  ),
});
/** @internal */
export type RestAuthenticationBasic$Outbound = {
  authentication: "basic";
  username: string;
  password: string;
  discovery?:
    | (
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectVerb?: any | undefined;
  collectRequestParams?: any | undefined;
  collectBody?: any | undefined;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationBasicRestPaginationTypeNone$Outbound
    | RestAuthenticationBasicRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationBasicRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationBasicRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationBasicRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationBasicRestRetryRulesTypeNone$Outbound
    | RestAuthenticationBasicRestRetryRulesTypeStatic$Outbound
    | RestAuthenticationBasicRestRetryRulesTypeBackoff$Outbound
    | undefined;
  __scheduling?: RestAuthenticationBasicScheduling$Outbound | undefined;
};

/** @internal */
export const RestAuthenticationBasic$outboundSchema: z.ZodType<
  RestAuthenticationBasic$Outbound,
  z.ZodTypeDef,
  RestAuthenticationBasic
> = z.object({
  authentication: z.literal("basic"),
  username: z.string(),
  password: z.string(),
  discovery: z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationBasicRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]).optional(),
  collectUrl: z.string(),
  collectMethod: RestAuthenticationBasicCollectMethod$outboundSchema,
  collectVerb: z.any().optional(),
  collectRequestParams: z.any().optional(),
  collectBody: z.any().optional(),
  collectRequestHeaders: z.array(
    ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
  ).optional(),
  pagination: z.union([
    z.lazy(() => RestAuthenticationBasicRestPaginationTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestPaginationTypeRequestPage$outboundSchema
    ),
  ]).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  decodeUrl: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  captureHeaders: z.boolean().optional(),
  stopOnEmptyResults: z.boolean().optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.union([
    z.lazy(() => RestAuthenticationBasicRestRetryRulesTypeNone$outboundSchema),
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationBasicRestRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
  __scheduling: z.lazy(() => RestAuthenticationBasicScheduling$outboundSchema)
    .optional(),
});

export function restAuthenticationBasicToJSON(
  restAuthenticationBasic: RestAuthenticationBasic,
): string {
  return JSON.stringify(
    RestAuthenticationBasic$outboundSchema.parse(restAuthenticationBasic),
  );
}
export function restAuthenticationBasicFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationBasic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationBasic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationBasic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound = {
  discoverType: "none";
};

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeNone:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$outboundSchema.parse(
      restAuthenticationNoneRestDiscoveryDiscoverTypeNone,
    ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound = {
  discoverType: "list";
  itemList: Array<string>;
};

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeList:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeList$outboundSchema.parse(
      restAuthenticationNoneRestDiscoveryDiscoverTypeList,
    ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeList$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound = {
  discoverType: "json";
  manualDiscoverResult: string;
  discoverDataField?: string | undefined;
};

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeJson:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$outboundSchema.parse(
      restAuthenticationNoneRestDiscoveryDiscoverTypeJson,
    ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.optional(z.any()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverRequestParams: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverRequestParams?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.any().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverRequestParams: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(z.any()),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverVerb: types.optional(z.any()),
    discoverBody: types.optional(z.any()),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.optional(z.any()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?: any | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverVerb?: any | undefined;
    discoverBody?: any | undefined;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat?: any | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.any().optional(),
    discoverType:
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverVerb: z.any().optional(),
    discoverBody: z.any().optional(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.any().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationNoneRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}
