/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  DataCompressionFormatOptionsPersistence,
  DataCompressionFormatOptionsPersistence$inboundSchema,
  DataCompressionFormatOptionsPersistence$outboundSchema,
} from "./datacompressionformatoptionspersistence.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeConnectionsOptional,
  ItemsTypeConnectionsOptional$inboundSchema,
  ItemsTypeConnectionsOptional$Outbound,
  ItemsTypeConnectionsOptional$outboundSchema,
} from "./itemstypeconnectionsoptional.js";
import {
  ItemsTypeNotificationMetadata,
  ItemsTypeNotificationMetadata$inboundSchema,
  ItemsTypeNotificationMetadata$Outbound,
  ItemsTypeNotificationMetadata$outboundSchema,
} from "./itemstypenotificationmetadata.js";
import {
  ModeOptionsHost,
  ModeOptionsHost$inboundSchema,
  ModeOptionsHost$outboundSchema,
} from "./modeoptionshost.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  ProcessType,
  ProcessType$inboundSchema,
  ProcessType$Outbound,
  ProcessType$outboundSchema,
} from "./processtype.js";

/**
 * Select the level of detail for system metrics
 */
export const InputSystemMetricsSystemMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for system metrics
 */
export type InputSystemMetricsSystemMode = OpenEnum<
  typeof InputSystemMetricsSystemMode
>;

export type InputSystemMetricsSystem = {
  /**
   * Select the level of detail for system metrics
   */
  mode?: InputSystemMetricsSystemMode | undefined;
  /**
   * Generate metrics for the numbers of processes in various states
   */
  processes?: boolean | undefined;
};

/**
 * Select the level of detail for CPU metrics
 */
export const InputSystemMetricsCpuMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for CPU metrics
 */
export type InputSystemMetricsCpuMode = OpenEnum<
  typeof InputSystemMetricsCpuMode
>;

export type InputSystemMetricsCpu = {
  /**
   * Select the level of detail for CPU metrics
   */
  mode?: InputSystemMetricsCpuMode | undefined;
  /**
   * Generate metrics for each CPU
   */
  perCpu?: boolean | undefined;
  /**
   * Generate metrics for all CPU states
   */
  detail?: boolean | undefined;
  /**
   * Generate raw, monotonic CPU time counters
   */
  time?: boolean | undefined;
};

/**
 * Select the level of detail for memory metrics
 */
export const InputSystemMetricsMemoryMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for memory metrics
 */
export type InputSystemMetricsMemoryMode = OpenEnum<
  typeof InputSystemMetricsMemoryMode
>;

export type InputSystemMetricsMemory = {
  /**
   * Select the level of detail for memory metrics
   */
  mode?: InputSystemMetricsMemoryMode | undefined;
  /**
   * Generate metrics for all memory states
   */
  detail?: boolean | undefined;
};

/**
 * Select the level of detail for network metrics
 */
export const InputSystemMetricsNetworkMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for network metrics
 */
export type InputSystemMetricsNetworkMode = OpenEnum<
  typeof InputSystemMetricsNetworkMode
>;

export type InputSystemMetricsNetwork = {
  /**
   * Select the level of detail for network metrics
   */
  mode?: InputSystemMetricsNetworkMode | undefined;
  /**
   * Generate full network metrics
   */
  detail?: boolean | undefined;
  /**
   * Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
   */
  protocols?: boolean | undefined;
  /**
   * Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty.
   */
  devices?: Array<string> | undefined;
  /**
   * Generate separate metrics for each interface
   */
  perInterface?: boolean | undefined;
};

/**
 * Select the level of detail for disk metrics
 */
export const InputSystemMetricsDiskMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for disk metrics
 */
export type InputSystemMetricsDiskMode = OpenEnum<
  typeof InputSystemMetricsDiskMode
>;

export type InputSystemMetricsDisk = {
  /**
   * Select the level of detail for disk metrics
   */
  mode?: InputSystemMetricsDiskMode | undefined;
  /**
   * Generate full disk metrics
   */
  detail?: boolean | undefined;
  /**
   * Generate filesystem inode metrics
   */
  inodes?: boolean | undefined;
  /**
   * Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty.
   */
  devices?: Array<string> | undefined;
  /**
   * Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty.
   */
  mountpoints?: Array<string> | undefined;
  /**
   * Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty.
   */
  fstypes?: Array<string> | undefined;
  /**
   * Generate separate metrics for each device
   */
  perDevice?: boolean | undefined;
};

export type InputSystemMetricsCustom = {
  system?: InputSystemMetricsSystem | undefined;
  cpu?: InputSystemMetricsCpu | undefined;
  memory?: InputSystemMetricsMemory | undefined;
  network?: InputSystemMetricsNetwork | undefined;
  disk?: InputSystemMetricsDisk | undefined;
};

export type InputSystemMetricsHost = {
  /**
   * Select level of detail for host metrics
   */
  mode?: ModeOptionsHost | undefined;
  custom?: InputSystemMetricsCustom | undefined;
};

/**
 * Select the level of detail for container metrics
 */
export const ContainerMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for container metrics
 */
export type ContainerMode = OpenEnum<typeof ContainerMode>;

export type InputSystemMetricsFilter = {
  expr: string;
};

export type Container = {
  /**
   * Select the level of detail for container metrics
   */
  mode?: ContainerMode | undefined;
  /**
   * Full paths for Docker's UNIX-domain socket
   */
  dockerSocket?: Array<string> | undefined;
  /**
   * Timeout, in seconds, for the Docker API
   */
  dockerTimeout?: number | undefined;
  /**
   * Containers matching any of these will be included. All are included if no filters are added.
   */
  filters?: Array<InputSystemMetricsFilter> | undefined;
  /**
   * Include stopped and paused containers
   */
  allContainers?: boolean | undefined;
  /**
   * Generate separate metrics for each device
   */
  perDevice?: boolean | undefined;
  /**
   * Generate full container metrics
   */
  detail?: boolean | undefined;
};

export type InputSystemMetricsPersistence = {
  /**
   * Spool metrics to disk for Cribl Edge and Search
   */
  enable?: boolean | undefined;
  /**
   * Time span for each file bucket
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
   */
  maxDataTime?: string | undefined;
  compress?: DataCompressionFormatOptionsPersistence | undefined;
  /**
   * Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics
   */
  destPath?: string | undefined;
};

export type InputSystemMetrics = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: "system_metrics";
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnectionsOptional> | undefined;
  pq?: PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputSystemMetricsHost | undefined;
  process?: ProcessType | undefined;
  container?: Container | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputSystemMetricsPersistence | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemMetricsSystemMode$inboundSchema: z.ZodType<
  InputSystemMetricsSystemMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputSystemMetricsSystemMode);
/** @internal */
export const InputSystemMetricsSystemMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsSystemMode
> = openEnums.outboundSchema(InputSystemMetricsSystemMode);

/** @internal */
export const InputSystemMetricsSystem$inboundSchema: z.ZodType<
  InputSystemMetricsSystem,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: types.optional(InputSystemMetricsSystemMode$inboundSchema),
  processes: types.optional(types.boolean()),
});
/** @internal */
export type InputSystemMetricsSystem$Outbound = {
  mode?: string | undefined;
  processes?: boolean | undefined;
};

/** @internal */
export const InputSystemMetricsSystem$outboundSchema: z.ZodType<
  InputSystemMetricsSystem$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsSystem
> = z.object({
  mode: InputSystemMetricsSystemMode$outboundSchema.optional(),
  processes: z.boolean().optional(),
});

export function inputSystemMetricsSystemToJSON(
  inputSystemMetricsSystem: InputSystemMetricsSystem,
): string {
  return JSON.stringify(
    InputSystemMetricsSystem$outboundSchema.parse(inputSystemMetricsSystem),
  );
}
export function inputSystemMetricsSystemFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsSystem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsSystem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsSystem' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsCpuMode$inboundSchema: z.ZodType<
  InputSystemMetricsCpuMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputSystemMetricsCpuMode);
/** @internal */
export const InputSystemMetricsCpuMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsCpuMode
> = openEnums.outboundSchema(InputSystemMetricsCpuMode);

/** @internal */
export const InputSystemMetricsCpu$inboundSchema: z.ZodType<
  InputSystemMetricsCpu,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: types.optional(InputSystemMetricsCpuMode$inboundSchema),
  perCpu: types.optional(types.boolean()),
  detail: types.optional(types.boolean()),
  time: types.optional(types.boolean()),
});
/** @internal */
export type InputSystemMetricsCpu$Outbound = {
  mode?: string | undefined;
  perCpu?: boolean | undefined;
  detail?: boolean | undefined;
  time?: boolean | undefined;
};

/** @internal */
export const InputSystemMetricsCpu$outboundSchema: z.ZodType<
  InputSystemMetricsCpu$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsCpu
> = z.object({
  mode: InputSystemMetricsCpuMode$outboundSchema.optional(),
  perCpu: z.boolean().optional(),
  detail: z.boolean().optional(),
  time: z.boolean().optional(),
});

export function inputSystemMetricsCpuToJSON(
  inputSystemMetricsCpu: InputSystemMetricsCpu,
): string {
  return JSON.stringify(
    InputSystemMetricsCpu$outboundSchema.parse(inputSystemMetricsCpu),
  );
}
export function inputSystemMetricsCpuFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsCpu, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsCpu$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsCpu' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsMemoryMode$inboundSchema: z.ZodType<
  InputSystemMetricsMemoryMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputSystemMetricsMemoryMode);
/** @internal */
export const InputSystemMetricsMemoryMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsMemoryMode
> = openEnums.outboundSchema(InputSystemMetricsMemoryMode);

/** @internal */
export const InputSystemMetricsMemory$inboundSchema: z.ZodType<
  InputSystemMetricsMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: types.optional(InputSystemMetricsMemoryMode$inboundSchema),
  detail: types.optional(types.boolean()),
});
/** @internal */
export type InputSystemMetricsMemory$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
};

/** @internal */
export const InputSystemMetricsMemory$outboundSchema: z.ZodType<
  InputSystemMetricsMemory$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsMemory
> = z.object({
  mode: InputSystemMetricsMemoryMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
});

export function inputSystemMetricsMemoryToJSON(
  inputSystemMetricsMemory: InputSystemMetricsMemory,
): string {
  return JSON.stringify(
    InputSystemMetricsMemory$outboundSchema.parse(inputSystemMetricsMemory),
  );
}
export function inputSystemMetricsMemoryFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsMemory' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsNetworkMode$inboundSchema: z.ZodType<
  InputSystemMetricsNetworkMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputSystemMetricsNetworkMode);
/** @internal */
export const InputSystemMetricsNetworkMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsNetworkMode
> = openEnums.outboundSchema(InputSystemMetricsNetworkMode);

/** @internal */
export const InputSystemMetricsNetwork$inboundSchema: z.ZodType<
  InputSystemMetricsNetwork,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: types.optional(InputSystemMetricsNetworkMode$inboundSchema),
  detail: types.optional(types.boolean()),
  protocols: types.optional(types.boolean()),
  devices: types.optional(z.array(types.string())),
  perInterface: types.optional(types.boolean()),
});
/** @internal */
export type InputSystemMetricsNetwork$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
  protocols?: boolean | undefined;
  devices?: Array<string> | undefined;
  perInterface?: boolean | undefined;
};

/** @internal */
export const InputSystemMetricsNetwork$outboundSchema: z.ZodType<
  InputSystemMetricsNetwork$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsNetwork
> = z.object({
  mode: InputSystemMetricsNetworkMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
  protocols: z.boolean().optional(),
  devices: z.array(z.string()).optional(),
  perInterface: z.boolean().optional(),
});

export function inputSystemMetricsNetworkToJSON(
  inputSystemMetricsNetwork: InputSystemMetricsNetwork,
): string {
  return JSON.stringify(
    InputSystemMetricsNetwork$outboundSchema.parse(inputSystemMetricsNetwork),
  );
}
export function inputSystemMetricsNetworkFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsNetwork, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsNetwork$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsNetwork' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsDiskMode$inboundSchema: z.ZodType<
  InputSystemMetricsDiskMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputSystemMetricsDiskMode);
/** @internal */
export const InputSystemMetricsDiskMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsDiskMode
> = openEnums.outboundSchema(InputSystemMetricsDiskMode);

/** @internal */
export const InputSystemMetricsDisk$inboundSchema: z.ZodType<
  InputSystemMetricsDisk,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: types.optional(InputSystemMetricsDiskMode$inboundSchema),
  detail: types.optional(types.boolean()),
  inodes: types.optional(types.boolean()),
  devices: types.optional(z.array(types.string())),
  mountpoints: types.optional(z.array(types.string())),
  fstypes: types.optional(z.array(types.string())),
  perDevice: types.optional(types.boolean()),
});
/** @internal */
export type InputSystemMetricsDisk$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
  inodes?: boolean | undefined;
  devices?: Array<string> | undefined;
  mountpoints?: Array<string> | undefined;
  fstypes?: Array<string> | undefined;
  perDevice?: boolean | undefined;
};

/** @internal */
export const InputSystemMetricsDisk$outboundSchema: z.ZodType<
  InputSystemMetricsDisk$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsDisk
> = z.object({
  mode: InputSystemMetricsDiskMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
  inodes: z.boolean().optional(),
  devices: z.array(z.string()).optional(),
  mountpoints: z.array(z.string()).optional(),
  fstypes: z.array(z.string()).optional(),
  perDevice: z.boolean().optional(),
});

export function inputSystemMetricsDiskToJSON(
  inputSystemMetricsDisk: InputSystemMetricsDisk,
): string {
  return JSON.stringify(
    InputSystemMetricsDisk$outboundSchema.parse(inputSystemMetricsDisk),
  );
}
export function inputSystemMetricsDiskFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsDisk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsDisk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsDisk' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsCustom$inboundSchema: z.ZodType<
  InputSystemMetricsCustom,
  z.ZodTypeDef,
  unknown
> = z.object({
  system: types.optional(z.lazy(() => InputSystemMetricsSystem$inboundSchema)),
  cpu: types.optional(z.lazy(() => InputSystemMetricsCpu$inboundSchema)),
  memory: types.optional(z.lazy(() => InputSystemMetricsMemory$inboundSchema)),
  network: types.optional(
    z.lazy(() => InputSystemMetricsNetwork$inboundSchema),
  ),
  disk: types.optional(z.lazy(() => InputSystemMetricsDisk$inboundSchema)),
});
/** @internal */
export type InputSystemMetricsCustom$Outbound = {
  system?: InputSystemMetricsSystem$Outbound | undefined;
  cpu?: InputSystemMetricsCpu$Outbound | undefined;
  memory?: InputSystemMetricsMemory$Outbound | undefined;
  network?: InputSystemMetricsNetwork$Outbound | undefined;
  disk?: InputSystemMetricsDisk$Outbound | undefined;
};

/** @internal */
export const InputSystemMetricsCustom$outboundSchema: z.ZodType<
  InputSystemMetricsCustom$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsCustom
> = z.object({
  system: z.lazy(() => InputSystemMetricsSystem$outboundSchema).optional(),
  cpu: z.lazy(() => InputSystemMetricsCpu$outboundSchema).optional(),
  memory: z.lazy(() => InputSystemMetricsMemory$outboundSchema).optional(),
  network: z.lazy(() => InputSystemMetricsNetwork$outboundSchema).optional(),
  disk: z.lazy(() => InputSystemMetricsDisk$outboundSchema).optional(),
});

export function inputSystemMetricsCustomToJSON(
  inputSystemMetricsCustom: InputSystemMetricsCustom,
): string {
  return JSON.stringify(
    InputSystemMetricsCustom$outboundSchema.parse(inputSystemMetricsCustom),
  );
}
export function inputSystemMetricsCustomFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsCustom, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsCustom$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsCustom' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsHost$inboundSchema: z.ZodType<
  InputSystemMetricsHost,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: types.optional(ModeOptionsHost$inboundSchema),
  custom: types.optional(z.lazy(() => InputSystemMetricsCustom$inboundSchema)),
});
/** @internal */
export type InputSystemMetricsHost$Outbound = {
  mode?: string | undefined;
  custom?: InputSystemMetricsCustom$Outbound | undefined;
};

/** @internal */
export const InputSystemMetricsHost$outboundSchema: z.ZodType<
  InputSystemMetricsHost$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsHost
> = z.object({
  mode: ModeOptionsHost$outboundSchema.optional(),
  custom: z.lazy(() => InputSystemMetricsCustom$outboundSchema).optional(),
});

export function inputSystemMetricsHostToJSON(
  inputSystemMetricsHost: InputSystemMetricsHost,
): string {
  return JSON.stringify(
    InputSystemMetricsHost$outboundSchema.parse(inputSystemMetricsHost),
  );
}
export function inputSystemMetricsHostFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsHost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsHost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsHost' from JSON`,
  );
}

/** @internal */
export const ContainerMode$inboundSchema: z.ZodType<
  ContainerMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ContainerMode);
/** @internal */
export const ContainerMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ContainerMode
> = openEnums.outboundSchema(ContainerMode);

/** @internal */
export const InputSystemMetricsFilter$inboundSchema: z.ZodType<
  InputSystemMetricsFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  expr: types.string(),
});
/** @internal */
export type InputSystemMetricsFilter$Outbound = {
  expr: string;
};

/** @internal */
export const InputSystemMetricsFilter$outboundSchema: z.ZodType<
  InputSystemMetricsFilter$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsFilter
> = z.object({
  expr: z.string(),
});

export function inputSystemMetricsFilterToJSON(
  inputSystemMetricsFilter: InputSystemMetricsFilter,
): string {
  return JSON.stringify(
    InputSystemMetricsFilter$outboundSchema.parse(inputSystemMetricsFilter),
  );
}
export function inputSystemMetricsFilterFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsFilter' from JSON`,
  );
}

/** @internal */
export const Container$inboundSchema: z.ZodType<
  Container,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: types.optional(ContainerMode$inboundSchema),
  dockerSocket: types.optional(z.array(types.string())),
  dockerTimeout: types.optional(types.number()),
  filters: types.optional(
    z.array(z.lazy(() => InputSystemMetricsFilter$inboundSchema)),
  ),
  allContainers: types.optional(types.boolean()),
  perDevice: types.optional(types.boolean()),
  detail: types.optional(types.boolean()),
});
/** @internal */
export type Container$Outbound = {
  mode?: string | undefined;
  dockerSocket?: Array<string> | undefined;
  dockerTimeout?: number | undefined;
  filters?: Array<InputSystemMetricsFilter$Outbound> | undefined;
  allContainers?: boolean | undefined;
  perDevice?: boolean | undefined;
  detail?: boolean | undefined;
};

/** @internal */
export const Container$outboundSchema: z.ZodType<
  Container$Outbound,
  z.ZodTypeDef,
  Container
> = z.object({
  mode: ContainerMode$outboundSchema.optional(),
  dockerSocket: z.array(z.string()).optional(),
  dockerTimeout: z.number().optional(),
  filters: z.array(z.lazy(() => InputSystemMetricsFilter$outboundSchema))
    .optional(),
  allContainers: z.boolean().optional(),
  perDevice: z.boolean().optional(),
  detail: z.boolean().optional(),
});

export function containerToJSON(container: Container): string {
  return JSON.stringify(Container$outboundSchema.parse(container));
}
export function containerFromJSON(
  jsonString: string,
): SafeParseResult<Container, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Container$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Container' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsPersistence$inboundSchema: z.ZodType<
  InputSystemMetricsPersistence,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: types.optional(types.boolean()),
  timeWindow: types.optional(types.string()),
  maxDataSize: types.optional(types.string()),
  maxDataTime: types.optional(types.string()),
  compress: types.optional(
    DataCompressionFormatOptionsPersistence$inboundSchema,
  ),
  destPath: types.optional(types.string()),
});
/** @internal */
export type InputSystemMetricsPersistence$Outbound = {
  enable?: boolean | undefined;
  timeWindow?: string | undefined;
  maxDataSize?: string | undefined;
  maxDataTime?: string | undefined;
  compress?: string | undefined;
  destPath?: string | undefined;
};

/** @internal */
export const InputSystemMetricsPersistence$outboundSchema: z.ZodType<
  InputSystemMetricsPersistence$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsPersistence
> = z.object({
  enable: z.boolean().optional(),
  timeWindow: z.string().optional(),
  maxDataSize: z.string().optional(),
  maxDataTime: z.string().optional(),
  compress: DataCompressionFormatOptionsPersistence$outboundSchema.optional(),
  destPath: z.string().optional(),
});

export function inputSystemMetricsPersistenceToJSON(
  inputSystemMetricsPersistence: InputSystemMetricsPersistence,
): string {
  return JSON.stringify(
    InputSystemMetricsPersistence$outboundSchema.parse(
      inputSystemMetricsPersistence,
    ),
  );
}
export function inputSystemMetricsPersistenceFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsPersistence, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsPersistence$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsPersistence' from JSON`,
  );
}

/** @internal */
export const InputSystemMetrics$inboundSchema: z.ZodType<
  InputSystemMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.optional(types.string()),
  type: types.literal("system_metrics"),
  disabled: types.optional(types.boolean()),
  pipeline: types.optional(types.string()),
  sendToRoutes: types.optional(types.boolean()),
  environment: types.optional(types.string()),
  pqEnabled: types.optional(types.boolean()),
  streamtags: types.optional(z.array(types.string())),
  connections: types.optional(
    z.array(ItemsTypeConnectionsOptional$inboundSchema),
  ),
  pq: types.optional(PqType$inboundSchema),
  interval: types.optional(types.number()),
  host: types.optional(z.lazy(() => InputSystemMetricsHost$inboundSchema)),
  process: types.optional(ProcessType$inboundSchema),
  container: types.optional(z.lazy(() => Container$inboundSchema)),
  metadata: types.optional(
    z.array(ItemsTypeNotificationMetadata$inboundSchema),
  ),
  persistence: types.optional(
    z.lazy(() => InputSystemMetricsPersistence$inboundSchema),
  ),
  description: types.optional(types.string()),
});
/** @internal */
export type InputSystemMetrics$Outbound = {
  id?: string | undefined;
  type: "system_metrics";
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  interval?: number | undefined;
  host?: InputSystemMetricsHost$Outbound | undefined;
  process?: ProcessType$Outbound | undefined;
  container?: Container$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputSystemMetricsPersistence$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemMetrics$outboundSchema: z.ZodType<
  InputSystemMetrics$Outbound,
  z.ZodTypeDef,
  InputSystemMetrics
> = z.object({
  id: z.string().optional(),
  type: z.literal("system_metrics"),
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ItemsTypeConnectionsOptional$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  interval: z.number().optional(),
  host: z.lazy(() => InputSystemMetricsHost$outboundSchema).optional(),
  process: ProcessType$outboundSchema.optional(),
  container: z.lazy(() => Container$outboundSchema).optional(),
  metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
  persistence: z.lazy(() => InputSystemMetricsPersistence$outboundSchema)
    .optional(),
  description: z.string().optional(),
});

export function inputSystemMetricsToJSON(
  inputSystemMetrics: InputSystemMetrics,
): string {
  return JSON.stringify(
    InputSystemMetrics$outboundSchema.parse(inputSystemMetrics),
  );
}
export function inputSystemMetricsFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetrics' from JSON`,
  );
}
