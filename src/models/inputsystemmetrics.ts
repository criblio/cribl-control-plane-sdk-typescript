/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  DataCompressionFormatOptionsPersistence,
  DataCompressionFormatOptionsPersistence$inboundSchema,
  DataCompressionFormatOptionsPersistence$outboundSchema,
} from "./datacompressionformatoptionspersistence.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeConnections,
  ItemsTypeConnections$inboundSchema,
  ItemsTypeConnections$Outbound,
  ItemsTypeConnections$outboundSchema,
} from "./itemstypeconnections.js";
import {
  ItemsTypeNotificationMetadata,
  ItemsTypeNotificationMetadata$inboundSchema,
  ItemsTypeNotificationMetadata$Outbound,
  ItemsTypeNotificationMetadata$outboundSchema,
} from "./itemstypenotificationmetadata.js";
import {
  ModeOptionsHost,
  ModeOptionsHost$inboundSchema,
  ModeOptionsHost$outboundSchema,
} from "./modeoptionshost.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  ProcessType,
  ProcessType$inboundSchema,
  ProcessType$Outbound,
  ProcessType$outboundSchema,
} from "./processtype.js";

export const InputSystemMetricsType = {
  SystemMetrics: "system_metrics",
} as const;
export type InputSystemMetricsType = ClosedEnum<typeof InputSystemMetricsType>;

/**
 * Select the level of detail for system metrics
 */
export const InputSystemMetricsSystemMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for system metrics
 */
export type InputSystemMetricsSystemMode = OpenEnum<
  typeof InputSystemMetricsSystemMode
>;

export type InputSystemMetricsSystem = {
  /**
   * Select the level of detail for system metrics
   */
  mode?: InputSystemMetricsSystemMode | undefined;
  /**
   * Generate metrics for the numbers of processes in various states
   */
  processes?: boolean | undefined;
};

/**
 * Select the level of detail for CPU metrics
 */
export const InputSystemMetricsCpuMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for CPU metrics
 */
export type InputSystemMetricsCpuMode = OpenEnum<
  typeof InputSystemMetricsCpuMode
>;

export type InputSystemMetricsCpu = {
  /**
   * Select the level of detail for CPU metrics
   */
  mode?: InputSystemMetricsCpuMode | undefined;
  /**
   * Generate metrics for each CPU
   */
  perCpu?: boolean | undefined;
  /**
   * Generate metrics for all CPU states
   */
  detail?: boolean | undefined;
  /**
   * Generate raw, monotonic CPU time counters
   */
  time?: boolean | undefined;
};

/**
 * Select the level of detail for memory metrics
 */
export const InputSystemMetricsMemoryMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for memory metrics
 */
export type InputSystemMetricsMemoryMode = OpenEnum<
  typeof InputSystemMetricsMemoryMode
>;

export type InputSystemMetricsMemory = {
  /**
   * Select the level of detail for memory metrics
   */
  mode?: InputSystemMetricsMemoryMode | undefined;
  /**
   * Generate metrics for all memory states
   */
  detail?: boolean | undefined;
};

/**
 * Select the level of detail for network metrics
 */
export const InputSystemMetricsNetworkMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for network metrics
 */
export type InputSystemMetricsNetworkMode = OpenEnum<
  typeof InputSystemMetricsNetworkMode
>;

export type InputSystemMetricsNetwork = {
  /**
   * Select the level of detail for network metrics
   */
  mode?: InputSystemMetricsNetworkMode | undefined;
  /**
   * Generate full network metrics
   */
  detail?: boolean | undefined;
  /**
   * Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
   */
  protocols?: boolean | undefined;
  /**
   * Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty.
   */
  devices?: Array<string> | undefined;
  /**
   * Generate separate metrics for each interface
   */
  perInterface?: boolean | undefined;
};

/**
 * Select the level of detail for disk metrics
 */
export const InputSystemMetricsDiskMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for disk metrics
 */
export type InputSystemMetricsDiskMode = OpenEnum<
  typeof InputSystemMetricsDiskMode
>;

export type InputSystemMetricsDisk = {
  /**
   * Select the level of detail for disk metrics
   */
  mode?: InputSystemMetricsDiskMode | undefined;
  /**
   * Generate full disk metrics
   */
  detail?: boolean | undefined;
  /**
   * Generate filesystem inode metrics
   */
  inodes?: boolean | undefined;
  /**
   * Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty.
   */
  devices?: Array<string> | undefined;
  /**
   * Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty.
   */
  mountpoints?: Array<string> | undefined;
  /**
   * Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty.
   */
  fstypes?: Array<string> | undefined;
  /**
   * Generate separate metrics for each device
   */
  perDevice?: boolean | undefined;
};

export type InputSystemMetricsCustom = {
  system?: InputSystemMetricsSystem | undefined;
  cpu?: InputSystemMetricsCpu | undefined;
  memory?: InputSystemMetricsMemory | undefined;
  network?: InputSystemMetricsNetwork | undefined;
  disk?: InputSystemMetricsDisk | undefined;
};

export type InputSystemMetricsHost = {
  /**
   * Select level of detail for host metrics
   */
  mode?: ModeOptionsHost | undefined;
  custom?: InputSystemMetricsCustom | undefined;
};

/**
 * Select the level of detail for container metrics
 */
export const ContainerMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of detail for container metrics
 */
export type ContainerMode = OpenEnum<typeof ContainerMode>;

export type InputSystemMetricsFilter = {
  expr: string;
};

export type Container = {
  /**
   * Select the level of detail for container metrics
   */
  mode?: ContainerMode | undefined;
  /**
   * Full paths for Docker's UNIX-domain socket
   */
  dockerSocket?: Array<string> | undefined;
  /**
   * Timeout, in seconds, for the Docker API
   */
  dockerTimeout?: number | undefined;
  /**
   * Containers matching any of these will be included. All are included if no filters are added.
   */
  filters?: Array<InputSystemMetricsFilter> | undefined;
  /**
   * Include stopped and paused containers
   */
  allContainers?: boolean | undefined;
  /**
   * Generate separate metrics for each device
   */
  perDevice?: boolean | undefined;
  /**
   * Generate full container metrics
   */
  detail?: boolean | undefined;
};

export type InputSystemMetricsPersistence = {
  /**
   * Spool metrics to disk for Cribl Edge and Search
   */
  enable?: boolean | undefined;
  /**
   * Time span for each file bucket
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
   */
  maxDataTime?: string | undefined;
  compress?: DataCompressionFormatOptionsPersistence | undefined;
  /**
   * Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics
   */
  destPath?: string | undefined;
};

export type InputSystemMetricsInputCollectionPart1Type1 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  pq?: PqType | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSystemMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputSystemMetricsHost | undefined;
  process?: ProcessType | undefined;
  container?: Container | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputSystemMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputSystemMetricsInputCollectionPart0Type1 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSystemMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  pq?: PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputSystemMetricsHost | undefined;
  process?: ProcessType | undefined;
  container?: Container | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputSystemMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputSystemMetricsInputCollectionPart1Type = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSystemMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputSystemMetricsHost | undefined;
  process?: ProcessType | undefined;
  container?: Container | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputSystemMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputSystemMetricsInputCollectionPart0Type = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSystemMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  pq?: PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputSystemMetricsHost | undefined;
  process?: ProcessType | undefined;
  container?: Container | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputSystemMetricsPersistence | undefined;
  description?: string | undefined;
};

export type InputSystemMetrics =
  | InputSystemMetricsInputCollectionPart0Type
  | InputSystemMetricsInputCollectionPart1Type
  | InputSystemMetricsInputCollectionPart0Type1
  | InputSystemMetricsInputCollectionPart1Type1;

/** @internal */
export const InputSystemMetricsType$inboundSchema: z.ZodNativeEnum<
  typeof InputSystemMetricsType
> = z.nativeEnum(InputSystemMetricsType);
/** @internal */
export const InputSystemMetricsType$outboundSchema: z.ZodNativeEnum<
  typeof InputSystemMetricsType
> = InputSystemMetricsType$inboundSchema;

/** @internal */
export const InputSystemMetricsSystemMode$inboundSchema: z.ZodType<
  InputSystemMetricsSystemMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputSystemMetricsSystemMode);
/** @internal */
export const InputSystemMetricsSystemMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsSystemMode
> = openEnums.outboundSchema(InputSystemMetricsSystemMode);

/** @internal */
export const InputSystemMetricsSystem$inboundSchema: z.ZodType<
  InputSystemMetricsSystem,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSystemMetricsSystemMode$inboundSchema.default("basic"),
  processes: z.boolean().default(false),
});
/** @internal */
export type InputSystemMetricsSystem$Outbound = {
  mode: string;
  processes: boolean;
};

/** @internal */
export const InputSystemMetricsSystem$outboundSchema: z.ZodType<
  InputSystemMetricsSystem$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsSystem
> = z.object({
  mode: InputSystemMetricsSystemMode$outboundSchema.default("basic"),
  processes: z.boolean().default(false),
});

export function inputSystemMetricsSystemToJSON(
  inputSystemMetricsSystem: InputSystemMetricsSystem,
): string {
  return JSON.stringify(
    InputSystemMetricsSystem$outboundSchema.parse(inputSystemMetricsSystem),
  );
}
export function inputSystemMetricsSystemFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsSystem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsSystem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsSystem' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsCpuMode$inboundSchema: z.ZodType<
  InputSystemMetricsCpuMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputSystemMetricsCpuMode);
/** @internal */
export const InputSystemMetricsCpuMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsCpuMode
> = openEnums.outboundSchema(InputSystemMetricsCpuMode);

/** @internal */
export const InputSystemMetricsCpu$inboundSchema: z.ZodType<
  InputSystemMetricsCpu,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSystemMetricsCpuMode$inboundSchema.default("basic"),
  perCpu: z.boolean().default(false),
  detail: z.boolean().default(false),
  time: z.boolean().default(false),
});
/** @internal */
export type InputSystemMetricsCpu$Outbound = {
  mode: string;
  perCpu: boolean;
  detail: boolean;
  time: boolean;
};

/** @internal */
export const InputSystemMetricsCpu$outboundSchema: z.ZodType<
  InputSystemMetricsCpu$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsCpu
> = z.object({
  mode: InputSystemMetricsCpuMode$outboundSchema.default("basic"),
  perCpu: z.boolean().default(false),
  detail: z.boolean().default(false),
  time: z.boolean().default(false),
});

export function inputSystemMetricsCpuToJSON(
  inputSystemMetricsCpu: InputSystemMetricsCpu,
): string {
  return JSON.stringify(
    InputSystemMetricsCpu$outboundSchema.parse(inputSystemMetricsCpu),
  );
}
export function inputSystemMetricsCpuFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsCpu, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsCpu$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsCpu' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsMemoryMode$inboundSchema: z.ZodType<
  InputSystemMetricsMemoryMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputSystemMetricsMemoryMode);
/** @internal */
export const InputSystemMetricsMemoryMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsMemoryMode
> = openEnums.outboundSchema(InputSystemMetricsMemoryMode);

/** @internal */
export const InputSystemMetricsMemory$inboundSchema: z.ZodType<
  InputSystemMetricsMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSystemMetricsMemoryMode$inboundSchema.default("basic"),
  detail: z.boolean().default(false),
});
/** @internal */
export type InputSystemMetricsMemory$Outbound = {
  mode: string;
  detail: boolean;
};

/** @internal */
export const InputSystemMetricsMemory$outboundSchema: z.ZodType<
  InputSystemMetricsMemory$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsMemory
> = z.object({
  mode: InputSystemMetricsMemoryMode$outboundSchema.default("basic"),
  detail: z.boolean().default(false),
});

export function inputSystemMetricsMemoryToJSON(
  inputSystemMetricsMemory: InputSystemMetricsMemory,
): string {
  return JSON.stringify(
    InputSystemMetricsMemory$outboundSchema.parse(inputSystemMetricsMemory),
  );
}
export function inputSystemMetricsMemoryFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsMemory' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsNetworkMode$inboundSchema: z.ZodType<
  InputSystemMetricsNetworkMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputSystemMetricsNetworkMode);
/** @internal */
export const InputSystemMetricsNetworkMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsNetworkMode
> = openEnums.outboundSchema(InputSystemMetricsNetworkMode);

/** @internal */
export const InputSystemMetricsNetwork$inboundSchema: z.ZodType<
  InputSystemMetricsNetwork,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSystemMetricsNetworkMode$inboundSchema.default("basic"),
  detail: z.boolean().default(false),
  protocols: z.boolean().default(false),
  devices: z.array(z.string()).optional(),
  perInterface: z.boolean().default(false),
});
/** @internal */
export type InputSystemMetricsNetwork$Outbound = {
  mode: string;
  detail: boolean;
  protocols: boolean;
  devices?: Array<string> | undefined;
  perInterface: boolean;
};

/** @internal */
export const InputSystemMetricsNetwork$outboundSchema: z.ZodType<
  InputSystemMetricsNetwork$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsNetwork
> = z.object({
  mode: InputSystemMetricsNetworkMode$outboundSchema.default("basic"),
  detail: z.boolean().default(false),
  protocols: z.boolean().default(false),
  devices: z.array(z.string()).optional(),
  perInterface: z.boolean().default(false),
});

export function inputSystemMetricsNetworkToJSON(
  inputSystemMetricsNetwork: InputSystemMetricsNetwork,
): string {
  return JSON.stringify(
    InputSystemMetricsNetwork$outboundSchema.parse(inputSystemMetricsNetwork),
  );
}
export function inputSystemMetricsNetworkFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsNetwork, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsNetwork$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsNetwork' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsDiskMode$inboundSchema: z.ZodType<
  InputSystemMetricsDiskMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputSystemMetricsDiskMode);
/** @internal */
export const InputSystemMetricsDiskMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputSystemMetricsDiskMode
> = openEnums.outboundSchema(InputSystemMetricsDiskMode);

/** @internal */
export const InputSystemMetricsDisk$inboundSchema: z.ZodType<
  InputSystemMetricsDisk,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputSystemMetricsDiskMode$inboundSchema.default("basic"),
  detail: z.boolean().default(false),
  inodes: z.boolean().default(false),
  devices: z.array(z.string()).optional(),
  mountpoints: z.array(z.string()).optional(),
  fstypes: z.array(z.string()).optional(),
  perDevice: z.boolean().default(false),
});
/** @internal */
export type InputSystemMetricsDisk$Outbound = {
  mode: string;
  detail: boolean;
  inodes: boolean;
  devices?: Array<string> | undefined;
  mountpoints?: Array<string> | undefined;
  fstypes?: Array<string> | undefined;
  perDevice: boolean;
};

/** @internal */
export const InputSystemMetricsDisk$outboundSchema: z.ZodType<
  InputSystemMetricsDisk$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsDisk
> = z.object({
  mode: InputSystemMetricsDiskMode$outboundSchema.default("basic"),
  detail: z.boolean().default(false),
  inodes: z.boolean().default(false),
  devices: z.array(z.string()).optional(),
  mountpoints: z.array(z.string()).optional(),
  fstypes: z.array(z.string()).optional(),
  perDevice: z.boolean().default(false),
});

export function inputSystemMetricsDiskToJSON(
  inputSystemMetricsDisk: InputSystemMetricsDisk,
): string {
  return JSON.stringify(
    InputSystemMetricsDisk$outboundSchema.parse(inputSystemMetricsDisk),
  );
}
export function inputSystemMetricsDiskFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsDisk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsDisk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsDisk' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsCustom$inboundSchema: z.ZodType<
  InputSystemMetricsCustom,
  z.ZodTypeDef,
  unknown
> = z.object({
  system: z.lazy(() => InputSystemMetricsSystem$inboundSchema).optional(),
  cpu: z.lazy(() => InputSystemMetricsCpu$inboundSchema).optional(),
  memory: z.lazy(() => InputSystemMetricsMemory$inboundSchema).optional(),
  network: z.lazy(() => InputSystemMetricsNetwork$inboundSchema).optional(),
  disk: z.lazy(() => InputSystemMetricsDisk$inboundSchema).optional(),
});
/** @internal */
export type InputSystemMetricsCustom$Outbound = {
  system?: InputSystemMetricsSystem$Outbound | undefined;
  cpu?: InputSystemMetricsCpu$Outbound | undefined;
  memory?: InputSystemMetricsMemory$Outbound | undefined;
  network?: InputSystemMetricsNetwork$Outbound | undefined;
  disk?: InputSystemMetricsDisk$Outbound | undefined;
};

/** @internal */
export const InputSystemMetricsCustom$outboundSchema: z.ZodType<
  InputSystemMetricsCustom$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsCustom
> = z.object({
  system: z.lazy(() => InputSystemMetricsSystem$outboundSchema).optional(),
  cpu: z.lazy(() => InputSystemMetricsCpu$outboundSchema).optional(),
  memory: z.lazy(() => InputSystemMetricsMemory$outboundSchema).optional(),
  network: z.lazy(() => InputSystemMetricsNetwork$outboundSchema).optional(),
  disk: z.lazy(() => InputSystemMetricsDisk$outboundSchema).optional(),
});

export function inputSystemMetricsCustomToJSON(
  inputSystemMetricsCustom: InputSystemMetricsCustom,
): string {
  return JSON.stringify(
    InputSystemMetricsCustom$outboundSchema.parse(inputSystemMetricsCustom),
  );
}
export function inputSystemMetricsCustomFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsCustom, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsCustom$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsCustom' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsHost$inboundSchema: z.ZodType<
  InputSystemMetricsHost,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeOptionsHost$inboundSchema.default("basic"),
  custom: z.lazy(() => InputSystemMetricsCustom$inboundSchema).optional(),
});
/** @internal */
export type InputSystemMetricsHost$Outbound = {
  mode: string;
  custom?: InputSystemMetricsCustom$Outbound | undefined;
};

/** @internal */
export const InputSystemMetricsHost$outboundSchema: z.ZodType<
  InputSystemMetricsHost$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsHost
> = z.object({
  mode: ModeOptionsHost$outboundSchema.default("basic"),
  custom: z.lazy(() => InputSystemMetricsCustom$outboundSchema).optional(),
});

export function inputSystemMetricsHostToJSON(
  inputSystemMetricsHost: InputSystemMetricsHost,
): string {
  return JSON.stringify(
    InputSystemMetricsHost$outboundSchema.parse(inputSystemMetricsHost),
  );
}
export function inputSystemMetricsHostFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsHost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsHost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsHost' from JSON`,
  );
}

/** @internal */
export const ContainerMode$inboundSchema: z.ZodType<
  ContainerMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ContainerMode);
/** @internal */
export const ContainerMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ContainerMode
> = openEnums.outboundSchema(ContainerMode);

/** @internal */
export const InputSystemMetricsFilter$inboundSchema: z.ZodType<
  InputSystemMetricsFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  expr: z.string(),
});
/** @internal */
export type InputSystemMetricsFilter$Outbound = {
  expr: string;
};

/** @internal */
export const InputSystemMetricsFilter$outboundSchema: z.ZodType<
  InputSystemMetricsFilter$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsFilter
> = z.object({
  expr: z.string(),
});

export function inputSystemMetricsFilterToJSON(
  inputSystemMetricsFilter: InputSystemMetricsFilter,
): string {
  return JSON.stringify(
    InputSystemMetricsFilter$outboundSchema.parse(inputSystemMetricsFilter),
  );
}
export function inputSystemMetricsFilterFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsFilter' from JSON`,
  );
}

/** @internal */
export const Container$inboundSchema: z.ZodType<
  Container,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ContainerMode$inboundSchema.default("basic"),
  dockerSocket: z.array(z.string()).optional(),
  dockerTimeout: z.number().default(5),
  filters: z.array(z.lazy(() => InputSystemMetricsFilter$inboundSchema))
    .optional(),
  allContainers: z.boolean().default(false),
  perDevice: z.boolean().default(false),
  detail: z.boolean().default(false),
});
/** @internal */
export type Container$Outbound = {
  mode: string;
  dockerSocket?: Array<string> | undefined;
  dockerTimeout: number;
  filters?: Array<InputSystemMetricsFilter$Outbound> | undefined;
  allContainers: boolean;
  perDevice: boolean;
  detail: boolean;
};

/** @internal */
export const Container$outboundSchema: z.ZodType<
  Container$Outbound,
  z.ZodTypeDef,
  Container
> = z.object({
  mode: ContainerMode$outboundSchema.default("basic"),
  dockerSocket: z.array(z.string()).optional(),
  dockerTimeout: z.number().default(5),
  filters: z.array(z.lazy(() => InputSystemMetricsFilter$outboundSchema))
    .optional(),
  allContainers: z.boolean().default(false),
  perDevice: z.boolean().default(false),
  detail: z.boolean().default(false),
});

export function containerToJSON(container: Container): string {
  return JSON.stringify(Container$outboundSchema.parse(container));
}
export function containerFromJSON(
  jsonString: string,
): SafeParseResult<Container, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Container$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Container' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsPersistence$inboundSchema: z.ZodType<
  InputSystemMetricsPersistence,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: DataCompressionFormatOptionsPersistence$inboundSchema.default(
    "gzip",
  ),
  destPath: z.string().default("$CRIBL_HOME/state/system_metrics"),
});
/** @internal */
export type InputSystemMetricsPersistence$Outbound = {
  enable: boolean;
  timeWindow: string;
  maxDataSize: string;
  maxDataTime: string;
  compress: string;
  destPath: string;
};

/** @internal */
export const InputSystemMetricsPersistence$outboundSchema: z.ZodType<
  InputSystemMetricsPersistence$Outbound,
  z.ZodTypeDef,
  InputSystemMetricsPersistence
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: DataCompressionFormatOptionsPersistence$outboundSchema.default(
    "gzip",
  ),
  destPath: z.string().default("$CRIBL_HOME/state/system_metrics"),
});

export function inputSystemMetricsPersistenceToJSON(
  inputSystemMetricsPersistence: InputSystemMetricsPersistence,
): string {
  return JSON.stringify(
    InputSystemMetricsPersistence$outboundSchema.parse(
      inputSystemMetricsPersistence,
    ),
  );
}
export function inputSystemMetricsPersistenceFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetricsPersistence, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetricsPersistence$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetricsPersistence' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsInputCollectionPart1Type1$inboundSchema:
  z.ZodType<
    InputSystemMetricsInputCollectionPart1Type1,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$inboundSchema.optional(),
    id: z.string().optional(),
    type: InputSystemMetricsType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputSystemMetricsHost$inboundSchema).optional(),
    process: ProcessType$inboundSchema.optional(),
    container: z.lazy(() => Container$inboundSchema).optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    persistence: z.lazy(() => InputSystemMetricsPersistence$inboundSchema)
      .optional(),
    description: z.string().optional(),
  });
/** @internal */
export type InputSystemMetricsInputCollectionPart1Type1$Outbound = {
  pqEnabled: boolean;
  pq?: PqType$Outbound | undefined;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  interval: number;
  host?: InputSystemMetricsHost$Outbound | undefined;
  process?: ProcessType$Outbound | undefined;
  container?: Container$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputSystemMetricsPersistence$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemMetricsInputCollectionPart1Type1$outboundSchema:
  z.ZodType<
    InputSystemMetricsInputCollectionPart1Type1$Outbound,
    z.ZodTypeDef,
    InputSystemMetricsInputCollectionPart1Type1
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$outboundSchema.optional(),
    id: z.string().optional(),
    type: InputSystemMetricsType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputSystemMetricsHost$outboundSchema).optional(),
    process: ProcessType$outboundSchema.optional(),
    container: z.lazy(() => Container$outboundSchema).optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    persistence: z.lazy(() => InputSystemMetricsPersistence$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputSystemMetricsInputCollectionPart1Type1ToJSON(
  inputSystemMetricsInputCollectionPart1Type1:
    InputSystemMetricsInputCollectionPart1Type1,
): string {
  return JSON.stringify(
    InputSystemMetricsInputCollectionPart1Type1$outboundSchema.parse(
      inputSystemMetricsInputCollectionPart1Type1,
    ),
  );
}
export function inputSystemMetricsInputCollectionPart1Type1FromJSON(
  jsonString: string,
): SafeParseResult<
  InputSystemMetricsInputCollectionPart1Type1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputSystemMetricsInputCollectionPart1Type1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputSystemMetricsInputCollectionPart1Type1' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsInputCollectionPart0Type1$inboundSchema:
  z.ZodType<
    InputSystemMetricsInputCollectionPart0Type1,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    id: z.string().optional(),
    type: InputSystemMetricsType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    pq: PqType$inboundSchema.optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputSystemMetricsHost$inboundSchema).optional(),
    process: ProcessType$inboundSchema.optional(),
    container: z.lazy(() => Container$inboundSchema).optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    persistence: z.lazy(() => InputSystemMetricsPersistence$inboundSchema)
      .optional(),
    description: z.string().optional(),
  });
/** @internal */
export type InputSystemMetricsInputCollectionPart0Type1$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  interval: number;
  host?: InputSystemMetricsHost$Outbound | undefined;
  process?: ProcessType$Outbound | undefined;
  container?: Container$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputSystemMetricsPersistence$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemMetricsInputCollectionPart0Type1$outboundSchema:
  z.ZodType<
    InputSystemMetricsInputCollectionPart0Type1$Outbound,
    z.ZodTypeDef,
    InputSystemMetricsInputCollectionPart0Type1
  > = z.object({
    pqEnabled: z.boolean().default(false),
    id: z.string().optional(),
    type: InputSystemMetricsType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    pq: PqType$outboundSchema.optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputSystemMetricsHost$outboundSchema).optional(),
    process: ProcessType$outboundSchema.optional(),
    container: z.lazy(() => Container$outboundSchema).optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    persistence: z.lazy(() => InputSystemMetricsPersistence$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputSystemMetricsInputCollectionPart0Type1ToJSON(
  inputSystemMetricsInputCollectionPart0Type1:
    InputSystemMetricsInputCollectionPart0Type1,
): string {
  return JSON.stringify(
    InputSystemMetricsInputCollectionPart0Type1$outboundSchema.parse(
      inputSystemMetricsInputCollectionPart0Type1,
    ),
  );
}
export function inputSystemMetricsInputCollectionPart0Type1FromJSON(
  jsonString: string,
): SafeParseResult<
  InputSystemMetricsInputCollectionPart0Type1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputSystemMetricsInputCollectionPart0Type1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputSystemMetricsInputCollectionPart0Type1' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsInputCollectionPart1Type$inboundSchema:
  z.ZodType<InputSystemMetricsInputCollectionPart1Type, z.ZodTypeDef, unknown> =
    z.object({
      sendToRoutes: z.boolean().default(true),
      connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
      id: z.string().optional(),
      type: InputSystemMetricsType$inboundSchema,
      disabled: z.boolean().default(false),
      pipeline: z.string().optional(),
      environment: z.string().optional(),
      pqEnabled: z.boolean().default(false),
      streamtags: z.array(z.string()).optional(),
      pq: PqType$inboundSchema.optional(),
      interval: z.number().default(10),
      host: z.lazy(() => InputSystemMetricsHost$inboundSchema).optional(),
      process: ProcessType$inboundSchema.optional(),
      container: z.lazy(() => Container$inboundSchema).optional(),
      metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
      persistence: z.lazy(() => InputSystemMetricsPersistence$inboundSchema)
        .optional(),
      description: z.string().optional(),
    });
/** @internal */
export type InputSystemMetricsInputCollectionPart1Type$Outbound = {
  sendToRoutes: boolean;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  pq?: PqType$Outbound | undefined;
  interval: number;
  host?: InputSystemMetricsHost$Outbound | undefined;
  process?: ProcessType$Outbound | undefined;
  container?: Container$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputSystemMetricsPersistence$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemMetricsInputCollectionPart1Type$outboundSchema:
  z.ZodType<
    InputSystemMetricsInputCollectionPart1Type$Outbound,
    z.ZodTypeDef,
    InputSystemMetricsInputCollectionPart1Type
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    id: z.string().optional(),
    type: InputSystemMetricsType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$outboundSchema.optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputSystemMetricsHost$outboundSchema).optional(),
    process: ProcessType$outboundSchema.optional(),
    container: z.lazy(() => Container$outboundSchema).optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    persistence: z.lazy(() => InputSystemMetricsPersistence$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputSystemMetricsInputCollectionPart1TypeToJSON(
  inputSystemMetricsInputCollectionPart1Type:
    InputSystemMetricsInputCollectionPart1Type,
): string {
  return JSON.stringify(
    InputSystemMetricsInputCollectionPart1Type$outboundSchema.parse(
      inputSystemMetricsInputCollectionPart1Type,
    ),
  );
}
export function inputSystemMetricsInputCollectionPart1TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  InputSystemMetricsInputCollectionPart1Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputSystemMetricsInputCollectionPart1Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputSystemMetricsInputCollectionPart1Type' from JSON`,
  );
}

/** @internal */
export const InputSystemMetricsInputCollectionPart0Type$inboundSchema:
  z.ZodType<InputSystemMetricsInputCollectionPart0Type, z.ZodTypeDef, unknown> =
    z.object({
      sendToRoutes: z.boolean().default(true),
      id: z.string().optional(),
      type: InputSystemMetricsType$inboundSchema,
      disabled: z.boolean().default(false),
      pipeline: z.string().optional(),
      environment: z.string().optional(),
      pqEnabled: z.boolean().default(false),
      streamtags: z.array(z.string()).optional(),
      connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
      pq: PqType$inboundSchema.optional(),
      interval: z.number().default(10),
      host: z.lazy(() => InputSystemMetricsHost$inboundSchema).optional(),
      process: ProcessType$inboundSchema.optional(),
      container: z.lazy(() => Container$inboundSchema).optional(),
      metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
      persistence: z.lazy(() => InputSystemMetricsPersistence$inboundSchema)
        .optional(),
      description: z.string().optional(),
    });
/** @internal */
export type InputSystemMetricsInputCollectionPart0Type$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  interval: number;
  host?: InputSystemMetricsHost$Outbound | undefined;
  process?: ProcessType$Outbound | undefined;
  container?: Container$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputSystemMetricsPersistence$Outbound | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputSystemMetricsInputCollectionPart0Type$outboundSchema:
  z.ZodType<
    InputSystemMetricsInputCollectionPart0Type$Outbound,
    z.ZodTypeDef,
    InputSystemMetricsInputCollectionPart0Type
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    id: z.string().optional(),
    type: InputSystemMetricsType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    pq: PqType$outboundSchema.optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputSystemMetricsHost$outboundSchema).optional(),
    process: ProcessType$outboundSchema.optional(),
    container: z.lazy(() => Container$outboundSchema).optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    persistence: z.lazy(() => InputSystemMetricsPersistence$outboundSchema)
      .optional(),
    description: z.string().optional(),
  });

export function inputSystemMetricsInputCollectionPart0TypeToJSON(
  inputSystemMetricsInputCollectionPart0Type:
    InputSystemMetricsInputCollectionPart0Type,
): string {
  return JSON.stringify(
    InputSystemMetricsInputCollectionPart0Type$outboundSchema.parse(
      inputSystemMetricsInputCollectionPart0Type,
    ),
  );
}
export function inputSystemMetricsInputCollectionPart0TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  InputSystemMetricsInputCollectionPart0Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputSystemMetricsInputCollectionPart0Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputSystemMetricsInputCollectionPart0Type' from JSON`,
  );
}

/** @internal */
export const InputSystemMetrics$inboundSchema: z.ZodType<
  InputSystemMetrics,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputSystemMetricsInputCollectionPart0Type$inboundSchema),
  z.lazy(() => InputSystemMetricsInputCollectionPart1Type$inboundSchema),
  z.lazy(() => InputSystemMetricsInputCollectionPart0Type1$inboundSchema),
  z.lazy(() => InputSystemMetricsInputCollectionPart1Type1$inboundSchema),
]);
/** @internal */
export type InputSystemMetrics$Outbound =
  | InputSystemMetricsInputCollectionPart0Type$Outbound
  | InputSystemMetricsInputCollectionPart1Type$Outbound
  | InputSystemMetricsInputCollectionPart0Type1$Outbound
  | InputSystemMetricsInputCollectionPart1Type1$Outbound;

/** @internal */
export const InputSystemMetrics$outboundSchema: z.ZodType<
  InputSystemMetrics$Outbound,
  z.ZodTypeDef,
  InputSystemMetrics
> = z.union([
  z.lazy(() => InputSystemMetricsInputCollectionPart0Type$outboundSchema),
  z.lazy(() => InputSystemMetricsInputCollectionPart1Type$outboundSchema),
  z.lazy(() => InputSystemMetricsInputCollectionPart0Type1$outboundSchema),
  z.lazy(() => InputSystemMetricsInputCollectionPart1Type1$outboundSchema),
]);

export function inputSystemMetricsToJSON(
  inputSystemMetrics: InputSystemMetrics,
): string {
  return JSON.stringify(
    InputSystemMetrics$outboundSchema.parse(inputSystemMetrics),
  );
}
export function inputSystemMetricsFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemMetrics' from JSON`,
  );
}
