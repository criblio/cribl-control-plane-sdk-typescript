/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Remote Write authentication type
 */
export const PrometheusAuthTypeAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Remote Write authentication type
 */
export type PrometheusAuthTypeAuthenticationType = OpenEnum<
  typeof PrometheusAuthTypeAuthenticationType
>;

export type PrometheusAuthTypeOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type OauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type PrometheusAuthType = {
  /**
   * Remote Write authentication type
   */
  authType?: PrometheusAuthTypeAuthenticationType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<PrometheusAuthTypeOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<OauthHeader> | undefined;
};

/** @internal */
export const PrometheusAuthTypeAuthenticationType$inboundSchema: z.ZodType<
  PrometheusAuthTypeAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PrometheusAuthTypeAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const PrometheusAuthTypeAuthenticationType$outboundSchema: z.ZodType<
  PrometheusAuthTypeAuthenticationType,
  z.ZodTypeDef,
  PrometheusAuthTypeAuthenticationType
> = z.union([
  z.nativeEnum(PrometheusAuthTypeAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const PrometheusAuthTypeOauthParam$inboundSchema: z.ZodType<
  PrometheusAuthTypeOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type PrometheusAuthTypeOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const PrometheusAuthTypeOauthParam$outboundSchema: z.ZodType<
  PrometheusAuthTypeOauthParam$Outbound,
  z.ZodTypeDef,
  PrometheusAuthTypeOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function prometheusAuthTypeOauthParamToJSON(
  prometheusAuthTypeOauthParam: PrometheusAuthTypeOauthParam,
): string {
  return JSON.stringify(
    PrometheusAuthTypeOauthParam$outboundSchema.parse(
      prometheusAuthTypeOauthParam,
    ),
  );
}
export function prometheusAuthTypeOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthTypeOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthTypeOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthTypeOauthParam' from JSON`,
  );
}

/** @internal */
export const OauthHeader$inboundSchema: z.ZodType<
  OauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type OauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const OauthHeader$outboundSchema: z.ZodType<
  OauthHeader$Outbound,
  z.ZodTypeDef,
  OauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function oauthHeaderToJSON(oauthHeader: OauthHeader): string {
  return JSON.stringify(OauthHeader$outboundSchema.parse(oauthHeader));
}
export function oauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<OauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OauthHeader' from JSON`,
  );
}

/** @internal */
export const PrometheusAuthType$inboundSchema: z.ZodType<
  PrometheusAuthType,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: PrometheusAuthTypeAuthenticationType$inboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => PrometheusAuthTypeOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeader$inboundSchema)).optional(),
});
/** @internal */
export type PrometheusAuthType$Outbound = {
  authType: string;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<PrometheusAuthTypeOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<OauthHeader$Outbound> | undefined;
};

/** @internal */
export const PrometheusAuthType$outboundSchema: z.ZodType<
  PrometheusAuthType$Outbound,
  z.ZodTypeDef,
  PrometheusAuthType
> = z.object({
  authType: PrometheusAuthTypeAuthenticationType$outboundSchema.default("none"),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(
    z.lazy(() => PrometheusAuthTypeOauthParam$outboundSchema),
  ).optional(),
  oauthHeaders: z.array(z.lazy(() => OauthHeader$outboundSchema)).optional(),
});

export function prometheusAuthTypeToJSON(
  prometheusAuthType: PrometheusAuthType,
): string {
  return JSON.stringify(
    PrometheusAuthType$outboundSchema.parse(prometheusAuthType),
  );
}
export function prometheusAuthTypeFromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthType' from JSON`,
  );
}
