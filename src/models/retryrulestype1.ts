/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type RetryRulesType1 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: string;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/** @internal */
export const RetryRulesType1$inboundSchema: z.ZodType<
  RetryRulesType1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.string(),
  interval: types.optional(types.number()),
  limit: types.optional(types.number()),
  multiplier: types.optional(types.number()),
  codes: types.optional(z.array(types.number())),
  enableHeader: types.optional(types.boolean()),
  retryConnectTimeout: types.optional(types.boolean()),
  retryConnectReset: types.optional(types.boolean()),
});
/** @internal */
export type RetryRulesType1$Outbound = {
  type: string;
  interval?: number | undefined;
  limit?: number | undefined;
  multiplier?: number | undefined;
  codes?: Array<number> | undefined;
  enableHeader?: boolean | undefined;
  retryConnectTimeout?: boolean | undefined;
  retryConnectReset?: boolean | undefined;
};

/** @internal */
export const RetryRulesType1$outboundSchema: z.ZodType<
  RetryRulesType1$Outbound,
  z.ZodTypeDef,
  RetryRulesType1
> = z.object({
  type: z.string(),
  interval: z.number().optional(),
  limit: z.number().optional(),
  multiplier: z.number().optional(),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().optional(),
  retryConnectTimeout: z.boolean().optional(),
  retryConnectReset: z.boolean().optional(),
});

export function retryRulesType1ToJSON(
  retryRulesType1: RetryRulesType1,
): string {
  return JSON.stringify(RetryRulesType1$outboundSchema.parse(retryRulesType1));
}
export function retryRulesType1FromJSON(
  jsonString: string,
): SafeParseResult<RetryRulesType1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetryRulesType1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetryRulesType1' from JSON`,
  );
}
