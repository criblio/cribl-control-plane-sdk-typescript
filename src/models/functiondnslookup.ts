/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const FunctionDnsLookupId = {
  DnsLookup: "dns_lookup",
} as const;
export type FunctionDnsLookupId = ClosedEnum<typeof FunctionDnsLookupId>;

/**
 * The DNS record type (RR) to return. Defaults to 'A'.
 */
export const ResourceRecordType = {
  /**
   * A
   */
  A: "A",
  /**
   * AAAA
   */
  Aaaa: "AAAA",
  /**
   * ANY
   */
  Any: "ANY",
  /**
   * CNAME
   */
  Cname: "CNAME",
  /**
   * MX
   */
  Mx: "MX",
  /**
   * NAPTR
   */
  Naptr: "NAPTR",
  /**
   * NS
   */
  Ns: "NS",
  /**
   * PTR
   */
  Ptr: "PTR",
  /**
   * SOA
   */
  Soa: "SOA",
  /**
   * SRV
   */
  Srv: "SRV",
  /**
   * TXT
   */
  Txt: "TXT",
} as const;
/**
 * The DNS record type (RR) to return. Defaults to 'A'.
 */
export type ResourceRecordType = OpenEnum<typeof ResourceRecordType>;

export type DnsLookupField = {
  inFieldName?: string | undefined;
  /**
   * The DNS record type (RR) to return. Defaults to 'A'.
   */
  resourceRecordType?: ResourceRecordType | undefined;
  /**
   * Name of field to add lookup results to. Leave blank to overwrite the lookup field.
   */
  outFieldName?: string | undefined;
};

export type ReverseLookupField = {
  /**
   * Name of the field containing the IP to look up. If the field value is not in IPv4 or IPv6 format, the lookup is skipped.
   */
  inFieldName?: string | undefined;
  /**
   * Name of field to add the resolved domain to. Leave blank to overwrite the lookup field.
   */
  outFieldName?: string | undefined;
};

export const LogLevelForFailedLookups = {
  /**
   * silly
   */
  Silly: "silly",
  /**
   * debug
   */
  Debug: "debug",
  /**
   * info
   */
  Info: "info",
  /**
   * warn
   */
  Warn: "warn",
  /**
   * error
   */
  Error: "error",
} as const;
export type LogLevelForFailedLookups = OpenEnum<
  typeof LogLevelForFailedLookups
>;

export type FunctionDnsLookupSchema = {
  /**
   * List of field names on which to perform DNS lookup
   */
  dnsLookupFields?: Array<DnsLookupField> | undefined;
  /**
   * List of field names on which to perform reverse DNS lookup
   */
  reverseLookupFields?: Array<ReverseLookupField> | undefined;
  /**
   * IPs, in RFC 5952 format, of the DNS servers to use for resolution. Examples: IPv4 1.1.1.1, 4.2.2.2:53, or IPv6 [2001:4860:4860::8888], [2001:4860:4860::8888]:1053. If not specified, system's DNS will be used.
   */
  dnsServers?: Array<string> | undefined;
  /**
   * How frequently to expire and refetch DNS cache. Use 0 to disable.
   */
  cacheTTL?: number | undefined;
  /**
   * The maximum number of DNS resolutions to be cached locally. Leave at default unless you understand the implications of changing.
   */
  maxCacheSize?: number | undefined;
  /**
   * Attempt to resolve DNS short names using the search or domain directive from /etc/resolv.conf
   */
  useResolvConf?: boolean | undefined;
  /**
   * If unable to resolve a DNS short name, make a DNS.lookup() call to resolve it. Caution: This might degrade performance in unrelated areas of @{product}.
   */
  lookupFallback?: boolean | undefined;
  /**
   * Specify fallback values for the DNS resolver to use when it cannot resolve a DNS short name
   */
  domainOverrides?: Array<string> | undefined;
  lookupFailLogLevel?: LogLevelForFailedLookups | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type FunctionDnsLookup = {
  filename: string;
  asyncTimeout?: number | undefined;
  criblVersion?: string | undefined;
  disabled: boolean;
  group: string;
  handleSignals?: boolean | undefined;
  id: FunctionDnsLookupId;
  loadTime: number;
  modTime: number;
  name: string;
  sync?: boolean | undefined;
  uischema: { [k: string]: any };
  version: string;
  schema?: FunctionDnsLookupSchema | undefined;
};

/** @internal */
export const FunctionDnsLookupId$inboundSchema: z.ZodNativeEnum<
  typeof FunctionDnsLookupId
> = z.nativeEnum(FunctionDnsLookupId);

/** @internal */
export const ResourceRecordType$inboundSchema: z.ZodType<
  ResourceRecordType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ResourceRecordType);

/** @internal */
export const DnsLookupField$inboundSchema: z.ZodType<
  DnsLookupField,
  z.ZodTypeDef,
  unknown
> = z.object({
  inFieldName: z.string().optional(),
  resourceRecordType: ResourceRecordType$inboundSchema.default("A"),
  outFieldName: z.string().optional(),
});

export function dnsLookupFieldFromJSON(
  jsonString: string,
): SafeParseResult<DnsLookupField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DnsLookupField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DnsLookupField' from JSON`,
  );
}

/** @internal */
export const ReverseLookupField$inboundSchema: z.ZodType<
  ReverseLookupField,
  z.ZodTypeDef,
  unknown
> = z.object({
  inFieldName: z.string().optional(),
  outFieldName: z.string().optional(),
});

export function reverseLookupFieldFromJSON(
  jsonString: string,
): SafeParseResult<ReverseLookupField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReverseLookupField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReverseLookupField' from JSON`,
  );
}

/** @internal */
export const LogLevelForFailedLookups$inboundSchema: z.ZodType<
  LogLevelForFailedLookups,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(LogLevelForFailedLookups);

/** @internal */
export const FunctionDnsLookupSchema$inboundSchema: z.ZodType<
  FunctionDnsLookupSchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    dnsLookupFields: z.array(z.lazy(() => DnsLookupField$inboundSchema))
      .optional(),
    reverseLookupFields: z.array(z.lazy(() => ReverseLookupField$inboundSchema))
      .optional(),
    dnsServers: z.array(z.string()).optional(),
    cacheTTL: z.number().default(30),
    maxCacheSize: z.number().default(5000),
    useResolvConf: z.boolean().default(false),
    lookupFallback: z.boolean().default(false),
    domainOverrides: z.array(z.string()).optional(),
    lookupFailLogLevel: LogLevelForFailedLookups$inboundSchema.default("error"),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function functionDnsLookupSchemaFromJSON(
  jsonString: string,
): SafeParseResult<FunctionDnsLookupSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionDnsLookupSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionDnsLookupSchema' from JSON`,
  );
}

/** @internal */
export const FunctionDnsLookup$inboundSchema: z.ZodType<
  FunctionDnsLookup,
  z.ZodTypeDef,
  unknown
> = z.object({
  __filename: z.string(),
  asyncTimeout: z.number().optional(),
  cribl_version: z.string().optional(),
  disabled: z.boolean(),
  group: z.string(),
  handleSignals: z.boolean().optional(),
  id: FunctionDnsLookupId$inboundSchema,
  loadTime: z.number(),
  modTime: z.number(),
  name: z.string(),
  sync: z.boolean().optional(),
  uischema: z.record(z.any()),
  version: z.string(),
  schema: z.lazy(() => FunctionDnsLookupSchema$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "__filename": "filename",
    "cribl_version": "criblVersion",
  });
});

export function functionDnsLookupFromJSON(
  jsonString: string,
): SafeParseResult<FunctionDnsLookup, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionDnsLookup$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionDnsLookup' from JSON`,
  );
}
