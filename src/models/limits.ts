/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  EdgeHeartbeatMetricsMode,
  EdgeHeartbeatMetricsMode$inboundSchema,
  EdgeHeartbeatMetricsMode$outboundSchema,
} from "./edgeheartbeatmetricsmode.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type Samples = {
  maxSize: string;
};

export type Limits = {
  cpuProfileTTL: string;
  disableMetricsAccessorCache?: boolean | undefined;
  edgeMetricsCustomExpression?: string | undefined;
  edgeMetricsMode?: EdgeHeartbeatMetricsMode | undefined;
  edgeNodesCount?: number | undefined;
  enableMetricsPersistence: boolean;
  enableWorkerPersistence?: boolean | undefined;
  eventsMetadataSources?: Array<string> | undefined;
  largeEventsThreshold?: string | undefined;
  lookupMaxSize?: string | undefined;
  lookupMaxTotalSize?: string | undefined;
  maxMetrics?: number | undefined;
  maxPQSize?: string | undefined;
  metricsDirectory: string;
  metricsDropList?: Array<string> | undefined;
  metricsFieldsBlacklist: Array<string>;
  metricsGCPeriod: string;
  metricsMaxCardinality?: number | undefined;
  metricsMaxDiskSpace?: string | undefined;
  metricsNeverDropList: Array<string>;
  metricsWorkerIdBlacklist: Array<string>;
  minFreeSpace: string;
  samples: Samples;
  workerMaxMetrics?: number | undefined;
};

/** @internal */
export const Samples$inboundSchema: z.ZodType<Samples, z.ZodTypeDef, unknown> =
  z.object({
    maxSize: z.string(),
  });

/** @internal */
export type Samples$Outbound = {
  maxSize: string;
};

/** @internal */
export const Samples$outboundSchema: z.ZodType<
  Samples$Outbound,
  z.ZodTypeDef,
  Samples
> = z.object({
  maxSize: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Samples$ {
  /** @deprecated use `Samples$inboundSchema` instead. */
  export const inboundSchema = Samples$inboundSchema;
  /** @deprecated use `Samples$outboundSchema` instead. */
  export const outboundSchema = Samples$outboundSchema;
  /** @deprecated use `Samples$Outbound` instead. */
  export type Outbound = Samples$Outbound;
}

export function samplesToJSON(samples: Samples): string {
  return JSON.stringify(Samples$outboundSchema.parse(samples));
}

export function samplesFromJSON(
  jsonString: string,
): SafeParseResult<Samples, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Samples$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Samples' from JSON`,
  );
}

/** @internal */
export const Limits$inboundSchema: z.ZodType<Limits, z.ZodTypeDef, unknown> = z
  .object({
    cpuProfileTTL: z.string(),
    disableMetricsAccessorCache: z.boolean().optional(),
    edgeMetricsCustomExpression: z.string().optional(),
    edgeMetricsMode: EdgeHeartbeatMetricsMode$inboundSchema.optional(),
    edgeNodesCount: z.number().optional(),
    enableMetricsPersistence: z.boolean(),
    enableWorkerPersistence: z.boolean().optional(),
    eventsMetadataSources: z.array(z.string()).optional(),
    largeEventsThreshold: z.string().optional(),
    lookupMaxSize: z.string().optional(),
    lookupMaxTotalSize: z.string().optional(),
    maxMetrics: z.number().optional(),
    maxPQSize: z.string().optional(),
    metricsDirectory: z.string(),
    metricsDropList: z.array(z.string()).optional(),
    metricsFieldsBlacklist: z.array(z.string()),
    metricsGCPeriod: z.string(),
    metricsMaxCardinality: z.number().optional(),
    metricsMaxDiskSpace: z.string().optional(),
    metricsNeverDropList: z.array(z.string()),
    metricsWorkerIdBlacklist: z.array(z.string()),
    minFreeSpace: z.string(),
    samples: z.lazy(() => Samples$inboundSchema),
    workerMaxMetrics: z.number().optional(),
  });

/** @internal */
export type Limits$Outbound = {
  cpuProfileTTL: string;
  disableMetricsAccessorCache?: boolean | undefined;
  edgeMetricsCustomExpression?: string | undefined;
  edgeMetricsMode?: string | undefined;
  edgeNodesCount?: number | undefined;
  enableMetricsPersistence: boolean;
  enableWorkerPersistence?: boolean | undefined;
  eventsMetadataSources?: Array<string> | undefined;
  largeEventsThreshold?: string | undefined;
  lookupMaxSize?: string | undefined;
  lookupMaxTotalSize?: string | undefined;
  maxMetrics?: number | undefined;
  maxPQSize?: string | undefined;
  metricsDirectory: string;
  metricsDropList?: Array<string> | undefined;
  metricsFieldsBlacklist: Array<string>;
  metricsGCPeriod: string;
  metricsMaxCardinality?: number | undefined;
  metricsMaxDiskSpace?: string | undefined;
  metricsNeverDropList: Array<string>;
  metricsWorkerIdBlacklist: Array<string>;
  minFreeSpace: string;
  samples: Samples$Outbound;
  workerMaxMetrics?: number | undefined;
};

/** @internal */
export const Limits$outboundSchema: z.ZodType<
  Limits$Outbound,
  z.ZodTypeDef,
  Limits
> = z.object({
  cpuProfileTTL: z.string(),
  disableMetricsAccessorCache: z.boolean().optional(),
  edgeMetricsCustomExpression: z.string().optional(),
  edgeMetricsMode: EdgeHeartbeatMetricsMode$outboundSchema.optional(),
  edgeNodesCount: z.number().optional(),
  enableMetricsPersistence: z.boolean(),
  enableWorkerPersistence: z.boolean().optional(),
  eventsMetadataSources: z.array(z.string()).optional(),
  largeEventsThreshold: z.string().optional(),
  lookupMaxSize: z.string().optional(),
  lookupMaxTotalSize: z.string().optional(),
  maxMetrics: z.number().optional(),
  maxPQSize: z.string().optional(),
  metricsDirectory: z.string(),
  metricsDropList: z.array(z.string()).optional(),
  metricsFieldsBlacklist: z.array(z.string()),
  metricsGCPeriod: z.string(),
  metricsMaxCardinality: z.number().optional(),
  metricsMaxDiskSpace: z.string().optional(),
  metricsNeverDropList: z.array(z.string()),
  metricsWorkerIdBlacklist: z.array(z.string()),
  minFreeSpace: z.string(),
  samples: z.lazy(() => Samples$outboundSchema),
  workerMaxMetrics: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Limits$ {
  /** @deprecated use `Limits$inboundSchema` instead. */
  export const inboundSchema = Limits$inboundSchema;
  /** @deprecated use `Limits$outboundSchema` instead. */
  export const outboundSchema = Limits$outboundSchema;
  /** @deprecated use `Limits$Outbound` instead. */
  export type Outbound = Limits$Outbound;
}

export function limitsToJSON(limits: Limits): string {
  return JSON.stringify(Limits$outboundSchema.parse(limits));
}

export function limitsFromJSON(
  jsonString: string,
): SafeParseResult<Limits, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Limits$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Limits' from JSON`,
  );
}
