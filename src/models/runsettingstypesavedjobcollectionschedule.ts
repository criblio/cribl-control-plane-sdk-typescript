/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  LogLevelOptionsRunnableJobCollectionScheduleRun,
  LogLevelOptionsRunnableJobCollectionScheduleRun$inboundSchema,
  LogLevelOptionsRunnableJobCollectionScheduleRun$outboundSchema,
} from "./logleveloptionsrunnablejobcollectionschedulerun.js";
import {
  MetricsStore,
  MetricsStore$inboundSchema,
  MetricsStore$Outbound,
  MetricsStore$outboundSchema,
} from "./metricsstore.js";

export const RunSettingsTypeSavedJobCollectionScheduleType = {
  Collection: "collection",
} as const;
export type RunSettingsTypeSavedJobCollectionScheduleType = OpenEnum<
  typeof RunSettingsTypeSavedJobCollectionScheduleType
>;

export type RunSettingsTypeSavedJobCollectionSchedule = {
  type?: RunSettingsTypeSavedJobCollectionScheduleType | undefined;
  /**
   * Reschedule tasks that failed with non-fatal errors
   */
  rescheduleDroppedTasks?: boolean | undefined;
  /**
   * Maximum number of times a task can be rescheduled
   */
  maxTaskReschedule?: number | undefined;
  /**
   * Level at which to set task logging
   */
  logLevel?: LogLevelOptionsRunnableJobCollectionScheduleRun | undefined;
  /**
   * Maximum time the job is allowed to run. Time unit defaults to seconds if not specified (examples: 30, 45s, 15m). Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * Job run mode. Preview will either return up to N matching results, or will run until capture time T is reached. Discovery will gather the list of files to turn into streaming tasks, without running the data collection job. Full Run will run the collection job.
   */
  mode: string;
  timeRangeType?: string | undefined;
  /**
   * Earliest time to collect data for the selected timezone
   */
  earliest?: number | undefined;
  /**
   * Latest time to collect data for the selected timezone
   */
  latest?: number | undefined;
  timestampTimezone?: any | undefined;
  timeWarning?: MetricsStore | undefined;
  /**
   * A filter for tokens in the provided collect path and/or the events being collected
   */
  expression?: string | undefined;
  /**
   * Limits the bundle size for small tasks. For example,
   *
   * @remarks
   *
   *         if your lower bundle size is 1MB, you can bundle up to five 200KB files into one task.
   */
  minTaskSize?: string | undefined;
  /**
   * Limits the bundle size for files above the lower task bundle size. For example, if your upper bundle size is 10MB,
   *
   * @remarks
   *
   *         you can bundle up to five 2MB files into one task. Files greater than this size will be assigned to individual tasks.
   */
  maxTaskSize?: string | undefined;
};

/** @internal */
export const RunSettingsTypeSavedJobCollectionScheduleType$inboundSchema:
  z.ZodType<
    RunSettingsTypeSavedJobCollectionScheduleType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(RunSettingsTypeSavedJobCollectionScheduleType);
/** @internal */
export const RunSettingsTypeSavedJobCollectionScheduleType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RunSettingsTypeSavedJobCollectionScheduleType
  > = openEnums.outboundSchema(RunSettingsTypeSavedJobCollectionScheduleType);

/** @internal */
export const RunSettingsTypeSavedJobCollectionSchedule$inboundSchema: z.ZodType<
  RunSettingsTypeSavedJobCollectionSchedule,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(
    RunSettingsTypeSavedJobCollectionScheduleType$inboundSchema,
  ),
  rescheduleDroppedTasks: types.optional(types.boolean()),
  maxTaskReschedule: types.optional(types.number()),
  logLevel: types.optional(
    LogLevelOptionsRunnableJobCollectionScheduleRun$inboundSchema,
  ),
  jobTimeout: types.optional(types.string()),
  mode: types.string(),
  timeRangeType: types.optional(types.string()),
  earliest: types.optional(types.number()),
  latest: types.optional(types.number()),
  timestampTimezone: types.optional(z.any()),
  timeWarning: types.optional(MetricsStore$inboundSchema),
  expression: types.optional(types.string()),
  minTaskSize: types.optional(types.string()),
  maxTaskSize: types.optional(types.string()),
});
/** @internal */
export type RunSettingsTypeSavedJobCollectionSchedule$Outbound = {
  type?: string | undefined;
  rescheduleDroppedTasks?: boolean | undefined;
  maxTaskReschedule?: number | undefined;
  logLevel?: string | undefined;
  jobTimeout?: string | undefined;
  mode: string;
  timeRangeType?: string | undefined;
  earliest?: number | undefined;
  latest?: number | undefined;
  timestampTimezone?: any | undefined;
  timeWarning?: MetricsStore$Outbound | undefined;
  expression?: string | undefined;
  minTaskSize?: string | undefined;
  maxTaskSize?: string | undefined;
};

/** @internal */
export const RunSettingsTypeSavedJobCollectionSchedule$outboundSchema:
  z.ZodType<
    RunSettingsTypeSavedJobCollectionSchedule$Outbound,
    z.ZodTypeDef,
    RunSettingsTypeSavedJobCollectionSchedule
  > = z.object({
    type: RunSettingsTypeSavedJobCollectionScheduleType$outboundSchema
      .optional(),
    rescheduleDroppedTasks: z.boolean().optional(),
    maxTaskReschedule: z.number().optional(),
    logLevel: LogLevelOptionsRunnableJobCollectionScheduleRun$outboundSchema
      .optional(),
    jobTimeout: z.string().optional(),
    mode: z.string(),
    timeRangeType: z.string().optional(),
    earliest: z.number().optional(),
    latest: z.number().optional(),
    timestampTimezone: z.any().optional(),
    timeWarning: MetricsStore$outboundSchema.optional(),
    expression: z.string().optional(),
    minTaskSize: z.string().optional(),
    maxTaskSize: z.string().optional(),
  });

export function runSettingsTypeSavedJobCollectionScheduleToJSON(
  runSettingsTypeSavedJobCollectionSchedule:
    RunSettingsTypeSavedJobCollectionSchedule,
): string {
  return JSON.stringify(
    RunSettingsTypeSavedJobCollectionSchedule$outboundSchema.parse(
      runSettingsTypeSavedJobCollectionSchedule,
    ),
  );
}
export function runSettingsTypeSavedJobCollectionScheduleFromJSON(
  jsonString: string,
): SafeParseResult<
  RunSettingsTypeSavedJobCollectionSchedule,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RunSettingsTypeSavedJobCollectionSchedule$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RunSettingsTypeSavedJobCollectionSchedule' from JSON`,
  );
}
