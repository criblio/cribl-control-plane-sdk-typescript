/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const InputWinEventLogsType = {
  WinEventLogs: "win_event_logs",
} as const;
export type InputWinEventLogsType = ClosedEnum<typeof InputWinEventLogsType>;

export type InputWinEventLogsConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputWinEventLogsMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputWinEventLogsMode = OpenEnum<typeof InputWinEventLogsMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputWinEventLogsCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputWinEventLogsCompression = OpenEnum<
  typeof InputWinEventLogsCompression
>;

export type InputWinEventLogsPqControls = {};

export type InputWinEventLogsPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputWinEventLogsMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputWinEventLogsCompression | undefined;
  pqControls?: InputWinEventLogsPqControls | undefined;
};

/**
 * Read all stored and future event logs, or only future events
 */
export const ReadMode = {
  Oldest: "oldest",
  Newest: "newest",
} as const;
/**
 * Read all stored and future event logs, or only future events
 */
export type ReadMode = OpenEnum<typeof ReadMode>;

/**
 * Format of individual events
 */
export const EventFormat = {
  Json: "json",
  Xml: "xml",
} as const;
/**
 * Format of individual events
 */
export type EventFormat = OpenEnum<typeof EventFormat>;

export type InputWinEventLogsMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputWinEventLogs = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWinEventLogsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputWinEventLogsConnection> | undefined;
  pq?: InputWinEventLogsPq | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat | undefined;
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputWinEventLogsMetadatum> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputWinEventLogsType$inboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType
> = z.nativeEnum(InputWinEventLogsType);

/** @internal */
export const InputWinEventLogsType$outboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType
> = InputWinEventLogsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsType$ {
  /** @deprecated use `InputWinEventLogsType$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsType$inboundSchema;
  /** @deprecated use `InputWinEventLogsType$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsType$outboundSchema;
}

/** @internal */
export const InputWinEventLogsConnection$inboundSchema: z.ZodType<
  InputWinEventLogsConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputWinEventLogsConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputWinEventLogsConnection$outboundSchema: z.ZodType<
  InputWinEventLogsConnection$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsConnection$ {
  /** @deprecated use `InputWinEventLogsConnection$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsConnection$inboundSchema;
  /** @deprecated use `InputWinEventLogsConnection$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsConnection$outboundSchema;
  /** @deprecated use `InputWinEventLogsConnection$Outbound` instead. */
  export type Outbound = InputWinEventLogsConnection$Outbound;
}

export function inputWinEventLogsConnectionToJSON(
  inputWinEventLogsConnection: InputWinEventLogsConnection,
): string {
  return JSON.stringify(
    InputWinEventLogsConnection$outboundSchema.parse(
      inputWinEventLogsConnection,
    ),
  );
}

export function inputWinEventLogsConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsConnection' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogsMode$inboundSchema: z.ZodType<
  InputWinEventLogsMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWinEventLogsMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWinEventLogsMode$outboundSchema: z.ZodType<
  InputWinEventLogsMode,
  z.ZodTypeDef,
  InputWinEventLogsMode
> = z.union([
  z.nativeEnum(InputWinEventLogsMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsMode$ {
  /** @deprecated use `InputWinEventLogsMode$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsMode$inboundSchema;
  /** @deprecated use `InputWinEventLogsMode$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsMode$outboundSchema;
}

/** @internal */
export const InputWinEventLogsCompression$inboundSchema: z.ZodType<
  InputWinEventLogsCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWinEventLogsCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWinEventLogsCompression$outboundSchema: z.ZodType<
  InputWinEventLogsCompression,
  z.ZodTypeDef,
  InputWinEventLogsCompression
> = z.union([
  z.nativeEnum(InputWinEventLogsCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsCompression$ {
  /** @deprecated use `InputWinEventLogsCompression$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsCompression$inboundSchema;
  /** @deprecated use `InputWinEventLogsCompression$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsCompression$outboundSchema;
}

/** @internal */
export const InputWinEventLogsPqControls$inboundSchema: z.ZodType<
  InputWinEventLogsPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type InputWinEventLogsPqControls$Outbound = {};

/** @internal */
export const InputWinEventLogsPqControls$outboundSchema: z.ZodType<
  InputWinEventLogsPqControls$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsPqControls$ {
  /** @deprecated use `InputWinEventLogsPqControls$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsPqControls$inboundSchema;
  /** @deprecated use `InputWinEventLogsPqControls$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsPqControls$outboundSchema;
  /** @deprecated use `InputWinEventLogsPqControls$Outbound` instead. */
  export type Outbound = InputWinEventLogsPqControls$Outbound;
}

export function inputWinEventLogsPqControlsToJSON(
  inputWinEventLogsPqControls: InputWinEventLogsPqControls,
): string {
  return JSON.stringify(
    InputWinEventLogsPqControls$outboundSchema.parse(
      inputWinEventLogsPqControls,
    ),
  );
}

export function inputWinEventLogsPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsPqControls' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogsPq$inboundSchema: z.ZodType<
  InputWinEventLogsPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWinEventLogsMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWinEventLogsCompression$inboundSchema.default("none"),
  pqControls: z.lazy(() => InputWinEventLogsPqControls$inboundSchema)
    .optional(),
});

/** @internal */
export type InputWinEventLogsPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
  pqControls?: InputWinEventLogsPqControls$Outbound | undefined;
};

/** @internal */
export const InputWinEventLogsPq$outboundSchema: z.ZodType<
  InputWinEventLogsPq$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsPq
> = z.object({
  mode: InputWinEventLogsMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWinEventLogsCompression$outboundSchema.default("none"),
  pqControls: z.lazy(() => InputWinEventLogsPqControls$outboundSchema)
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsPq$ {
  /** @deprecated use `InputWinEventLogsPq$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsPq$inboundSchema;
  /** @deprecated use `InputWinEventLogsPq$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsPq$outboundSchema;
  /** @deprecated use `InputWinEventLogsPq$Outbound` instead. */
  export type Outbound = InputWinEventLogsPq$Outbound;
}

export function inputWinEventLogsPqToJSON(
  inputWinEventLogsPq: InputWinEventLogsPq,
): string {
  return JSON.stringify(
    InputWinEventLogsPq$outboundSchema.parse(inputWinEventLogsPq),
  );
}

export function inputWinEventLogsPqFromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsPq' from JSON`,
  );
}

/** @internal */
export const ReadMode$inboundSchema: z.ZodType<
  ReadMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ReadMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const ReadMode$outboundSchema: z.ZodType<
  ReadMode,
  z.ZodTypeDef,
  ReadMode
> = z.union([
  z.nativeEnum(ReadMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReadMode$ {
  /** @deprecated use `ReadMode$inboundSchema` instead. */
  export const inboundSchema = ReadMode$inboundSchema;
  /** @deprecated use `ReadMode$outboundSchema` instead. */
  export const outboundSchema = ReadMode$outboundSchema;
}

/** @internal */
export const EventFormat$inboundSchema: z.ZodType<
  EventFormat,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EventFormat),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const EventFormat$outboundSchema: z.ZodType<
  EventFormat,
  z.ZodTypeDef,
  EventFormat
> = z.union([
  z.nativeEnum(EventFormat),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace EventFormat$ {
  /** @deprecated use `EventFormat$inboundSchema` instead. */
  export const inboundSchema = EventFormat$inboundSchema;
  /** @deprecated use `EventFormat$outboundSchema` instead. */
  export const outboundSchema = EventFormat$outboundSchema;
}

/** @internal */
export const InputWinEventLogsMetadatum$inboundSchema: z.ZodType<
  InputWinEventLogsMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputWinEventLogsMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputWinEventLogsMetadatum$outboundSchema: z.ZodType<
  InputWinEventLogsMetadatum$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogsMetadatum$ {
  /** @deprecated use `InputWinEventLogsMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogsMetadatum$inboundSchema;
  /** @deprecated use `InputWinEventLogsMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogsMetadatum$outboundSchema;
  /** @deprecated use `InputWinEventLogsMetadatum$Outbound` instead. */
  export type Outbound = InputWinEventLogsMetadatum$Outbound;
}

export function inputWinEventLogsMetadatumToJSON(
  inputWinEventLogsMetadatum: InputWinEventLogsMetadatum,
): string {
  return JSON.stringify(
    InputWinEventLogsMetadatum$outboundSchema.parse(inputWinEventLogsMetadatum),
  );
}

export function inputWinEventLogsMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsMetadatum' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogs$inboundSchema: z.ZodType<
  InputWinEventLogs,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: InputWinEventLogsType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWinEventLogsConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputWinEventLogsPq$inboundSchema).optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode$inboundSchema.default("newest"),
  eventFormat: EventFormat$inboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(z.lazy(() => InputWinEventLogsMetadatum$inboundSchema))
    .optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
});

/** @internal */
export type InputWinEventLogs$Outbound = {
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputWinEventLogsConnection$Outbound> | undefined;
  pq?: InputWinEventLogsPq$Outbound | undefined;
  logNames: Array<string>;
  readMode: string;
  eventFormat: string;
  disableNativeModule: boolean;
  interval: number;
  batchSize: number;
  metadata?: Array<InputWinEventLogsMetadatum$Outbound> | undefined;
  maxEventBytes: number;
  description?: string | undefined;
};

/** @internal */
export const InputWinEventLogs$outboundSchema: z.ZodType<
  InputWinEventLogs$Outbound,
  z.ZodTypeDef,
  InputWinEventLogs
> = z.object({
  id: z.string().optional(),
  type: InputWinEventLogsType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWinEventLogsConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputWinEventLogsPq$outboundSchema).optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode$outboundSchema.default("newest"),
  eventFormat: EventFormat$outboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(z.lazy(() => InputWinEventLogsMetadatum$outboundSchema))
    .optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWinEventLogs$ {
  /** @deprecated use `InputWinEventLogs$inboundSchema` instead. */
  export const inboundSchema = InputWinEventLogs$inboundSchema;
  /** @deprecated use `InputWinEventLogs$outboundSchema` instead. */
  export const outboundSchema = InputWinEventLogs$outboundSchema;
  /** @deprecated use `InputWinEventLogs$Outbound` instead. */
  export type Outbound = InputWinEventLogs$Outbound;
}

export function inputWinEventLogsToJSON(
  inputWinEventLogs: InputWinEventLogs,
): string {
  return JSON.stringify(
    InputWinEventLogs$outboundSchema.parse(inputWinEventLogs),
  );
}

export function inputWinEventLogsFromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogs' from JSON`,
  );
}
