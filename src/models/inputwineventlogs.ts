/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  ConnectionsType,
  ConnectionsType$inboundSchema,
  ConnectionsType$Outbound,
  ConnectionsType$outboundSchema,
} from "./connectionstype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata1Type,
  Metadata1Type$inboundSchema,
  Metadata1Type$Outbound,
  Metadata1Type$outboundSchema,
} from "./metadata1type.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";

export const InputWinEventLogsType6 = {
  WinEventLogs: "win_event_logs",
} as const;
export type InputWinEventLogsType6 = ClosedEnum<typeof InputWinEventLogsType6>;

/**
 * Read all stored and future event logs, or only future events
 */
export const ReadMode6 = {
  /**
   * Entire log
   */
  Oldest: "oldest",
  /**
   * From last entry
   */
  Newest: "newest",
} as const;
/**
 * Read all stored and future event logs, or only future events
 */
export type ReadMode6 = OpenEnum<typeof ReadMode6>;

/**
 * Format of individual events
 */
export const EventFormat6 = {
  /**
   * JSON
   */
  Json: "json",
  /**
   * XML
   */
  Xml: "xml",
} as const;
/**
 * Format of individual events
 */
export type EventFormat6 = OpenEnum<typeof EventFormat6>;

export type InputWinEventLogsWinEventLogs6 = {
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWinEventLogsType6;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode6 | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat6 | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableJsonRendering?: boolean | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableXmlRendering?: boolean | undefined;
};

export const InputWinEventLogsType5 = {
  WinEventLogs: "win_event_logs",
} as const;
export type InputWinEventLogsType5 = ClosedEnum<typeof InputWinEventLogsType5>;

/**
 * Read all stored and future event logs, or only future events
 */
export const ReadMode5 = {
  /**
   * Entire log
   */
  Oldest: "oldest",
  /**
   * From last entry
   */
  Newest: "newest",
} as const;
/**
 * Read all stored and future event logs, or only future events
 */
export type ReadMode5 = OpenEnum<typeof ReadMode5>;

/**
 * Format of individual events
 */
export const EventFormat5 = {
  /**
   * JSON
   */
  Json: "json",
  /**
   * XML
   */
  Xml: "xml",
} as const;
/**
 * Format of individual events
 */
export type EventFormat5 = OpenEnum<typeof EventFormat5>;

export type InputWinEventLogsWinEventLogs5 = {
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWinEventLogsType5;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode5 | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat5 | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableJsonRendering?: boolean | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableXmlRendering?: boolean | undefined;
};

export const InputWinEventLogsType4 = {
  WinEventLogs: "win_event_logs",
} as const;
export type InputWinEventLogsType4 = ClosedEnum<typeof InputWinEventLogsType4>;

/**
 * Read all stored and future event logs, or only future events
 */
export const ReadMode4 = {
  /**
   * Entire log
   */
  Oldest: "oldest",
  /**
   * From last entry
   */
  Newest: "newest",
} as const;
/**
 * Read all stored and future event logs, or only future events
 */
export type ReadMode4 = OpenEnum<typeof ReadMode4>;

/**
 * Format of individual events
 */
export const EventFormat4 = {
  /**
   * JSON
   */
  Json: "json",
  /**
   * XML
   */
  Xml: "xml",
} as const;
/**
 * Format of individual events
 */
export type EventFormat4 = OpenEnum<typeof EventFormat4>;

export type InputWinEventLogsWinEventLogs4 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWinEventLogsType4;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq: PqType;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode4 | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat4 | undefined;
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableJsonRendering?: boolean | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableXmlRendering?: boolean | undefined;
};

export const InputWinEventLogsType3 = {
  WinEventLogs: "win_event_logs",
} as const;
export type InputWinEventLogsType3 = ClosedEnum<typeof InputWinEventLogsType3>;

/**
 * Read all stored and future event logs, or only future events
 */
export const ReadMode3 = {
  /**
   * Entire log
   */
  Oldest: "oldest",
  /**
   * From last entry
   */
  Newest: "newest",
} as const;
/**
 * Read all stored and future event logs, or only future events
 */
export type ReadMode3 = OpenEnum<typeof ReadMode3>;

/**
 * Format of individual events
 */
export const EventFormat3 = {
  /**
   * JSON
   */
  Json: "json",
  /**
   * XML
   */
  Xml: "xml",
} as const;
/**
 * Format of individual events
 */
export type EventFormat3 = OpenEnum<typeof EventFormat3>;

export type InputWinEventLogsWinEventLogs3 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWinEventLogsType3;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode3 | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat3 | undefined;
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableJsonRendering?: boolean | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableXmlRendering?: boolean | undefined;
};

export const InputWinEventLogsType2 = {
  WinEventLogs: "win_event_logs",
} as const;
export type InputWinEventLogsType2 = ClosedEnum<typeof InputWinEventLogsType2>;

/**
 * Read all stored and future event logs, or only future events
 */
export const ReadMode2 = {
  /**
   * Entire log
   */
  Oldest: "oldest",
  /**
   * From last entry
   */
  Newest: "newest",
} as const;
/**
 * Read all stored and future event logs, or only future events
 */
export type ReadMode2 = OpenEnum<typeof ReadMode2>;

/**
 * Format of individual events
 */
export const EventFormat2 = {
  /**
   * JSON
   */
  Json: "json",
  /**
   * XML
   */
  Xml: "xml",
} as const;
/**
 * Format of individual events
 */
export type EventFormat2 = OpenEnum<typeof EventFormat2>;

export type InputWinEventLogsWinEventLogs2 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWinEventLogsType2;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections: Array<ConnectionsType>;
  pq?: PqType | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode2 | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat2 | undefined;
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableJsonRendering?: boolean | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableXmlRendering?: boolean | undefined;
};

export const InputWinEventLogsType1 = {
  WinEventLogs: "win_event_logs",
} as const;
export type InputWinEventLogsType1 = ClosedEnum<typeof InputWinEventLogsType1>;

/**
 * Read all stored and future event logs, or only future events
 */
export const ReadMode1 = {
  /**
   * Entire log
   */
  Oldest: "oldest",
  /**
   * From last entry
   */
  Newest: "newest",
} as const;
/**
 * Read all stored and future event logs, or only future events
 */
export type ReadMode1 = OpenEnum<typeof ReadMode1>;

/**
 * Format of individual events
 */
export const EventFormat1 = {
  /**
   * JSON
   */
  Json: "json",
  /**
   * XML
   */
  Xml: "xml",
} as const;
/**
 * Format of individual events
 */
export type EventFormat1 = OpenEnum<typeof EventFormat1>;

export type InputWinEventLogsWinEventLogs1 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWinEventLogsType1;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs.
   */
  logNames: Array<string>;
  /**
   * Read all stored and future event logs, or only future events
   */
  readMode?: ReadMode1 | undefined;
  /**
   * Format of individual events
   */
  eventFormat?: EventFormat1 | undefined;
  /**
   * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings)
   */
  disableNativeModule?: boolean | undefined;
  /**
   * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  interval?: number | undefined;
  /**
   * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools)
   */
  batchSize?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * The maximum number of bytes in an event before it is flushed to the pipelines
   */
  maxEventBytes?: number | undefined;
  description?: string | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableJsonRendering?: boolean | undefined;
  /**
   * Enable/disable the rendering of localized event message strings (Applicable for 4.8.0 nodes and newer that use the Native API)
   */
  disableXmlRendering?: boolean | undefined;
};

export type InputWinEventLogs =
  | InputWinEventLogsWinEventLogs2
  | InputWinEventLogsWinEventLogs4
  | InputWinEventLogsWinEventLogs1
  | InputWinEventLogsWinEventLogs3
  | InputWinEventLogsWinEventLogs5
  | InputWinEventLogsWinEventLogs6;

/** @internal */
export const InputWinEventLogsType6$inboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType6
> = z.nativeEnum(InputWinEventLogsType6);
/** @internal */
export const InputWinEventLogsType6$outboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType6
> = InputWinEventLogsType6$inboundSchema;

/** @internal */
export const ReadMode6$inboundSchema: z.ZodType<
  ReadMode6,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ReadMode6),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ReadMode6$outboundSchema: z.ZodType<
  ReadMode6,
  z.ZodTypeDef,
  ReadMode6
> = z.union([
  z.nativeEnum(ReadMode6),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const EventFormat6$inboundSchema: z.ZodType<
  EventFormat6,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EventFormat6),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const EventFormat6$outboundSchema: z.ZodType<
  EventFormat6,
  z.ZodTypeDef,
  EventFormat6
> = z.union([
  z.nativeEnum(EventFormat6),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputWinEventLogsWinEventLogs6$inboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs6,
  z.ZodTypeDef,
  unknown
> = z.object({
  disableNativeModule: z.boolean().default(false),
  id: z.string().optional(),
  type: InputWinEventLogsType6$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode6$inboundSchema.default("newest"),
  eventFormat: EventFormat6$inboundSchema.default("json"),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});
/** @internal */
export type InputWinEventLogsWinEventLogs6$Outbound = {
  disableNativeModule: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  logNames: Array<string>;
  readMode: string;
  eventFormat: string;
  interval: number;
  batchSize: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  maxEventBytes: number;
  description?: string | undefined;
  disableJsonRendering: boolean;
  disableXmlRendering: boolean;
};

/** @internal */
export const InputWinEventLogsWinEventLogs6$outboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs6$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsWinEventLogs6
> = z.object({
  disableNativeModule: z.boolean().default(false),
  id: z.string().optional(),
  type: InputWinEventLogsType6$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode6$outboundSchema.default("newest"),
  eventFormat: EventFormat6$outboundSchema.default("json"),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});

export function inputWinEventLogsWinEventLogs6ToJSON(
  inputWinEventLogsWinEventLogs6: InputWinEventLogsWinEventLogs6,
): string {
  return JSON.stringify(
    InputWinEventLogsWinEventLogs6$outboundSchema.parse(
      inputWinEventLogsWinEventLogs6,
    ),
  );
}
export function inputWinEventLogsWinEventLogs6FromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsWinEventLogs6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsWinEventLogs6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsWinEventLogs6' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogsType5$inboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType5
> = z.nativeEnum(InputWinEventLogsType5);
/** @internal */
export const InputWinEventLogsType5$outboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType5
> = InputWinEventLogsType5$inboundSchema;

/** @internal */
export const ReadMode5$inboundSchema: z.ZodType<
  ReadMode5,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ReadMode5),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ReadMode5$outboundSchema: z.ZodType<
  ReadMode5,
  z.ZodTypeDef,
  ReadMode5
> = z.union([
  z.nativeEnum(ReadMode5),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const EventFormat5$inboundSchema: z.ZodType<
  EventFormat5,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EventFormat5),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const EventFormat5$outboundSchema: z.ZodType<
  EventFormat5,
  z.ZodTypeDef,
  EventFormat5
> = z.union([
  z.nativeEnum(EventFormat5),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputWinEventLogsWinEventLogs5$inboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs5,
  z.ZodTypeDef,
  unknown
> = z.object({
  disableNativeModule: z.boolean().default(false),
  id: z.string().optional(),
  type: InputWinEventLogsType5$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode5$inboundSchema.default("newest"),
  eventFormat: EventFormat5$inboundSchema.default("json"),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});
/** @internal */
export type InputWinEventLogsWinEventLogs5$Outbound = {
  disableNativeModule: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  logNames: Array<string>;
  readMode: string;
  eventFormat: string;
  interval: number;
  batchSize: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  maxEventBytes: number;
  description?: string | undefined;
  disableJsonRendering: boolean;
  disableXmlRendering: boolean;
};

/** @internal */
export const InputWinEventLogsWinEventLogs5$outboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs5$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsWinEventLogs5
> = z.object({
  disableNativeModule: z.boolean().default(false),
  id: z.string().optional(),
  type: InputWinEventLogsType5$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode5$outboundSchema.default("newest"),
  eventFormat: EventFormat5$outboundSchema.default("json"),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});

export function inputWinEventLogsWinEventLogs5ToJSON(
  inputWinEventLogsWinEventLogs5: InputWinEventLogsWinEventLogs5,
): string {
  return JSON.stringify(
    InputWinEventLogsWinEventLogs5$outboundSchema.parse(
      inputWinEventLogsWinEventLogs5,
    ),
  );
}
export function inputWinEventLogsWinEventLogs5FromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsWinEventLogs5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsWinEventLogs5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsWinEventLogs5' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogsType4$inboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType4
> = z.nativeEnum(InputWinEventLogsType4);
/** @internal */
export const InputWinEventLogsType4$outboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType4
> = InputWinEventLogsType4$inboundSchema;

/** @internal */
export const ReadMode4$inboundSchema: z.ZodType<
  ReadMode4,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ReadMode4),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ReadMode4$outboundSchema: z.ZodType<
  ReadMode4,
  z.ZodTypeDef,
  ReadMode4
> = z.union([
  z.nativeEnum(ReadMode4),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const EventFormat4$inboundSchema: z.ZodType<
  EventFormat4,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EventFormat4),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const EventFormat4$outboundSchema: z.ZodType<
  EventFormat4,
  z.ZodTypeDef,
  EventFormat4
> = z.union([
  z.nativeEnum(EventFormat4),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputWinEventLogsWinEventLogs4$inboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs4,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputWinEventLogsType4$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema,
  logNames: z.array(z.string()),
  readMode: ReadMode4$inboundSchema.default("newest"),
  eventFormat: EventFormat4$inboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});
/** @internal */
export type InputWinEventLogsWinEventLogs4$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq: PqType$Outbound;
  logNames: Array<string>;
  readMode: string;
  eventFormat: string;
  disableNativeModule: boolean;
  interval: number;
  batchSize: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  maxEventBytes: number;
  description?: string | undefined;
  disableJsonRendering: boolean;
  disableXmlRendering: boolean;
};

/** @internal */
export const InputWinEventLogsWinEventLogs4$outboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs4$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsWinEventLogs4
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputWinEventLogsType4$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema,
  logNames: z.array(z.string()),
  readMode: ReadMode4$outboundSchema.default("newest"),
  eventFormat: EventFormat4$outboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});

export function inputWinEventLogsWinEventLogs4ToJSON(
  inputWinEventLogsWinEventLogs4: InputWinEventLogsWinEventLogs4,
): string {
  return JSON.stringify(
    InputWinEventLogsWinEventLogs4$outboundSchema.parse(
      inputWinEventLogsWinEventLogs4,
    ),
  );
}
export function inputWinEventLogsWinEventLogs4FromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsWinEventLogs4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsWinEventLogs4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsWinEventLogs4' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogsType3$inboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType3
> = z.nativeEnum(InputWinEventLogsType3);
/** @internal */
export const InputWinEventLogsType3$outboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType3
> = InputWinEventLogsType3$inboundSchema;

/** @internal */
export const ReadMode3$inboundSchema: z.ZodType<
  ReadMode3,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ReadMode3),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ReadMode3$outboundSchema: z.ZodType<
  ReadMode3,
  z.ZodTypeDef,
  ReadMode3
> = z.union([
  z.nativeEnum(ReadMode3),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const EventFormat3$inboundSchema: z.ZodType<
  EventFormat3,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EventFormat3),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const EventFormat3$outboundSchema: z.ZodType<
  EventFormat3,
  z.ZodTypeDef,
  EventFormat3
> = z.union([
  z.nativeEnum(EventFormat3),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputWinEventLogsWinEventLogs3$inboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs3,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputWinEventLogsType3$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode3$inboundSchema.default("newest"),
  eventFormat: EventFormat3$inboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});
/** @internal */
export type InputWinEventLogsWinEventLogs3$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  logNames: Array<string>;
  readMode: string;
  eventFormat: string;
  disableNativeModule: boolean;
  interval: number;
  batchSize: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  maxEventBytes: number;
  description?: string | undefined;
  disableJsonRendering: boolean;
  disableXmlRendering: boolean;
};

/** @internal */
export const InputWinEventLogsWinEventLogs3$outboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs3$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsWinEventLogs3
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputWinEventLogsType3$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode3$outboundSchema.default("newest"),
  eventFormat: EventFormat3$outboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});

export function inputWinEventLogsWinEventLogs3ToJSON(
  inputWinEventLogsWinEventLogs3: InputWinEventLogsWinEventLogs3,
): string {
  return JSON.stringify(
    InputWinEventLogsWinEventLogs3$outboundSchema.parse(
      inputWinEventLogsWinEventLogs3,
    ),
  );
}
export function inputWinEventLogsWinEventLogs3FromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsWinEventLogs3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsWinEventLogs3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsWinEventLogs3' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogsType2$inboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType2
> = z.nativeEnum(InputWinEventLogsType2);
/** @internal */
export const InputWinEventLogsType2$outboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType2
> = InputWinEventLogsType2$inboundSchema;

/** @internal */
export const ReadMode2$inboundSchema: z.ZodType<
  ReadMode2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ReadMode2),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ReadMode2$outboundSchema: z.ZodType<
  ReadMode2,
  z.ZodTypeDef,
  ReadMode2
> = z.union([
  z.nativeEnum(ReadMode2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const EventFormat2$inboundSchema: z.ZodType<
  EventFormat2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EventFormat2),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const EventFormat2$outboundSchema: z.ZodType<
  EventFormat2,
  z.ZodTypeDef,
  EventFormat2
> = z.union([
  z.nativeEnum(EventFormat2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputWinEventLogsWinEventLogs2$inboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs2,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputWinEventLogsType2$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema),
  pq: PqType$inboundSchema.optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode2$inboundSchema.default("newest"),
  eventFormat: EventFormat2$inboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});
/** @internal */
export type InputWinEventLogsWinEventLogs2$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections: Array<ConnectionsType$Outbound>;
  pq?: PqType$Outbound | undefined;
  logNames: Array<string>;
  readMode: string;
  eventFormat: string;
  disableNativeModule: boolean;
  interval: number;
  batchSize: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  maxEventBytes: number;
  description?: string | undefined;
  disableJsonRendering: boolean;
  disableXmlRendering: boolean;
};

/** @internal */
export const InputWinEventLogsWinEventLogs2$outboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs2$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsWinEventLogs2
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputWinEventLogsType2$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema),
  pq: PqType$outboundSchema.optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode2$outboundSchema.default("newest"),
  eventFormat: EventFormat2$outboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});

export function inputWinEventLogsWinEventLogs2ToJSON(
  inputWinEventLogsWinEventLogs2: InputWinEventLogsWinEventLogs2,
): string {
  return JSON.stringify(
    InputWinEventLogsWinEventLogs2$outboundSchema.parse(
      inputWinEventLogsWinEventLogs2,
    ),
  );
}
export function inputWinEventLogsWinEventLogs2FromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsWinEventLogs2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsWinEventLogs2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsWinEventLogs2' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogsType1$inboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType1
> = z.nativeEnum(InputWinEventLogsType1);
/** @internal */
export const InputWinEventLogsType1$outboundSchema: z.ZodNativeEnum<
  typeof InputWinEventLogsType1
> = InputWinEventLogsType1$inboundSchema;

/** @internal */
export const ReadMode1$inboundSchema: z.ZodType<
  ReadMode1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ReadMode1),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ReadMode1$outboundSchema: z.ZodType<
  ReadMode1,
  z.ZodTypeDef,
  ReadMode1
> = z.union([
  z.nativeEnum(ReadMode1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const EventFormat1$inboundSchema: z.ZodType<
  EventFormat1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(EventFormat1),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const EventFormat1$outboundSchema: z.ZodType<
  EventFormat1,
  z.ZodTypeDef,
  EventFormat1
> = z.union([
  z.nativeEnum(EventFormat1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputWinEventLogsWinEventLogs1$inboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs1,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputWinEventLogsType1$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode1$inboundSchema.default("newest"),
  eventFormat: EventFormat1$inboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});
/** @internal */
export type InputWinEventLogsWinEventLogs1$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  logNames: Array<string>;
  readMode: string;
  eventFormat: string;
  disableNativeModule: boolean;
  interval: number;
  batchSize: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  maxEventBytes: number;
  description?: string | undefined;
  disableJsonRendering: boolean;
  disableXmlRendering: boolean;
};

/** @internal */
export const InputWinEventLogsWinEventLogs1$outboundSchema: z.ZodType<
  InputWinEventLogsWinEventLogs1$Outbound,
  z.ZodTypeDef,
  InputWinEventLogsWinEventLogs1
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputWinEventLogsType1$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  logNames: z.array(z.string()),
  readMode: ReadMode1$outboundSchema.default("newest"),
  eventFormat: EventFormat1$outboundSchema.default("json"),
  disableNativeModule: z.boolean().default(false),
  interval: z.number().default(10),
  batchSize: z.number().default(500),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  maxEventBytes: z.number().default(51200),
  description: z.string().optional(),
  disableJsonRendering: z.boolean().default(false),
  disableXmlRendering: z.boolean().default(true),
});

export function inputWinEventLogsWinEventLogs1ToJSON(
  inputWinEventLogsWinEventLogs1: InputWinEventLogsWinEventLogs1,
): string {
  return JSON.stringify(
    InputWinEventLogsWinEventLogs1$outboundSchema.parse(
      inputWinEventLogsWinEventLogs1,
    ),
  );
}
export function inputWinEventLogsWinEventLogs1FromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogsWinEventLogs1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogsWinEventLogs1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogsWinEventLogs1' from JSON`,
  );
}

/** @internal */
export const InputWinEventLogs$inboundSchema: z.ZodType<
  InputWinEventLogs,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputWinEventLogsWinEventLogs2$inboundSchema),
  z.lazy(() => InputWinEventLogsWinEventLogs4$inboundSchema),
  z.lazy(() => InputWinEventLogsWinEventLogs1$inboundSchema),
  z.lazy(() => InputWinEventLogsWinEventLogs3$inboundSchema),
  z.lazy(() => InputWinEventLogsWinEventLogs5$inboundSchema),
  z.lazy(() => InputWinEventLogsWinEventLogs6$inboundSchema),
]);
/** @internal */
export type InputWinEventLogs$Outbound =
  | InputWinEventLogsWinEventLogs2$Outbound
  | InputWinEventLogsWinEventLogs4$Outbound
  | InputWinEventLogsWinEventLogs1$Outbound
  | InputWinEventLogsWinEventLogs3$Outbound
  | InputWinEventLogsWinEventLogs5$Outbound
  | InputWinEventLogsWinEventLogs6$Outbound;

/** @internal */
export const InputWinEventLogs$outboundSchema: z.ZodType<
  InputWinEventLogs$Outbound,
  z.ZodTypeDef,
  InputWinEventLogs
> = z.union([
  z.lazy(() => InputWinEventLogsWinEventLogs2$outboundSchema),
  z.lazy(() => InputWinEventLogsWinEventLogs4$outboundSchema),
  z.lazy(() => InputWinEventLogsWinEventLogs1$outboundSchema),
  z.lazy(() => InputWinEventLogsWinEventLogs3$outboundSchema),
  z.lazy(() => InputWinEventLogsWinEventLogs5$outboundSchema),
  z.lazy(() => InputWinEventLogsWinEventLogs6$outboundSchema),
]);

export function inputWinEventLogsToJSON(
  inputWinEventLogs: InputWinEventLogs,
): string {
  return JSON.stringify(
    InputWinEventLogs$outboundSchema.parse(inputWinEventLogs),
  );
}
export function inputWinEventLogsFromJSON(
  jsonString: string,
): SafeParseResult<InputWinEventLogs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWinEventLogs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWinEventLogs' from JSON`,
  );
}
