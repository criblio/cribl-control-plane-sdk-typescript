/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  OutputModeOptions,
  OutputModeOptions$inboundSchema,
  OutputModeOptions$outboundSchema,
} from "./outputmodeoptions.js";
import {
  RetryTypeOptionsRetryRules,
  RetryTypeOptionsRetryRules$inboundSchema,
  RetryTypeOptionsRetryRules$outboundSchema,
} from "./retrytypeoptionsretryrules.js";

/**
 * Authentication method for Discover and Collect REST calls
 */
export const CollectorSplunkAuthentication4 = {
  /**
   * None
   */
  None: "none",
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * Basic (credentials secret)
   */
  BasicSecret: "basicSecret",
  /**
   * Bearer Token
   */
  Token: "token",
  /**
   * Bearer Token (text secret)
   */
  TokenSecret: "tokenSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls
 */
export type CollectorSplunkAuthentication4 = OpenEnum<
  typeof CollectorSplunkAuthentication4
>;

/**
 * Collector type: splunk
 */
export const CollectorSplunkType5 = {
  Splunk: "splunk",
} as const;
/**
 * Collector type: splunk
 */
export type CollectorSplunkType5 = ClosedEnum<typeof CollectorSplunkType5>;

export type CollectRequestParam4 = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type CollectorSplunkCollectRequestHeader4 = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type CollectorSplunkRetryRules4 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorSplunkSplunk4 = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication?: CollectorSplunkAuthentication4 | undefined;
  /**
   * URL to use for login API call, this call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are allowed.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Collector type: splunk
   */
  type: CollectorSplunkType5;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputModeOptions | undefined;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?: Array<CollectRequestParam4> | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?:
    | Array<CollectorSplunkCollectRequestHeader4>
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?: CollectorSplunkRetryRules4 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  /**
   * Select or create a stored secret that references your Bearer token
   */
  tokenSecret?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls
 */
export const CollectorSplunkAuthentication3 = {
  /**
   * None
   */
  None: "none",
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * Basic (credentials secret)
   */
  BasicSecret: "basicSecret",
  /**
   * Bearer Token
   */
  Token: "token",
  /**
   * Bearer Token (text secret)
   */
  TokenSecret: "tokenSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls
 */
export type CollectorSplunkAuthentication3 = OpenEnum<
  typeof CollectorSplunkAuthentication3
>;

/**
 * Collector type: splunk
 */
export const CollectorSplunkType4 = {
  Splunk: "splunk",
} as const;
/**
 * Collector type: splunk
 */
export type CollectorSplunkType4 = ClosedEnum<typeof CollectorSplunkType4>;

export type CollectRequestParam3 = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type CollectorSplunkCollectRequestHeader3 = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type CollectorSplunkRetryRules3 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorSplunkSplunk3 = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication?: CollectorSplunkAuthentication3 | undefined;
  /**
   * URL to use for login API call, this call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  username: string;
  password: string;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are allowed.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Collector type: splunk
   */
  type: CollectorSplunkType4;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputModeOptions | undefined;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?: Array<CollectRequestParam3> | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?:
    | Array<CollectorSplunkCollectRequestHeader3>
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?: CollectorSplunkRetryRules3 | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  token?: string | undefined;
  /**
   * Select or create a stored secret that references your Bearer token
   */
  tokenSecret?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls
 */
export const CollectorSplunkAuthentication2 = {
  /**
   * None
   */
  None: "none",
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * Basic (credentials secret)
   */
  BasicSecret: "basicSecret",
  /**
   * Bearer Token
   */
  Token: "token",
  /**
   * Bearer Token (text secret)
   */
  TokenSecret: "tokenSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls
 */
export type CollectorSplunkAuthentication2 = OpenEnum<
  typeof CollectorSplunkAuthentication2
>;

/**
 * Collector type: splunk
 */
export const CollectorSplunkType3 = {
  Splunk: "splunk",
} as const;
/**
 * Collector type: splunk
 */
export type CollectorSplunkType3 = ClosedEnum<typeof CollectorSplunkType3>;

export type CollectRequestParam2 = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type CollectorSplunkCollectRequestHeader2 = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type CollectorSplunkRetryRules2 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorSplunkSplunk2 = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication?: CollectorSplunkAuthentication2 | undefined;
  /**
   * Select or create a stored secret that references your Bearer token
   */
  tokenSecret: string;
  /**
   * Collector type: splunk
   */
  type: CollectorSplunkType3;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputModeOptions | undefined;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?: Array<CollectRequestParam2> | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?:
    | Array<CollectorSplunkCollectRequestHeader2>
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?: CollectorSplunkRetryRules2 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  token?: string | undefined;
  /**
   * URL to use for login API call, this call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are allowed.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls
 */
export const CollectorSplunkAuthentication1 = {
  /**
   * None
   */
  None: "none",
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * Basic (credentials secret)
   */
  BasicSecret: "basicSecret",
  /**
   * Bearer Token
   */
  Token: "token",
  /**
   * Bearer Token (text secret)
   */
  TokenSecret: "tokenSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls
 */
export type CollectorSplunkAuthentication1 = OpenEnum<
  typeof CollectorSplunkAuthentication1
>;

/**
 * Collector type: splunk
 */
export const CollectorSplunkType2 = {
  Splunk: "splunk",
} as const;
/**
 * Collector type: splunk
 */
export type CollectorSplunkType2 = ClosedEnum<typeof CollectorSplunkType2>;

export type CollectRequestParam1 = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type CollectorSplunkCollectRequestHeader1 = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type CollectorSplunkRetryRules1 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorSplunkSplunk1 = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication?: CollectorSplunkAuthentication1 | undefined;
  token: string;
  /**
   * Collector type: splunk
   */
  type: CollectorSplunkType2;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputModeOptions | undefined;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?: Array<CollectRequestParam1> | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?:
    | Array<CollectorSplunkCollectRequestHeader1>
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?: CollectorSplunkRetryRules1 | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored secret that references your Bearer token
   */
  tokenSecret?: string | undefined;
  /**
   * URL to use for login API call, this call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are allowed.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls
 */
export const AuthenticationSplunk = {
  /**
   * None
   */
  None: "none",
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * Basic (credentials secret)
   */
  BasicSecret: "basicSecret",
  /**
   * Bearer Token
   */
  Token: "token",
  /**
   * Bearer Token (text secret)
   */
  TokenSecret: "tokenSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls
 */
export type AuthenticationSplunk = OpenEnum<typeof AuthenticationSplunk>;

/**
 * Collector type: splunk
 */
export const CollectorSplunkType1 = {
  Splunk: "splunk",
} as const;
/**
 * Collector type: splunk
 */
export type CollectorSplunkType1 = ClosedEnum<typeof CollectorSplunkType1>;

export type CollectRequestParamSplunk = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type CollectRequestHeaderSplunk = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type RetryRulesSplunk = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorSplunkCollectorHealthCheckPart2Type = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication?: AuthenticationSplunk | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Collector type: splunk
   */
  type: CollectorSplunkType1;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputModeOptions | undefined;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?: Array<CollectRequestParamSplunk> | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?: Array<CollectRequestHeaderSplunk> | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?: RetryRulesSplunk | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  /**
   * Select or create a stored secret that references your Bearer token
   */
  tokenSecret?: string | undefined;
  /**
   * URL to use for login API call, this call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are allowed.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
};

export type CollectorSplunkCollectorHealthCheckPart1Type = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication?: AuthenticationSplunk | undefined;
  username: string;
  password: string;
  /**
   * Collector type: splunk
   */
  type: CollectorSplunkType1;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputModeOptions | undefined;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?: Array<CollectRequestParamSplunk> | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?: Array<CollectRequestHeaderSplunk> | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?: RetryRulesSplunk | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  token?: string | undefined;
  /**
   * Select or create a stored secret that references your Bearer token
   */
  tokenSecret?: string | undefined;
  /**
   * URL to use for login API call, this call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are allowed.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
};

export type CollectorSplunkCollectorHealthCheckPart0Type = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication?: AuthenticationSplunk | undefined;
  /**
   * Collector type: splunk
   */
  type: CollectorSplunkType1;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: OutputModeOptions | undefined;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?: Array<CollectRequestParamSplunk> | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?: Array<CollectRequestHeaderSplunk> | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?: RetryRulesSplunk | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  token?: string | undefined;
  /**
   * Select or create a stored secret that references your Bearer token
   */
  tokenSecret?: string | undefined;
  /**
   * URL to use for login API call, this call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are allowed.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
};

export type CollectorSplunk =
  | CollectorSplunkCollectorHealthCheckPart1Type
  | CollectorSplunkSplunk3
  | CollectorSplunkCollectorHealthCheckPart2Type
  | CollectorSplunkSplunk1
  | CollectorSplunkSplunk2
  | CollectorSplunkSplunk4
  | CollectorSplunkCollectorHealthCheckPart0Type;

/** @internal */
export const CollectorSplunkAuthentication4$inboundSchema: z.ZodType<
  CollectorSplunkAuthentication4,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorSplunkAuthentication4);
/** @internal */
export const CollectorSplunkAuthentication4$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorSplunkAuthentication4
> = openEnums.outboundSchema(CollectorSplunkAuthentication4);

/** @internal */
export const CollectorSplunkType5$inboundSchema: z.ZodNativeEnum<
  typeof CollectorSplunkType5
> = z.nativeEnum(CollectorSplunkType5);
/** @internal */
export const CollectorSplunkType5$outboundSchema: z.ZodNativeEnum<
  typeof CollectorSplunkType5
> = CollectorSplunkType5$inboundSchema;

/** @internal */
export const CollectRequestParam4$inboundSchema: z.ZodType<
  CollectRequestParam4,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectRequestParam4$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectRequestParam4$outboundSchema: z.ZodType<
  CollectRequestParam4$Outbound,
  z.ZodTypeDef,
  CollectRequestParam4
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectRequestParam4ToJSON(
  collectRequestParam4: CollectRequestParam4,
): string {
  return JSON.stringify(
    CollectRequestParam4$outboundSchema.parse(collectRequestParam4),
  );
}
export function collectRequestParam4FromJSON(
  jsonString: string,
): SafeParseResult<CollectRequestParam4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectRequestParam4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectRequestParam4' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkCollectRequestHeader4$inboundSchema: z.ZodType<
  CollectorSplunkCollectRequestHeader4,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorSplunkCollectRequestHeader4$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorSplunkCollectRequestHeader4$outboundSchema: z.ZodType<
  CollectorSplunkCollectRequestHeader4$Outbound,
  z.ZodTypeDef,
  CollectorSplunkCollectRequestHeader4
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectorSplunkCollectRequestHeader4ToJSON(
  collectorSplunkCollectRequestHeader4: CollectorSplunkCollectRequestHeader4,
): string {
  return JSON.stringify(
    CollectorSplunkCollectRequestHeader4$outboundSchema.parse(
      collectorSplunkCollectRequestHeader4,
    ),
  );
}
export function collectorSplunkCollectRequestHeader4FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkCollectRequestHeader4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorSplunkCollectRequestHeader4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkCollectRequestHeader4' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkRetryRules4$inboundSchema: z.ZodType<
  CollectorSplunkRetryRules4,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorSplunkRetryRules4$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorSplunkRetryRules4$outboundSchema: z.ZodType<
  CollectorSplunkRetryRules4$Outbound,
  z.ZodTypeDef,
  CollectorSplunkRetryRules4
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorSplunkRetryRules4ToJSON(
  collectorSplunkRetryRules4: CollectorSplunkRetryRules4,
): string {
  return JSON.stringify(
    CollectorSplunkRetryRules4$outboundSchema.parse(collectorSplunkRetryRules4),
  );
}
export function collectorSplunkRetryRules4FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkRetryRules4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorSplunkRetryRules4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkRetryRules4' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkSplunk4$inboundSchema: z.ZodType<
  CollectorSplunkSplunk4,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorSplunkAuthentication4$inboundSchema.default("basic"),
  loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
  credentialsSecret: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().default("token"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  type: CollectorSplunkType5$inboundSchema,
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputModeOptions$inboundSchema.default("json"),
  collectRequestParams: z.array(
    z.lazy(() => CollectRequestParam4$inboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorSplunkCollectRequestHeader4$inboundSchema),
  ).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => CollectorSplunkRetryRules4$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  tokenSecret: z.string().optional(),
});
/** @internal */
export type CollectorSplunkSplunk4$Outbound = {
  authentication: string;
  loginUrl: string;
  credentialsSecret: string;
  loginBody: string;
  tokenRespAttribute: string;
  authHeaderExpr: string;
  type: string;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?: Array<CollectRequestParam4$Outbound> | undefined;
  collectRequestHeaders?:
    | Array<CollectorSplunkCollectRequestHeader4$Outbound>
    | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  rejectUnauthorized: boolean;
  handleEscapedChars: boolean;
  retryRules?: CollectorSplunkRetryRules4$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  tokenSecret?: string | undefined;
};

/** @internal */
export const CollectorSplunkSplunk4$outboundSchema: z.ZodType<
  CollectorSplunkSplunk4$Outbound,
  z.ZodTypeDef,
  CollectorSplunkSplunk4
> = z.object({
  authentication: CollectorSplunkAuthentication4$outboundSchema.default(
    "basic",
  ),
  loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
  credentialsSecret: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().default("token"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  type: CollectorSplunkType5$outboundSchema,
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputModeOptions$outboundSchema.default("json"),
  collectRequestParams: z.array(
    z.lazy(() => CollectRequestParam4$outboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorSplunkCollectRequestHeader4$outboundSchema),
  ).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => CollectorSplunkRetryRules4$outboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  tokenSecret: z.string().optional(),
});

export function collectorSplunkSplunk4ToJSON(
  collectorSplunkSplunk4: CollectorSplunkSplunk4,
): string {
  return JSON.stringify(
    CollectorSplunkSplunk4$outboundSchema.parse(collectorSplunkSplunk4),
  );
}
export function collectorSplunkSplunk4FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkSplunk4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorSplunkSplunk4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkSplunk4' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkAuthentication3$inboundSchema: z.ZodType<
  CollectorSplunkAuthentication3,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorSplunkAuthentication3);
/** @internal */
export const CollectorSplunkAuthentication3$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorSplunkAuthentication3
> = openEnums.outboundSchema(CollectorSplunkAuthentication3);

/** @internal */
export const CollectorSplunkType4$inboundSchema: z.ZodNativeEnum<
  typeof CollectorSplunkType4
> = z.nativeEnum(CollectorSplunkType4);
/** @internal */
export const CollectorSplunkType4$outboundSchema: z.ZodNativeEnum<
  typeof CollectorSplunkType4
> = CollectorSplunkType4$inboundSchema;

/** @internal */
export const CollectRequestParam3$inboundSchema: z.ZodType<
  CollectRequestParam3,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectRequestParam3$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectRequestParam3$outboundSchema: z.ZodType<
  CollectRequestParam3$Outbound,
  z.ZodTypeDef,
  CollectRequestParam3
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectRequestParam3ToJSON(
  collectRequestParam3: CollectRequestParam3,
): string {
  return JSON.stringify(
    CollectRequestParam3$outboundSchema.parse(collectRequestParam3),
  );
}
export function collectRequestParam3FromJSON(
  jsonString: string,
): SafeParseResult<CollectRequestParam3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectRequestParam3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectRequestParam3' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkCollectRequestHeader3$inboundSchema: z.ZodType<
  CollectorSplunkCollectRequestHeader3,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorSplunkCollectRequestHeader3$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorSplunkCollectRequestHeader3$outboundSchema: z.ZodType<
  CollectorSplunkCollectRequestHeader3$Outbound,
  z.ZodTypeDef,
  CollectorSplunkCollectRequestHeader3
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectorSplunkCollectRequestHeader3ToJSON(
  collectorSplunkCollectRequestHeader3: CollectorSplunkCollectRequestHeader3,
): string {
  return JSON.stringify(
    CollectorSplunkCollectRequestHeader3$outboundSchema.parse(
      collectorSplunkCollectRequestHeader3,
    ),
  );
}
export function collectorSplunkCollectRequestHeader3FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkCollectRequestHeader3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorSplunkCollectRequestHeader3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkCollectRequestHeader3' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkRetryRules3$inboundSchema: z.ZodType<
  CollectorSplunkRetryRules3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorSplunkRetryRules3$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorSplunkRetryRules3$outboundSchema: z.ZodType<
  CollectorSplunkRetryRules3$Outbound,
  z.ZodTypeDef,
  CollectorSplunkRetryRules3
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorSplunkRetryRules3ToJSON(
  collectorSplunkRetryRules3: CollectorSplunkRetryRules3,
): string {
  return JSON.stringify(
    CollectorSplunkRetryRules3$outboundSchema.parse(collectorSplunkRetryRules3),
  );
}
export function collectorSplunkRetryRules3FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkRetryRules3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorSplunkRetryRules3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkRetryRules3' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkSplunk3$inboundSchema: z.ZodType<
  CollectorSplunkSplunk3,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorSplunkAuthentication3$inboundSchema.default("basic"),
  loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
  username: z.string(),
  password: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().default("token"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  type: CollectorSplunkType4$inboundSchema,
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputModeOptions$inboundSchema.default("json"),
  collectRequestParams: z.array(
    z.lazy(() => CollectRequestParam3$inboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorSplunkCollectRequestHeader3$inboundSchema),
  ).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => CollectorSplunkRetryRules3$inboundSchema).optional(),
  credentialsSecret: z.string().optional(),
  token: z.string().optional(),
  tokenSecret: z.string().optional(),
});
/** @internal */
export type CollectorSplunkSplunk3$Outbound = {
  authentication: string;
  loginUrl: string;
  username: string;
  password: string;
  loginBody: string;
  tokenRespAttribute: string;
  authHeaderExpr: string;
  type: string;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?: Array<CollectRequestParam3$Outbound> | undefined;
  collectRequestHeaders?:
    | Array<CollectorSplunkCollectRequestHeader3$Outbound>
    | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  rejectUnauthorized: boolean;
  handleEscapedChars: boolean;
  retryRules?: CollectorSplunkRetryRules3$Outbound | undefined;
  credentialsSecret?: string | undefined;
  token?: string | undefined;
  tokenSecret?: string | undefined;
};

/** @internal */
export const CollectorSplunkSplunk3$outboundSchema: z.ZodType<
  CollectorSplunkSplunk3$Outbound,
  z.ZodTypeDef,
  CollectorSplunkSplunk3
> = z.object({
  authentication: CollectorSplunkAuthentication3$outboundSchema.default(
    "basic",
  ),
  loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
  username: z.string(),
  password: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().default("token"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  type: CollectorSplunkType4$outboundSchema,
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputModeOptions$outboundSchema.default("json"),
  collectRequestParams: z.array(
    z.lazy(() => CollectRequestParam3$outboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorSplunkCollectRequestHeader3$outboundSchema),
  ).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => CollectorSplunkRetryRules3$outboundSchema)
    .optional(),
  credentialsSecret: z.string().optional(),
  token: z.string().optional(),
  tokenSecret: z.string().optional(),
});

export function collectorSplunkSplunk3ToJSON(
  collectorSplunkSplunk3: CollectorSplunkSplunk3,
): string {
  return JSON.stringify(
    CollectorSplunkSplunk3$outboundSchema.parse(collectorSplunkSplunk3),
  );
}
export function collectorSplunkSplunk3FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkSplunk3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorSplunkSplunk3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkSplunk3' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkAuthentication2$inboundSchema: z.ZodType<
  CollectorSplunkAuthentication2,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorSplunkAuthentication2);
/** @internal */
export const CollectorSplunkAuthentication2$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorSplunkAuthentication2
> = openEnums.outboundSchema(CollectorSplunkAuthentication2);

/** @internal */
export const CollectorSplunkType3$inboundSchema: z.ZodNativeEnum<
  typeof CollectorSplunkType3
> = z.nativeEnum(CollectorSplunkType3);
/** @internal */
export const CollectorSplunkType3$outboundSchema: z.ZodNativeEnum<
  typeof CollectorSplunkType3
> = CollectorSplunkType3$inboundSchema;

/** @internal */
export const CollectRequestParam2$inboundSchema: z.ZodType<
  CollectRequestParam2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectRequestParam2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectRequestParam2$outboundSchema: z.ZodType<
  CollectRequestParam2$Outbound,
  z.ZodTypeDef,
  CollectRequestParam2
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectRequestParam2ToJSON(
  collectRequestParam2: CollectRequestParam2,
): string {
  return JSON.stringify(
    CollectRequestParam2$outboundSchema.parse(collectRequestParam2),
  );
}
export function collectRequestParam2FromJSON(
  jsonString: string,
): SafeParseResult<CollectRequestParam2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectRequestParam2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectRequestParam2' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkCollectRequestHeader2$inboundSchema: z.ZodType<
  CollectorSplunkCollectRequestHeader2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorSplunkCollectRequestHeader2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorSplunkCollectRequestHeader2$outboundSchema: z.ZodType<
  CollectorSplunkCollectRequestHeader2$Outbound,
  z.ZodTypeDef,
  CollectorSplunkCollectRequestHeader2
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectorSplunkCollectRequestHeader2ToJSON(
  collectorSplunkCollectRequestHeader2: CollectorSplunkCollectRequestHeader2,
): string {
  return JSON.stringify(
    CollectorSplunkCollectRequestHeader2$outboundSchema.parse(
      collectorSplunkCollectRequestHeader2,
    ),
  );
}
export function collectorSplunkCollectRequestHeader2FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkCollectRequestHeader2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorSplunkCollectRequestHeader2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkCollectRequestHeader2' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkRetryRules2$inboundSchema: z.ZodType<
  CollectorSplunkRetryRules2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorSplunkRetryRules2$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorSplunkRetryRules2$outboundSchema: z.ZodType<
  CollectorSplunkRetryRules2$Outbound,
  z.ZodTypeDef,
  CollectorSplunkRetryRules2
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorSplunkRetryRules2ToJSON(
  collectorSplunkRetryRules2: CollectorSplunkRetryRules2,
): string {
  return JSON.stringify(
    CollectorSplunkRetryRules2$outboundSchema.parse(collectorSplunkRetryRules2),
  );
}
export function collectorSplunkRetryRules2FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkRetryRules2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorSplunkRetryRules2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkRetryRules2' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkSplunk2$inboundSchema: z.ZodType<
  CollectorSplunkSplunk2,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorSplunkAuthentication2$inboundSchema.default("basic"),
  tokenSecret: z.string(),
  type: CollectorSplunkType3$inboundSchema,
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputModeOptions$inboundSchema.default("json"),
  collectRequestParams: z.array(
    z.lazy(() => CollectRequestParam2$inboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorSplunkCollectRequestHeader2$inboundSchema),
  ).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => CollectorSplunkRetryRules2$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  token: z.string().optional(),
  loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().default("token"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
});
/** @internal */
export type CollectorSplunkSplunk2$Outbound = {
  authentication: string;
  tokenSecret: string;
  type: string;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?: Array<CollectRequestParam2$Outbound> | undefined;
  collectRequestHeaders?:
    | Array<CollectorSplunkCollectRequestHeader2$Outbound>
    | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  rejectUnauthorized: boolean;
  handleEscapedChars: boolean;
  retryRules?: CollectorSplunkRetryRules2$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  token?: string | undefined;
  loginUrl: string;
  loginBody: string;
  tokenRespAttribute: string;
  authHeaderExpr: string;
};

/** @internal */
export const CollectorSplunkSplunk2$outboundSchema: z.ZodType<
  CollectorSplunkSplunk2$Outbound,
  z.ZodTypeDef,
  CollectorSplunkSplunk2
> = z.object({
  authentication: CollectorSplunkAuthentication2$outboundSchema.default(
    "basic",
  ),
  tokenSecret: z.string(),
  type: CollectorSplunkType3$outboundSchema,
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputModeOptions$outboundSchema.default("json"),
  collectRequestParams: z.array(
    z.lazy(() => CollectRequestParam2$outboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorSplunkCollectRequestHeader2$outboundSchema),
  ).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => CollectorSplunkRetryRules2$outboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  token: z.string().optional(),
  loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().default("token"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
});

export function collectorSplunkSplunk2ToJSON(
  collectorSplunkSplunk2: CollectorSplunkSplunk2,
): string {
  return JSON.stringify(
    CollectorSplunkSplunk2$outboundSchema.parse(collectorSplunkSplunk2),
  );
}
export function collectorSplunkSplunk2FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkSplunk2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorSplunkSplunk2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkSplunk2' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkAuthentication1$inboundSchema: z.ZodType<
  CollectorSplunkAuthentication1,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorSplunkAuthentication1);
/** @internal */
export const CollectorSplunkAuthentication1$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorSplunkAuthentication1
> = openEnums.outboundSchema(CollectorSplunkAuthentication1);

/** @internal */
export const CollectorSplunkType2$inboundSchema: z.ZodNativeEnum<
  typeof CollectorSplunkType2
> = z.nativeEnum(CollectorSplunkType2);
/** @internal */
export const CollectorSplunkType2$outboundSchema: z.ZodNativeEnum<
  typeof CollectorSplunkType2
> = CollectorSplunkType2$inboundSchema;

/** @internal */
export const CollectRequestParam1$inboundSchema: z.ZodType<
  CollectRequestParam1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectRequestParam1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectRequestParam1$outboundSchema: z.ZodType<
  CollectRequestParam1$Outbound,
  z.ZodTypeDef,
  CollectRequestParam1
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectRequestParam1ToJSON(
  collectRequestParam1: CollectRequestParam1,
): string {
  return JSON.stringify(
    CollectRequestParam1$outboundSchema.parse(collectRequestParam1),
  );
}
export function collectRequestParam1FromJSON(
  jsonString: string,
): SafeParseResult<CollectRequestParam1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectRequestParam1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectRequestParam1' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkCollectRequestHeader1$inboundSchema: z.ZodType<
  CollectorSplunkCollectRequestHeader1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorSplunkCollectRequestHeader1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorSplunkCollectRequestHeader1$outboundSchema: z.ZodType<
  CollectorSplunkCollectRequestHeader1$Outbound,
  z.ZodTypeDef,
  CollectorSplunkCollectRequestHeader1
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectorSplunkCollectRequestHeader1ToJSON(
  collectorSplunkCollectRequestHeader1: CollectorSplunkCollectRequestHeader1,
): string {
  return JSON.stringify(
    CollectorSplunkCollectRequestHeader1$outboundSchema.parse(
      collectorSplunkCollectRequestHeader1,
    ),
  );
}
export function collectorSplunkCollectRequestHeader1FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkCollectRequestHeader1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorSplunkCollectRequestHeader1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkCollectRequestHeader1' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkRetryRules1$inboundSchema: z.ZodType<
  CollectorSplunkRetryRules1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorSplunkRetryRules1$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorSplunkRetryRules1$outboundSchema: z.ZodType<
  CollectorSplunkRetryRules1$Outbound,
  z.ZodTypeDef,
  CollectorSplunkRetryRules1
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorSplunkRetryRules1ToJSON(
  collectorSplunkRetryRules1: CollectorSplunkRetryRules1,
): string {
  return JSON.stringify(
    CollectorSplunkRetryRules1$outboundSchema.parse(collectorSplunkRetryRules1),
  );
}
export function collectorSplunkRetryRules1FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkRetryRules1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorSplunkRetryRules1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkRetryRules1' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkSplunk1$inboundSchema: z.ZodType<
  CollectorSplunkSplunk1,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorSplunkAuthentication1$inboundSchema.default("basic"),
  token: z.string(),
  type: CollectorSplunkType2$inboundSchema,
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputModeOptions$inboundSchema.default("json"),
  collectRequestParams: z.array(
    z.lazy(() => CollectRequestParam1$inboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorSplunkCollectRequestHeader1$inboundSchema),
  ).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => CollectorSplunkRetryRules1$inboundSchema).optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  tokenSecret: z.string().optional(),
  loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().default("token"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
});
/** @internal */
export type CollectorSplunkSplunk1$Outbound = {
  authentication: string;
  token: string;
  type: string;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?: Array<CollectRequestParam1$Outbound> | undefined;
  collectRequestHeaders?:
    | Array<CollectorSplunkCollectRequestHeader1$Outbound>
    | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  rejectUnauthorized: boolean;
  handleEscapedChars: boolean;
  retryRules?: CollectorSplunkRetryRules1$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  tokenSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  tokenRespAttribute: string;
  authHeaderExpr: string;
};

/** @internal */
export const CollectorSplunkSplunk1$outboundSchema: z.ZodType<
  CollectorSplunkSplunk1$Outbound,
  z.ZodTypeDef,
  CollectorSplunkSplunk1
> = z.object({
  authentication: CollectorSplunkAuthentication1$outboundSchema.default(
    "basic",
  ),
  token: z.string(),
  type: CollectorSplunkType2$outboundSchema,
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: OutputModeOptions$outboundSchema.default("json"),
  collectRequestParams: z.array(
    z.lazy(() => CollectRequestParam1$outboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorSplunkCollectRequestHeader1$outboundSchema),
  ).optional(),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => CollectorSplunkRetryRules1$outboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  tokenSecret: z.string().optional(),
  loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().default("token"),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
});

export function collectorSplunkSplunk1ToJSON(
  collectorSplunkSplunk1: CollectorSplunkSplunk1,
): string {
  return JSON.stringify(
    CollectorSplunkSplunk1$outboundSchema.parse(collectorSplunkSplunk1),
  );
}
export function collectorSplunkSplunk1FromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkSplunk1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorSplunkSplunk1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkSplunk1' from JSON`,
  );
}

/** @internal */
export const AuthenticationSplunk$inboundSchema: z.ZodType<
  AuthenticationSplunk,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(AuthenticationSplunk);
/** @internal */
export const AuthenticationSplunk$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  AuthenticationSplunk
> = openEnums.outboundSchema(AuthenticationSplunk);

/** @internal */
export const CollectorSplunkType1$inboundSchema: z.ZodNativeEnum<
  typeof CollectorSplunkType1
> = z.nativeEnum(CollectorSplunkType1);
/** @internal */
export const CollectorSplunkType1$outboundSchema: z.ZodNativeEnum<
  typeof CollectorSplunkType1
> = CollectorSplunkType1$inboundSchema;

/** @internal */
export const CollectRequestParamSplunk$inboundSchema: z.ZodType<
  CollectRequestParamSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectRequestParamSplunk$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectRequestParamSplunk$outboundSchema: z.ZodType<
  CollectRequestParamSplunk$Outbound,
  z.ZodTypeDef,
  CollectRequestParamSplunk
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectRequestParamSplunkToJSON(
  collectRequestParamSplunk: CollectRequestParamSplunk,
): string {
  return JSON.stringify(
    CollectRequestParamSplunk$outboundSchema.parse(collectRequestParamSplunk),
  );
}
export function collectRequestParamSplunkFromJSON(
  jsonString: string,
): SafeParseResult<CollectRequestParamSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectRequestParamSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectRequestParamSplunk' from JSON`,
  );
}

/** @internal */
export const CollectRequestHeaderSplunk$inboundSchema: z.ZodType<
  CollectRequestHeaderSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectRequestHeaderSplunk$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectRequestHeaderSplunk$outboundSchema: z.ZodType<
  CollectRequestHeaderSplunk$Outbound,
  z.ZodTypeDef,
  CollectRequestHeaderSplunk
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectRequestHeaderSplunkToJSON(
  collectRequestHeaderSplunk: CollectRequestHeaderSplunk,
): string {
  return JSON.stringify(
    CollectRequestHeaderSplunk$outboundSchema.parse(collectRequestHeaderSplunk),
  );
}
export function collectRequestHeaderSplunkFromJSON(
  jsonString: string,
): SafeParseResult<CollectRequestHeaderSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectRequestHeaderSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectRequestHeaderSplunk' from JSON`,
  );
}

/** @internal */
export const RetryRulesSplunk$inboundSchema: z.ZodType<
  RetryRulesSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type RetryRulesSplunk$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const RetryRulesSplunk$outboundSchema: z.ZodType<
  RetryRulesSplunk$Outbound,
  z.ZodTypeDef,
  RetryRulesSplunk
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function retryRulesSplunkToJSON(
  retryRulesSplunk: RetryRulesSplunk,
): string {
  return JSON.stringify(
    RetryRulesSplunk$outboundSchema.parse(retryRulesSplunk),
  );
}
export function retryRulesSplunkFromJSON(
  jsonString: string,
): SafeParseResult<RetryRulesSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetryRulesSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetryRulesSplunk' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkCollectorHealthCheckPart2Type$inboundSchema:
  z.ZodType<
    CollectorSplunkCollectorHealthCheckPart2Type,
    z.ZodTypeDef,
    unknown
  > = z.object({
    authentication: AuthenticationSplunk$inboundSchema.default("basic"),
    credentialsSecret: z.string(),
    type: CollectorSplunkType1$inboundSchema,
    searchHead: z.string().default("https://localhost:8089"),
    search: z.string(),
    earliest: z.string().optional(),
    latest: z.string().optional(),
    endpoint: z.string().default("/services/search/v2/jobs/export"),
    outputMode: OutputModeOptions$inboundSchema.default("json"),
    collectRequestParams: z.array(
      z.lazy(() => CollectRequestParamSplunk$inboundSchema),
    ).optional(),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderSplunk$inboundSchema),
    ).optional(),
    timeout: z.number().default(0),
    useRoundRobinDns: z.boolean().default(false),
    disableTimeFilter: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(false),
    handleEscapedChars: z.boolean().default(false),
    retryRules: z.lazy(() => RetryRulesSplunk$inboundSchema).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    tokenSecret: z.string().optional(),
    loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().default("token"),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
  });
/** @internal */
export type CollectorSplunkCollectorHealthCheckPart2Type$Outbound = {
  authentication: string;
  credentialsSecret: string;
  type: string;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?: Array<CollectRequestParamSplunk$Outbound> | undefined;
  collectRequestHeaders?:
    | Array<CollectRequestHeaderSplunk$Outbound>
    | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  rejectUnauthorized: boolean;
  handleEscapedChars: boolean;
  retryRules?: RetryRulesSplunk$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  tokenSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  tokenRespAttribute: string;
  authHeaderExpr: string;
};

/** @internal */
export const CollectorSplunkCollectorHealthCheckPart2Type$outboundSchema:
  z.ZodType<
    CollectorSplunkCollectorHealthCheckPart2Type$Outbound,
    z.ZodTypeDef,
    CollectorSplunkCollectorHealthCheckPart2Type
  > = z.object({
    authentication: AuthenticationSplunk$outboundSchema.default("basic"),
    credentialsSecret: z.string(),
    type: CollectorSplunkType1$outboundSchema,
    searchHead: z.string().default("https://localhost:8089"),
    search: z.string(),
    earliest: z.string().optional(),
    latest: z.string().optional(),
    endpoint: z.string().default("/services/search/v2/jobs/export"),
    outputMode: OutputModeOptions$outboundSchema.default("json"),
    collectRequestParams: z.array(
      z.lazy(() => CollectRequestParamSplunk$outboundSchema),
    ).optional(),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderSplunk$outboundSchema),
    ).optional(),
    timeout: z.number().default(0),
    useRoundRobinDns: z.boolean().default(false),
    disableTimeFilter: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(false),
    handleEscapedChars: z.boolean().default(false),
    retryRules: z.lazy(() => RetryRulesSplunk$outboundSchema).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    token: z.string().optional(),
    tokenSecret: z.string().optional(),
    loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().default("token"),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
  });

export function collectorSplunkCollectorHealthCheckPart2TypeToJSON(
  collectorSplunkCollectorHealthCheckPart2Type:
    CollectorSplunkCollectorHealthCheckPart2Type,
): string {
  return JSON.stringify(
    CollectorSplunkCollectorHealthCheckPart2Type$outboundSchema.parse(
      collectorSplunkCollectorHealthCheckPart2Type,
    ),
  );
}
export function collectorSplunkCollectorHealthCheckPart2TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorSplunkCollectorHealthCheckPart2Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorSplunkCollectorHealthCheckPart2Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorSplunkCollectorHealthCheckPart2Type' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkCollectorHealthCheckPart1Type$inboundSchema:
  z.ZodType<
    CollectorSplunkCollectorHealthCheckPart1Type,
    z.ZodTypeDef,
    unknown
  > = z.object({
    authentication: AuthenticationSplunk$inboundSchema.default("basic"),
    username: z.string(),
    password: z.string(),
    type: CollectorSplunkType1$inboundSchema,
    searchHead: z.string().default("https://localhost:8089"),
    search: z.string(),
    earliest: z.string().optional(),
    latest: z.string().optional(),
    endpoint: z.string().default("/services/search/v2/jobs/export"),
    outputMode: OutputModeOptions$inboundSchema.default("json"),
    collectRequestParams: z.array(
      z.lazy(() => CollectRequestParamSplunk$inboundSchema),
    ).optional(),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderSplunk$inboundSchema),
    ).optional(),
    timeout: z.number().default(0),
    useRoundRobinDns: z.boolean().default(false),
    disableTimeFilter: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(false),
    handleEscapedChars: z.boolean().default(false),
    retryRules: z.lazy(() => RetryRulesSplunk$inboundSchema).optional(),
    credentialsSecret: z.string().optional(),
    token: z.string().optional(),
    tokenSecret: z.string().optional(),
    loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().default("token"),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
  });
/** @internal */
export type CollectorSplunkCollectorHealthCheckPart1Type$Outbound = {
  authentication: string;
  username: string;
  password: string;
  type: string;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?: Array<CollectRequestParamSplunk$Outbound> | undefined;
  collectRequestHeaders?:
    | Array<CollectRequestHeaderSplunk$Outbound>
    | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  rejectUnauthorized: boolean;
  handleEscapedChars: boolean;
  retryRules?: RetryRulesSplunk$Outbound | undefined;
  credentialsSecret?: string | undefined;
  token?: string | undefined;
  tokenSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  tokenRespAttribute: string;
  authHeaderExpr: string;
};

/** @internal */
export const CollectorSplunkCollectorHealthCheckPart1Type$outboundSchema:
  z.ZodType<
    CollectorSplunkCollectorHealthCheckPart1Type$Outbound,
    z.ZodTypeDef,
    CollectorSplunkCollectorHealthCheckPart1Type
  > = z.object({
    authentication: AuthenticationSplunk$outboundSchema.default("basic"),
    username: z.string(),
    password: z.string(),
    type: CollectorSplunkType1$outboundSchema,
    searchHead: z.string().default("https://localhost:8089"),
    search: z.string(),
    earliest: z.string().optional(),
    latest: z.string().optional(),
    endpoint: z.string().default("/services/search/v2/jobs/export"),
    outputMode: OutputModeOptions$outboundSchema.default("json"),
    collectRequestParams: z.array(
      z.lazy(() => CollectRequestParamSplunk$outboundSchema),
    ).optional(),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderSplunk$outboundSchema),
    ).optional(),
    timeout: z.number().default(0),
    useRoundRobinDns: z.boolean().default(false),
    disableTimeFilter: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(false),
    handleEscapedChars: z.boolean().default(false),
    retryRules: z.lazy(() => RetryRulesSplunk$outboundSchema).optional(),
    credentialsSecret: z.string().optional(),
    token: z.string().optional(),
    tokenSecret: z.string().optional(),
    loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().default("token"),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
  });

export function collectorSplunkCollectorHealthCheckPart1TypeToJSON(
  collectorSplunkCollectorHealthCheckPart1Type:
    CollectorSplunkCollectorHealthCheckPart1Type,
): string {
  return JSON.stringify(
    CollectorSplunkCollectorHealthCheckPart1Type$outboundSchema.parse(
      collectorSplunkCollectorHealthCheckPart1Type,
    ),
  );
}
export function collectorSplunkCollectorHealthCheckPart1TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorSplunkCollectorHealthCheckPart1Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorSplunkCollectorHealthCheckPart1Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorSplunkCollectorHealthCheckPart1Type' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkCollectorHealthCheckPart0Type$inboundSchema:
  z.ZodType<
    CollectorSplunkCollectorHealthCheckPart0Type,
    z.ZodTypeDef,
    unknown
  > = z.object({
    authentication: AuthenticationSplunk$inboundSchema.default("basic"),
    type: CollectorSplunkType1$inboundSchema,
    searchHead: z.string().default("https://localhost:8089"),
    search: z.string(),
    earliest: z.string().optional(),
    latest: z.string().optional(),
    endpoint: z.string().default("/services/search/v2/jobs/export"),
    outputMode: OutputModeOptions$inboundSchema.default("json"),
    collectRequestParams: z.array(
      z.lazy(() => CollectRequestParamSplunk$inboundSchema),
    ).optional(),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderSplunk$inboundSchema),
    ).optional(),
    timeout: z.number().default(0),
    useRoundRobinDns: z.boolean().default(false),
    disableTimeFilter: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(false),
    handleEscapedChars: z.boolean().default(false),
    retryRules: z.lazy(() => RetryRulesSplunk$inboundSchema).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
    token: z.string().optional(),
    tokenSecret: z.string().optional(),
    loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().default("token"),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
  });
/** @internal */
export type CollectorSplunkCollectorHealthCheckPart0Type$Outbound = {
  authentication: string;
  type: string;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?: Array<CollectRequestParamSplunk$Outbound> | undefined;
  collectRequestHeaders?:
    | Array<CollectRequestHeaderSplunk$Outbound>
    | undefined;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  rejectUnauthorized: boolean;
  handleEscapedChars: boolean;
  retryRules?: RetryRulesSplunk$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  token?: string | undefined;
  tokenSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  tokenRespAttribute: string;
  authHeaderExpr: string;
};

/** @internal */
export const CollectorSplunkCollectorHealthCheckPart0Type$outboundSchema:
  z.ZodType<
    CollectorSplunkCollectorHealthCheckPart0Type$Outbound,
    z.ZodTypeDef,
    CollectorSplunkCollectorHealthCheckPart0Type
  > = z.object({
    authentication: AuthenticationSplunk$outboundSchema.default("basic"),
    type: CollectorSplunkType1$outboundSchema,
    searchHead: z.string().default("https://localhost:8089"),
    search: z.string(),
    earliest: z.string().optional(),
    latest: z.string().optional(),
    endpoint: z.string().default("/services/search/v2/jobs/export"),
    outputMode: OutputModeOptions$outboundSchema.default("json"),
    collectRequestParams: z.array(
      z.lazy(() => CollectRequestParamSplunk$outboundSchema),
    ).optional(),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderSplunk$outboundSchema),
    ).optional(),
    timeout: z.number().default(0),
    useRoundRobinDns: z.boolean().default(false),
    disableTimeFilter: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(false),
    handleEscapedChars: z.boolean().default(false),
    retryRules: z.lazy(() => RetryRulesSplunk$outboundSchema).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
    token: z.string().optional(),
    tokenSecret: z.string().optional(),
    loginUrl: z.string().default("`https://localhost:9000/api/v1/auth/login`"),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().default("token"),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
  });

export function collectorSplunkCollectorHealthCheckPart0TypeToJSON(
  collectorSplunkCollectorHealthCheckPart0Type:
    CollectorSplunkCollectorHealthCheckPart0Type,
): string {
  return JSON.stringify(
    CollectorSplunkCollectorHealthCheckPart0Type$outboundSchema.parse(
      collectorSplunkCollectorHealthCheckPart0Type,
    ),
  );
}
export function collectorSplunkCollectorHealthCheckPart0TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorSplunkCollectorHealthCheckPart0Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorSplunkCollectorHealthCheckPart0Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorSplunkCollectorHealthCheckPart0Type' from JSON`,
  );
}

/** @internal */
export const CollectorSplunk$inboundSchema: z.ZodType<
  CollectorSplunk,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CollectorSplunkCollectorHealthCheckPart1Type$inboundSchema),
  z.lazy(() => CollectorSplunkSplunk3$inboundSchema),
  z.lazy(() => CollectorSplunkCollectorHealthCheckPart2Type$inboundSchema),
  z.lazy(() => CollectorSplunkSplunk1$inboundSchema),
  z.lazy(() => CollectorSplunkSplunk2$inboundSchema),
  z.lazy(() => CollectorSplunkSplunk4$inboundSchema),
  z.lazy(() => CollectorSplunkCollectorHealthCheckPart0Type$inboundSchema),
]);
/** @internal */
export type CollectorSplunk$Outbound =
  | CollectorSplunkCollectorHealthCheckPart1Type$Outbound
  | CollectorSplunkSplunk3$Outbound
  | CollectorSplunkCollectorHealthCheckPart2Type$Outbound
  | CollectorSplunkSplunk1$Outbound
  | CollectorSplunkSplunk2$Outbound
  | CollectorSplunkSplunk4$Outbound
  | CollectorSplunkCollectorHealthCheckPart0Type$Outbound;

/** @internal */
export const CollectorSplunk$outboundSchema: z.ZodType<
  CollectorSplunk$Outbound,
  z.ZodTypeDef,
  CollectorSplunk
> = z.union([
  z.lazy(() => CollectorSplunkCollectorHealthCheckPart1Type$outboundSchema),
  z.lazy(() => CollectorSplunkSplunk3$outboundSchema),
  z.lazy(() => CollectorSplunkCollectorHealthCheckPart2Type$outboundSchema),
  z.lazy(() => CollectorSplunkSplunk1$outboundSchema),
  z.lazy(() => CollectorSplunkSplunk2$outboundSchema),
  z.lazy(() => CollectorSplunkSplunk4$outboundSchema),
  z.lazy(() => CollectorSplunkCollectorHealthCheckPart0Type$outboundSchema),
]);

export function collectorSplunkToJSON(
  collectorSplunk: CollectorSplunk,
): string {
  return JSON.stringify(CollectorSplunk$outboundSchema.parse(collectorSplunk));
}
export function collectorSplunkFromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunk' from JSON`,
  );
}
