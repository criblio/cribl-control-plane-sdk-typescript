/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Format of the returned output
 */
export const CollectorSplunkOutputMode = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type CollectorSplunkOutputMode = OpenEnum<
  typeof CollectorSplunkOutputMode
>;

export type CollectRequestParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type CollectorSplunkCollectRequestHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

/**
 * Authentication method for Discover and Collect REST calls
 */
export const CollectorSplunkAuthentication = {
  /**
   * None
   */
  None: "none",
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * Basic (credentials secret)
   */
  BasicSecret: "basicSecret",
  /**
   * Bearer Token
   */
  Token: "token",
  /**
   * Bearer Token (text secret)
   */
  TokenSecret: "tokenSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls
 */
export type CollectorSplunkAuthentication = OpenEnum<
  typeof CollectorSplunkAuthentication
>;

/**
 * Algorithm to use when performing HTTP retries
 */
export const CollectorSplunkRetryType = {
  /**
   * Disabled
   */
  None: "none",
  /**
   * Backoff
   */
  Backoff: "backoff",
  /**
   * Static
   */
  Static: "static",
} as const;
/**
 * Algorithm to use when performing HTTP retries
 */
export type CollectorSplunkRetryType = OpenEnum<
  typeof CollectorSplunkRetryType
>;

export type CollectorSplunkRetryRules = {
  /**
   * Algorithm to use when performing HTTP retries
   */
  type?: CollectorSplunkRetryType | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type CollectorSplunk = {
  /**
   * Collector type: splunk
   */
  type: "splunk";
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: CollectorSplunkOutputMode | undefined;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?: Array<CollectRequestParam> | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?:
    | Array<CollectorSplunkCollectRequestHeader>
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication?: CollectorSplunkAuthentication | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?: CollectorSplunkRetryRules | undefined;
};

/** @internal */
export const CollectorSplunkOutputMode$inboundSchema: z.ZodType<
  CollectorSplunkOutputMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorSplunkOutputMode);
/** @internal */
export const CollectorSplunkOutputMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorSplunkOutputMode
> = openEnums.outboundSchema(CollectorSplunkOutputMode);

/** @internal */
export const CollectRequestParam$inboundSchema: z.ZodType<
  CollectRequestParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectRequestParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectRequestParam$outboundSchema: z.ZodType<
  CollectRequestParam$Outbound,
  z.ZodTypeDef,
  CollectRequestParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectRequestParamToJSON(
  collectRequestParam: CollectRequestParam,
): string {
  return JSON.stringify(
    CollectRequestParam$outboundSchema.parse(collectRequestParam),
  );
}
export function collectRequestParamFromJSON(
  jsonString: string,
): SafeParseResult<CollectRequestParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectRequestParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectRequestParam' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkCollectRequestHeader$inboundSchema: z.ZodType<
  CollectorSplunkCollectRequestHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorSplunkCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorSplunkCollectRequestHeader$outboundSchema: z.ZodType<
  CollectorSplunkCollectRequestHeader$Outbound,
  z.ZodTypeDef,
  CollectorSplunkCollectRequestHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectorSplunkCollectRequestHeaderToJSON(
  collectorSplunkCollectRequestHeader: CollectorSplunkCollectRequestHeader,
): string {
  return JSON.stringify(
    CollectorSplunkCollectRequestHeader$outboundSchema.parse(
      collectorSplunkCollectRequestHeader,
    ),
  );
}
export function collectorSplunkCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkCollectRequestHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorSplunkCollectRequestHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const CollectorSplunkAuthentication$inboundSchema: z.ZodType<
  CollectorSplunkAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorSplunkAuthentication);
/** @internal */
export const CollectorSplunkAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorSplunkAuthentication
> = openEnums.outboundSchema(CollectorSplunkAuthentication);

/** @internal */
export const CollectorSplunkRetryType$inboundSchema: z.ZodType<
  CollectorSplunkRetryType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorSplunkRetryType);
/** @internal */
export const CollectorSplunkRetryType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorSplunkRetryType
> = openEnums.outboundSchema(CollectorSplunkRetryType);

/** @internal */
export const CollectorSplunkRetryRules$inboundSchema: z.ZodType<
  CollectorSplunkRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CollectorSplunkRetryType$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type CollectorSplunkRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const CollectorSplunkRetryRules$outboundSchema: z.ZodType<
  CollectorSplunkRetryRules$Outbound,
  z.ZodTypeDef,
  CollectorSplunkRetryRules
> = z.object({
  type: CollectorSplunkRetryType$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function collectorSplunkRetryRulesToJSON(
  collectorSplunkRetryRules: CollectorSplunkRetryRules,
): string {
  return JSON.stringify(
    CollectorSplunkRetryRules$outboundSchema.parse(collectorSplunkRetryRules),
  );
}
export function collectorSplunkRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunkRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorSplunkRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunkRetryRules' from JSON`,
  );
}

/** @internal */
export const CollectorSplunk$inboundSchema: z.ZodType<
  CollectorSplunk,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("splunk"),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: CollectorSplunkOutputMode$inboundSchema.default("json"),
  collectRequestParams: z.array(z.lazy(() => CollectRequestParam$inboundSchema))
    .optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorSplunkCollectRequestHeader$inboundSchema),
  ).optional(),
  authentication: CollectorSplunkAuthentication$inboundSchema.default("basic"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => CollectorSplunkRetryRules$inboundSchema).optional(),
});
/** @internal */
export type CollectorSplunk$Outbound = {
  type: "splunk";
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?: Array<CollectRequestParam$Outbound> | undefined;
  collectRequestHeaders?:
    | Array<CollectorSplunkCollectRequestHeader$Outbound>
    | undefined;
  authentication: string;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  rejectUnauthorized: boolean;
  handleEscapedChars: boolean;
  retryRules?: CollectorSplunkRetryRules$Outbound | undefined;
};

/** @internal */
export const CollectorSplunk$outboundSchema: z.ZodType<
  CollectorSplunk$Outbound,
  z.ZodTypeDef,
  CollectorSplunk
> = z.object({
  type: z.literal("splunk"),
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: CollectorSplunkOutputMode$outboundSchema.default("json"),
  collectRequestParams: z.array(
    z.lazy(() => CollectRequestParam$outboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorSplunkCollectRequestHeader$outboundSchema),
  ).optional(),
  authentication: CollectorSplunkAuthentication$outboundSchema.default("basic"),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => CollectorSplunkRetryRules$outboundSchema).optional(),
});

export function collectorSplunkToJSON(
  collectorSplunk: CollectorSplunk,
): string {
  return JSON.stringify(CollectorSplunk$outboundSchema.parse(collectorSplunk));
}
export function collectorSplunkFromJSON(
  jsonString: string,
): SafeParseResult<CollectorSplunk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorSplunk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorSplunk' from JSON`,
  );
}
