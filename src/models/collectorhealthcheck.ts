/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  HiddenDefaultBreakersOptions,
  HiddenDefaultBreakersOptions$inboundSchema,
  HiddenDefaultBreakersOptions$outboundSchema,
} from "./hiddendefaultbreakersoptions.js";
import {
  ItemsTypeAuthRequestHeaders,
  ItemsTypeAuthRequestHeaders$inboundSchema,
  ItemsTypeAuthRequestHeaders$Outbound,
  ItemsTypeAuthRequestHeaders$outboundSchema,
} from "./itemstypeauthrequestheaders.js";
import {
  ItemsTypeAuthRequestParams,
  ItemsTypeAuthRequestParams$inboundSchema,
  ItemsTypeAuthRequestParams$Outbound,
  ItemsTypeAuthRequestParams$outboundSchema,
} from "./itemstypeauthrequestparams.js";
import {
  ItemsTypeCollectRequestParams,
  ItemsTypeCollectRequestParams$inboundSchema,
  ItemsTypeCollectRequestParams$Outbound,
  ItemsTypeCollectRequestParams$outboundSchema,
} from "./itemstypecollectrequestparams.js";
import {
  RetryTypeOptionsRetryRules,
  RetryTypeOptionsRetryRules$inboundSchema,
  RetryTypeOptionsRetryRules$outboundSchema,
} from "./retrytypeoptionsretryrules.js";

/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorHealthCheckAuthentication7 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorHealthCheckAuthentication7 = OpenEnum<
  typeof CollectorHealthCheckAuthentication7
>;

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const CollectorHealthCheckDiscoverType7 = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type CollectorHealthCheckDiscoverType7 = OpenEnum<
  typeof CollectorHealthCheckDiscoverType7
>;

export type CollectorHealthCheckDiscovery7 = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType?: CollectorHealthCheckDiscoverType7 | undefined;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckMethod7 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckMethod7 = OpenEnum<typeof HealthCheckMethod7>;

export type CollectorHealthCheckCollectRequestHeader7 = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type CollectorHealthCheckRetryRules7 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/**
 * Collector type: health_check
 */
export const CollectorHealthCheckType8 = {
  HealthCheck: "health_check",
} as const;
/**
 * Collector type: health_check
 */
export type CollectorHealthCheckType8 = ClosedEnum<
  typeof CollectorHealthCheckType8
>;

export type CollectorHealthCheckHealthCheck7 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorHealthCheckAuthentication7 | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Select or create a text secret that contains the client secret's value.
   */
  textSecret: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeAuthRequestParams> | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders> | undefined;
  discovery?: CollectorHealthCheckDiscovery7 | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod?: HealthCheckMethod7 | undefined;
  /**
   * Optional health check request parameters.
   */
  collectRequestParams?: Array<ItemsTypeCollectRequestParams> | undefined;
  /**
   * Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}.
   */
  collectBody?: string | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader7>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: HiddenDefaultBreakersOptions | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules7 | undefined;
  /**
   * Login username
   */
  username?: string | undefined;
  /**
   * Login password
   */
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters
   */
  clientSecretParamValue?: string | undefined;
  /**
   * Collector type: health_check
   */
  type: CollectorHealthCheckType8;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorHealthCheckAuthentication6 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorHealthCheckAuthentication6 = OpenEnum<
  typeof CollectorHealthCheckAuthentication6
>;

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const CollectorHealthCheckDiscoverType6 = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type CollectorHealthCheckDiscoverType6 = OpenEnum<
  typeof CollectorHealthCheckDiscoverType6
>;

export type CollectorHealthCheckDiscovery6 = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType?: CollectorHealthCheckDiscoverType6 | undefined;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckMethod6 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckMethod6 = OpenEnum<typeof HealthCheckMethod6>;

export type CollectorHealthCheckCollectRequestHeader6 = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type CollectorHealthCheckRetryRules6 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/**
 * Collector type: health_check
 */
export const CollectorHealthCheckType7 = {
  HealthCheck: "health_check",
} as const;
/**
 * Collector type: health_check
 */
export type CollectorHealthCheckType7 = ClosedEnum<
  typeof CollectorHealthCheckType7
>;

export type CollectorHealthCheckHealthCheck6 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorHealthCheckAuthentication6 | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters
   */
  clientSecretParamValue: string;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeAuthRequestParams> | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders> | undefined;
  discovery?: CollectorHealthCheckDiscovery6 | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod?: HealthCheckMethod6 | undefined;
  /**
   * Optional health check request parameters.
   */
  collectRequestParams?: Array<ItemsTypeCollectRequestParams> | undefined;
  /**
   * Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}.
   */
  collectBody?: string | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader6>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: HiddenDefaultBreakersOptions | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules6 | undefined;
  /**
   * Login username
   */
  username?: string | undefined;
  /**
   * Login password
   */
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Select or create a text secret that contains the client secret's value.
   */
  textSecret?: string | undefined;
  /**
   * Collector type: health_check
   */
  type: CollectorHealthCheckType7;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorHealthCheckAuthentication5 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorHealthCheckAuthentication5 = OpenEnum<
  typeof CollectorHealthCheckAuthentication5
>;

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const CollectorHealthCheckDiscoverType5 = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type CollectorHealthCheckDiscoverType5 = OpenEnum<
  typeof CollectorHealthCheckDiscoverType5
>;

export type CollectorHealthCheckDiscovery5 = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType?: CollectorHealthCheckDiscoverType5 | undefined;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckMethod5 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckMethod5 = OpenEnum<typeof HealthCheckMethod5>;

export type CollectorHealthCheckCollectRequestHeader5 = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type CollectorHealthCheckRetryRules5 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/**
 * Collector type: health_check
 */
export const CollectorHealthCheckType6 = {
  HealthCheck: "health_check",
} as const;
/**
 * Collector type: health_check
 */
export type CollectorHealthCheckType6 = ClosedEnum<
  typeof CollectorHealthCheckType6
>;

export type CollectorHealthCheckHealthCheck5 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorHealthCheckAuthentication5 | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders> | undefined;
  discovery?: CollectorHealthCheckDiscovery5 | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod?: HealthCheckMethod5 | undefined;
  /**
   * Optional health check request parameters.
   */
  collectRequestParams?: Array<ItemsTypeCollectRequestParams> | undefined;
  /**
   * Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}.
   */
  collectBody?: string | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader5>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: HiddenDefaultBreakersOptions | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules5 | undefined;
  /**
   * Login username
   */
  username?: string | undefined;
  /**
   * Login password
   */
  password?: string | undefined;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeAuthRequestParams> | undefined;
  /**
   * Select or create a text secret that contains the client secret's value.
   */
  textSecret?: string | undefined;
  /**
   * Collector type: health_check
   */
  type: CollectorHealthCheckType6;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorHealthCheckAuthentication4 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorHealthCheckAuthentication4 = OpenEnum<
  typeof CollectorHealthCheckAuthentication4
>;

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const CollectorHealthCheckDiscoverType4 = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type CollectorHealthCheckDiscoverType4 = OpenEnum<
  typeof CollectorHealthCheckDiscoverType4
>;

export type CollectorHealthCheckDiscovery4 = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType?: CollectorHealthCheckDiscoverType4 | undefined;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckMethod4 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckMethod4 = OpenEnum<typeof HealthCheckMethod4>;

export type CollectorHealthCheckCollectRequestHeader4 = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type CollectorHealthCheckRetryRules4 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/**
 * Collector type: health_check
 */
export const CollectorHealthCheckType5 = {
  HealthCheck: "health_check",
} as const;
/**
 * Collector type: health_check
 */
export type CollectorHealthCheckType5 = ClosedEnum<
  typeof CollectorHealthCheckType5
>;

export type CollectorHealthCheckHealthCheck4 = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorHealthCheckAuthentication4 | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Login username
   */
  username: string;
  /**
   * Login password
   */
  password: string;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders> | undefined;
  discovery?: CollectorHealthCheckDiscovery4 | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod?: HealthCheckMethod4 | undefined;
  /**
   * Optional health check request parameters.
   */
  collectRequestParams?: Array<ItemsTypeCollectRequestParams> | undefined;
  /**
   * Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}.
   */
  collectBody?: string | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader4>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: HiddenDefaultBreakersOptions | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules4 | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeAuthRequestParams> | undefined;
  /**
   * Select or create a text secret that contains the client secret's value.
   */
  textSecret?: string | undefined;
  /**
   * Collector type: health_check
   */
  type: CollectorHealthCheckType5;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export const AuthenticationHealthCheck = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export type AuthenticationHealthCheck = OpenEnum<
  typeof AuthenticationHealthCheck
>;

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const DiscoverTypeHealthCheck = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type DiscoverTypeHealthCheck = OpenEnum<typeof DiscoverTypeHealthCheck>;

export type DiscoveryHealthCheck = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType?: DiscoverTypeHealthCheck | undefined;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckMethodHealthCheck = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckMethodHealthCheck = OpenEnum<
  typeof HealthCheckMethodHealthCheck
>;

export type CollectRequestHeaderHealthCheck = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

export type RetryRulesHealthCheck = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/**
 * Collector type: health_check
 */
export const CollectorHealthCheckType4 = {
  HealthCheck: "health_check",
} as const;
/**
 * Collector type: health_check
 */
export type CollectorHealthCheckType4 = ClosedEnum<
  typeof CollectorHealthCheckType4
>;

export type CollectorHealthCheckCollectorHealthCheckPart2Type = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: AuthenticationHealthCheck | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  discovery?: DiscoveryHealthCheck | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod?: HealthCheckMethodHealthCheck | undefined;
  /**
   * Optional health check request parameters.
   */
  collectRequestParams?: Array<ItemsTypeCollectRequestParams> | undefined;
  /**
   * Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}.
   */
  collectBody?: string | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?: Array<CollectRequestHeaderHealthCheck> | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: HiddenDefaultBreakersOptions | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RetryRulesHealthCheck | undefined;
  /**
   * Login username
   */
  username?: string | undefined;
  /**
   * Login password
   */
  password?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders> | undefined;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeAuthRequestParams> | undefined;
  /**
   * Select or create a text secret that contains the client secret's value.
   */
  textSecret?: string | undefined;
  /**
   * Collector type: health_check
   */
  type: CollectorHealthCheckType4;
};

export type CollectorHealthCheckCollectorHealthCheckPart1Type = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: AuthenticationHealthCheck | undefined;
  /**
   * Login username
   */
  username: string;
  /**
   * Login password
   */
  password: string;
  discovery?: DiscoveryHealthCheck | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod?: HealthCheckMethodHealthCheck | undefined;
  /**
   * Optional health check request parameters.
   */
  collectRequestParams?: Array<ItemsTypeCollectRequestParams> | undefined;
  /**
   * Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}.
   */
  collectBody?: string | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?: Array<CollectRequestHeaderHealthCheck> | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: HiddenDefaultBreakersOptions | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RetryRulesHealthCheck | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders> | undefined;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeAuthRequestParams> | undefined;
  /**
   * Select or create a text secret that contains the client secret's value.
   */
  textSecret?: string | undefined;
  /**
   * Collector type: health_check
   */
  type: CollectorHealthCheckType4;
};

export type CollectorHealthCheckCollectorHealthCheckPart0Type = {
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: AuthenticationHealthCheck | undefined;
  discovery?: DiscoveryHealthCheck | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Health check HTTP method.
   */
  collectMethod?: HealthCheckMethodHealthCheck | undefined;
  /**
   * Optional health check request parameters.
   */
  collectRequestParams?: Array<ItemsTypeCollectRequestParams> | undefined;
  /**
   * Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}.
   */
  collectBody?: string | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?: Array<CollectRequestHeaderHealthCheck> | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: HiddenDefaultBreakersOptions | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: RetryRulesHealthCheck | undefined;
  /**
   * Login username
   */
  username?: string | undefined;
  /**
   * Login password
   */
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders> | undefined;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeAuthRequestParams> | undefined;
  /**
   * Select or create a text secret that contains the client secret's value.
   */
  textSecret?: string | undefined;
  /**
   * Collector type: health_check
   */
  type: CollectorHealthCheckType4;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckMethod3 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckMethod3 = OpenEnum<typeof HealthCheckMethod3>;

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const CollectorHealthCheckDiscoverType3 = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type CollectorHealthCheckDiscoverType3 = OpenEnum<
  typeof CollectorHealthCheckDiscoverType3
>;

export type CollectorHealthCheckDiscovery3 = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType?: CollectorHealthCheckDiscoverType3 | undefined;
};

export type CollectorHealthCheckCollectRequestHeader3 = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorHealthCheckAuthentication3 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorHealthCheckAuthentication3 = OpenEnum<
  typeof CollectorHealthCheckAuthentication3
>;

export type CollectorHealthCheckRetryRules3 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/**
 * Collector type: health_check
 */
export const CollectorHealthCheckType3 = {
  HealthCheck: "health_check",
} as const;
/**
 * Collector type: health_check
 */
export type CollectorHealthCheckType3 = ClosedEnum<
  typeof CollectorHealthCheckType3
>;

export type CollectorHealthCheckHealthCheck3 = {
  /**
   * Health check HTTP method.
   */
  collectMethod?: HealthCheckMethod3 | undefined;
  /**
   * Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}.
   */
  collectBody?: string | undefined;
  discovery?: CollectorHealthCheckDiscovery3 | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Optional health check request parameters.
   */
  collectRequestParams?: Array<ItemsTypeCollectRequestParams> | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader3>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorHealthCheckAuthentication3 | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: HiddenDefaultBreakersOptions | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules3 | undefined;
  /**
   * Login username
   */
  username?: string | undefined;
  /**
   * Login password
   */
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders> | undefined;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeAuthRequestParams> | undefined;
  /**
   * Select or create a text secret that contains the client secret's value.
   */
  textSecret?: string | undefined;
  /**
   * Collector type: health_check
   */
  type: CollectorHealthCheckType3;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckMethod2 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckMethod2 = OpenEnum<typeof HealthCheckMethod2>;

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const CollectorHealthCheckDiscoverType2 = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type CollectorHealthCheckDiscoverType2 = OpenEnum<
  typeof CollectorHealthCheckDiscoverType2
>;

export type CollectorHealthCheckDiscovery2 = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType?: CollectorHealthCheckDiscoverType2 | undefined;
};

export type CollectorHealthCheckCollectRequestHeader2 = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorHealthCheckAuthentication2 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorHealthCheckAuthentication2 = OpenEnum<
  typeof CollectorHealthCheckAuthentication2
>;

export type CollectorHealthCheckRetryRules2 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/**
 * Collector type: health_check
 */
export const CollectorHealthCheckType2 = {
  HealthCheck: "health_check",
} as const;
/**
 * Collector type: health_check
 */
export type CollectorHealthCheckType2 = ClosedEnum<
  typeof CollectorHealthCheckType2
>;

export type CollectorHealthCheckHealthCheck2 = {
  /**
   * Health check HTTP method.
   */
  collectMethod?: HealthCheckMethod2 | undefined;
  /**
   * Optional health check request parameters.
   */
  collectRequestParams?: Array<ItemsTypeCollectRequestParams> | undefined;
  discovery?: CollectorHealthCheckDiscovery2 | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}.
   */
  collectBody?: string | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader2>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorHealthCheckAuthentication2 | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: HiddenDefaultBreakersOptions | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules2 | undefined;
  /**
   * Login username
   */
  username?: string | undefined;
  /**
   * Login password
   */
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders> | undefined;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeAuthRequestParams> | undefined;
  /**
   * Select or create a text secret that contains the client secret's value.
   */
  textSecret?: string | undefined;
  /**
   * Collector type: health_check
   */
  type: CollectorHealthCheckType2;
};

/**
 * Health check HTTP method.
 */
export const HealthCheckMethod1 = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
} as const;
/**
 * Health check HTTP method.
 */
export type HealthCheckMethod1 = OpenEnum<typeof HealthCheckMethod1>;

/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export const CollectorHealthCheckDiscoverType1 = {
  /**
   * HTTP Request
   */
  Http: "http",
  /**
   * JSON Response
   */
  Json: "json",
  /**
   * Item List
   */
  List: "list",
  /**
   * None
   */
  None: "none",
} as const;
/**
 * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
 */
export type CollectorHealthCheckDiscoverType1 = OpenEnum<
  typeof CollectorHealthCheckDiscoverType1
>;

export type CollectorHealthCheckDiscovery1 = {
  /**
   * Defines how task discovery will be performed. Use None to skip the discovery. Use HTTP Request to make a REST call to discover tasks. Use Item List to enumerate items for collect to retrieve. Use JSON Response to manually define discover tasks as a JSON array of objects. Each entry returned by the discover operation will result in a collect task.
   */
  discoverType?: CollectorHealthCheckDiscoverType1 | undefined;
};

export type CollectorHealthCheckCollectRequestHeader1 = {
  /**
   * Header Name
   */
  name: string;
  /**
   * JavaScript expression to compute the header value (can be a constant).
   */
  value: string;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export const CollectorHealthCheckAuthentication1 = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
 */
export type CollectorHealthCheckAuthentication1 = OpenEnum<
  typeof CollectorHealthCheckAuthentication1
>;

export type CollectorHealthCheckRetryRules1 = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: RetryTypeOptionsRetryRules | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/**
 * Collector type: health_check
 */
export const CollectorHealthCheckType1 = {
  HealthCheck: "health_check",
} as const;
/**
 * Collector type: health_check
 */
export type CollectorHealthCheckType1 = ClosedEnum<
  typeof CollectorHealthCheckType1
>;

export type CollectorHealthCheckHealthCheck1 = {
  /**
   * Health check HTTP method.
   */
  collectMethod?: HealthCheckMethod1 | undefined;
  /**
   * Optional health check request parameters.
   */
  collectRequestParams?: Array<ItemsTypeCollectRequestParams> | undefined;
  discovery?: CollectorHealthCheckDiscovery1 | undefined;
  /**
   * Expression to derive URL to use for the health check operation (can be a constant).
   */
  collectUrl: string;
  /**
   * Template for POST body to send with the health check request. You can reference parameters from the Discover response, using template params of the form: ${variable}.
   */
  collectBody?: string | undefined;
  /**
   * Optional health check request headers.
   */
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader1>
    | undefined;
  /**
   * Enable to make auth health check call.
   */
  authenticateCollect?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API Key–based authentication by adding the appropriate Collect headers.
   */
  authentication?: CollectorHealthCheckAuthentication1 | undefined;
  /**
   * HTTP request inactivity timeout, use 0 to disable
   */
  timeout?: number | undefined;
  /**
   * Whether to reject certificates that cannot be verified against a valid CA (e.g., self-signed certificates).
   */
  rejectUnauthorized?: boolean | undefined;
  defaultBreakers?: HiddenDefaultBreakersOptions | undefined;
  /**
   * List of headers that are safe to log in plain text.
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules1 | undefined;
  /**
   * Login username
   */
  username?: string | undefined;
  /**
   * Login password
   */
  password?: string | undefined;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * URL to use for the OAuth API call. This call is expected to be a POST.
   */
  loginUrl?: string | undefined;
  /**
   * Template for POST body to send with login request, ${username} and ${password} are used to specify location of these attributes in the message
   */
  loginBody?: string | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in discover and collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr?: string | undefined;
  /**
   * Optional authentication request headers.
   */
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders> | undefined;
  /**
   * Parameter name that contains client secret. Defaults to 'client_secret', and is automatically added to request parameters.
   */
  clientSecretParamName?: string | undefined;
  /**
   * Secret value to add to HTTP requests as the 'client secret' parameter. Stored on disk encrypted, and is automatically added to request parameters
   */
  clientSecretParamValue?: string | undefined;
  /**
   * OAuth request parameters added to the POST body. The Content-Type header will automatically be set to application/x-www-form-urlencoded.
   */
  authRequestParams?: Array<ItemsTypeAuthRequestParams> | undefined;
  /**
   * Select or create a text secret that contains the client secret's value.
   */
  textSecret?: string | undefined;
  /**
   * Collector type: health_check
   */
  type: CollectorHealthCheckType1;
};

export type CollectorHealthCheck =
  | CollectorHealthCheckCollectorHealthCheckPart1Type
  | CollectorHealthCheckHealthCheck4
  | CollectorHealthCheckCollectorHealthCheckPart2Type
  | CollectorHealthCheckHealthCheck5
  | CollectorHealthCheckHealthCheck6
  | CollectorHealthCheckHealthCheck7
  | CollectorHealthCheckHealthCheck1
  | CollectorHealthCheckHealthCheck2
  | CollectorHealthCheckHealthCheck3
  | CollectorHealthCheckCollectorHealthCheckPart0Type;

/** @internal */
export const CollectorHealthCheckAuthentication7$inboundSchema: z.ZodType<
  CollectorHealthCheckAuthentication7,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckAuthentication7);
/** @internal */
export const CollectorHealthCheckAuthentication7$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckAuthentication7
> = openEnums.outboundSchema(CollectorHealthCheckAuthentication7);

/** @internal */
export const CollectorHealthCheckDiscoverType7$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscoverType7,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckDiscoverType7);
/** @internal */
export const CollectorHealthCheckDiscoverType7$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckDiscoverType7
> = openEnums.outboundSchema(CollectorHealthCheckDiscoverType7);

/** @internal */
export const CollectorHealthCheckDiscovery7$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery7,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType7$inboundSchema.default("none"),
});
/** @internal */
export type CollectorHealthCheckDiscovery7$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorHealthCheckDiscovery7$outboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery7$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckDiscovery7
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType7$outboundSchema.default(
    "none",
  ),
});

export function collectorHealthCheckDiscovery7ToJSON(
  collectorHealthCheckDiscovery7: CollectorHealthCheckDiscovery7,
): string {
  return JSON.stringify(
    CollectorHealthCheckDiscovery7$outboundSchema.parse(
      collectorHealthCheckDiscovery7,
    ),
  );
}
export function collectorHealthCheckDiscovery7FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckDiscovery7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckDiscovery7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckDiscovery7' from JSON`,
  );
}

/** @internal */
export const HealthCheckMethod7$inboundSchema: z.ZodType<
  HealthCheckMethod7,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckMethod7);
/** @internal */
export const HealthCheckMethod7$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  HealthCheckMethod7
> = openEnums.outboundSchema(HealthCheckMethod7);

/** @internal */
export const CollectorHealthCheckCollectRequestHeader7$inboundSchema: z.ZodType<
  CollectorHealthCheckCollectRequestHeader7,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorHealthCheckCollectRequestHeader7$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorHealthCheckCollectRequestHeader7$outboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectRequestHeader7$Outbound,
    z.ZodTypeDef,
    CollectorHealthCheckCollectRequestHeader7
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function collectorHealthCheckCollectRequestHeader7ToJSON(
  collectorHealthCheckCollectRequestHeader7:
    CollectorHealthCheckCollectRequestHeader7,
): string {
  return JSON.stringify(
    CollectorHealthCheckCollectRequestHeader7$outboundSchema.parse(
      collectorHealthCheckCollectRequestHeader7,
    ),
  );
}
export function collectorHealthCheckCollectRequestHeader7FromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorHealthCheckCollectRequestHeader7,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorHealthCheckCollectRequestHeader7$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorHealthCheckCollectRequestHeader7' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckRetryRules7$inboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules7,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type CollectorHealthCheckRetryRules7$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const CollectorHealthCheckRetryRules7$outboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules7$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckRetryRules7
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function collectorHealthCheckRetryRules7ToJSON(
  collectorHealthCheckRetryRules7: CollectorHealthCheckRetryRules7,
): string {
  return JSON.stringify(
    CollectorHealthCheckRetryRules7$outboundSchema.parse(
      collectorHealthCheckRetryRules7,
    ),
  );
}
export function collectorHealthCheckRetryRules7FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckRetryRules7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckRetryRules7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckRetryRules7' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckType8$inboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType8
> = z.nativeEnum(CollectorHealthCheckType8);
/** @internal */
export const CollectorHealthCheckType8$outboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType8
> = CollectorHealthCheckType8$inboundSchema;

/** @internal */
export const CollectorHealthCheckHealthCheck7$inboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck7,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorHealthCheckAuthentication7$inboundSchema.default(
    "none",
  ),
  loginUrl: z.string().default(""),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  clientSecretParamName: z.string().default("client_secret"),
  textSecret: z.string(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$inboundSchema)
    .optional(),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$inboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery7$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckMethod7$inboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$inboundSchema)
    .optional(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader7$inboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules7$inboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  clientSecretParamValue: z.string().optional(),
  type: CollectorHealthCheckType8$inboundSchema,
});
/** @internal */
export type CollectorHealthCheckHealthCheck7$Outbound = {
  authentication: string;
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  textSecret: string;
  authRequestParams?: Array<ItemsTypeAuthRequestParams$Outbound> | undefined;
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders$Outbound> | undefined;
  discovery?: CollectorHealthCheckDiscovery7$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams$Outbound>
    | undefined;
  collectBody: string;
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader7$Outbound>
    | undefined;
  authenticateCollect: boolean;
  timeout: number;
  rejectUnauthorized: boolean;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules7$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginBody: string;
  clientSecretParamValue?: string | undefined;
  type: string;
};

/** @internal */
export const CollectorHealthCheckHealthCheck7$outboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck7$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckHealthCheck7
> = z.object({
  authentication: CollectorHealthCheckAuthentication7$outboundSchema.default(
    "none",
  ),
  loginUrl: z.string().default(""),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  clientSecretParamName: z.string().default("client_secret"),
  textSecret: z.string(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$outboundSchema)
    .optional(),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$outboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery7$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckMethod7$outboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$outboundSchema)
    .optional(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader7$outboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules7$outboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  clientSecretParamValue: z.string().optional(),
  type: CollectorHealthCheckType8$outboundSchema,
});

export function collectorHealthCheckHealthCheck7ToJSON(
  collectorHealthCheckHealthCheck7: CollectorHealthCheckHealthCheck7,
): string {
  return JSON.stringify(
    CollectorHealthCheckHealthCheck7$outboundSchema.parse(
      collectorHealthCheckHealthCheck7,
    ),
  );
}
export function collectorHealthCheckHealthCheck7FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckHealthCheck7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckHealthCheck7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckHealthCheck7' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckAuthentication6$inboundSchema: z.ZodType<
  CollectorHealthCheckAuthentication6,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckAuthentication6);
/** @internal */
export const CollectorHealthCheckAuthentication6$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckAuthentication6
> = openEnums.outboundSchema(CollectorHealthCheckAuthentication6);

/** @internal */
export const CollectorHealthCheckDiscoverType6$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscoverType6,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckDiscoverType6);
/** @internal */
export const CollectorHealthCheckDiscoverType6$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckDiscoverType6
> = openEnums.outboundSchema(CollectorHealthCheckDiscoverType6);

/** @internal */
export const CollectorHealthCheckDiscovery6$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery6,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType6$inboundSchema.default("none"),
});
/** @internal */
export type CollectorHealthCheckDiscovery6$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorHealthCheckDiscovery6$outboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery6$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckDiscovery6
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType6$outboundSchema.default(
    "none",
  ),
});

export function collectorHealthCheckDiscovery6ToJSON(
  collectorHealthCheckDiscovery6: CollectorHealthCheckDiscovery6,
): string {
  return JSON.stringify(
    CollectorHealthCheckDiscovery6$outboundSchema.parse(
      collectorHealthCheckDiscovery6,
    ),
  );
}
export function collectorHealthCheckDiscovery6FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckDiscovery6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckDiscovery6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckDiscovery6' from JSON`,
  );
}

/** @internal */
export const HealthCheckMethod6$inboundSchema: z.ZodType<
  HealthCheckMethod6,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckMethod6);
/** @internal */
export const HealthCheckMethod6$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  HealthCheckMethod6
> = openEnums.outboundSchema(HealthCheckMethod6);

/** @internal */
export const CollectorHealthCheckCollectRequestHeader6$inboundSchema: z.ZodType<
  CollectorHealthCheckCollectRequestHeader6,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorHealthCheckCollectRequestHeader6$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorHealthCheckCollectRequestHeader6$outboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectRequestHeader6$Outbound,
    z.ZodTypeDef,
    CollectorHealthCheckCollectRequestHeader6
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function collectorHealthCheckCollectRequestHeader6ToJSON(
  collectorHealthCheckCollectRequestHeader6:
    CollectorHealthCheckCollectRequestHeader6,
): string {
  return JSON.stringify(
    CollectorHealthCheckCollectRequestHeader6$outboundSchema.parse(
      collectorHealthCheckCollectRequestHeader6,
    ),
  );
}
export function collectorHealthCheckCollectRequestHeader6FromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorHealthCheckCollectRequestHeader6,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorHealthCheckCollectRequestHeader6$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorHealthCheckCollectRequestHeader6' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckRetryRules6$inboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules6,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type CollectorHealthCheckRetryRules6$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const CollectorHealthCheckRetryRules6$outboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules6$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckRetryRules6
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function collectorHealthCheckRetryRules6ToJSON(
  collectorHealthCheckRetryRules6: CollectorHealthCheckRetryRules6,
): string {
  return JSON.stringify(
    CollectorHealthCheckRetryRules6$outboundSchema.parse(
      collectorHealthCheckRetryRules6,
    ),
  );
}
export function collectorHealthCheckRetryRules6FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckRetryRules6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckRetryRules6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckRetryRules6' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckType7$inboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType7
> = z.nativeEnum(CollectorHealthCheckType7);
/** @internal */
export const CollectorHealthCheckType7$outboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType7
> = CollectorHealthCheckType7$inboundSchema;

/** @internal */
export const CollectorHealthCheckHealthCheck6$inboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck6,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorHealthCheckAuthentication6$inboundSchema.default(
    "none",
  ),
  loginUrl: z.string().default(""),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$inboundSchema)
    .optional(),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$inboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery6$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckMethod6$inboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$inboundSchema)
    .optional(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader6$inboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules6$inboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType7$inboundSchema,
});
/** @internal */
export type CollectorHealthCheckHealthCheck6$Outbound = {
  authentication: string;
  loginUrl: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  clientSecretParamName: string;
  clientSecretParamValue: string;
  authRequestParams?: Array<ItemsTypeAuthRequestParams$Outbound> | undefined;
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders$Outbound> | undefined;
  discovery?: CollectorHealthCheckDiscovery6$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams$Outbound>
    | undefined;
  collectBody: string;
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader6$Outbound>
    | undefined;
  authenticateCollect: boolean;
  timeout: number;
  rejectUnauthorized: boolean;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules6$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginBody: string;
  textSecret?: string | undefined;
  type: string;
};

/** @internal */
export const CollectorHealthCheckHealthCheck6$outboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck6$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckHealthCheck6
> = z.object({
  authentication: CollectorHealthCheckAuthentication6$outboundSchema.default(
    "none",
  ),
  loginUrl: z.string().default(""),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$outboundSchema)
    .optional(),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$outboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery6$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckMethod6$outboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$outboundSchema)
    .optional(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader6$outboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules6$outboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType7$outboundSchema,
});

export function collectorHealthCheckHealthCheck6ToJSON(
  collectorHealthCheckHealthCheck6: CollectorHealthCheckHealthCheck6,
): string {
  return JSON.stringify(
    CollectorHealthCheckHealthCheck6$outboundSchema.parse(
      collectorHealthCheckHealthCheck6,
    ),
  );
}
export function collectorHealthCheckHealthCheck6FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckHealthCheck6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckHealthCheck6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckHealthCheck6' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckAuthentication5$inboundSchema: z.ZodType<
  CollectorHealthCheckAuthentication5,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckAuthentication5);
/** @internal */
export const CollectorHealthCheckAuthentication5$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckAuthentication5
> = openEnums.outboundSchema(CollectorHealthCheckAuthentication5);

/** @internal */
export const CollectorHealthCheckDiscoverType5$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscoverType5,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckDiscoverType5);
/** @internal */
export const CollectorHealthCheckDiscoverType5$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckDiscoverType5
> = openEnums.outboundSchema(CollectorHealthCheckDiscoverType5);

/** @internal */
export const CollectorHealthCheckDiscovery5$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery5,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType5$inboundSchema.default("none"),
});
/** @internal */
export type CollectorHealthCheckDiscovery5$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorHealthCheckDiscovery5$outboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery5$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckDiscovery5
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType5$outboundSchema.default(
    "none",
  ),
});

export function collectorHealthCheckDiscovery5ToJSON(
  collectorHealthCheckDiscovery5: CollectorHealthCheckDiscovery5,
): string {
  return JSON.stringify(
    CollectorHealthCheckDiscovery5$outboundSchema.parse(
      collectorHealthCheckDiscovery5,
    ),
  );
}
export function collectorHealthCheckDiscovery5FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckDiscovery5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckDiscovery5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckDiscovery5' from JSON`,
  );
}

/** @internal */
export const HealthCheckMethod5$inboundSchema: z.ZodType<
  HealthCheckMethod5,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckMethod5);
/** @internal */
export const HealthCheckMethod5$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  HealthCheckMethod5
> = openEnums.outboundSchema(HealthCheckMethod5);

/** @internal */
export const CollectorHealthCheckCollectRequestHeader5$inboundSchema: z.ZodType<
  CollectorHealthCheckCollectRequestHeader5,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorHealthCheckCollectRequestHeader5$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorHealthCheckCollectRequestHeader5$outboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectRequestHeader5$Outbound,
    z.ZodTypeDef,
    CollectorHealthCheckCollectRequestHeader5
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function collectorHealthCheckCollectRequestHeader5ToJSON(
  collectorHealthCheckCollectRequestHeader5:
    CollectorHealthCheckCollectRequestHeader5,
): string {
  return JSON.stringify(
    CollectorHealthCheckCollectRequestHeader5$outboundSchema.parse(
      collectorHealthCheckCollectRequestHeader5,
    ),
  );
}
export function collectorHealthCheckCollectRequestHeader5FromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorHealthCheckCollectRequestHeader5,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorHealthCheckCollectRequestHeader5$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorHealthCheckCollectRequestHeader5' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckRetryRules5$inboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules5,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type CollectorHealthCheckRetryRules5$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const CollectorHealthCheckRetryRules5$outboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules5$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckRetryRules5
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function collectorHealthCheckRetryRules5ToJSON(
  collectorHealthCheckRetryRules5: CollectorHealthCheckRetryRules5,
): string {
  return JSON.stringify(
    CollectorHealthCheckRetryRules5$outboundSchema.parse(
      collectorHealthCheckRetryRules5,
    ),
  );
}
export function collectorHealthCheckRetryRules5FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckRetryRules5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckRetryRules5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckRetryRules5' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckType6$inboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType6
> = z.nativeEnum(CollectorHealthCheckType6);
/** @internal */
export const CollectorHealthCheckType6$outboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType6
> = CollectorHealthCheckType6$inboundSchema;

/** @internal */
export const CollectorHealthCheckHealthCheck5$inboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck5,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorHealthCheckAuthentication5$inboundSchema.default(
    "none",
  ),
  loginUrl: z.string().default(""),
  credentialsSecret: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$inboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery5$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckMethod5$inboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$inboundSchema)
    .optional(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader5$inboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules5$inboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType6$inboundSchema,
});
/** @internal */
export type CollectorHealthCheckHealthCheck5$Outbound = {
  authentication: string;
  loginUrl: string;
  credentialsSecret: string;
  loginBody: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders$Outbound> | undefined;
  discovery?: CollectorHealthCheckDiscovery5$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams$Outbound>
    | undefined;
  collectBody: string;
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader5$Outbound>
    | undefined;
  authenticateCollect: boolean;
  timeout: number;
  rejectUnauthorized: boolean;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules5$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?: Array<ItemsTypeAuthRequestParams$Outbound> | undefined;
  textSecret?: string | undefined;
  type: string;
};

/** @internal */
export const CollectorHealthCheckHealthCheck5$outboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck5$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckHealthCheck5
> = z.object({
  authentication: CollectorHealthCheckAuthentication5$outboundSchema.default(
    "none",
  ),
  loginUrl: z.string().default(""),
  credentialsSecret: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$outboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery5$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckMethod5$outboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$outboundSchema)
    .optional(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader5$outboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules5$outboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType6$outboundSchema,
});

export function collectorHealthCheckHealthCheck5ToJSON(
  collectorHealthCheckHealthCheck5: CollectorHealthCheckHealthCheck5,
): string {
  return JSON.stringify(
    CollectorHealthCheckHealthCheck5$outboundSchema.parse(
      collectorHealthCheckHealthCheck5,
    ),
  );
}
export function collectorHealthCheckHealthCheck5FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckHealthCheck5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckHealthCheck5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckHealthCheck5' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckAuthentication4$inboundSchema: z.ZodType<
  CollectorHealthCheckAuthentication4,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckAuthentication4);
/** @internal */
export const CollectorHealthCheckAuthentication4$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckAuthentication4
> = openEnums.outboundSchema(CollectorHealthCheckAuthentication4);

/** @internal */
export const CollectorHealthCheckDiscoverType4$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscoverType4,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckDiscoverType4);
/** @internal */
export const CollectorHealthCheckDiscoverType4$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckDiscoverType4
> = openEnums.outboundSchema(CollectorHealthCheckDiscoverType4);

/** @internal */
export const CollectorHealthCheckDiscovery4$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery4,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType4$inboundSchema.default("none"),
});
/** @internal */
export type CollectorHealthCheckDiscovery4$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorHealthCheckDiscovery4$outboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery4$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckDiscovery4
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType4$outboundSchema.default(
    "none",
  ),
});

export function collectorHealthCheckDiscovery4ToJSON(
  collectorHealthCheckDiscovery4: CollectorHealthCheckDiscovery4,
): string {
  return JSON.stringify(
    CollectorHealthCheckDiscovery4$outboundSchema.parse(
      collectorHealthCheckDiscovery4,
    ),
  );
}
export function collectorHealthCheckDiscovery4FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckDiscovery4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckDiscovery4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckDiscovery4' from JSON`,
  );
}

/** @internal */
export const HealthCheckMethod4$inboundSchema: z.ZodType<
  HealthCheckMethod4,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckMethod4);
/** @internal */
export const HealthCheckMethod4$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  HealthCheckMethod4
> = openEnums.outboundSchema(HealthCheckMethod4);

/** @internal */
export const CollectorHealthCheckCollectRequestHeader4$inboundSchema: z.ZodType<
  CollectorHealthCheckCollectRequestHeader4,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorHealthCheckCollectRequestHeader4$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorHealthCheckCollectRequestHeader4$outboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectRequestHeader4$Outbound,
    z.ZodTypeDef,
    CollectorHealthCheckCollectRequestHeader4
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function collectorHealthCheckCollectRequestHeader4ToJSON(
  collectorHealthCheckCollectRequestHeader4:
    CollectorHealthCheckCollectRequestHeader4,
): string {
  return JSON.stringify(
    CollectorHealthCheckCollectRequestHeader4$outboundSchema.parse(
      collectorHealthCheckCollectRequestHeader4,
    ),
  );
}
export function collectorHealthCheckCollectRequestHeader4FromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorHealthCheckCollectRequestHeader4,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorHealthCheckCollectRequestHeader4$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorHealthCheckCollectRequestHeader4' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckRetryRules4$inboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules4,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type CollectorHealthCheckRetryRules4$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const CollectorHealthCheckRetryRules4$outboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules4$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckRetryRules4
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function collectorHealthCheckRetryRules4ToJSON(
  collectorHealthCheckRetryRules4: CollectorHealthCheckRetryRules4,
): string {
  return JSON.stringify(
    CollectorHealthCheckRetryRules4$outboundSchema.parse(
      collectorHealthCheckRetryRules4,
    ),
  );
}
export function collectorHealthCheckRetryRules4FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckRetryRules4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckRetryRules4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckRetryRules4' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckType5$inboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType5
> = z.nativeEnum(CollectorHealthCheckType5);
/** @internal */
export const CollectorHealthCheckType5$outboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType5
> = CollectorHealthCheckType5$inboundSchema;

/** @internal */
export const CollectorHealthCheckHealthCheck4$inboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck4,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: CollectorHealthCheckAuthentication4$inboundSchema.default(
    "none",
  ),
  loginUrl: z.string().default(""),
  username: z.string(),
  password: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$inboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery4$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckMethod4$inboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$inboundSchema)
    .optional(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader4$inboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules4$inboundSchema)
    .optional(),
  credentialsSecret: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType5$inboundSchema,
});
/** @internal */
export type CollectorHealthCheckHealthCheck4$Outbound = {
  authentication: string;
  loginUrl: string;
  username: string;
  password: string;
  loginBody: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders$Outbound> | undefined;
  discovery?: CollectorHealthCheckDiscovery4$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams$Outbound>
    | undefined;
  collectBody: string;
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader4$Outbound>
    | undefined;
  authenticateCollect: boolean;
  timeout: number;
  rejectUnauthorized: boolean;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules4$Outbound | undefined;
  credentialsSecret?: string | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?: Array<ItemsTypeAuthRequestParams$Outbound> | undefined;
  textSecret?: string | undefined;
  type: string;
};

/** @internal */
export const CollectorHealthCheckHealthCheck4$outboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck4$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckHealthCheck4
> = z.object({
  authentication: CollectorHealthCheckAuthentication4$outboundSchema.default(
    "none",
  ),
  loginUrl: z.string().default(""),
  username: z.string(),
  password: z.string(),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$outboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery4$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectMethod: HealthCheckMethod4$outboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$outboundSchema)
    .optional(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader4$outboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules4$outboundSchema)
    .optional(),
  credentialsSecret: z.string().optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType5$outboundSchema,
});

export function collectorHealthCheckHealthCheck4ToJSON(
  collectorHealthCheckHealthCheck4: CollectorHealthCheckHealthCheck4,
): string {
  return JSON.stringify(
    CollectorHealthCheckHealthCheck4$outboundSchema.parse(
      collectorHealthCheckHealthCheck4,
    ),
  );
}
export function collectorHealthCheckHealthCheck4FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckHealthCheck4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckHealthCheck4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckHealthCheck4' from JSON`,
  );
}

/** @internal */
export const AuthenticationHealthCheck$inboundSchema: z.ZodType<
  AuthenticationHealthCheck,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(AuthenticationHealthCheck);
/** @internal */
export const AuthenticationHealthCheck$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  AuthenticationHealthCheck
> = openEnums.outboundSchema(AuthenticationHealthCheck);

/** @internal */
export const DiscoverTypeHealthCheck$inboundSchema: z.ZodType<
  DiscoverTypeHealthCheck,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(DiscoverTypeHealthCheck);
/** @internal */
export const DiscoverTypeHealthCheck$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  DiscoverTypeHealthCheck
> = openEnums.outboundSchema(DiscoverTypeHealthCheck);

/** @internal */
export const DiscoveryHealthCheck$inboundSchema: z.ZodType<
  DiscoveryHealthCheck,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: DiscoverTypeHealthCheck$inboundSchema.default("none"),
});
/** @internal */
export type DiscoveryHealthCheck$Outbound = {
  discoverType: string;
};

/** @internal */
export const DiscoveryHealthCheck$outboundSchema: z.ZodType<
  DiscoveryHealthCheck$Outbound,
  z.ZodTypeDef,
  DiscoveryHealthCheck
> = z.object({
  discoverType: DiscoverTypeHealthCheck$outboundSchema.default("none"),
});

export function discoveryHealthCheckToJSON(
  discoveryHealthCheck: DiscoveryHealthCheck,
): string {
  return JSON.stringify(
    DiscoveryHealthCheck$outboundSchema.parse(discoveryHealthCheck),
  );
}
export function discoveryHealthCheckFromJSON(
  jsonString: string,
): SafeParseResult<DiscoveryHealthCheck, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DiscoveryHealthCheck$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DiscoveryHealthCheck' from JSON`,
  );
}

/** @internal */
export const HealthCheckMethodHealthCheck$inboundSchema: z.ZodType<
  HealthCheckMethodHealthCheck,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckMethodHealthCheck);
/** @internal */
export const HealthCheckMethodHealthCheck$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  HealthCheckMethodHealthCheck
> = openEnums.outboundSchema(HealthCheckMethodHealthCheck);

/** @internal */
export const CollectRequestHeaderHealthCheck$inboundSchema: z.ZodType<
  CollectRequestHeaderHealthCheck,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectRequestHeaderHealthCheck$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectRequestHeaderHealthCheck$outboundSchema: z.ZodType<
  CollectRequestHeaderHealthCheck$Outbound,
  z.ZodTypeDef,
  CollectRequestHeaderHealthCheck
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectRequestHeaderHealthCheckToJSON(
  collectRequestHeaderHealthCheck: CollectRequestHeaderHealthCheck,
): string {
  return JSON.stringify(
    CollectRequestHeaderHealthCheck$outboundSchema.parse(
      collectRequestHeaderHealthCheck,
    ),
  );
}
export function collectRequestHeaderHealthCheckFromJSON(
  jsonString: string,
): SafeParseResult<CollectRequestHeaderHealthCheck, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectRequestHeaderHealthCheck$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectRequestHeaderHealthCheck' from JSON`,
  );
}

/** @internal */
export const RetryRulesHealthCheck$inboundSchema: z.ZodType<
  RetryRulesHealthCheck,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type RetryRulesHealthCheck$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const RetryRulesHealthCheck$outboundSchema: z.ZodType<
  RetryRulesHealthCheck$Outbound,
  z.ZodTypeDef,
  RetryRulesHealthCheck
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function retryRulesHealthCheckToJSON(
  retryRulesHealthCheck: RetryRulesHealthCheck,
): string {
  return JSON.stringify(
    RetryRulesHealthCheck$outboundSchema.parse(retryRulesHealthCheck),
  );
}
export function retryRulesHealthCheckFromJSON(
  jsonString: string,
): SafeParseResult<RetryRulesHealthCheck, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetryRulesHealthCheck$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetryRulesHealthCheck' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckType4$inboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType4
> = z.nativeEnum(CollectorHealthCheckType4);
/** @internal */
export const CollectorHealthCheckType4$outboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType4
> = CollectorHealthCheckType4$inboundSchema;

/** @internal */
export const CollectorHealthCheckCollectorHealthCheckPart2Type$inboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectorHealthCheckPart2Type,
    z.ZodTypeDef,
    unknown
  > = z.object({
    authentication: AuthenticationHealthCheck$inboundSchema.default("none"),
    credentialsSecret: z.string(),
    discovery: z.lazy(() => DiscoveryHealthCheck$inboundSchema).optional(),
    collectUrl: z.string(),
    collectMethod: HealthCheckMethodHealthCheck$inboundSchema.default("get"),
    collectRequestParams: z.array(ItemsTypeCollectRequestParams$inboundSchema)
      .optional(),
    collectBody: z.string().default("`{ }`"),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderHealthCheck$inboundSchema),
    ).optional(),
    authenticateCollect: z.boolean().default(false),
    timeout: z.number().default(30),
    rejectUnauthorized: z.boolean().default(false),
    defaultBreakers: HiddenDefaultBreakersOptions$inboundSchema.optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() => RetryRulesHealthCheck$inboundSchema).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    loginUrl: z.string().default(""),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().optional(),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
    authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$inboundSchema)
      .optional(),
    clientSecretParamName: z.string().default("client_secret"),
    clientSecretParamValue: z.string().optional(),
    authRequestParams: z.array(ItemsTypeAuthRequestParams$inboundSchema)
      .optional(),
    textSecret: z.string().optional(),
    type: CollectorHealthCheckType4$inboundSchema,
  });
/** @internal */
export type CollectorHealthCheckCollectorHealthCheckPart2Type$Outbound = {
  authentication: string;
  credentialsSecret: string;
  discovery?: DiscoveryHealthCheck$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams$Outbound>
    | undefined;
  collectBody: string;
  collectRequestHeaders?:
    | Array<CollectRequestHeaderHealthCheck$Outbound>
    | undefined;
  authenticateCollect: boolean;
  timeout: number;
  rejectUnauthorized: boolean;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RetryRulesHealthCheck$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  loginUrl: string;
  loginBody: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders$Outbound> | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?: Array<ItemsTypeAuthRequestParams$Outbound> | undefined;
  textSecret?: string | undefined;
  type: string;
};

/** @internal */
export const CollectorHealthCheckCollectorHealthCheckPart2Type$outboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectorHealthCheckPart2Type$Outbound,
    z.ZodTypeDef,
    CollectorHealthCheckCollectorHealthCheckPart2Type
  > = z.object({
    authentication: AuthenticationHealthCheck$outboundSchema.default("none"),
    credentialsSecret: z.string(),
    discovery: z.lazy(() => DiscoveryHealthCheck$outboundSchema).optional(),
    collectUrl: z.string(),
    collectMethod: HealthCheckMethodHealthCheck$outboundSchema.default("get"),
    collectRequestParams: z.array(ItemsTypeCollectRequestParams$outboundSchema)
      .optional(),
    collectBody: z.string().default("`{ }`"),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderHealthCheck$outboundSchema),
    ).optional(),
    authenticateCollect: z.boolean().default(false),
    timeout: z.number().default(30),
    rejectUnauthorized: z.boolean().default(false),
    defaultBreakers: HiddenDefaultBreakersOptions$outboundSchema.optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() => RetryRulesHealthCheck$outboundSchema).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    loginUrl: z.string().default(""),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().optional(),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
    authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$outboundSchema)
      .optional(),
    clientSecretParamName: z.string().default("client_secret"),
    clientSecretParamValue: z.string().optional(),
    authRequestParams: z.array(ItemsTypeAuthRequestParams$outboundSchema)
      .optional(),
    textSecret: z.string().optional(),
    type: CollectorHealthCheckType4$outboundSchema,
  });

export function collectorHealthCheckCollectorHealthCheckPart2TypeToJSON(
  collectorHealthCheckCollectorHealthCheckPart2Type:
    CollectorHealthCheckCollectorHealthCheckPart2Type,
): string {
  return JSON.stringify(
    CollectorHealthCheckCollectorHealthCheckPart2Type$outboundSchema.parse(
      collectorHealthCheckCollectorHealthCheckPart2Type,
    ),
  );
}
export function collectorHealthCheckCollectorHealthCheckPart2TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorHealthCheckCollectorHealthCheckPart2Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorHealthCheckCollectorHealthCheckPart2Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorHealthCheckCollectorHealthCheckPart2Type' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckCollectorHealthCheckPart1Type$inboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectorHealthCheckPart1Type,
    z.ZodTypeDef,
    unknown
  > = z.object({
    authentication: AuthenticationHealthCheck$inboundSchema.default("none"),
    username: z.string(),
    password: z.string(),
    discovery: z.lazy(() => DiscoveryHealthCheck$inboundSchema).optional(),
    collectUrl: z.string(),
    collectMethod: HealthCheckMethodHealthCheck$inboundSchema.default("get"),
    collectRequestParams: z.array(ItemsTypeCollectRequestParams$inboundSchema)
      .optional(),
    collectBody: z.string().default("`{ }`"),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderHealthCheck$inboundSchema),
    ).optional(),
    authenticateCollect: z.boolean().default(false),
    timeout: z.number().default(30),
    rejectUnauthorized: z.boolean().default(false),
    defaultBreakers: HiddenDefaultBreakersOptions$inboundSchema.optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() => RetryRulesHealthCheck$inboundSchema).optional(),
    credentialsSecret: z.string().optional(),
    loginUrl: z.string().default(""),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().optional(),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
    authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$inboundSchema)
      .optional(),
    clientSecretParamName: z.string().default("client_secret"),
    clientSecretParamValue: z.string().optional(),
    authRequestParams: z.array(ItemsTypeAuthRequestParams$inboundSchema)
      .optional(),
    textSecret: z.string().optional(),
    type: CollectorHealthCheckType4$inboundSchema,
  });
/** @internal */
export type CollectorHealthCheckCollectorHealthCheckPart1Type$Outbound = {
  authentication: string;
  username: string;
  password: string;
  discovery?: DiscoveryHealthCheck$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams$Outbound>
    | undefined;
  collectBody: string;
  collectRequestHeaders?:
    | Array<CollectRequestHeaderHealthCheck$Outbound>
    | undefined;
  authenticateCollect: boolean;
  timeout: number;
  rejectUnauthorized: boolean;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RetryRulesHealthCheck$Outbound | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders$Outbound> | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?: Array<ItemsTypeAuthRequestParams$Outbound> | undefined;
  textSecret?: string | undefined;
  type: string;
};

/** @internal */
export const CollectorHealthCheckCollectorHealthCheckPart1Type$outboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectorHealthCheckPart1Type$Outbound,
    z.ZodTypeDef,
    CollectorHealthCheckCollectorHealthCheckPart1Type
  > = z.object({
    authentication: AuthenticationHealthCheck$outboundSchema.default("none"),
    username: z.string(),
    password: z.string(),
    discovery: z.lazy(() => DiscoveryHealthCheck$outboundSchema).optional(),
    collectUrl: z.string(),
    collectMethod: HealthCheckMethodHealthCheck$outboundSchema.default("get"),
    collectRequestParams: z.array(ItemsTypeCollectRequestParams$outboundSchema)
      .optional(),
    collectBody: z.string().default("`{ }`"),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderHealthCheck$outboundSchema),
    ).optional(),
    authenticateCollect: z.boolean().default(false),
    timeout: z.number().default(30),
    rejectUnauthorized: z.boolean().default(false),
    defaultBreakers: HiddenDefaultBreakersOptions$outboundSchema.optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() => RetryRulesHealthCheck$outboundSchema).optional(),
    credentialsSecret: z.string().optional(),
    loginUrl: z.string().default(""),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().optional(),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
    authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$outboundSchema)
      .optional(),
    clientSecretParamName: z.string().default("client_secret"),
    clientSecretParamValue: z.string().optional(),
    authRequestParams: z.array(ItemsTypeAuthRequestParams$outboundSchema)
      .optional(),
    textSecret: z.string().optional(),
    type: CollectorHealthCheckType4$outboundSchema,
  });

export function collectorHealthCheckCollectorHealthCheckPart1TypeToJSON(
  collectorHealthCheckCollectorHealthCheckPart1Type:
    CollectorHealthCheckCollectorHealthCheckPart1Type,
): string {
  return JSON.stringify(
    CollectorHealthCheckCollectorHealthCheckPart1Type$outboundSchema.parse(
      collectorHealthCheckCollectorHealthCheckPart1Type,
    ),
  );
}
export function collectorHealthCheckCollectorHealthCheckPart1TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorHealthCheckCollectorHealthCheckPart1Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorHealthCheckCollectorHealthCheckPart1Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorHealthCheckCollectorHealthCheckPart1Type' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckCollectorHealthCheckPart0Type$inboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectorHealthCheckPart0Type,
    z.ZodTypeDef,
    unknown
  > = z.object({
    authentication: AuthenticationHealthCheck$inboundSchema.default("none"),
    discovery: z.lazy(() => DiscoveryHealthCheck$inboundSchema).optional(),
    collectUrl: z.string(),
    collectMethod: HealthCheckMethodHealthCheck$inboundSchema.default("get"),
    collectRequestParams: z.array(ItemsTypeCollectRequestParams$inboundSchema)
      .optional(),
    collectBody: z.string().default("`{ }`"),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderHealthCheck$inboundSchema),
    ).optional(),
    authenticateCollect: z.boolean().default(false),
    timeout: z.number().default(30),
    rejectUnauthorized: z.boolean().default(false),
    defaultBreakers: HiddenDefaultBreakersOptions$inboundSchema.optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() => RetryRulesHealthCheck$inboundSchema).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
    loginUrl: z.string().default(""),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().optional(),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
    authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$inboundSchema)
      .optional(),
    clientSecretParamName: z.string().default("client_secret"),
    clientSecretParamValue: z.string().optional(),
    authRequestParams: z.array(ItemsTypeAuthRequestParams$inboundSchema)
      .optional(),
    textSecret: z.string().optional(),
    type: CollectorHealthCheckType4$inboundSchema,
  });
/** @internal */
export type CollectorHealthCheckCollectorHealthCheckPart0Type$Outbound = {
  authentication: string;
  discovery?: DiscoveryHealthCheck$Outbound | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams$Outbound>
    | undefined;
  collectBody: string;
  collectRequestHeaders?:
    | Array<CollectRequestHeaderHealthCheck$Outbound>
    | undefined;
  authenticateCollect: boolean;
  timeout: number;
  rejectUnauthorized: boolean;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: RetryRulesHealthCheck$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders$Outbound> | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?: Array<ItemsTypeAuthRequestParams$Outbound> | undefined;
  textSecret?: string | undefined;
  type: string;
};

/** @internal */
export const CollectorHealthCheckCollectorHealthCheckPart0Type$outboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectorHealthCheckPart0Type$Outbound,
    z.ZodTypeDef,
    CollectorHealthCheckCollectorHealthCheckPart0Type
  > = z.object({
    authentication: AuthenticationHealthCheck$outboundSchema.default("none"),
    discovery: z.lazy(() => DiscoveryHealthCheck$outboundSchema).optional(),
    collectUrl: z.string(),
    collectMethod: HealthCheckMethodHealthCheck$outboundSchema.default("get"),
    collectRequestParams: z.array(ItemsTypeCollectRequestParams$outboundSchema)
      .optional(),
    collectBody: z.string().default("`{ }`"),
    collectRequestHeaders: z.array(
      z.lazy(() => CollectRequestHeaderHealthCheck$outboundSchema),
    ).optional(),
    authenticateCollect: z.boolean().default(false),
    timeout: z.number().default(30),
    rejectUnauthorized: z.boolean().default(false),
    defaultBreakers: HiddenDefaultBreakersOptions$outboundSchema.optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.lazy(() => RetryRulesHealthCheck$outboundSchema).optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    credentialsSecret: z.string().optional(),
    loginUrl: z.string().default(""),
    loginBody: z.string().default(
      "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
    ),
    tokenRespAttribute: z.string().optional(),
    authHeaderExpr: z.string().default("`Bearer ${token}`"),
    authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$outboundSchema)
      .optional(),
    clientSecretParamName: z.string().default("client_secret"),
    clientSecretParamValue: z.string().optional(),
    authRequestParams: z.array(ItemsTypeAuthRequestParams$outboundSchema)
      .optional(),
    textSecret: z.string().optional(),
    type: CollectorHealthCheckType4$outboundSchema,
  });

export function collectorHealthCheckCollectorHealthCheckPart0TypeToJSON(
  collectorHealthCheckCollectorHealthCheckPart0Type:
    CollectorHealthCheckCollectorHealthCheckPart0Type,
): string {
  return JSON.stringify(
    CollectorHealthCheckCollectorHealthCheckPart0Type$outboundSchema.parse(
      collectorHealthCheckCollectorHealthCheckPart0Type,
    ),
  );
}
export function collectorHealthCheckCollectorHealthCheckPart0TypeFromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorHealthCheckCollectorHealthCheckPart0Type,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorHealthCheckCollectorHealthCheckPart0Type$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorHealthCheckCollectorHealthCheckPart0Type' from JSON`,
  );
}

/** @internal */
export const HealthCheckMethod3$inboundSchema: z.ZodType<
  HealthCheckMethod3,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckMethod3);
/** @internal */
export const HealthCheckMethod3$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  HealthCheckMethod3
> = openEnums.outboundSchema(HealthCheckMethod3);

/** @internal */
export const CollectorHealthCheckDiscoverType3$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscoverType3,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckDiscoverType3);
/** @internal */
export const CollectorHealthCheckDiscoverType3$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckDiscoverType3
> = openEnums.outboundSchema(CollectorHealthCheckDiscoverType3);

/** @internal */
export const CollectorHealthCheckDiscovery3$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery3,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType3$inboundSchema.default("none"),
});
/** @internal */
export type CollectorHealthCheckDiscovery3$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorHealthCheckDiscovery3$outboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery3$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckDiscovery3
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType3$outboundSchema.default(
    "none",
  ),
});

export function collectorHealthCheckDiscovery3ToJSON(
  collectorHealthCheckDiscovery3: CollectorHealthCheckDiscovery3,
): string {
  return JSON.stringify(
    CollectorHealthCheckDiscovery3$outboundSchema.parse(
      collectorHealthCheckDiscovery3,
    ),
  );
}
export function collectorHealthCheckDiscovery3FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckDiscovery3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckDiscovery3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckDiscovery3' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckCollectRequestHeader3$inboundSchema: z.ZodType<
  CollectorHealthCheckCollectRequestHeader3,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorHealthCheckCollectRequestHeader3$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorHealthCheckCollectRequestHeader3$outboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectRequestHeader3$Outbound,
    z.ZodTypeDef,
    CollectorHealthCheckCollectRequestHeader3
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function collectorHealthCheckCollectRequestHeader3ToJSON(
  collectorHealthCheckCollectRequestHeader3:
    CollectorHealthCheckCollectRequestHeader3,
): string {
  return JSON.stringify(
    CollectorHealthCheckCollectRequestHeader3$outboundSchema.parse(
      collectorHealthCheckCollectRequestHeader3,
    ),
  );
}
export function collectorHealthCheckCollectRequestHeader3FromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorHealthCheckCollectRequestHeader3,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorHealthCheckCollectRequestHeader3$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorHealthCheckCollectRequestHeader3' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckAuthentication3$inboundSchema: z.ZodType<
  CollectorHealthCheckAuthentication3,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckAuthentication3);
/** @internal */
export const CollectorHealthCheckAuthentication3$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckAuthentication3
> = openEnums.outboundSchema(CollectorHealthCheckAuthentication3);

/** @internal */
export const CollectorHealthCheckRetryRules3$inboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type CollectorHealthCheckRetryRules3$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const CollectorHealthCheckRetryRules3$outboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules3$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckRetryRules3
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function collectorHealthCheckRetryRules3ToJSON(
  collectorHealthCheckRetryRules3: CollectorHealthCheckRetryRules3,
): string {
  return JSON.stringify(
    CollectorHealthCheckRetryRules3$outboundSchema.parse(
      collectorHealthCheckRetryRules3,
    ),
  );
}
export function collectorHealthCheckRetryRules3FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckRetryRules3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckRetryRules3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckRetryRules3' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckType3$inboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType3
> = z.nativeEnum(CollectorHealthCheckType3);
/** @internal */
export const CollectorHealthCheckType3$outboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType3
> = CollectorHealthCheckType3$inboundSchema;

/** @internal */
export const CollectorHealthCheckHealthCheck3$inboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck3,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: HealthCheckMethod3$inboundSchema.default("get"),
  collectBody: z.string().default("`{ }`"),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery3$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$inboundSchema)
    .optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader3$inboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  authentication: CollectorHealthCheckAuthentication3$inboundSchema.default(
    "none",
  ),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules3$inboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$inboundSchema)
    .optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType3$inboundSchema,
});
/** @internal */
export type CollectorHealthCheckHealthCheck3$Outbound = {
  collectMethod: string;
  collectBody: string;
  discovery?: CollectorHealthCheckDiscovery3$Outbound | undefined;
  collectUrl: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams$Outbound>
    | undefined;
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader3$Outbound>
    | undefined;
  authenticateCollect: boolean;
  authentication: string;
  timeout: number;
  rejectUnauthorized: boolean;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules3$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders$Outbound> | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?: Array<ItemsTypeAuthRequestParams$Outbound> | undefined;
  textSecret?: string | undefined;
  type: string;
};

/** @internal */
export const CollectorHealthCheckHealthCheck3$outboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck3$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckHealthCheck3
> = z.object({
  collectMethod: HealthCheckMethod3$outboundSchema.default("get"),
  collectBody: z.string().default("`{ }`"),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery3$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$outboundSchema)
    .optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader3$outboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  authentication: CollectorHealthCheckAuthentication3$outboundSchema.default(
    "none",
  ),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules3$outboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$outboundSchema)
    .optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType3$outboundSchema,
});

export function collectorHealthCheckHealthCheck3ToJSON(
  collectorHealthCheckHealthCheck3: CollectorHealthCheckHealthCheck3,
): string {
  return JSON.stringify(
    CollectorHealthCheckHealthCheck3$outboundSchema.parse(
      collectorHealthCheckHealthCheck3,
    ),
  );
}
export function collectorHealthCheckHealthCheck3FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckHealthCheck3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckHealthCheck3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckHealthCheck3' from JSON`,
  );
}

/** @internal */
export const HealthCheckMethod2$inboundSchema: z.ZodType<
  HealthCheckMethod2,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckMethod2);
/** @internal */
export const HealthCheckMethod2$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  HealthCheckMethod2
> = openEnums.outboundSchema(HealthCheckMethod2);

/** @internal */
export const CollectorHealthCheckDiscoverType2$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscoverType2,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckDiscoverType2);
/** @internal */
export const CollectorHealthCheckDiscoverType2$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckDiscoverType2
> = openEnums.outboundSchema(CollectorHealthCheckDiscoverType2);

/** @internal */
export const CollectorHealthCheckDiscovery2$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery2,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType2$inboundSchema.default("none"),
});
/** @internal */
export type CollectorHealthCheckDiscovery2$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorHealthCheckDiscovery2$outboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery2$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckDiscovery2
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType2$outboundSchema.default(
    "none",
  ),
});

export function collectorHealthCheckDiscovery2ToJSON(
  collectorHealthCheckDiscovery2: CollectorHealthCheckDiscovery2,
): string {
  return JSON.stringify(
    CollectorHealthCheckDiscovery2$outboundSchema.parse(
      collectorHealthCheckDiscovery2,
    ),
  );
}
export function collectorHealthCheckDiscovery2FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckDiscovery2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckDiscovery2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckDiscovery2' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckCollectRequestHeader2$inboundSchema: z.ZodType<
  CollectorHealthCheckCollectRequestHeader2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorHealthCheckCollectRequestHeader2$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorHealthCheckCollectRequestHeader2$outboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectRequestHeader2$Outbound,
    z.ZodTypeDef,
    CollectorHealthCheckCollectRequestHeader2
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function collectorHealthCheckCollectRequestHeader2ToJSON(
  collectorHealthCheckCollectRequestHeader2:
    CollectorHealthCheckCollectRequestHeader2,
): string {
  return JSON.stringify(
    CollectorHealthCheckCollectRequestHeader2$outboundSchema.parse(
      collectorHealthCheckCollectRequestHeader2,
    ),
  );
}
export function collectorHealthCheckCollectRequestHeader2FromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorHealthCheckCollectRequestHeader2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorHealthCheckCollectRequestHeader2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorHealthCheckCollectRequestHeader2' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckAuthentication2$inboundSchema: z.ZodType<
  CollectorHealthCheckAuthentication2,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckAuthentication2);
/** @internal */
export const CollectorHealthCheckAuthentication2$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckAuthentication2
> = openEnums.outboundSchema(CollectorHealthCheckAuthentication2);

/** @internal */
export const CollectorHealthCheckRetryRules2$inboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type CollectorHealthCheckRetryRules2$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const CollectorHealthCheckRetryRules2$outboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules2$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckRetryRules2
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function collectorHealthCheckRetryRules2ToJSON(
  collectorHealthCheckRetryRules2: CollectorHealthCheckRetryRules2,
): string {
  return JSON.stringify(
    CollectorHealthCheckRetryRules2$outboundSchema.parse(
      collectorHealthCheckRetryRules2,
    ),
  );
}
export function collectorHealthCheckRetryRules2FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckRetryRules2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckRetryRules2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckRetryRules2' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckType2$inboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType2
> = z.nativeEnum(CollectorHealthCheckType2);
/** @internal */
export const CollectorHealthCheckType2$outboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType2
> = CollectorHealthCheckType2$inboundSchema;

/** @internal */
export const CollectorHealthCheckHealthCheck2$inboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck2,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: HealthCheckMethod2$inboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$inboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery2$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader2$inboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  authentication: CollectorHealthCheckAuthentication2$inboundSchema.default(
    "none",
  ),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules2$inboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$inboundSchema)
    .optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType2$inboundSchema,
});
/** @internal */
export type CollectorHealthCheckHealthCheck2$Outbound = {
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams$Outbound>
    | undefined;
  discovery?: CollectorHealthCheckDiscovery2$Outbound | undefined;
  collectUrl: string;
  collectBody: string;
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader2$Outbound>
    | undefined;
  authenticateCollect: boolean;
  authentication: string;
  timeout: number;
  rejectUnauthorized: boolean;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules2$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders$Outbound> | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?: Array<ItemsTypeAuthRequestParams$Outbound> | undefined;
  textSecret?: string | undefined;
  type: string;
};

/** @internal */
export const CollectorHealthCheckHealthCheck2$outboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck2$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckHealthCheck2
> = z.object({
  collectMethod: HealthCheckMethod2$outboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$outboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery2$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader2$outboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  authentication: CollectorHealthCheckAuthentication2$outboundSchema.default(
    "none",
  ),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules2$outboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$outboundSchema)
    .optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType2$outboundSchema,
});

export function collectorHealthCheckHealthCheck2ToJSON(
  collectorHealthCheckHealthCheck2: CollectorHealthCheckHealthCheck2,
): string {
  return JSON.stringify(
    CollectorHealthCheckHealthCheck2$outboundSchema.parse(
      collectorHealthCheckHealthCheck2,
    ),
  );
}
export function collectorHealthCheckHealthCheck2FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckHealthCheck2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckHealthCheck2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckHealthCheck2' from JSON`,
  );
}

/** @internal */
export const HealthCheckMethod1$inboundSchema: z.ZodType<
  HealthCheckMethod1,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(HealthCheckMethod1);
/** @internal */
export const HealthCheckMethod1$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  HealthCheckMethod1
> = openEnums.outboundSchema(HealthCheckMethod1);

/** @internal */
export const CollectorHealthCheckDiscoverType1$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscoverType1,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckDiscoverType1);
/** @internal */
export const CollectorHealthCheckDiscoverType1$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckDiscoverType1
> = openEnums.outboundSchema(CollectorHealthCheckDiscoverType1);

/** @internal */
export const CollectorHealthCheckDiscovery1$inboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery1,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType1$inboundSchema.default("none"),
});
/** @internal */
export type CollectorHealthCheckDiscovery1$Outbound = {
  discoverType: string;
};

/** @internal */
export const CollectorHealthCheckDiscovery1$outboundSchema: z.ZodType<
  CollectorHealthCheckDiscovery1$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckDiscovery1
> = z.object({
  discoverType: CollectorHealthCheckDiscoverType1$outboundSchema.default(
    "none",
  ),
});

export function collectorHealthCheckDiscovery1ToJSON(
  collectorHealthCheckDiscovery1: CollectorHealthCheckDiscovery1,
): string {
  return JSON.stringify(
    CollectorHealthCheckDiscovery1$outboundSchema.parse(
      collectorHealthCheckDiscovery1,
    ),
  );
}
export function collectorHealthCheckDiscovery1FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckDiscovery1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckDiscovery1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckDiscovery1' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckCollectRequestHeader1$inboundSchema: z.ZodType<
  CollectorHealthCheckCollectRequestHeader1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectorHealthCheckCollectRequestHeader1$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectorHealthCheckCollectRequestHeader1$outboundSchema:
  z.ZodType<
    CollectorHealthCheckCollectRequestHeader1$Outbound,
    z.ZodTypeDef,
    CollectorHealthCheckCollectRequestHeader1
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function collectorHealthCheckCollectRequestHeader1ToJSON(
  collectorHealthCheckCollectRequestHeader1:
    CollectorHealthCheckCollectRequestHeader1,
): string {
  return JSON.stringify(
    CollectorHealthCheckCollectRequestHeader1$outboundSchema.parse(
      collectorHealthCheckCollectRequestHeader1,
    ),
  );
}
export function collectorHealthCheckCollectRequestHeader1FromJSON(
  jsonString: string,
): SafeParseResult<
  CollectorHealthCheckCollectRequestHeader1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CollectorHealthCheckCollectRequestHeader1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CollectorHealthCheckCollectRequestHeader1' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckAuthentication1$inboundSchema: z.ZodType<
  CollectorHealthCheckAuthentication1,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(CollectorHealthCheckAuthentication1);
/** @internal */
export const CollectorHealthCheckAuthentication1$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  CollectorHealthCheckAuthentication1
> = openEnums.outboundSchema(CollectorHealthCheckAuthentication1);

/** @internal */
export const CollectorHealthCheckRetryRules1$inboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetryTypeOptionsRetryRules$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});
/** @internal */
export type CollectorHealthCheckRetryRules1$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
};

/** @internal */
export const CollectorHealthCheckRetryRules1$outboundSchema: z.ZodType<
  CollectorHealthCheckRetryRules1$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckRetryRules1
> = z.object({
  type: RetryTypeOptionsRetryRules$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
});

export function collectorHealthCheckRetryRules1ToJSON(
  collectorHealthCheckRetryRules1: CollectorHealthCheckRetryRules1,
): string {
  return JSON.stringify(
    CollectorHealthCheckRetryRules1$outboundSchema.parse(
      collectorHealthCheckRetryRules1,
    ),
  );
}
export function collectorHealthCheckRetryRules1FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckRetryRules1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckRetryRules1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckRetryRules1' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheckType1$inboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType1
> = z.nativeEnum(CollectorHealthCheckType1);
/** @internal */
export const CollectorHealthCheckType1$outboundSchema: z.ZodNativeEnum<
  typeof CollectorHealthCheckType1
> = CollectorHealthCheckType1$inboundSchema;

/** @internal */
export const CollectorHealthCheckHealthCheck1$inboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck1,
  z.ZodTypeDef,
  unknown
> = z.object({
  collectMethod: HealthCheckMethod1$inboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$inboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery1$inboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader1$inboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  authentication: CollectorHealthCheckAuthentication1$inboundSchema.default(
    "none",
  ),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$inboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules1$inboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$inboundSchema)
    .optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$inboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType1$inboundSchema,
});
/** @internal */
export type CollectorHealthCheckHealthCheck1$Outbound = {
  collectMethod: string;
  collectRequestParams?:
    | Array<ItemsTypeCollectRequestParams$Outbound>
    | undefined;
  discovery?: CollectorHealthCheckDiscovery1$Outbound | undefined;
  collectUrl: string;
  collectBody: string;
  collectRequestHeaders?:
    | Array<CollectorHealthCheckCollectRequestHeader1$Outbound>
    | undefined;
  authenticateCollect: boolean;
  authentication: string;
  timeout: number;
  rejectUnauthorized: boolean;
  defaultBreakers?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?: CollectorHealthCheckRetryRules1$Outbound | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  loginUrl: string;
  loginBody: string;
  tokenRespAttribute?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?: Array<ItemsTypeAuthRequestHeaders$Outbound> | undefined;
  clientSecretParamName: string;
  clientSecretParamValue?: string | undefined;
  authRequestParams?: Array<ItemsTypeAuthRequestParams$Outbound> | undefined;
  textSecret?: string | undefined;
  type: string;
};

/** @internal */
export const CollectorHealthCheckHealthCheck1$outboundSchema: z.ZodType<
  CollectorHealthCheckHealthCheck1$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheckHealthCheck1
> = z.object({
  collectMethod: HealthCheckMethod1$outboundSchema.default("get"),
  collectRequestParams: z.array(ItemsTypeCollectRequestParams$outboundSchema)
    .optional(),
  discovery: z.lazy(() => CollectorHealthCheckDiscovery1$outboundSchema)
    .optional(),
  collectUrl: z.string(),
  collectBody: z.string().default("`{ }`"),
  collectRequestHeaders: z.array(
    z.lazy(() => CollectorHealthCheckCollectRequestHeader1$outboundSchema),
  ).optional(),
  authenticateCollect: z.boolean().default(false),
  authentication: CollectorHealthCheckAuthentication1$outboundSchema.default(
    "none",
  ),
  timeout: z.number().default(30),
  rejectUnauthorized: z.boolean().default(false),
  defaultBreakers: HiddenDefaultBreakersOptions$outboundSchema.optional(),
  safeHeaders: z.array(z.string()).optional(),
  retryRules: z.lazy(() => CollectorHealthCheckRetryRules1$outboundSchema)
    .optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  loginUrl: z.string().default(""),
  loginBody: z.string().default(
    "`{ \"username\": \"${username}\", \"password\": \"${password}\" }`",
  ),
  tokenRespAttribute: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  authRequestHeaders: z.array(ItemsTypeAuthRequestHeaders$outboundSchema)
    .optional(),
  clientSecretParamName: z.string().default("client_secret"),
  clientSecretParamValue: z.string().optional(),
  authRequestParams: z.array(ItemsTypeAuthRequestParams$outboundSchema)
    .optional(),
  textSecret: z.string().optional(),
  type: CollectorHealthCheckType1$outboundSchema,
});

export function collectorHealthCheckHealthCheck1ToJSON(
  collectorHealthCheckHealthCheck1: CollectorHealthCheckHealthCheck1,
): string {
  return JSON.stringify(
    CollectorHealthCheckHealthCheck1$outboundSchema.parse(
      collectorHealthCheckHealthCheck1,
    ),
  );
}
export function collectorHealthCheckHealthCheck1FromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheckHealthCheck1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheckHealthCheck1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheckHealthCheck1' from JSON`,
  );
}

/** @internal */
export const CollectorHealthCheck$inboundSchema: z.ZodType<
  CollectorHealthCheck,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CollectorHealthCheckCollectorHealthCheckPart1Type$inboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck4$inboundSchema),
  z.lazy(() => CollectorHealthCheckCollectorHealthCheckPart2Type$inboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck5$inboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck6$inboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck7$inboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck1$inboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck2$inboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck3$inboundSchema),
  z.lazy(() => CollectorHealthCheckCollectorHealthCheckPart0Type$inboundSchema),
]);
/** @internal */
export type CollectorHealthCheck$Outbound =
  | CollectorHealthCheckCollectorHealthCheckPart1Type$Outbound
  | CollectorHealthCheckHealthCheck4$Outbound
  | CollectorHealthCheckCollectorHealthCheckPart2Type$Outbound
  | CollectorHealthCheckHealthCheck5$Outbound
  | CollectorHealthCheckHealthCheck6$Outbound
  | CollectorHealthCheckHealthCheck7$Outbound
  | CollectorHealthCheckHealthCheck1$Outbound
  | CollectorHealthCheckHealthCheck2$Outbound
  | CollectorHealthCheckHealthCheck3$Outbound
  | CollectorHealthCheckCollectorHealthCheckPart0Type$Outbound;

/** @internal */
export const CollectorHealthCheck$outboundSchema: z.ZodType<
  CollectorHealthCheck$Outbound,
  z.ZodTypeDef,
  CollectorHealthCheck
> = z.union([
  z.lazy(() =>
    CollectorHealthCheckCollectorHealthCheckPart1Type$outboundSchema
  ),
  z.lazy(() => CollectorHealthCheckHealthCheck4$outboundSchema),
  z.lazy(() =>
    CollectorHealthCheckCollectorHealthCheckPart2Type$outboundSchema
  ),
  z.lazy(() => CollectorHealthCheckHealthCheck5$outboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck6$outboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck7$outboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck1$outboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck2$outboundSchema),
  z.lazy(() => CollectorHealthCheckHealthCheck3$outboundSchema),
  z.lazy(() =>
    CollectorHealthCheckCollectorHealthCheckPart0Type$outboundSchema
  ),
]);

export function collectorHealthCheckToJSON(
  collectorHealthCheck: CollectorHealthCheck,
): string {
  return JSON.stringify(
    CollectorHealthCheck$outboundSchema.parse(collectorHealthCheck),
  );
}
export function collectorHealthCheckFromJSON(
  jsonString: string,
): SafeParseResult<CollectorHealthCheck, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectorHealthCheck$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectorHealthCheck' from JSON`,
  );
}
