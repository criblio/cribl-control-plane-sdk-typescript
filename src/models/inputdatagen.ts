/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const InputDatagenType = {
  Datagen: "datagen",
} as const;
export type InputDatagenType = ClosedEnum<typeof InputDatagenType>;

export type InputDatagenConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputDatagenMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputDatagenMode = OpenEnum<typeof InputDatagenMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputDatagenCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputDatagenCompression = OpenEnum<typeof InputDatagenCompression>;

export type InputDatagenPqControls = {};

export type InputDatagenPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputDatagenMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputDatagenCompression | undefined;
  pqControls?: InputDatagenPqControls | undefined;
};

export type Sample = {
  sample: string;
  /**
   * Maximum number of events to generate per second per Worker Node. Defaults to 10.
   */
  eventsPerSec?: number | undefined;
};

export type InputDatagenMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputDatagen = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputDatagenType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputDatagenConnection> | undefined;
  pq?: InputDatagenPq | undefined;
  samples: Array<Sample>;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputDatagenMetadatum> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatagenType$inboundSchema: z.ZodNativeEnum<
  typeof InputDatagenType
> = z.nativeEnum(InputDatagenType);

/** @internal */
export const InputDatagenType$outboundSchema: z.ZodNativeEnum<
  typeof InputDatagenType
> = InputDatagenType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenType$ {
  /** @deprecated use `InputDatagenType$inboundSchema` instead. */
  export const inboundSchema = InputDatagenType$inboundSchema;
  /** @deprecated use `InputDatagenType$outboundSchema` instead. */
  export const outboundSchema = InputDatagenType$outboundSchema;
}

/** @internal */
export const InputDatagenConnection$inboundSchema: z.ZodType<
  InputDatagenConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputDatagenConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputDatagenConnection$outboundSchema: z.ZodType<
  InputDatagenConnection$Outbound,
  z.ZodTypeDef,
  InputDatagenConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenConnection$ {
  /** @deprecated use `InputDatagenConnection$inboundSchema` instead. */
  export const inboundSchema = InputDatagenConnection$inboundSchema;
  /** @deprecated use `InputDatagenConnection$outboundSchema` instead. */
  export const outboundSchema = InputDatagenConnection$outboundSchema;
  /** @deprecated use `InputDatagenConnection$Outbound` instead. */
  export type Outbound = InputDatagenConnection$Outbound;
}

export function inputDatagenConnectionToJSON(
  inputDatagenConnection: InputDatagenConnection,
): string {
  return JSON.stringify(
    InputDatagenConnection$outboundSchema.parse(inputDatagenConnection),
  );
}

export function inputDatagenConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputDatagenConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatagenConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatagenConnection' from JSON`,
  );
}

/** @internal */
export const InputDatagenMode$inboundSchema: z.ZodType<
  InputDatagenMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputDatagenMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputDatagenMode$outboundSchema: z.ZodType<
  InputDatagenMode,
  z.ZodTypeDef,
  InputDatagenMode
> = z.union([
  z.nativeEnum(InputDatagenMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenMode$ {
  /** @deprecated use `InputDatagenMode$inboundSchema` instead. */
  export const inboundSchema = InputDatagenMode$inboundSchema;
  /** @deprecated use `InputDatagenMode$outboundSchema` instead. */
  export const outboundSchema = InputDatagenMode$outboundSchema;
}

/** @internal */
export const InputDatagenCompression$inboundSchema: z.ZodType<
  InputDatagenCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputDatagenCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputDatagenCompression$outboundSchema: z.ZodType<
  InputDatagenCompression,
  z.ZodTypeDef,
  InputDatagenCompression
> = z.union([
  z.nativeEnum(InputDatagenCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenCompression$ {
  /** @deprecated use `InputDatagenCompression$inboundSchema` instead. */
  export const inboundSchema = InputDatagenCompression$inboundSchema;
  /** @deprecated use `InputDatagenCompression$outboundSchema` instead. */
  export const outboundSchema = InputDatagenCompression$outboundSchema;
}

/** @internal */
export const InputDatagenPqControls$inboundSchema: z.ZodType<
  InputDatagenPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type InputDatagenPqControls$Outbound = {};

/** @internal */
export const InputDatagenPqControls$outboundSchema: z.ZodType<
  InputDatagenPqControls$Outbound,
  z.ZodTypeDef,
  InputDatagenPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenPqControls$ {
  /** @deprecated use `InputDatagenPqControls$inboundSchema` instead. */
  export const inboundSchema = InputDatagenPqControls$inboundSchema;
  /** @deprecated use `InputDatagenPqControls$outboundSchema` instead. */
  export const outboundSchema = InputDatagenPqControls$outboundSchema;
  /** @deprecated use `InputDatagenPqControls$Outbound` instead. */
  export type Outbound = InputDatagenPqControls$Outbound;
}

export function inputDatagenPqControlsToJSON(
  inputDatagenPqControls: InputDatagenPqControls,
): string {
  return JSON.stringify(
    InputDatagenPqControls$outboundSchema.parse(inputDatagenPqControls),
  );
}

export function inputDatagenPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<InputDatagenPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatagenPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatagenPqControls' from JSON`,
  );
}

/** @internal */
export const InputDatagenPq$inboundSchema: z.ZodType<
  InputDatagenPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputDatagenMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputDatagenCompression$inboundSchema.default("none"),
  pqControls: z.lazy(() => InputDatagenPqControls$inboundSchema).optional(),
});

/** @internal */
export type InputDatagenPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
  pqControls?: InputDatagenPqControls$Outbound | undefined;
};

/** @internal */
export const InputDatagenPq$outboundSchema: z.ZodType<
  InputDatagenPq$Outbound,
  z.ZodTypeDef,
  InputDatagenPq
> = z.object({
  mode: InputDatagenMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputDatagenCompression$outboundSchema.default("none"),
  pqControls: z.lazy(() => InputDatagenPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenPq$ {
  /** @deprecated use `InputDatagenPq$inboundSchema` instead. */
  export const inboundSchema = InputDatagenPq$inboundSchema;
  /** @deprecated use `InputDatagenPq$outboundSchema` instead. */
  export const outboundSchema = InputDatagenPq$outboundSchema;
  /** @deprecated use `InputDatagenPq$Outbound` instead. */
  export type Outbound = InputDatagenPq$Outbound;
}

export function inputDatagenPqToJSON(inputDatagenPq: InputDatagenPq): string {
  return JSON.stringify(InputDatagenPq$outboundSchema.parse(inputDatagenPq));
}

export function inputDatagenPqFromJSON(
  jsonString: string,
): SafeParseResult<InputDatagenPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatagenPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatagenPq' from JSON`,
  );
}

/** @internal */
export const Sample$inboundSchema: z.ZodType<Sample, z.ZodTypeDef, unknown> = z
  .object({
    sample: z.string(),
    eventsPerSec: z.number().default(10),
  });

/** @internal */
export type Sample$Outbound = {
  sample: string;
  eventsPerSec: number;
};

/** @internal */
export const Sample$outboundSchema: z.ZodType<
  Sample$Outbound,
  z.ZodTypeDef,
  Sample
> = z.object({
  sample: z.string(),
  eventsPerSec: z.number().default(10),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Sample$ {
  /** @deprecated use `Sample$inboundSchema` instead. */
  export const inboundSchema = Sample$inboundSchema;
  /** @deprecated use `Sample$outboundSchema` instead. */
  export const outboundSchema = Sample$outboundSchema;
  /** @deprecated use `Sample$Outbound` instead. */
  export type Outbound = Sample$Outbound;
}

export function sampleToJSON(sample: Sample): string {
  return JSON.stringify(Sample$outboundSchema.parse(sample));
}

export function sampleFromJSON(
  jsonString: string,
): SafeParseResult<Sample, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Sample$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Sample' from JSON`,
  );
}

/** @internal */
export const InputDatagenMetadatum$inboundSchema: z.ZodType<
  InputDatagenMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputDatagenMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputDatagenMetadatum$outboundSchema: z.ZodType<
  InputDatagenMetadatum$Outbound,
  z.ZodTypeDef,
  InputDatagenMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagenMetadatum$ {
  /** @deprecated use `InputDatagenMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputDatagenMetadatum$inboundSchema;
  /** @deprecated use `InputDatagenMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputDatagenMetadatum$outboundSchema;
  /** @deprecated use `InputDatagenMetadatum$Outbound` instead. */
  export type Outbound = InputDatagenMetadatum$Outbound;
}

export function inputDatagenMetadatumToJSON(
  inputDatagenMetadatum: InputDatagenMetadatum,
): string {
  return JSON.stringify(
    InputDatagenMetadatum$outboundSchema.parse(inputDatagenMetadatum),
  );
}

export function inputDatagenMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputDatagenMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatagenMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatagenMetadatum' from JSON`,
  );
}

/** @internal */
export const InputDatagen$inboundSchema: z.ZodType<
  InputDatagen,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: InputDatagenType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputDatagenConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputDatagenPq$inboundSchema).optional(),
  samples: z.array(z.lazy(() => Sample$inboundSchema)),
  metadata: z.array(z.lazy(() => InputDatagenMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputDatagen$Outbound = {
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputDatagenConnection$Outbound> | undefined;
  pq?: InputDatagenPq$Outbound | undefined;
  samples: Array<Sample$Outbound>;
  metadata?: Array<InputDatagenMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputDatagen$outboundSchema: z.ZodType<
  InputDatagen$Outbound,
  z.ZodTypeDef,
  InputDatagen
> = z.object({
  id: z.string().optional(),
  type: InputDatagenType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputDatagenConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputDatagenPq$outboundSchema).optional(),
  samples: z.array(z.lazy(() => Sample$outboundSchema)),
  metadata: z.array(z.lazy(() => InputDatagenMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputDatagen$ {
  /** @deprecated use `InputDatagen$inboundSchema` instead. */
  export const inboundSchema = InputDatagen$inboundSchema;
  /** @deprecated use `InputDatagen$outboundSchema` instead. */
  export const outboundSchema = InputDatagen$outboundSchema;
  /** @deprecated use `InputDatagen$Outbound` instead. */
  export type Outbound = InputDatagen$Outbound;
}

export function inputDatagenToJSON(inputDatagen: InputDatagen): string {
  return JSON.stringify(InputDatagen$outboundSchema.parse(inputDatagen));
}

export function inputDatagenFromJSON(
  jsonString: string,
): SafeParseResult<InputDatagen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputDatagen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputDatagen' from JSON`,
  );
}
