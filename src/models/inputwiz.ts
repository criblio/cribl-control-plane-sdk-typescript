/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const InputWizType = {
  Wiz: "wiz",
} as const;
export type InputWizType = ClosedEnum<typeof InputWizType>;

export type InputWizConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputWizMode = {
  /**
   * Smart
   */
  Smart: "smart",
  /**
   * Always On
   */
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputWizMode = OpenEnum<typeof InputWizMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputWizCompression = {
  /**
   * None
   */
  None: "none",
  /**
   * Gzip
   */
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputWizCompression = OpenEnum<typeof InputWizCompression>;

export type InputWizPqControls = {};

export type InputWizPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputWizMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputWizCompression | undefined;
  pqControls?: InputWizPqControls | undefined;
};

export type InputWizContentConfig = {
  /**
   * The name of the Wiz query
   */
  contentType: string;
  contentDescription?: string | undefined;
  enabled?: boolean | undefined;
};

export type InputWizMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const InputWizRetryType = {
  /**
   * Disabled
   */
  None: "none",
  /**
   * Backoff
   */
  Backoff: "backoff",
  /**
   * Static
   */
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type InputWizRetryType = OpenEnum<typeof InputWizRetryType>;

export type InputWizRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: InputWizRetryType | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Enter client secret directly, or select a stored secret
 */
export const InputWizAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter client secret directly, or select a stored secret
 */
export type InputWizAuthenticationMethod = OpenEnum<
  typeof InputWizAuthenticationMethod
>;

export type InputWiz = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWizType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputWizConnection> | undefined;
  pq?: InputWizPq | undefined;
  /**
   * The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
   */
  endpoint?: string | undefined;
  /**
   * The authentication URL to generate an OAuth token
   */
  authUrl: string;
  /**
   * The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
   */
  authAudienceOverride?: string | undefined;
  /**
   * The client ID of the Wiz application
   */
  clientId: string;
  contentConfig: Array<InputWizContentConfig>;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputWizMetadatum> | undefined;
  retryRules?: InputWizRetryRules | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: InputWizAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * The client secret of the Wiz application
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

/** @internal */
export const InputWizType$inboundSchema: z.ZodNativeEnum<typeof InputWizType> =
  z.nativeEnum(InputWizType);

/** @internal */
export const InputWizType$outboundSchema: z.ZodNativeEnum<typeof InputWizType> =
  InputWizType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizType$ {
  /** @deprecated use `InputWizType$inboundSchema` instead. */
  export const inboundSchema = InputWizType$inboundSchema;
  /** @deprecated use `InputWizType$outboundSchema` instead. */
  export const outboundSchema = InputWizType$outboundSchema;
}

/** @internal */
export const InputWizConnection$inboundSchema: z.ZodType<
  InputWizConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputWizConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputWizConnection$outboundSchema: z.ZodType<
  InputWizConnection$Outbound,
  z.ZodTypeDef,
  InputWizConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizConnection$ {
  /** @deprecated use `InputWizConnection$inboundSchema` instead. */
  export const inboundSchema = InputWizConnection$inboundSchema;
  /** @deprecated use `InputWizConnection$outboundSchema` instead. */
  export const outboundSchema = InputWizConnection$outboundSchema;
  /** @deprecated use `InputWizConnection$Outbound` instead. */
  export type Outbound = InputWizConnection$Outbound;
}

export function inputWizConnectionToJSON(
  inputWizConnection: InputWizConnection,
): string {
  return JSON.stringify(
    InputWizConnection$outboundSchema.parse(inputWizConnection),
  );
}

export function inputWizConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputWizConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizConnection' from JSON`,
  );
}

/** @internal */
export const InputWizMode$inboundSchema: z.ZodType<
  InputWizMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWizMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWizMode$outboundSchema: z.ZodType<
  InputWizMode,
  z.ZodTypeDef,
  InputWizMode
> = z.union([
  z.nativeEnum(InputWizMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizMode$ {
  /** @deprecated use `InputWizMode$inboundSchema` instead. */
  export const inboundSchema = InputWizMode$inboundSchema;
  /** @deprecated use `InputWizMode$outboundSchema` instead. */
  export const outboundSchema = InputWizMode$outboundSchema;
}

/** @internal */
export const InputWizCompression$inboundSchema: z.ZodType<
  InputWizCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWizCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWizCompression$outboundSchema: z.ZodType<
  InputWizCompression,
  z.ZodTypeDef,
  InputWizCompression
> = z.union([
  z.nativeEnum(InputWizCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizCompression$ {
  /** @deprecated use `InputWizCompression$inboundSchema` instead. */
  export const inboundSchema = InputWizCompression$inboundSchema;
  /** @deprecated use `InputWizCompression$outboundSchema` instead. */
  export const outboundSchema = InputWizCompression$outboundSchema;
}

/** @internal */
export const InputWizPqControls$inboundSchema: z.ZodType<
  InputWizPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type InputWizPqControls$Outbound = {};

/** @internal */
export const InputWizPqControls$outboundSchema: z.ZodType<
  InputWizPqControls$Outbound,
  z.ZodTypeDef,
  InputWizPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizPqControls$ {
  /** @deprecated use `InputWizPqControls$inboundSchema` instead. */
  export const inboundSchema = InputWizPqControls$inboundSchema;
  /** @deprecated use `InputWizPqControls$outboundSchema` instead. */
  export const outboundSchema = InputWizPqControls$outboundSchema;
  /** @deprecated use `InputWizPqControls$Outbound` instead. */
  export type Outbound = InputWizPqControls$Outbound;
}

export function inputWizPqControlsToJSON(
  inputWizPqControls: InputWizPqControls,
): string {
  return JSON.stringify(
    InputWizPqControls$outboundSchema.parse(inputWizPqControls),
  );
}

export function inputWizPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<InputWizPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizPqControls' from JSON`,
  );
}

/** @internal */
export const InputWizPq$inboundSchema: z.ZodType<
  InputWizPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWizMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWizCompression$inboundSchema.default("none"),
  pqControls: z.lazy(() => InputWizPqControls$inboundSchema).optional(),
});

/** @internal */
export type InputWizPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
  pqControls?: InputWizPqControls$Outbound | undefined;
};

/** @internal */
export const InputWizPq$outboundSchema: z.ZodType<
  InputWizPq$Outbound,
  z.ZodTypeDef,
  InputWizPq
> = z.object({
  mode: InputWizMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWizCompression$outboundSchema.default("none"),
  pqControls: z.lazy(() => InputWizPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizPq$ {
  /** @deprecated use `InputWizPq$inboundSchema` instead. */
  export const inboundSchema = InputWizPq$inboundSchema;
  /** @deprecated use `InputWizPq$outboundSchema` instead. */
  export const outboundSchema = InputWizPq$outboundSchema;
  /** @deprecated use `InputWizPq$Outbound` instead. */
  export type Outbound = InputWizPq$Outbound;
}

export function inputWizPqToJSON(inputWizPq: InputWizPq): string {
  return JSON.stringify(InputWizPq$outboundSchema.parse(inputWizPq));
}

export function inputWizPqFromJSON(
  jsonString: string,
): SafeParseResult<InputWizPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizPq' from JSON`,
  );
}

/** @internal */
export const InputWizContentConfig$inboundSchema: z.ZodType<
  InputWizContentConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  contentType: z.string(),
  contentDescription: z.string().optional(),
  enabled: z.boolean().default(false),
});

/** @internal */
export type InputWizContentConfig$Outbound = {
  contentType: string;
  contentDescription?: string | undefined;
  enabled: boolean;
};

/** @internal */
export const InputWizContentConfig$outboundSchema: z.ZodType<
  InputWizContentConfig$Outbound,
  z.ZodTypeDef,
  InputWizContentConfig
> = z.object({
  contentType: z.string(),
  contentDescription: z.string().optional(),
  enabled: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizContentConfig$ {
  /** @deprecated use `InputWizContentConfig$inboundSchema` instead. */
  export const inboundSchema = InputWizContentConfig$inboundSchema;
  /** @deprecated use `InputWizContentConfig$outboundSchema` instead. */
  export const outboundSchema = InputWizContentConfig$outboundSchema;
  /** @deprecated use `InputWizContentConfig$Outbound` instead. */
  export type Outbound = InputWizContentConfig$Outbound;
}

export function inputWizContentConfigToJSON(
  inputWizContentConfig: InputWizContentConfig,
): string {
  return JSON.stringify(
    InputWizContentConfig$outboundSchema.parse(inputWizContentConfig),
  );
}

export function inputWizContentConfigFromJSON(
  jsonString: string,
): SafeParseResult<InputWizContentConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizContentConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizContentConfig' from JSON`,
  );
}

/** @internal */
export const InputWizMetadatum$inboundSchema: z.ZodType<
  InputWizMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputWizMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputWizMetadatum$outboundSchema: z.ZodType<
  InputWizMetadatum$Outbound,
  z.ZodTypeDef,
  InputWizMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizMetadatum$ {
  /** @deprecated use `InputWizMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputWizMetadatum$inboundSchema;
  /** @deprecated use `InputWizMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputWizMetadatum$outboundSchema;
  /** @deprecated use `InputWizMetadatum$Outbound` instead. */
  export type Outbound = InputWizMetadatum$Outbound;
}

export function inputWizMetadatumToJSON(
  inputWizMetadatum: InputWizMetadatum,
): string {
  return JSON.stringify(
    InputWizMetadatum$outboundSchema.parse(inputWizMetadatum),
  );
}

export function inputWizMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputWizMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizMetadatum' from JSON`,
  );
}

/** @internal */
export const InputWizRetryType$inboundSchema: z.ZodType<
  InputWizRetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWizRetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWizRetryType$outboundSchema: z.ZodType<
  InputWizRetryType,
  z.ZodTypeDef,
  InputWizRetryType
> = z.union([
  z.nativeEnum(InputWizRetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizRetryType$ {
  /** @deprecated use `InputWizRetryType$inboundSchema` instead. */
  export const inboundSchema = InputWizRetryType$inboundSchema;
  /** @deprecated use `InputWizRetryType$outboundSchema` instead. */
  export const outboundSchema = InputWizRetryType$outboundSchema;
}

/** @internal */
export const InputWizRetryRules$inboundSchema: z.ZodType<
  InputWizRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InputWizRetryType$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type InputWizRetryRules$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const InputWizRetryRules$outboundSchema: z.ZodType<
  InputWizRetryRules$Outbound,
  z.ZodTypeDef,
  InputWizRetryRules
> = z.object({
  type: InputWizRetryType$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizRetryRules$ {
  /** @deprecated use `InputWizRetryRules$inboundSchema` instead. */
  export const inboundSchema = InputWizRetryRules$inboundSchema;
  /** @deprecated use `InputWizRetryRules$outboundSchema` instead. */
  export const outboundSchema = InputWizRetryRules$outboundSchema;
  /** @deprecated use `InputWizRetryRules$Outbound` instead. */
  export type Outbound = InputWizRetryRules$Outbound;
}

export function inputWizRetryRulesToJSON(
  inputWizRetryRules: InputWizRetryRules,
): string {
  return JSON.stringify(
    InputWizRetryRules$outboundSchema.parse(inputWizRetryRules),
  );
}

export function inputWizRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<InputWizRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizRetryRules' from JSON`,
  );
}

/** @internal */
export const InputWizAuthenticationMethod$inboundSchema: z.ZodType<
  InputWizAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputWizAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputWizAuthenticationMethod$outboundSchema: z.ZodType<
  InputWizAuthenticationMethod,
  z.ZodTypeDef,
  InputWizAuthenticationMethod
> = z.union([
  z.nativeEnum(InputWizAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWizAuthenticationMethod$ {
  /** @deprecated use `InputWizAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema = InputWizAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputWizAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema = InputWizAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputWiz$inboundSchema: z.ZodType<
  InputWiz,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: InputWizType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWizConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputWizPq$inboundSchema).optional(),
  endpoint: z.string().default("https://api.<region>.app.wiz.io/graphql"),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => InputWizContentConfig$inboundSchema)),
  requestTimeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputWizMetadatum$inboundSchema)).optional(),
  retryRules: z.lazy(() => InputWizRetryRules$inboundSchema).optional(),
  authType: InputWizAuthenticationMethod$inboundSchema.default("manual"),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/** @internal */
export type InputWiz$Outbound = {
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputWizConnection$Outbound> | undefined;
  pq?: InputWizPq$Outbound | undefined;
  endpoint: string;
  authUrl: string;
  authAudienceOverride?: string | undefined;
  clientId: string;
  contentConfig: Array<InputWizContentConfig$Outbound>;
  requestTimeout: number;
  keepAliveTime: number;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<InputWizMetadatum$Outbound> | undefined;
  retryRules?: InputWizRetryRules$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputWiz$outboundSchema: z.ZodType<
  InputWiz$Outbound,
  z.ZodTypeDef,
  InputWiz
> = z.object({
  id: z.string().optional(),
  type: InputWizType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWizConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputWizPq$outboundSchema).optional(),
  endpoint: z.string().default("https://api.<region>.app.wiz.io/graphql"),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => InputWizContentConfig$outboundSchema)),
  requestTimeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputWizMetadatum$outboundSchema)).optional(),
  retryRules: z.lazy(() => InputWizRetryRules$outboundSchema).optional(),
  authType: InputWizAuthenticationMethod$outboundSchema.default("manual"),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputWiz$ {
  /** @deprecated use `InputWiz$inboundSchema` instead. */
  export const inboundSchema = InputWiz$inboundSchema;
  /** @deprecated use `InputWiz$outboundSchema` instead. */
  export const outboundSchema = InputWiz$outboundSchema;
  /** @deprecated use `InputWiz$Outbound` instead. */
  export type Outbound = InputWiz$Outbound;
}

export function inputWizToJSON(inputWiz: InputWiz): string {
  return JSON.stringify(InputWiz$outboundSchema.parse(inputWiz));
}

export function inputWizFromJSON(
  jsonString: string,
): SafeParseResult<InputWiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWiz' from JSON`,
  );
}
