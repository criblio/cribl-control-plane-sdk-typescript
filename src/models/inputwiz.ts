/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const InputWizType = {
  Wiz: "wiz",
} as const;
export type InputWizType = ClosedEnum<typeof InputWizType>;

export type InputWizConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputWizMode = {
  /**
   * Smart
   */
  Smart: "smart",
  /**
   * Always On
   */
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputWizMode = OpenEnum<typeof InputWizMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputWizCompression = {
  /**
   * None
   */
  None: "none",
  /**
   * Gzip
   */
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputWizCompression = OpenEnum<typeof InputWizCompression>;

export type InputWizPqControls = {};

export type InputWizPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputWizMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputWizCompression | undefined;
  pqControls?: InputWizPqControls | undefined;
};

export type InputWizContentConfig = {
  /**
   * The name of the Wiz query
   */
  contentType: string;
  contentDescription?: string | undefined;
  enabled?: boolean | undefined;
};

export type InputWizMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const InputWizRetryType = {
  /**
   * Disabled
   */
  None: "none",
  /**
   * Backoff
   */
  Backoff: "backoff",
  /**
   * Static
   */
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type InputWizRetryType = OpenEnum<typeof InputWizRetryType>;

export type InputWizRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: InputWizRetryType | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Enter client secret directly, or select a stored secret
 */
export const InputWizAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter client secret directly, or select a stored secret
 */
export type InputWizAuthenticationMethod = OpenEnum<
  typeof InputWizAuthenticationMethod
>;

export type InputWiz = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWizType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputWizConnection> | undefined;
  pq?: InputWizPq | undefined;
  /**
   * The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
   */
  endpoint?: string | undefined;
  /**
   * The authentication URL to generate an OAuth token
   */
  authUrl: string;
  /**
   * The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
   */
  authAudienceOverride?: string | undefined;
  /**
   * The client ID of the Wiz application
   */
  clientId: string;
  contentConfig: Array<InputWizContentConfig>;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputWizMetadatum> | undefined;
  retryRules?: InputWizRetryRules | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: InputWizAuthenticationMethod | undefined;
  description?: string | undefined;
  /**
   * The client secret of the Wiz application
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

/** @internal */
export const InputWizType$inboundSchema: z.ZodNativeEnum<typeof InputWizType> =
  z.nativeEnum(InputWizType);
/** @internal */
export const InputWizType$outboundSchema: z.ZodNativeEnum<typeof InputWizType> =
  InputWizType$inboundSchema;

/** @internal */
export const InputWizConnection$inboundSchema: z.ZodType<
  InputWizConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});
/** @internal */
export type InputWizConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputWizConnection$outboundSchema: z.ZodType<
  InputWizConnection$Outbound,
  z.ZodTypeDef,
  InputWizConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

export function inputWizConnectionToJSON(
  inputWizConnection: InputWizConnection,
): string {
  return JSON.stringify(
    InputWizConnection$outboundSchema.parse(inputWizConnection),
  );
}
export function inputWizConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputWizConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizConnection' from JSON`,
  );
}

/** @internal */
export const InputWizMode$inboundSchema: z.ZodType<
  InputWizMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWizMode);
/** @internal */
export const InputWizMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWizMode
> = openEnums.outboundSchema(InputWizMode);

/** @internal */
export const InputWizCompression$inboundSchema: z.ZodType<
  InputWizCompression,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWizCompression);
/** @internal */
export const InputWizCompression$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWizCompression
> = openEnums.outboundSchema(InputWizCompression);

/** @internal */
export const InputWizPqControls$inboundSchema: z.ZodType<
  InputWizPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type InputWizPqControls$Outbound = {};

/** @internal */
export const InputWizPqControls$outboundSchema: z.ZodType<
  InputWizPqControls$Outbound,
  z.ZodTypeDef,
  InputWizPqControls
> = z.object({});

export function inputWizPqControlsToJSON(
  inputWizPqControls: InputWizPqControls,
): string {
  return JSON.stringify(
    InputWizPqControls$outboundSchema.parse(inputWizPqControls),
  );
}
export function inputWizPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<InputWizPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizPqControls' from JSON`,
  );
}

/** @internal */
export const InputWizPq$inboundSchema: z.ZodType<
  InputWizPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWizMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWizCompression$inboundSchema.default("none"),
  pqControls: z.lazy(() => InputWizPqControls$inboundSchema).optional(),
});
/** @internal */
export type InputWizPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
  pqControls?: InputWizPqControls$Outbound | undefined;
};

/** @internal */
export const InputWizPq$outboundSchema: z.ZodType<
  InputWizPq$Outbound,
  z.ZodTypeDef,
  InputWizPq
> = z.object({
  mode: InputWizMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWizCompression$outboundSchema.default("none"),
  pqControls: z.lazy(() => InputWizPqControls$outboundSchema).optional(),
});

export function inputWizPqToJSON(inputWizPq: InputWizPq): string {
  return JSON.stringify(InputWizPq$outboundSchema.parse(inputWizPq));
}
export function inputWizPqFromJSON(
  jsonString: string,
): SafeParseResult<InputWizPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizPq' from JSON`,
  );
}

/** @internal */
export const InputWizContentConfig$inboundSchema: z.ZodType<
  InputWizContentConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  contentType: z.string(),
  contentDescription: z.string().optional(),
  enabled: z.boolean().default(false),
});
/** @internal */
export type InputWizContentConfig$Outbound = {
  contentType: string;
  contentDescription?: string | undefined;
  enabled: boolean;
};

/** @internal */
export const InputWizContentConfig$outboundSchema: z.ZodType<
  InputWizContentConfig$Outbound,
  z.ZodTypeDef,
  InputWizContentConfig
> = z.object({
  contentType: z.string(),
  contentDescription: z.string().optional(),
  enabled: z.boolean().default(false),
});

export function inputWizContentConfigToJSON(
  inputWizContentConfig: InputWizContentConfig,
): string {
  return JSON.stringify(
    InputWizContentConfig$outboundSchema.parse(inputWizContentConfig),
  );
}
export function inputWizContentConfigFromJSON(
  jsonString: string,
): SafeParseResult<InputWizContentConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizContentConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizContentConfig' from JSON`,
  );
}

/** @internal */
export const InputWizMetadatum$inboundSchema: z.ZodType<
  InputWizMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type InputWizMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputWizMetadatum$outboundSchema: z.ZodType<
  InputWizMetadatum$Outbound,
  z.ZodTypeDef,
  InputWizMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function inputWizMetadatumToJSON(
  inputWizMetadatum: InputWizMetadatum,
): string {
  return JSON.stringify(
    InputWizMetadatum$outboundSchema.parse(inputWizMetadatum),
  );
}
export function inputWizMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputWizMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizMetadatum' from JSON`,
  );
}

/** @internal */
export const InputWizRetryType$inboundSchema: z.ZodType<
  InputWizRetryType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWizRetryType);
/** @internal */
export const InputWizRetryType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWizRetryType
> = openEnums.outboundSchema(InputWizRetryType);

/** @internal */
export const InputWizRetryRules$inboundSchema: z.ZodType<
  InputWizRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InputWizRetryType$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});
/** @internal */
export type InputWizRetryRules$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const InputWizRetryRules$outboundSchema: z.ZodType<
  InputWizRetryRules$Outbound,
  z.ZodTypeDef,
  InputWizRetryRules
> = z.object({
  type: InputWizRetryType$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

export function inputWizRetryRulesToJSON(
  inputWizRetryRules: InputWizRetryRules,
): string {
  return JSON.stringify(
    InputWizRetryRules$outboundSchema.parse(inputWizRetryRules),
  );
}
export function inputWizRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<InputWizRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizRetryRules' from JSON`,
  );
}

/** @internal */
export const InputWizAuthenticationMethod$inboundSchema: z.ZodType<
  InputWizAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWizAuthenticationMethod);
/** @internal */
export const InputWizAuthenticationMethod$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWizAuthenticationMethod
> = openEnums.outboundSchema(InputWizAuthenticationMethod);

/** @internal */
export const InputWiz$inboundSchema: z.ZodType<
  InputWiz,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: InputWizType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWizConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputWizPq$inboundSchema).optional(),
  endpoint: z.string().default("https://api.<region>.app.wiz.io/graphql"),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => InputWizContentConfig$inboundSchema)),
  requestTimeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputWizMetadatum$inboundSchema)).optional(),
  retryRules: z.lazy(() => InputWizRetryRules$inboundSchema).optional(),
  authType: InputWizAuthenticationMethod$inboundSchema.default("manual"),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputWiz$Outbound = {
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputWizConnection$Outbound> | undefined;
  pq?: InputWizPq$Outbound | undefined;
  endpoint: string;
  authUrl: string;
  authAudienceOverride?: string | undefined;
  clientId: string;
  contentConfig: Array<InputWizContentConfig$Outbound>;
  requestTimeout: number;
  keepAliveTime: number;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<InputWizMetadatum$Outbound> | undefined;
  retryRules?: InputWizRetryRules$Outbound | undefined;
  authType: string;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputWiz$outboundSchema: z.ZodType<
  InputWiz$Outbound,
  z.ZodTypeDef,
  InputWiz
> = z.object({
  id: z.string().optional(),
  type: InputWizType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputWizConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputWizPq$outboundSchema).optional(),
  endpoint: z.string().default("https://api.<region>.app.wiz.io/graphql"),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => InputWizContentConfig$outboundSchema)),
  requestTimeout: z.number().default(300),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputWizMetadatum$outboundSchema)).optional(),
  retryRules: z.lazy(() => InputWizRetryRules$outboundSchema).optional(),
  authType: InputWizAuthenticationMethod$outboundSchema.default("manual"),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

export function inputWizToJSON(inputWiz: InputWiz): string {
  return JSON.stringify(InputWiz$outboundSchema.parse(inputWiz));
}
export function inputWizFromJSON(
  jsonString: string,
): SafeParseResult<InputWiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWiz' from JSON`,
  );
}
