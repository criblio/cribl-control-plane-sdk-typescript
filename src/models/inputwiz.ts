/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthenticationMethodOptions1,
  AuthenticationMethodOptions1$inboundSchema,
  AuthenticationMethodOptions1$outboundSchema,
} from "./authenticationmethodoptions1.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeConnectionsOptional,
  ItemsTypeConnectionsOptional$inboundSchema,
  ItemsTypeConnectionsOptional$Outbound,
  ItemsTypeConnectionsOptional$outboundSchema,
} from "./itemstypeconnectionsoptional.js";
import {
  ItemsTypeNotificationMetadata,
  ItemsTypeNotificationMetadata$inboundSchema,
  ItemsTypeNotificationMetadata$Outbound,
  ItemsTypeNotificationMetadata$outboundSchema,
} from "./itemstypenotificationmetadata.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  RetryRulesType,
  RetryRulesType$inboundSchema,
  RetryRulesType$Outbound,
  RetryRulesType$outboundSchema,
} from "./retryrulestype.js";

export type ManageState = {};

/**
 * Collector runtime log level
 */
export const InputWizLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
  Silly: "silly",
} as const;
/**
 * Collector runtime log level
 */
export type InputWizLogLevel = OpenEnum<typeof InputWizLogLevel>;

export type InputWizContentConfig = {
  /**
   * The name of the Wiz query
   */
  contentType: string;
  contentDescription?: string | undefined;
  enabled?: boolean | undefined;
  /**
   * Track collection progress between consecutive scheduled executions
   */
  stateTracking?: boolean | undefined;
  /**
   * JavaScript expression that defines how to update the state from an event. Use the event's data and the current state to compute the new state. See [Understanding State Expression Fields](https://docs.cribl.io/stream/collectors-rest#state-tracking-expression-fields) for more information.
   */
  stateUpdateExpression?: string | undefined;
  /**
   * JavaScript expression that defines which state to keep when merging a task's newly reported state with previously saved state. Evaluates `prevState` and `newState` variables, resolving to the state to keep.
   */
  stateMergeExpression?: string | undefined;
  manageState?: ManageState | undefined;
  /**
   * Template for POST body to send with the Collect request. Reference global variables, or functions using template params: `${C.vars.myVar}`, or `${Date.now()}`, `${param}`.
   */
  contentQuery: string;
  /**
   * A cron schedule on which to run this job
   */
  cronSchedule: string;
  /**
   * Earliest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)
   */
  earliest: string;
  /**
   * Latest time, relative to now. Format supported: [+|-]<time_integer><time_unit>@<snap-to_time_unit> (ex: -1hr, -42m, -42m@h)
   */
  latest: string;
  /**
   * Maximum time the job is allowed to run (examples: 30, 45s, 15m). Units default to seconds if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * Collector runtime log level
   */
  logLevel?: InputWizLogLevel | undefined;
  /**
   * Maximum number of pages to retrieve per collection task. Defaults to 0. Set to 0 to retrieve all pages.
   */
  maxPages?: number | undefined;
};

export type InputWiz = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: "wiz";
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnectionsOptional> | undefined;
  pq?: PqType | undefined;
  /**
   * The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql
   */
  endpoint: string;
  /**
   * The authentication URL to generate an OAuth token
   */
  authUrl: string;
  /**
   * The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
   */
  authAudienceOverride?: string | undefined;
  /**
   * The client ID of the Wiz application
   */
  clientId: string;
  contentConfig: Array<InputWizContentConfig>;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  retryRules?: RetryRulesType | undefined;
  /**
   * Enter client secret directly, or select a stored secret
   */
  authType?: AuthenticationMethodOptions1 | undefined;
  description?: string | undefined;
  /**
   * The client secret of the Wiz application
   */
  clientSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

/** @internal */
export const ManageState$inboundSchema: z.ZodType<
  ManageState,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type ManageState$Outbound = {};

/** @internal */
export const ManageState$outboundSchema: z.ZodType<
  ManageState$Outbound,
  z.ZodTypeDef,
  ManageState
> = z.object({});

export function manageStateToJSON(manageState: ManageState): string {
  return JSON.stringify(ManageState$outboundSchema.parse(manageState));
}
export function manageStateFromJSON(
  jsonString: string,
): SafeParseResult<ManageState, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ManageState$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ManageState' from JSON`,
  );
}

/** @internal */
export const InputWizLogLevel$inboundSchema: z.ZodType<
  InputWizLogLevel,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWizLogLevel);
/** @internal */
export const InputWizLogLevel$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWizLogLevel
> = openEnums.outboundSchema(InputWizLogLevel);

/** @internal */
export const InputWizContentConfig$inboundSchema: z.ZodType<
  InputWizContentConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  contentType: z.string(),
  contentDescription: z.string().optional(),
  enabled: z.boolean().optional(),
  stateTracking: z.boolean().optional(),
  stateUpdateExpression: z.string().optional(),
  stateMergeExpression: z.string().optional(),
  manageState: z.lazy(() => ManageState$inboundSchema).optional(),
  contentQuery: z.string(),
  cronSchedule: z.string(),
  earliest: z.string(),
  latest: z.string(),
  jobTimeout: z.string().optional(),
  logLevel: InputWizLogLevel$inboundSchema.optional(),
  maxPages: z.number().optional(),
});
/** @internal */
export type InputWizContentConfig$Outbound = {
  contentType: string;
  contentDescription?: string | undefined;
  enabled?: boolean | undefined;
  stateTracking?: boolean | undefined;
  stateUpdateExpression?: string | undefined;
  stateMergeExpression?: string | undefined;
  manageState?: ManageState$Outbound | undefined;
  contentQuery: string;
  cronSchedule: string;
  earliest: string;
  latest: string;
  jobTimeout?: string | undefined;
  logLevel?: string | undefined;
  maxPages?: number | undefined;
};

/** @internal */
export const InputWizContentConfig$outboundSchema: z.ZodType<
  InputWizContentConfig$Outbound,
  z.ZodTypeDef,
  InputWizContentConfig
> = z.object({
  contentType: z.string(),
  contentDescription: z.string().optional(),
  enabled: z.boolean().optional(),
  stateTracking: z.boolean().optional(),
  stateUpdateExpression: z.string().optional(),
  stateMergeExpression: z.string().optional(),
  manageState: z.lazy(() => ManageState$outboundSchema).optional(),
  contentQuery: z.string(),
  cronSchedule: z.string(),
  earliest: z.string(),
  latest: z.string(),
  jobTimeout: z.string().optional(),
  logLevel: InputWizLogLevel$outboundSchema.optional(),
  maxPages: z.number().optional(),
});

export function inputWizContentConfigToJSON(
  inputWizContentConfig: InputWizContentConfig,
): string {
  return JSON.stringify(
    InputWizContentConfig$outboundSchema.parse(inputWizContentConfig),
  );
}
export function inputWizContentConfigFromJSON(
  jsonString: string,
): SafeParseResult<InputWizContentConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWizContentConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWizContentConfig' from JSON`,
  );
}

/** @internal */
export const InputWiz$inboundSchema: z.ZodType<
  InputWiz,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: z.literal("wiz"),
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ItemsTypeConnectionsOptional$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  endpoint: z.string(),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => InputWizContentConfig$inboundSchema)),
  requestTimeout: z.number().optional(),
  keepAliveTime: z.number().optional(),
  maxMissedKeepAlives: z.number().optional(),
  ttl: z.string().optional(),
  ignoreGroupJobsLimit: z.boolean().optional(),
  metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
  retryRules: RetryRulesType$inboundSchema.optional(),
  authType: AuthenticationMethodOptions1$inboundSchema.optional(),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputWiz$Outbound = {
  id?: string | undefined;
  type: "wiz";
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  endpoint: string;
  authUrl: string;
  authAudienceOverride?: string | undefined;
  clientId: string;
  contentConfig: Array<InputWizContentConfig$Outbound>;
  requestTimeout?: number | undefined;
  keepAliveTime?: number | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  retryRules?: RetryRulesType$Outbound | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  clientSecret?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const InputWiz$outboundSchema: z.ZodType<
  InputWiz$Outbound,
  z.ZodTypeDef,
  InputWiz
> = z.object({
  id: z.string().optional(),
  type: z.literal("wiz"),
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ItemsTypeConnectionsOptional$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  endpoint: z.string(),
  authUrl: z.string(),
  authAudienceOverride: z.string().optional(),
  clientId: z.string(),
  contentConfig: z.array(z.lazy(() => InputWizContentConfig$outboundSchema)),
  requestTimeout: z.number().optional(),
  keepAliveTime: z.number().optional(),
  maxMissedKeepAlives: z.number().optional(),
  ttl: z.string().optional(),
  ignoreGroupJobsLimit: z.boolean().optional(),
  metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
  retryRules: RetryRulesType$outboundSchema.optional(),
  authType: AuthenticationMethodOptions1$outboundSchema.optional(),
  description: z.string().optional(),
  clientSecret: z.string().optional(),
  textSecret: z.string().optional(),
});

export function inputWizToJSON(inputWiz: InputWiz): string {
  return JSON.stringify(InputWiz$outboundSchema.parse(inputWiz));
}
export function inputWizFromJSON(
  jsonString: string,
): SafeParseResult<InputWiz, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWiz$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWiz' from JSON`,
  );
}
