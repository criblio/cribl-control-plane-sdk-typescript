/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const PrometheusAuth1TypeAuthenticationType = {
  /**
   * None
   */
  None: "none",
  /**
   * Auth token
   */
  Token: "token",
  /**
   * Auth token (text secret)
   */
  TextSecret: "textSecret",
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * Basic (credentials secret)
   */
  CredentialsSecret: "credentialsSecret",
} as const;
export type PrometheusAuth1TypeAuthenticationType = OpenEnum<
  typeof PrometheusAuth1TypeAuthenticationType
>;

export type PrometheusAuth1Type = {
  authType?: PrometheusAuth1TypeAuthenticationType | undefined;
  /**
   * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * Username for authentication
   */
  username?: string | undefined;
  /**
   * Password (API key in Grafana Cloud domain) for authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

/** @internal */
export const PrometheusAuth1TypeAuthenticationType$inboundSchema: z.ZodType<
  PrometheusAuth1TypeAuthenticationType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(PrometheusAuth1TypeAuthenticationType),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const PrometheusAuth1TypeAuthenticationType$outboundSchema: z.ZodType<
  PrometheusAuth1TypeAuthenticationType,
  z.ZodTypeDef,
  PrometheusAuth1TypeAuthenticationType
> = z.union([
  z.nativeEnum(PrometheusAuth1TypeAuthenticationType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const PrometheusAuth1Type$inboundSchema: z.ZodType<
  PrometheusAuth1Type,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: PrometheusAuth1TypeAuthenticationType$inboundSchema.default(
    "basic",
  ),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type PrometheusAuth1Type$Outbound = {
  authType: string;
  token?: string | undefined;
  textSecret?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const PrometheusAuth1Type$outboundSchema: z.ZodType<
  PrometheusAuth1Type$Outbound,
  z.ZodTypeDef,
  PrometheusAuth1Type
> = z.object({
  authType: PrometheusAuth1TypeAuthenticationType$outboundSchema.default(
    "basic",
  ),
  token: z.string().optional(),
  textSecret: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

export function prometheusAuth1TypeToJSON(
  prometheusAuth1Type: PrometheusAuth1Type,
): string {
  return JSON.stringify(
    PrometheusAuth1Type$outboundSchema.parse(prometheusAuth1Type),
  );
}
export function prometheusAuth1TypeFromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuth1Type, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuth1Type$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuth1Type' from JSON`,
  );
}
