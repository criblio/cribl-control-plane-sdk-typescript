/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * The output metric type
 */
export const AggregateMetricsCumulativeFalseMetricType = {
  Automatic: "automatic",
  Counter: "counter",
  Distribution: "distribution",
  Gauge: "gauge",
  Histogram: "histogram",
  Summary: "summary",
  Timer: "timer",
} as const;
/**
 * The output metric type
 */
export type AggregateMetricsCumulativeFalseMetricType = OpenEnum<
  typeof AggregateMetricsCumulativeFalseMetricType
>;

export type AggregateMetricsCumulativeFalseAggregation = {
  /**
   * The output metric type
   */
  metricType: AggregateMetricsCumulativeFalseMetricType;
  /**
   * Aggregate function to perform on events. Example: sum(bytes).where(action=='REJECT').as(TotalBytes)
   */
  agg: string;
};

export type AggregateMetricsCumulativeFalseAdd = {
  name?: string | undefined;
  /**
   * JavaScript expression to compute the value (can be constant)
   */
  value: string;
};

export type AggregateMetricsCumulativeFalse = {
  /**
   * Enable to retain aggregations for cumulative aggregations when flushing out an aggregation table event. When disabled (the default), aggregations are reset to 0 on flush.
   */
  cumulative?: boolean | undefined;
  /**
   * The tumbling window tolerance to late events. Must be a valid time string (such as 10s).
   */
  lagTolerance?: string | undefined;
  /**
   * How long to wait before flushing a bucket that has not received events. Must be a valid time string (such as 10s).
   */
  idleTimeLimit?: string | undefined;
  /**
   * Pass through the original events along with the aggregation events
   */
  passthrough?: boolean | undefined;
  /**
   * Preserve the structure of the original aggregation event's groupby fields
   */
  preserveGroupBys?: boolean | undefined;
  /**
   * Output only statistics that are sufficient for the supplied aggregations
   */
  sufficientStatsOnly?: boolean | undefined;
  /**
   * A prefix that is prepended to all of the fields output by this Aggregations Function
   */
  prefix?: string | undefined;
  /**
   * The time span of the tumbling window for aggregating events. Must be a valid time string (such as 10s).
   */
  timeWindow: string;
  /**
   * Combination of Aggregation function and output metric type
   */
  aggregations: Array<AggregateMetricsCumulativeFalseAggregation>;
  /**
   * Optional: One or more dimensions to group aggregates by. Supports wildcard expressions. Wrap dimension names in quotes if using literal identifiers, such as 'service.name'. Warning: Using wildcard '*' causes all dimensions in the event to be included, which can result in high cardinality and increased memory usage. Exclude dimensions that can result in high cardinality before using wildcards. Example: !_time, !_numericValue, *
   */
  groupbys?: Array<string> | undefined;
  /**
   * The maximum number of events to include in any given aggregation event
   */
  flushEventLimit?: number | undefined;
  /**
   * The memory usage limit to impose upon aggregations. Defaults to 80% of the process memory; value configured above default limit is ignored. Accepts numerals with units like KB and MB (example: 128MB).
   */
  flushMemLimit?: string | undefined;
  /**
   * Treat dots in dimension names as literals. This is useful for top-level dimensions that contain dots, such as 'service.name'.
   */
  shouldTreatDotsAsLiterals?: boolean | undefined;
  /**
   * Set of key-value pairs to evaluate and add/set
   */
  add?: Array<AggregateMetricsCumulativeFalseAdd> | undefined;
  /**
   * Flush aggregations when an input stream is closed. If disabled, Time Window Settings control flush behavior.
   */
  flushOnInputClose?: boolean | undefined;
};

/**
 * The output metric type
 */
export const AggregateMetricsCumulativeTrueMetricType = {
  Automatic: "automatic",
  Counter: "counter",
  Distribution: "distribution",
  Gauge: "gauge",
  Histogram: "histogram",
  Summary: "summary",
  Timer: "timer",
} as const;
/**
 * The output metric type
 */
export type AggregateMetricsCumulativeTrueMetricType = OpenEnum<
  typeof AggregateMetricsCumulativeTrueMetricType
>;

export type AggregateMetricsCumulativeTrueAggregation = {
  /**
   * The output metric type
   */
  metricType: AggregateMetricsCumulativeTrueMetricType;
  /**
   * Aggregate function to perform on events. Example: sum(bytes).where(action=='REJECT').as(TotalBytes)
   */
  agg: string;
};

export type AggregateMetricsCumulativeTrueAdd = {
  name?: string | undefined;
  /**
   * JavaScript expression to compute the value (can be constant)
   */
  value: string;
};

export type AggregateMetricsCumulativeTrue = {
  /**
   * Enable to retain aggregations for cumulative aggregations when flushing out an aggregation table event. When disabled (the default), aggregations are reset to 0 on flush.
   */
  cumulative?: boolean | undefined;
  /**
   * Pass through the original events along with the aggregation events
   */
  passthrough?: boolean | undefined;
  /**
   * Preserve the structure of the original aggregation event's groupby fields
   */
  preserveGroupBys?: boolean | undefined;
  /**
   * Output only statistics that are sufficient for the supplied aggregations
   */
  sufficientStatsOnly?: boolean | undefined;
  /**
   * A prefix that is prepended to all of the fields output by this Aggregations Function
   */
  prefix?: string | undefined;
  /**
   * The time span of the tumbling window for aggregating events. Must be a valid time string (such as 10s).
   */
  timeWindow: string;
  /**
   * Combination of Aggregation function and output metric type
   */
  aggregations: Array<AggregateMetricsCumulativeTrueAggregation>;
  /**
   * Optional: One or more dimensions to group aggregates by. Supports wildcard expressions. Wrap dimension names in quotes if using literal identifiers, such as 'service.name'. Warning: Using wildcard '*' causes all dimensions in the event to be included, which can result in high cardinality and increased memory usage. Exclude dimensions that can result in high cardinality before using wildcards. Example: !_time, !_numericValue, *
   */
  groupbys?: Array<string> | undefined;
  /**
   * The maximum number of events to include in any given aggregation event
   */
  flushEventLimit?: number | undefined;
  /**
   * The memory usage limit to impose upon aggregations. Defaults to 80% of the process memory; value configured above default limit is ignored. Accepts numerals with units like KB and MB (example: 128MB).
   */
  flushMemLimit?: string | undefined;
  /**
   * Treat dots in dimension names as literals. This is useful for top-level dimensions that contain dots, such as 'service.name'.
   */
  shouldTreatDotsAsLiterals?: boolean | undefined;
  /**
   * Set of key-value pairs to evaluate and add/set
   */
  add?: Array<AggregateMetricsCumulativeTrueAdd> | undefined;
  /**
   * Flush aggregations when an input stream is closed. If disabled, Time Window Settings control flush behavior.
   */
  flushOnInputClose?: boolean | undefined;
};

export type PipelineFunctionAggregateMetricsConf =
  | AggregateMetricsCumulativeTrue
  | AggregateMetricsCumulativeFalse;

export type PipelineFunctionAggregateMetrics = {
  /**
   * Filter that selects data to be fed through this Function
   */
  filter?: string | undefined;
  /**
   * Function ID
   */
  id: "aggregate_metrics";
  /**
   * Simple description of this step
   */
  description?: string | undefined;
  /**
   * If true, data will not be pushed through this function
   */
  disabled?: boolean | undefined;
  /**
   * If enabled, stops the results of this Function from being passed to the downstream Functions
   */
  final?: boolean | undefined;
  conf: AggregateMetricsCumulativeTrue | AggregateMetricsCumulativeFalse;
  /**
   * Group ID
   */
  groupId?: string | undefined;
};

/** @internal */
export const AggregateMetricsCumulativeFalseMetricType$inboundSchema: z.ZodType<
  AggregateMetricsCumulativeFalseMetricType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(AggregateMetricsCumulativeFalseMetricType);
/** @internal */
export const AggregateMetricsCumulativeFalseMetricType$outboundSchema:
  z.ZodType<string, z.ZodTypeDef, AggregateMetricsCumulativeFalseMetricType> =
    openEnums.outboundSchema(AggregateMetricsCumulativeFalseMetricType);

/** @internal */
export const AggregateMetricsCumulativeFalseAggregation$inboundSchema:
  z.ZodType<AggregateMetricsCumulativeFalseAggregation, z.ZodTypeDef, unknown> =
    z.object({
      metricType: AggregateMetricsCumulativeFalseMetricType$inboundSchema,
      agg: types.string(),
    });
/** @internal */
export type AggregateMetricsCumulativeFalseAggregation$Outbound = {
  metricType: string;
  agg: string;
};

/** @internal */
export const AggregateMetricsCumulativeFalseAggregation$outboundSchema:
  z.ZodType<
    AggregateMetricsCumulativeFalseAggregation$Outbound,
    z.ZodTypeDef,
    AggregateMetricsCumulativeFalseAggregation
  > = z.object({
    metricType: AggregateMetricsCumulativeFalseMetricType$outboundSchema,
    agg: z.string(),
  });

export function aggregateMetricsCumulativeFalseAggregationToJSON(
  aggregateMetricsCumulativeFalseAggregation:
    AggregateMetricsCumulativeFalseAggregation,
): string {
  return JSON.stringify(
    AggregateMetricsCumulativeFalseAggregation$outboundSchema.parse(
      aggregateMetricsCumulativeFalseAggregation,
    ),
  );
}
export function aggregateMetricsCumulativeFalseAggregationFromJSON(
  jsonString: string,
): SafeParseResult<
  AggregateMetricsCumulativeFalseAggregation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AggregateMetricsCumulativeFalseAggregation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AggregateMetricsCumulativeFalseAggregation' from JSON`,
  );
}

/** @internal */
export const AggregateMetricsCumulativeFalseAdd$inboundSchema: z.ZodType<
  AggregateMetricsCumulativeFalseAdd,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: types.optional(types.string()),
  value: types.string(),
});
/** @internal */
export type AggregateMetricsCumulativeFalseAdd$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const AggregateMetricsCumulativeFalseAdd$outboundSchema: z.ZodType<
  AggregateMetricsCumulativeFalseAdd$Outbound,
  z.ZodTypeDef,
  AggregateMetricsCumulativeFalseAdd
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

export function aggregateMetricsCumulativeFalseAddToJSON(
  aggregateMetricsCumulativeFalseAdd: AggregateMetricsCumulativeFalseAdd,
): string {
  return JSON.stringify(
    AggregateMetricsCumulativeFalseAdd$outboundSchema.parse(
      aggregateMetricsCumulativeFalseAdd,
    ),
  );
}
export function aggregateMetricsCumulativeFalseAddFromJSON(
  jsonString: string,
): SafeParseResult<AggregateMetricsCumulativeFalseAdd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AggregateMetricsCumulativeFalseAdd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AggregateMetricsCumulativeFalseAdd' from JSON`,
  );
}

/** @internal */
export const AggregateMetricsCumulativeFalse$inboundSchema: z.ZodType<
  AggregateMetricsCumulativeFalse,
  z.ZodTypeDef,
  unknown
> = z.object({
  cumulative: types.optional(types.boolean()),
  lagTolerance: types.optional(types.string()),
  idleTimeLimit: types.optional(types.string()),
  passthrough: types.optional(types.boolean()),
  preserveGroupBys: types.optional(types.boolean()),
  sufficientStatsOnly: types.optional(types.boolean()),
  prefix: types.optional(types.string()),
  timeWindow: types.string(),
  aggregations: z.array(
    z.lazy(() => AggregateMetricsCumulativeFalseAggregation$inboundSchema),
  ),
  groupbys: types.optional(z.array(types.string())),
  flushEventLimit: types.optional(types.number()),
  flushMemLimit: types.optional(types.string()),
  shouldTreatDotsAsLiterals: types.optional(types.boolean()),
  add: types.optional(
    z.array(z.lazy(() => AggregateMetricsCumulativeFalseAdd$inboundSchema)),
  ),
  flushOnInputClose: types.optional(types.boolean()),
});
/** @internal */
export type AggregateMetricsCumulativeFalse$Outbound = {
  cumulative?: boolean | undefined;
  lagTolerance?: string | undefined;
  idleTimeLimit?: string | undefined;
  passthrough?: boolean | undefined;
  preserveGroupBys?: boolean | undefined;
  sufficientStatsOnly?: boolean | undefined;
  prefix?: string | undefined;
  timeWindow: string;
  aggregations: Array<AggregateMetricsCumulativeFalseAggregation$Outbound>;
  groupbys?: Array<string> | undefined;
  flushEventLimit?: number | undefined;
  flushMemLimit?: string | undefined;
  shouldTreatDotsAsLiterals?: boolean | undefined;
  add?: Array<AggregateMetricsCumulativeFalseAdd$Outbound> | undefined;
  flushOnInputClose?: boolean | undefined;
};

/** @internal */
export const AggregateMetricsCumulativeFalse$outboundSchema: z.ZodType<
  AggregateMetricsCumulativeFalse$Outbound,
  z.ZodTypeDef,
  AggregateMetricsCumulativeFalse
> = z.object({
  cumulative: z.boolean().optional(),
  lagTolerance: z.string().optional(),
  idleTimeLimit: z.string().optional(),
  passthrough: z.boolean().optional(),
  preserveGroupBys: z.boolean().optional(),
  sufficientStatsOnly: z.boolean().optional(),
  prefix: z.string().optional(),
  timeWindow: z.string(),
  aggregations: z.array(
    z.lazy(() => AggregateMetricsCumulativeFalseAggregation$outboundSchema),
  ),
  groupbys: z.array(z.string()).optional(),
  flushEventLimit: z.number().optional(),
  flushMemLimit: z.string().optional(),
  shouldTreatDotsAsLiterals: z.boolean().optional(),
  add: z.array(z.lazy(() => AggregateMetricsCumulativeFalseAdd$outboundSchema))
    .optional(),
  flushOnInputClose: z.boolean().optional(),
});

export function aggregateMetricsCumulativeFalseToJSON(
  aggregateMetricsCumulativeFalse: AggregateMetricsCumulativeFalse,
): string {
  return JSON.stringify(
    AggregateMetricsCumulativeFalse$outboundSchema.parse(
      aggregateMetricsCumulativeFalse,
    ),
  );
}
export function aggregateMetricsCumulativeFalseFromJSON(
  jsonString: string,
): SafeParseResult<AggregateMetricsCumulativeFalse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AggregateMetricsCumulativeFalse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AggregateMetricsCumulativeFalse' from JSON`,
  );
}

/** @internal */
export const AggregateMetricsCumulativeTrueMetricType$inboundSchema: z.ZodType<
  AggregateMetricsCumulativeTrueMetricType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(AggregateMetricsCumulativeTrueMetricType);
/** @internal */
export const AggregateMetricsCumulativeTrueMetricType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  AggregateMetricsCumulativeTrueMetricType
> = openEnums.outboundSchema(AggregateMetricsCumulativeTrueMetricType);

/** @internal */
export const AggregateMetricsCumulativeTrueAggregation$inboundSchema: z.ZodType<
  AggregateMetricsCumulativeTrueAggregation,
  z.ZodTypeDef,
  unknown
> = z.object({
  metricType: AggregateMetricsCumulativeTrueMetricType$inboundSchema,
  agg: types.string(),
});
/** @internal */
export type AggregateMetricsCumulativeTrueAggregation$Outbound = {
  metricType: string;
  agg: string;
};

/** @internal */
export const AggregateMetricsCumulativeTrueAggregation$outboundSchema:
  z.ZodType<
    AggregateMetricsCumulativeTrueAggregation$Outbound,
    z.ZodTypeDef,
    AggregateMetricsCumulativeTrueAggregation
  > = z.object({
    metricType: AggregateMetricsCumulativeTrueMetricType$outboundSchema,
    agg: z.string(),
  });

export function aggregateMetricsCumulativeTrueAggregationToJSON(
  aggregateMetricsCumulativeTrueAggregation:
    AggregateMetricsCumulativeTrueAggregation,
): string {
  return JSON.stringify(
    AggregateMetricsCumulativeTrueAggregation$outboundSchema.parse(
      aggregateMetricsCumulativeTrueAggregation,
    ),
  );
}
export function aggregateMetricsCumulativeTrueAggregationFromJSON(
  jsonString: string,
): SafeParseResult<
  AggregateMetricsCumulativeTrueAggregation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AggregateMetricsCumulativeTrueAggregation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AggregateMetricsCumulativeTrueAggregation' from JSON`,
  );
}

/** @internal */
export const AggregateMetricsCumulativeTrueAdd$inboundSchema: z.ZodType<
  AggregateMetricsCumulativeTrueAdd,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: types.optional(types.string()),
  value: types.string(),
});
/** @internal */
export type AggregateMetricsCumulativeTrueAdd$Outbound = {
  name?: string | undefined;
  value: string;
};

/** @internal */
export const AggregateMetricsCumulativeTrueAdd$outboundSchema: z.ZodType<
  AggregateMetricsCumulativeTrueAdd$Outbound,
  z.ZodTypeDef,
  AggregateMetricsCumulativeTrueAdd
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

export function aggregateMetricsCumulativeTrueAddToJSON(
  aggregateMetricsCumulativeTrueAdd: AggregateMetricsCumulativeTrueAdd,
): string {
  return JSON.stringify(
    AggregateMetricsCumulativeTrueAdd$outboundSchema.parse(
      aggregateMetricsCumulativeTrueAdd,
    ),
  );
}
export function aggregateMetricsCumulativeTrueAddFromJSON(
  jsonString: string,
): SafeParseResult<AggregateMetricsCumulativeTrueAdd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AggregateMetricsCumulativeTrueAdd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AggregateMetricsCumulativeTrueAdd' from JSON`,
  );
}

/** @internal */
export const AggregateMetricsCumulativeTrue$inboundSchema: z.ZodType<
  AggregateMetricsCumulativeTrue,
  z.ZodTypeDef,
  unknown
> = z.object({
  cumulative: types.optional(types.boolean()),
  passthrough: types.optional(types.boolean()),
  preserveGroupBys: types.optional(types.boolean()),
  sufficientStatsOnly: types.optional(types.boolean()),
  prefix: types.optional(types.string()),
  timeWindow: types.string(),
  aggregations: z.array(
    z.lazy(() => AggregateMetricsCumulativeTrueAggregation$inboundSchema),
  ),
  groupbys: types.optional(z.array(types.string())),
  flushEventLimit: types.optional(types.number()),
  flushMemLimit: types.optional(types.string()),
  shouldTreatDotsAsLiterals: types.optional(types.boolean()),
  add: types.optional(
    z.array(z.lazy(() => AggregateMetricsCumulativeTrueAdd$inboundSchema)),
  ),
  flushOnInputClose: types.optional(types.boolean()),
});
/** @internal */
export type AggregateMetricsCumulativeTrue$Outbound = {
  cumulative?: boolean | undefined;
  passthrough?: boolean | undefined;
  preserveGroupBys?: boolean | undefined;
  sufficientStatsOnly?: boolean | undefined;
  prefix?: string | undefined;
  timeWindow: string;
  aggregations: Array<AggregateMetricsCumulativeTrueAggregation$Outbound>;
  groupbys?: Array<string> | undefined;
  flushEventLimit?: number | undefined;
  flushMemLimit?: string | undefined;
  shouldTreatDotsAsLiterals?: boolean | undefined;
  add?: Array<AggregateMetricsCumulativeTrueAdd$Outbound> | undefined;
  flushOnInputClose?: boolean | undefined;
};

/** @internal */
export const AggregateMetricsCumulativeTrue$outboundSchema: z.ZodType<
  AggregateMetricsCumulativeTrue$Outbound,
  z.ZodTypeDef,
  AggregateMetricsCumulativeTrue
> = z.object({
  cumulative: z.boolean().optional(),
  passthrough: z.boolean().optional(),
  preserveGroupBys: z.boolean().optional(),
  sufficientStatsOnly: z.boolean().optional(),
  prefix: z.string().optional(),
  timeWindow: z.string(),
  aggregations: z.array(
    z.lazy(() => AggregateMetricsCumulativeTrueAggregation$outboundSchema),
  ),
  groupbys: z.array(z.string()).optional(),
  flushEventLimit: z.number().optional(),
  flushMemLimit: z.string().optional(),
  shouldTreatDotsAsLiterals: z.boolean().optional(),
  add: z.array(z.lazy(() => AggregateMetricsCumulativeTrueAdd$outboundSchema))
    .optional(),
  flushOnInputClose: z.boolean().optional(),
});

export function aggregateMetricsCumulativeTrueToJSON(
  aggregateMetricsCumulativeTrue: AggregateMetricsCumulativeTrue,
): string {
  return JSON.stringify(
    AggregateMetricsCumulativeTrue$outboundSchema.parse(
      aggregateMetricsCumulativeTrue,
    ),
  );
}
export function aggregateMetricsCumulativeTrueFromJSON(
  jsonString: string,
): SafeParseResult<AggregateMetricsCumulativeTrue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AggregateMetricsCumulativeTrue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AggregateMetricsCumulativeTrue' from JSON`,
  );
}

/** @internal */
export const PipelineFunctionAggregateMetricsConf$inboundSchema: z.ZodType<
  PipelineFunctionAggregateMetricsConf,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => AggregateMetricsCumulativeTrue$inboundSchema),
  z.lazy(() => AggregateMetricsCumulativeFalse$inboundSchema),
]);
/** @internal */
export type PipelineFunctionAggregateMetricsConf$Outbound =
  | AggregateMetricsCumulativeTrue$Outbound
  | AggregateMetricsCumulativeFalse$Outbound;

/** @internal */
export const PipelineFunctionAggregateMetricsConf$outboundSchema: z.ZodType<
  PipelineFunctionAggregateMetricsConf$Outbound,
  z.ZodTypeDef,
  PipelineFunctionAggregateMetricsConf
> = smartUnion([
  z.lazy(() => AggregateMetricsCumulativeTrue$outboundSchema),
  z.lazy(() => AggregateMetricsCumulativeFalse$outboundSchema),
]);

export function pipelineFunctionAggregateMetricsConfToJSON(
  pipelineFunctionAggregateMetricsConf: PipelineFunctionAggregateMetricsConf,
): string {
  return JSON.stringify(
    PipelineFunctionAggregateMetricsConf$outboundSchema.parse(
      pipelineFunctionAggregateMetricsConf,
    ),
  );
}
export function pipelineFunctionAggregateMetricsConfFromJSON(
  jsonString: string,
): SafeParseResult<PipelineFunctionAggregateMetricsConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PipelineFunctionAggregateMetricsConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PipelineFunctionAggregateMetricsConf' from JSON`,
  );
}

/** @internal */
export const PipelineFunctionAggregateMetrics$inboundSchema: z.ZodType<
  PipelineFunctionAggregateMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: types.optional(types.string()),
  id: types.literal("aggregate_metrics"),
  description: types.optional(types.string()),
  disabled: types.optional(types.boolean()),
  final: types.optional(types.boolean()),
  conf: smartUnion([
    z.lazy(() => AggregateMetricsCumulativeTrue$inboundSchema),
    z.lazy(() => AggregateMetricsCumulativeFalse$inboundSchema),
  ]),
  groupId: types.optional(types.string()),
});
/** @internal */
export type PipelineFunctionAggregateMetrics$Outbound = {
  filter?: string | undefined;
  id: "aggregate_metrics";
  description?: string | undefined;
  disabled?: boolean | undefined;
  final?: boolean | undefined;
  conf:
    | AggregateMetricsCumulativeTrue$Outbound
    | AggregateMetricsCumulativeFalse$Outbound;
  groupId?: string | undefined;
};

/** @internal */
export const PipelineFunctionAggregateMetrics$outboundSchema: z.ZodType<
  PipelineFunctionAggregateMetrics$Outbound,
  z.ZodTypeDef,
  PipelineFunctionAggregateMetrics
> = z.object({
  filter: z.string().optional(),
  id: z.literal("aggregate_metrics"),
  description: z.string().optional(),
  disabled: z.boolean().optional(),
  final: z.boolean().optional(),
  conf: smartUnion([
    z.lazy(() => AggregateMetricsCumulativeTrue$outboundSchema),
    z.lazy(() => AggregateMetricsCumulativeFalse$outboundSchema),
  ]),
  groupId: z.string().optional(),
});

export function pipelineFunctionAggregateMetricsToJSON(
  pipelineFunctionAggregateMetrics: PipelineFunctionAggregateMetrics,
): string {
  return JSON.stringify(
    PipelineFunctionAggregateMetrics$outboundSchema.parse(
      pipelineFunctionAggregateMetrics,
    ),
  );
}
export function pipelineFunctionAggregateMetricsFromJSON(
  jsonString: string,
): SafeParseResult<PipelineFunctionAggregateMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PipelineFunctionAggregateMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PipelineFunctionAggregateMetrics' from JSON`,
  );
}
