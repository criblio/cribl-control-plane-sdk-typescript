/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthType2Options,
  AuthType2Options$inboundSchema,
  AuthType2Options$outboundSchema,
} from "./authtype2options.js";
import {
  AwsAuthenticationMethodOptions,
  AwsAuthenticationMethodOptions$inboundSchema,
  AwsAuthenticationMethodOptions$outboundSchema,
} from "./awsauthenticationmethodoptions.js";
import {
  ConnectionsType,
  ConnectionsType$inboundSchema,
  ConnectionsType$Outbound,
  ConnectionsType$outboundSchema,
} from "./connectionstype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  LogLevelOptions,
  LogLevelOptions$inboundSchema,
  LogLevelOptions$outboundSchema,
} from "./logleveloptions.js";
import {
  Metadata1Type,
  Metadata1Type$inboundSchema,
  Metadata1Type$Outbound,
  Metadata1Type$outboundSchema,
} from "./metadata1type.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  RecordTypeOptions,
  RecordTypeOptions$inboundSchema,
  RecordTypeOptions$outboundSchema,
} from "./recordtypeoptions.js";
import {
  ScrapeProtocolOptions,
  ScrapeProtocolOptions$inboundSchema,
  ScrapeProtocolOptions$outboundSchema,
} from "./scrapeprotocoloptions.js";
import {
  SearchFilterType,
  SearchFilterType$inboundSchema,
  SearchFilterType$Outbound,
  SearchFilterType$outboundSchema,
} from "./searchfiltertype.js";
import {
  SignatureVersionOptions,
  SignatureVersionOptions$inboundSchema,
  SignatureVersionOptions$outboundSchema,
} from "./signatureversionoptions.js";
import {
  TypePrometheusOption,
  TypePrometheusOption$inboundSchema,
  TypePrometheusOption$outboundSchema,
} from "./typeprometheusoption.js";

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType9 = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType9 = OpenEnum<
  typeof InputPrometheusDiscoveryType9
>;

export type InputPrometheusPrometheus9 = {
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypePrometheusOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType9 | undefined;
  /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   */
  interval?: number | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel: LogLevelOptions;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ScrapeProtocolOptions | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<SearchFilterType> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret: string;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType8 = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType8 = OpenEnum<
  typeof InputPrometheusDiscoveryType8
>;

export type InputPrometheusPrometheus8 = {
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypePrometheusOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType8 | undefined;
  /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   */
  interval?: number | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel: LogLevelOptions;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ScrapeProtocolOptions | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<SearchFilterType> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username: string;
  /**
   * Password for Prometheus Basic authentication
   */
  password: string;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType7 = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType7 = OpenEnum<
  typeof InputPrometheusDiscoveryType7
>;

export type InputPrometheusPrometheus7 = {
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType7 | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypePrometheusOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   */
  interval?: number | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel: LogLevelOptions;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ScrapeProtocolOptions | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter: Array<SearchFilterType>;
  awsSecretKey: string;
  /**
   * Region where the EC2 is located
   */
  region: string;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint: string;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn: string;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId: string;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType6 = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType6 = OpenEnum<
  typeof InputPrometheusDiscoveryType6
>;

export type InputPrometheusPrometheus6 = {
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType6 | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypePrometheusOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   */
  interval?: number | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel: LogLevelOptions;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList: Array<string>;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ScrapeProtocolOptions | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<SearchFilterType> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType5 = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType5 = OpenEnum<
  typeof InputPrometheusDiscoveryType5
>;

export type InputPrometheusPrometheus5 = {
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType5 | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypePrometheusOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   */
  interval?: number | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel: LogLevelOptions;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList: Array<string>;
  /**
   * DNS Record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ScrapeProtocolOptions | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<SearchFilterType> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType4 = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType4 = OpenEnum<
  typeof InputPrometheusDiscoveryType4
>;

export type InputPrometheusPrometheus4 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypePrometheusOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq: PqType;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType4 | undefined;
  /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   */
  interval?: number | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel: LogLevelOptions;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ScrapeProtocolOptions | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<SearchFilterType> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType3 = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType3 = OpenEnum<
  typeof InputPrometheusDiscoveryType3
>;

export type InputPrometheusPrometheus3 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypePrometheusOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType3 | undefined;
  /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   */
  interval?: number | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel: LogLevelOptions;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ScrapeProtocolOptions | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<SearchFilterType> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType2 = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType2 = OpenEnum<
  typeof InputPrometheusDiscoveryType2
>;

export type InputPrometheusPrometheus2 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypePrometheusOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections: Array<ConnectionsType>;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType2 | undefined;
  /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   */
  interval?: number | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel: LogLevelOptions;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ScrapeProtocolOptions | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<SearchFilterType> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType1 = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType1 = OpenEnum<
  typeof InputPrometheusDiscoveryType1
>;

export type InputPrometheusPrometheus1 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypePrometheusOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType1 | undefined;
  /**
   * How often in minutes to scrape targets for metrics, 60 must be evenly divisible by the value or save will fail.
   */
  interval?: number | undefined;
  /**
   * Collector runtime log level (verbosity)
   */
  logLevel: LogLevelOptions;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS Record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets.
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: ScrapeProtocolOptions | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Set to false if the private IP address should be used.
   */
  usePublicIp?: boolean | undefined;
  /**
   * EC2 Instance Search Filter
   */
  searchFilter?: Array<SearchFilterType> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export type InputPrometheus =
  | InputPrometheusPrometheus7
  | InputPrometheusPrometheus8
  | InputPrometheusPrometheus2
  | InputPrometheusPrometheus4
  | InputPrometheusPrometheus5
  | InputPrometheusPrometheus6
  | InputPrometheusPrometheus9
  | InputPrometheusPrometheus1
  | InputPrometheusPrometheus3;

/** @internal */
export const InputPrometheusDiscoveryType9$inboundSchema: z.ZodType<
  InputPrometheusDiscoveryType9,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusDiscoveryType9),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputPrometheusDiscoveryType9$outboundSchema: z.ZodType<
  InputPrometheusDiscoveryType9,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType9
> = z.union([
  z.nativeEnum(InputPrometheusDiscoveryType9),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputPrometheusPrometheus9$inboundSchema: z.ZodType<
  InputPrometheusPrometheus9,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthType2Options$inboundSchema.default("manual"),
  id: z.string().optional(),
  type: TypePrometheusOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType9$inboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$inboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$inboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$inboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string(),
});
/** @internal */
export type InputPrometheusPrometheus9$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  logLevel: string;
  rejectUnauthorized: boolean;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<SearchFilterType$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret: string;
};

/** @internal */
export const InputPrometheusPrometheus9$outboundSchema: z.ZodType<
  InputPrometheusPrometheus9$Outbound,
  z.ZodTypeDef,
  InputPrometheusPrometheus9
> = z.object({
  authType: AuthType2Options$outboundSchema.default("manual"),
  id: z.string().optional(),
  type: TypePrometheusOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType9$outboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$outboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$outboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$outboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string(),
});

export function inputPrometheusPrometheus9ToJSON(
  inputPrometheusPrometheus9: InputPrometheusPrometheus9,
): string {
  return JSON.stringify(
    InputPrometheusPrometheus9$outboundSchema.parse(inputPrometheusPrometheus9),
  );
}
export function inputPrometheusPrometheus9FromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusPrometheus9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusPrometheus9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusPrometheus9' from JSON`,
  );
}

/** @internal */
export const InputPrometheusDiscoveryType8$inboundSchema: z.ZodType<
  InputPrometheusDiscoveryType8,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusDiscoveryType8),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputPrometheusDiscoveryType8$outboundSchema: z.ZodType<
  InputPrometheusDiscoveryType8,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType8
> = z.union([
  z.nativeEnum(InputPrometheusDiscoveryType8),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputPrometheusPrometheus8$inboundSchema: z.ZodType<
  InputPrometheusPrometheus8,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: AuthType2Options$inboundSchema.default("manual"),
  id: z.string().optional(),
  type: TypePrometheusOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType8$inboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$inboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$inboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$inboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string(),
  password: z.string(),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type InputPrometheusPrometheus8$Outbound = {
  authType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  logLevel: string;
  rejectUnauthorized: boolean;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<SearchFilterType$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  username: string;
  password: string;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusPrometheus8$outboundSchema: z.ZodType<
  InputPrometheusPrometheus8$Outbound,
  z.ZodTypeDef,
  InputPrometheusPrometheus8
> = z.object({
  authType: AuthType2Options$outboundSchema.default("manual"),
  id: z.string().optional(),
  type: TypePrometheusOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType8$outboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$outboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$outboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$outboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string(),
  password: z.string(),
  credentialsSecret: z.string().optional(),
});

export function inputPrometheusPrometheus8ToJSON(
  inputPrometheusPrometheus8: InputPrometheusPrometheus8,
): string {
  return JSON.stringify(
    InputPrometheusPrometheus8$outboundSchema.parse(inputPrometheusPrometheus8),
  );
}
export function inputPrometheusPrometheus8FromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusPrometheus8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusPrometheus8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusPrometheus8' from JSON`,
  );
}

/** @internal */
export const InputPrometheusDiscoveryType7$inboundSchema: z.ZodType<
  InputPrometheusDiscoveryType7,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusDiscoveryType7),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputPrometheusDiscoveryType7$outboundSchema: z.ZodType<
  InputPrometheusDiscoveryType7,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType7
> = z.union([
  z.nativeEnum(InputPrometheusDiscoveryType7),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputPrometheusPrometheus7$inboundSchema: z.ZodType<
  InputPrometheusPrometheus7,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoveryType: InputPrometheusDiscoveryType7$inboundSchema.default("static"),
  id: z.string().optional(),
  type: TypePrometheusOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$inboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$inboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$inboundSchema),
  awsSecretKey: z.string(),
  region: z.string(),
  endpoint: z.string(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string(),
  assumeRoleExternalId: z.string(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type InputPrometheusPrometheus7$Outbound = {
  discoveryType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  interval: number;
  logLevel: string;
  rejectUnauthorized: boolean;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter: Array<SearchFilterType$Outbound>;
  awsSecretKey: string;
  region: string;
  endpoint: string;
  signatureVersion: string;
  reuseConnections: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn: string;
  assumeRoleExternalId: string;
  durationSeconds: number;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusPrometheus7$outboundSchema: z.ZodType<
  InputPrometheusPrometheus7$Outbound,
  z.ZodTypeDef,
  InputPrometheusPrometheus7
> = z.object({
  discoveryType: InputPrometheusDiscoveryType7$outboundSchema.default("static"),
  id: z.string().optional(),
  type: TypePrometheusOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$outboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$outboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$outboundSchema),
  awsSecretKey: z.string(),
  region: z.string(),
  endpoint: z.string(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string(),
  assumeRoleExternalId: z.string(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

export function inputPrometheusPrometheus7ToJSON(
  inputPrometheusPrometheus7: InputPrometheusPrometheus7,
): string {
  return JSON.stringify(
    InputPrometheusPrometheus7$outboundSchema.parse(inputPrometheusPrometheus7),
  );
}
export function inputPrometheusPrometheus7FromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusPrometheus7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusPrometheus7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusPrometheus7' from JSON`,
  );
}

/** @internal */
export const InputPrometheusDiscoveryType6$inboundSchema: z.ZodType<
  InputPrometheusDiscoveryType6,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusDiscoveryType6),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputPrometheusDiscoveryType6$outboundSchema: z.ZodType<
  InputPrometheusDiscoveryType6,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType6
> = z.union([
  z.nativeEnum(InputPrometheusDiscoveryType6),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputPrometheusPrometheus6$inboundSchema: z.ZodType<
  InputPrometheusPrometheus6,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoveryType: InputPrometheusDiscoveryType6$inboundSchema.default("static"),
  id: z.string().optional(),
  type: TypePrometheusOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$inboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$inboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()),
  scrapeProtocol: ScrapeProtocolOptions$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$inboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type InputPrometheusPrometheus6$Outbound = {
  discoveryType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  interval: number;
  logLevel: string;
  rejectUnauthorized: boolean;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType: string;
  scrapePort: number;
  nameList: Array<string>;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<SearchFilterType$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusPrometheus6$outboundSchema: z.ZodType<
  InputPrometheusPrometheus6$Outbound,
  z.ZodTypeDef,
  InputPrometheusPrometheus6
> = z.object({
  discoveryType: InputPrometheusDiscoveryType6$outboundSchema.default("static"),
  id: z.string().optional(),
  type: TypePrometheusOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$outboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$outboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()),
  scrapeProtocol: ScrapeProtocolOptions$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$outboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

export function inputPrometheusPrometheus6ToJSON(
  inputPrometheusPrometheus6: InputPrometheusPrometheus6,
): string {
  return JSON.stringify(
    InputPrometheusPrometheus6$outboundSchema.parse(inputPrometheusPrometheus6),
  );
}
export function inputPrometheusPrometheus6FromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusPrometheus6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusPrometheus6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusPrometheus6' from JSON`,
  );
}

/** @internal */
export const InputPrometheusDiscoveryType5$inboundSchema: z.ZodType<
  InputPrometheusDiscoveryType5,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusDiscoveryType5),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputPrometheusDiscoveryType5$outboundSchema: z.ZodType<
  InputPrometheusDiscoveryType5,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType5
> = z.union([
  z.nativeEnum(InputPrometheusDiscoveryType5),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputPrometheusPrometheus5$inboundSchema: z.ZodType<
  InputPrometheusPrometheus5,
  z.ZodTypeDef,
  unknown
> = z.object({
  discoveryType: InputPrometheusDiscoveryType5$inboundSchema.default("static"),
  id: z.string().optional(),
  type: TypePrometheusOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$inboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()),
  recordType: RecordTypeOptions$inboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$inboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type InputPrometheusPrometheus5$Outbound = {
  discoveryType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  interval: number;
  logLevel: string;
  rejectUnauthorized: boolean;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targetList: Array<string>;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<SearchFilterType$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusPrometheus5$outboundSchema: z.ZodType<
  InputPrometheusPrometheus5$Outbound,
  z.ZodTypeDef,
  InputPrometheusPrometheus5
> = z.object({
  discoveryType: InputPrometheusDiscoveryType5$outboundSchema.default("static"),
  id: z.string().optional(),
  type: TypePrometheusOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$outboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()),
  recordType: RecordTypeOptions$outboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$outboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

export function inputPrometheusPrometheus5ToJSON(
  inputPrometheusPrometheus5: InputPrometheusPrometheus5,
): string {
  return JSON.stringify(
    InputPrometheusPrometheus5$outboundSchema.parse(inputPrometheusPrometheus5),
  );
}
export function inputPrometheusPrometheus5FromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusPrometheus5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusPrometheus5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusPrometheus5' from JSON`,
  );
}

/** @internal */
export const InputPrometheusDiscoveryType4$inboundSchema: z.ZodType<
  InputPrometheusDiscoveryType4,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusDiscoveryType4),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputPrometheusDiscoveryType4$outboundSchema: z.ZodType<
  InputPrometheusDiscoveryType4,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType4
> = z.union([
  z.nativeEnum(InputPrometheusDiscoveryType4),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputPrometheusPrometheus4$inboundSchema: z.ZodType<
  InputPrometheusPrometheus4,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: TypePrometheusOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema,
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType4$inboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$inboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$inboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$inboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type InputPrometheusPrometheus4$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq: PqType$Outbound;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  logLevel: string;
  rejectUnauthorized: boolean;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<SearchFilterType$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusPrometheus4$outboundSchema: z.ZodType<
  InputPrometheusPrometheus4$Outbound,
  z.ZodTypeDef,
  InputPrometheusPrometheus4
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: TypePrometheusOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema,
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType4$outboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$outboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$outboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$outboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

export function inputPrometheusPrometheus4ToJSON(
  inputPrometheusPrometheus4: InputPrometheusPrometheus4,
): string {
  return JSON.stringify(
    InputPrometheusPrometheus4$outboundSchema.parse(inputPrometheusPrometheus4),
  );
}
export function inputPrometheusPrometheus4FromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusPrometheus4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusPrometheus4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusPrometheus4' from JSON`,
  );
}

/** @internal */
export const InputPrometheusDiscoveryType3$inboundSchema: z.ZodType<
  InputPrometheusDiscoveryType3,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusDiscoveryType3),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputPrometheusDiscoveryType3$outboundSchema: z.ZodType<
  InputPrometheusDiscoveryType3,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType3
> = z.union([
  z.nativeEnum(InputPrometheusDiscoveryType3),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputPrometheusPrometheus3$inboundSchema: z.ZodType<
  InputPrometheusPrometheus3,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: TypePrometheusOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType3$inboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$inboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$inboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$inboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type InputPrometheusPrometheus3$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  logLevel: string;
  rejectUnauthorized: boolean;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<SearchFilterType$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusPrometheus3$outboundSchema: z.ZodType<
  InputPrometheusPrometheus3$Outbound,
  z.ZodTypeDef,
  InputPrometheusPrometheus3
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: TypePrometheusOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType3$outboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$outboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$outboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$outboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

export function inputPrometheusPrometheus3ToJSON(
  inputPrometheusPrometheus3: InputPrometheusPrometheus3,
): string {
  return JSON.stringify(
    InputPrometheusPrometheus3$outboundSchema.parse(inputPrometheusPrometheus3),
  );
}
export function inputPrometheusPrometheus3FromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusPrometheus3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusPrometheus3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusPrometheus3' from JSON`,
  );
}

/** @internal */
export const InputPrometheusDiscoveryType2$inboundSchema: z.ZodType<
  InputPrometheusDiscoveryType2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusDiscoveryType2),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputPrometheusDiscoveryType2$outboundSchema: z.ZodType<
  InputPrometheusDiscoveryType2,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType2
> = z.union([
  z.nativeEnum(InputPrometheusDiscoveryType2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputPrometheusPrometheus2$inboundSchema: z.ZodType<
  InputPrometheusPrometheus2,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: TypePrometheusOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema),
  pq: PqType$inboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType2$inboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$inboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$inboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$inboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type InputPrometheusPrometheus2$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections: Array<ConnectionsType$Outbound>;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  logLevel: string;
  rejectUnauthorized: boolean;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<SearchFilterType$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusPrometheus2$outboundSchema: z.ZodType<
  InputPrometheusPrometheus2$Outbound,
  z.ZodTypeDef,
  InputPrometheusPrometheus2
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: TypePrometheusOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema),
  pq: PqType$outboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType2$outboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$outboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$outboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$outboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

export function inputPrometheusPrometheus2ToJSON(
  inputPrometheusPrometheus2: InputPrometheusPrometheus2,
): string {
  return JSON.stringify(
    InputPrometheusPrometheus2$outboundSchema.parse(inputPrometheusPrometheus2),
  );
}
export function inputPrometheusPrometheus2FromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusPrometheus2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusPrometheus2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusPrometheus2' from JSON`,
  );
}

/** @internal */
export const InputPrometheusDiscoveryType1$inboundSchema: z.ZodType<
  InputPrometheusDiscoveryType1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputPrometheusDiscoveryType1),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const InputPrometheusDiscoveryType1$outboundSchema: z.ZodType<
  InputPrometheusDiscoveryType1,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType1
> = z.union([
  z.nativeEnum(InputPrometheusDiscoveryType1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputPrometheusPrometheus1$inboundSchema: z.ZodType<
  InputPrometheusPrometheus1,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: TypePrometheusOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType1$inboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$inboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  authType: AuthType2Options$inboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$inboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$inboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$inboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type InputPrometheusPrometheus1$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType: string;
  interval: number;
  logLevel: string;
  rejectUnauthorized: boolean;
  keepAliveTime: number;
  jobTimeout: string;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  authType: string;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType: string;
  scrapePort: number;
  nameList?: Array<string> | undefined;
  scrapeProtocol: string;
  scrapePath: string;
  awsAuthenticationMethod: string;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp: boolean;
  searchFilter?: Array<SearchFilterType$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusPrometheus1$outboundSchema: z.ZodType<
  InputPrometheusPrometheus1$Outbound,
  z.ZodTypeDef,
  InputPrometheusPrometheus1
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: TypePrometheusOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType1$outboundSchema.default("static"),
  interval: z.number().default(15),
  logLevel: LogLevelOptions$outboundSchema,
  rejectUnauthorized: z.boolean().default(true),
  keepAliveTime: z.number().default(30),
  jobTimeout: z.string().default("0"),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  authType: AuthType2Options$outboundSchema.default("manual"),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$outboundSchema.default("SRV"),
  scrapePort: z.number().default(9090),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: ScrapeProtocolOptions$outboundSchema.default("http"),
  scrapePath: z.string().default("/metrics"),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().default(true),
  searchFilter: z.array(SearchFilterType$outboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

export function inputPrometheusPrometheus1ToJSON(
  inputPrometheusPrometheus1: InputPrometheusPrometheus1,
): string {
  return JSON.stringify(
    InputPrometheusPrometheus1$outboundSchema.parse(inputPrometheusPrometheus1),
  );
}
export function inputPrometheusPrometheus1FromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheusPrometheus1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheusPrometheus1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheusPrometheus1' from JSON`,
  );
}

/** @internal */
export const InputPrometheus$inboundSchema: z.ZodType<
  InputPrometheus,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputPrometheusPrometheus7$inboundSchema),
  z.lazy(() => InputPrometheusPrometheus8$inboundSchema),
  z.lazy(() => InputPrometheusPrometheus2$inboundSchema),
  z.lazy(() => InputPrometheusPrometheus4$inboundSchema),
  z.lazy(() => InputPrometheusPrometheus5$inboundSchema),
  z.lazy(() => InputPrometheusPrometheus6$inboundSchema),
  z.lazy(() => InputPrometheusPrometheus9$inboundSchema),
  z.lazy(() => InputPrometheusPrometheus1$inboundSchema),
  z.lazy(() => InputPrometheusPrometheus3$inboundSchema),
]);
/** @internal */
export type InputPrometheus$Outbound =
  | InputPrometheusPrometheus7$Outbound
  | InputPrometheusPrometheus8$Outbound
  | InputPrometheusPrometheus2$Outbound
  | InputPrometheusPrometheus4$Outbound
  | InputPrometheusPrometheus5$Outbound
  | InputPrometheusPrometheus6$Outbound
  | InputPrometheusPrometheus9$Outbound
  | InputPrometheusPrometheus1$Outbound
  | InputPrometheusPrometheus3$Outbound;

/** @internal */
export const InputPrometheus$outboundSchema: z.ZodType<
  InputPrometheus$Outbound,
  z.ZodTypeDef,
  InputPrometheus
> = z.union([
  z.lazy(() => InputPrometheusPrometheus7$outboundSchema),
  z.lazy(() => InputPrometheusPrometheus8$outboundSchema),
  z.lazy(() => InputPrometheusPrometheus2$outboundSchema),
  z.lazy(() => InputPrometheusPrometheus4$outboundSchema),
  z.lazy(() => InputPrometheusPrometheus5$outboundSchema),
  z.lazy(() => InputPrometheusPrometheus6$outboundSchema),
  z.lazy(() => InputPrometheusPrometheus9$outboundSchema),
  z.lazy(() => InputPrometheusPrometheus1$outboundSchema),
  z.lazy(() => InputPrometheusPrometheus3$outboundSchema),
]);

export function inputPrometheusToJSON(
  inputPrometheus: InputPrometheus,
): string {
  return JSON.stringify(InputPrometheus$outboundSchema.parse(inputPrometheus));
}
export function inputPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheus' from JSON`,
  );
}
