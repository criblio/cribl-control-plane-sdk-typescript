/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthenticationMethodOptionsSasl,
  AuthenticationMethodOptionsSasl$inboundSchema,
  AuthenticationMethodOptionsSasl$outboundSchema,
} from "./authenticationmethodoptionssasl.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeConnectionsOptional,
  ItemsTypeConnectionsOptional$inboundSchema,
  ItemsTypeConnectionsOptional$Outbound,
  ItemsTypeConnectionsOptional$outboundSchema,
} from "./itemstypeconnectionsoptional.js";
import {
  ItemsTypeNotificationMetadata,
  ItemsTypeNotificationMetadata$inboundSchema,
  ItemsTypeNotificationMetadata$Outbound,
  ItemsTypeNotificationMetadata$outboundSchema,
} from "./itemstypenotificationmetadata.js";
import {
  ItemsTypeSearchFilter,
  ItemsTypeSearchFilter$inboundSchema,
  ItemsTypeSearchFilter$Outbound,
  ItemsTypeSearchFilter$outboundSchema,
} from "./itemstypesearchfilter.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  RecordTypeOptions,
  RecordTypeOptions$inboundSchema,
  RecordTypeOptions$outboundSchema,
} from "./recordtypeoptions.js";
import {
  SignatureVersionOptions1,
  SignatureVersionOptions1$inboundSchema,
  SignatureVersionOptions1$outboundSchema,
} from "./signatureversionoptions1.js";

/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export const InputPrometheusDiscoveryType = {
  /**
   * Static
   */
  Static: "static",
  /**
   * DNS
   */
  Dns: "dns",
  /**
   * AWS EC2
   */
  Ec2: "ec2",
} as const;
/**
 * Target discovery mechanism. Use static to manually enter a list of targets.
 */
export type InputPrometheusDiscoveryType = OpenEnum<
  typeof InputPrometheusDiscoveryType
>;

/**
 * Collector runtime log level
 */
export const InputPrometheusLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
} as const;
/**
 * Collector runtime log level
 */
export type InputPrometheusLogLevel = OpenEnum<typeof InputPrometheusLogLevel>;

/**
 * Protocol to use when collecting metrics
 */
export const MetricsProtocol = {
  Http: "http",
  Https: "https",
} as const;
/**
 * Protocol to use when collecting metrics
 */
export type MetricsProtocol = OpenEnum<typeof MetricsProtocol>;

export type InputPrometheus = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: "prometheus";
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnectionsOptional> | undefined;
  pq?: PqType | undefined;
  /**
   * Other dimensions to include in events
   */
  dimensionList?: Array<string> | undefined;
  /**
   * Target discovery mechanism. Use static to manually enter a list of targets.
   */
  discoveryType?: InputPrometheusDiscoveryType | undefined;
  /**
   * How often, in minutes, to scrape targets for metrics. Maximum of 60 minutes. 60 must be evenly divisible by the value you enter.
   */
  interval: number;
  /**
   * Collector runtime log level
   */
  logLevel: InputPrometheusLogLevel;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Time, in seconds, before aborting HTTP connection attempts; use 0 for no timeout
   */
  timeout?: number | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthenticationMethodOptionsSasl | undefined;
  description?: string | undefined;
  /**
   * List of Prometheus targets to pull metrics from. Values can be in URL or host[:port] format. For example: http://localhost:9090/metrics, localhost:9090, or localhost. In cases where just host[:port] is specified, the endpoint will resolve to 'http://host[:port]/metrics'.
   */
  targetList?: Array<string> | undefined;
  /**
   * DNS record type to resolve
   */
  recordType?: RecordTypeOptions | undefined;
  /**
   * The port number in the metrics URL for discovered targets
   */
  scrapePort?: number | undefined;
  /**
   * List of DNS names to resolve
   */
  nameList?: Array<string> | undefined;
  /**
   * Protocol to use when collecting metrics
   */
  scrapeProtocol?: MetricsProtocol | undefined;
  /**
   * Path to use when collecting metrics from discovered targets
   */
  scrapePath?: string | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
  /**
   * Use public IP address for discovered targets. Disable to use the private IP address.
   */
  usePublicIp?: boolean | undefined;
  /**
   * Filter to apply when searching for EC2 instances
   */
  searchFilter?: Array<ItemsTypeSearchFilter> | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the EC2 is located
   */
  region?: string | undefined;
  /**
   * EC2 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to EC2-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing EC2 requests
   */
  signatureVersion?: SignatureVersionOptions1 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Use Assume Role credentials to access EC2
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Username for Prometheus Basic authentication
   */
  username?: string | undefined;
  /**
   * Password for Prometheus Basic authentication
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheusDiscoveryType$inboundSchema: z.ZodType<
  InputPrometheusDiscoveryType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputPrometheusDiscoveryType);
/** @internal */
export const InputPrometheusDiscoveryType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputPrometheusDiscoveryType
> = openEnums.outboundSchema(InputPrometheusDiscoveryType);

/** @internal */
export const InputPrometheusLogLevel$inboundSchema: z.ZodType<
  InputPrometheusLogLevel,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputPrometheusLogLevel);
/** @internal */
export const InputPrometheusLogLevel$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputPrometheusLogLevel
> = openEnums.outboundSchema(InputPrometheusLogLevel);

/** @internal */
export const MetricsProtocol$inboundSchema: z.ZodType<
  MetricsProtocol,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(MetricsProtocol);
/** @internal */
export const MetricsProtocol$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  MetricsProtocol
> = openEnums.outboundSchema(MetricsProtocol);

/** @internal */
export const InputPrometheus$inboundSchema: z.ZodType<
  InputPrometheus,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: z.literal("prometheus"),
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ItemsTypeConnectionsOptional$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType$inboundSchema.optional(),
  interval: z.number(),
  logLevel: InputPrometheusLogLevel$inboundSchema,
  rejectUnauthorized: z.boolean().optional(),
  timeout: z.number().optional(),
  keepAliveTime: z.number().optional(),
  jobTimeout: z.string().optional(),
  maxMissedKeepAlives: z.number().optional(),
  ttl: z.string().optional(),
  ignoreGroupJobsLimit: z.boolean().optional(),
  metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
  authType: AuthenticationMethodOptionsSasl$inboundSchema.optional(),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$inboundSchema.optional(),
  scrapePort: z.number().optional(),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: MetricsProtocol$inboundSchema.optional(),
  scrapePath: z.string().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().optional(),
  searchFilter: z.array(ItemsTypeSearchFilter$inboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions1$inboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type InputPrometheus$Outbound = {
  id?: string | undefined;
  type: "prometheus";
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  dimensionList?: Array<string> | undefined;
  discoveryType?: string | undefined;
  interval: number;
  logLevel: string;
  rejectUnauthorized?: boolean | undefined;
  timeout?: number | undefined;
  keepAliveTime?: number | undefined;
  jobTimeout?: string | undefined;
  maxMissedKeepAlives?: number | undefined;
  ttl?: string | undefined;
  ignoreGroupJobsLimit?: boolean | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  authType?: string | undefined;
  description?: string | undefined;
  targetList?: Array<string> | undefined;
  recordType?: string | undefined;
  scrapePort?: number | undefined;
  nameList?: Array<string> | undefined;
  scrapeProtocol?: string | undefined;
  scrapePath?: string | undefined;
  awsAuthenticationMethod?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
  usePublicIp?: boolean | undefined;
  searchFilter?: Array<ItemsTypeSearchFilter$Outbound> | undefined;
  awsSecretKey?: string | undefined;
  region?: string | undefined;
  endpoint?: string | undefined;
  signatureVersion?: string | undefined;
  reuseConnections?: boolean | undefined;
  enableAssumeRole?: boolean | undefined;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds?: number | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const InputPrometheus$outboundSchema: z.ZodType<
  InputPrometheus$Outbound,
  z.ZodTypeDef,
  InputPrometheus
> = z.object({
  id: z.string().optional(),
  type: z.literal("prometheus"),
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ItemsTypeConnectionsOptional$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  dimensionList: z.array(z.string()).optional(),
  discoveryType: InputPrometheusDiscoveryType$outboundSchema.optional(),
  interval: z.number(),
  logLevel: InputPrometheusLogLevel$outboundSchema,
  rejectUnauthorized: z.boolean().optional(),
  timeout: z.number().optional(),
  keepAliveTime: z.number().optional(),
  jobTimeout: z.string().optional(),
  maxMissedKeepAlives: z.number().optional(),
  ttl: z.string().optional(),
  ignoreGroupJobsLimit: z.boolean().optional(),
  metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
  authType: AuthenticationMethodOptionsSasl$outboundSchema.optional(),
  description: z.string().optional(),
  targetList: z.array(z.string()).optional(),
  recordType: RecordTypeOptions$outboundSchema.optional(),
  scrapePort: z.number().optional(),
  nameList: z.array(z.string()).optional(),
  scrapeProtocol: MetricsProtocol$outboundSchema.optional(),
  scrapePath: z.string().optional(),
  awsAuthenticationMethod: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
  usePublicIp: z.boolean().optional(),
  searchFilter: z.array(ItemsTypeSearchFilter$outboundSchema).optional(),
  awsSecretKey: z.string().optional(),
  region: z.string().optional(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions1$outboundSchema.optional(),
  reuseConnections: z.boolean().optional(),
  enableAssumeRole: z.boolean().optional(),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
});

export function inputPrometheusToJSON(
  inputPrometheus: InputPrometheus,
): string {
  return JSON.stringify(InputPrometheus$outboundSchema.parse(inputPrometheus));
}
export function inputPrometheusFromJSON(
  jsonString: string,
): SafeParseResult<InputPrometheus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputPrometheus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputPrometheus' from JSON`,
  );
}
