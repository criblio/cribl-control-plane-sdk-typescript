/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthenticationMethodOptionsAuthTokensItems,
  AuthenticationMethodOptionsAuthTokensItems$inboundSchema,
  AuthenticationMethodOptionsAuthTokensItems$outboundSchema,
} from "./authenticationmethodoptionsauthtokensitems.js";
import {
  BackpressureBehaviorOptions,
  BackpressureBehaviorOptions$inboundSchema,
  BackpressureBehaviorOptions$outboundSchema,
} from "./backpressurebehavioroptions.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  FailedRequestLoggingModeOptions,
  FailedRequestLoggingModeOptions$inboundSchema,
  FailedRequestLoggingModeOptions$outboundSchema,
} from "./failedrequestloggingmodeoptions.js";
import {
  ItemsTypeExtraHttpHeaders,
  ItemsTypeExtraHttpHeaders$inboundSchema,
  ItemsTypeExtraHttpHeaders$Outbound,
  ItemsTypeExtraHttpHeaders$outboundSchema,
} from "./itemstypeextrahttpheaders.js";
import {
  ItemsTypeResponseRetrySettings,
  ItemsTypeResponseRetrySettings$inboundSchema,
  ItemsTypeResponseRetrySettings$Outbound,
  ItemsTypeResponseRetrySettings$outboundSchema,
} from "./itemstyperesponseretrysettings.js";
import {
  TimeoutRetrySettingsType,
  TimeoutRetrySettingsType$inboundSchema,
  TimeoutRetrySettingsType$Outbound,
  TimeoutRetrySettingsType$outboundSchema,
} from "./timeoutretrysettingstype.js";
import {
  TlsSettingsClientSideType1,
  TlsSettingsClientSideType1$inboundSchema,
  TlsSettingsClientSideType1$Outbound,
  TlsSettingsClientSideType1$outboundSchema,
} from "./tlssettingsclientsidetype1.js";

export type OutputWizHec = {
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: "wiz_hec";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  loadBalanced?: any | undefined;
  /**
   * In the Splunk app, define which Splunk processing queue to send the events after HEC processing.
   */
  nextQueue?: string | undefined;
  /**
   * In the Splunk app, set the value of _TCP_ROUTING for events that do not have _ctrl._TCP_ROUTING set.
   */
  tcpRouting?: string | undefined;
  tls?: TlsSettingsClientSideType1 | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  enableMultiMetrics?: any | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ItemsTypeResponseRetrySettings> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorOptions | undefined;
  /**
   * The unique identifier for the specific Cribl connector defined in your Wiz Settings. This is used to cross-validate the bearer token and ensure traffic is originating from the authorized integration.
   */
  wiz_connector_id: string;
  /**
   * Your Wiz deployment environment.
   */
  wiz_environment: string;
  /**
   * Your Wiz deployment data center (e.g., us1, us8, eu1). From Tenant Info → Data Center and Regions → Tenant Data Center in your Wiz console.
   */
  data_center: string;
  wiz_sourcetype: string;
  description?: string | undefined;
  /**
   * Wiz Defender Auth token
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

/** @internal */
export const OutputWizHec$inboundSchema: z.ZodType<
  OutputWizHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: z.literal("wiz_hec"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  loadBalanced: z.any().optional(),
  nextQueue: z.string().optional(),
  tcpRouting: z.string().optional(),
  tls: TlsSettingsClientSideType1$inboundSchema.optional(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  timeoutSec: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  extraHttpHeaders: z.array(ItemsTypeExtraHttpHeaders$inboundSchema).optional(),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .optional(),
  safeHeaders: z.array(z.string()).optional(),
  enableMultiMetrics: z.any().optional(),
  authType: AuthenticationMethodOptionsAuthTokensItems$inboundSchema.optional(),
  responseRetrySettings: z.array(ItemsTypeResponseRetrySettings$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  onBackpressure: BackpressureBehaviorOptions$inboundSchema.optional(),
  wiz_connector_id: z.string(),
  wiz_environment: z.string(),
  data_center: z.string(),
  wiz_sourcetype: z.string(),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
});
/** @internal */
export type OutputWizHec$Outbound = {
  id?: string | undefined;
  type: "wiz_hec";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  loadBalanced?: any | undefined;
  nextQueue?: string | undefined;
  tcpRouting?: string | undefined;
  tls?: TlsSettingsClientSideType1$Outbound | undefined;
  concurrency?: number | undefined;
  maxPayloadSizeKB?: number | undefined;
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  timeoutSec?: number | undefined;
  flushPeriodSec?: number | undefined;
  extraHttpHeaders?: Array<ItemsTypeExtraHttpHeaders$Outbound> | undefined;
  failedRequestLoggingMode?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  enableMultiMetrics?: any | undefined;
  authType?: string | undefined;
  responseRetrySettings?:
    | Array<ItemsTypeResponseRetrySettings$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader?: boolean | undefined;
  onBackpressure?: string | undefined;
  wiz_connector_id: string;
  wiz_environment: string;
  data_center: string;
  wiz_sourcetype: string;
  description?: string | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputWizHec$outboundSchema: z.ZodType<
  OutputWizHec$Outbound,
  z.ZodTypeDef,
  OutputWizHec
> = z.object({
  id: z.string().optional(),
  type: z.literal("wiz_hec"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  loadBalanced: z.any().optional(),
  nextQueue: z.string().optional(),
  tcpRouting: z.string().optional(),
  tls: TlsSettingsClientSideType1$outboundSchema.optional(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  timeoutSec: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  extraHttpHeaders: z.array(ItemsTypeExtraHttpHeaders$outboundSchema)
    .optional(),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .optional(),
  safeHeaders: z.array(z.string()).optional(),
  enableMultiMetrics: z.any().optional(),
  authType: AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  responseRetrySettings: z.array(ItemsTypeResponseRetrySettings$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  onBackpressure: BackpressureBehaviorOptions$outboundSchema.optional(),
  wiz_connector_id: z.string(),
  wiz_environment: z.string(),
  data_center: z.string(),
  wiz_sourcetype: z.string(),
  description: z.string().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
});

export function outputWizHecToJSON(outputWizHec: OutputWizHec): string {
  return JSON.stringify(OutputWizHec$outboundSchema.parse(outputWizHec));
}
export function outputWizHecFromJSON(
  jsonString: string,
): SafeParseResult<OutputWizHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWizHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWizHec' from JSON`,
  );
}
