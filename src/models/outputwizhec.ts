/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthenticationMethodOptionsAuthTokensItems,
  AuthenticationMethodOptionsAuthTokensItems$inboundSchema,
  AuthenticationMethodOptionsAuthTokensItems$outboundSchema,
} from "./authenticationmethodoptionsauthtokensitems.js";
import {
  BackpressureBehaviorOptions,
  BackpressureBehaviorOptions$inboundSchema,
  BackpressureBehaviorOptions$outboundSchema,
} from "./backpressurebehavioroptions.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  FailedRequestLoggingModeOptions,
  FailedRequestLoggingModeOptions$inboundSchema,
  FailedRequestLoggingModeOptions$outboundSchema,
} from "./failedrequestloggingmodeoptions.js";
import {
  ItemsTypeExtraHttpHeaders,
  ItemsTypeExtraHttpHeaders$inboundSchema,
  ItemsTypeExtraHttpHeaders$Outbound,
  ItemsTypeExtraHttpHeaders$outboundSchema,
} from "./itemstypeextrahttpheaders.js";
import {
  ItemsTypeResponseRetrySettings,
  ItemsTypeResponseRetrySettings$inboundSchema,
  ItemsTypeResponseRetrySettings$Outbound,
  ItemsTypeResponseRetrySettings$outboundSchema,
} from "./itemstyperesponseretrysettings.js";
import {
  TimeoutRetrySettingsType,
  TimeoutRetrySettingsType$inboundSchema,
  TimeoutRetrySettingsType$Outbound,
  TimeoutRetrySettingsType$outboundSchema,
} from "./timeoutretrysettingstype.js";
import {
  TlsSettingsClientSideType1,
  TlsSettingsClientSideType1$inboundSchema,
  TlsSettingsClientSideType1$Outbound,
  TlsSettingsClientSideType1$outboundSchema,
} from "./tlssettingsclientsidetype1.js";

export type OutputWizHecUrl = {
  /**
   * URL to an endpoint to send events to, such as http://localhost:8088/services/collector/event
   */
  url: string;
  /**
   * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability
   */
  weight?: number | undefined;
};

export type OutputWizHec = {
  /**
   * Unique ID for this output
   */
  id?: string | undefined;
  type: "wiz_hec";
  /**
   * Pipeline to process data before sending out to this output
   */
  pipeline?: string | undefined;
  /**
   * Fields to automatically add to events, such as cribl_pipe. Supports wildcards.
   */
  systemFields?: Array<string> | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS.
   */
  loadBalanced?: boolean | undefined;
  /**
   * In the Splunk app, define which Splunk processing queue to send the events after HEC processing.
   */
  nextQueue?: string | undefined;
  /**
   * In the Splunk app, set the value of _TCP_ROUTING for events that do not have _ctrl._TCP_ROUTING set.
   */
  tcpRouting?: string | undefined;
  tls?: TlsSettingsClientSideType1 | undefined;
  /**
   * Maximum number of ongoing requests before blocking
   */
  concurrency?: number | undefined;
  /**
   * Maximum size, in KB, of the request body
   */
  maxPayloadSizeKB?: number | undefined;
  /**
   * Maximum number of events to include in the request body. Default is 0 (unlimited).
   */
  maxPayloadEvents?: number | undefined;
  /**
   * Compress the payload body before sending
   */
  compress?: boolean | undefined;
  /**
   * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
   *
   * @remarks
   *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
   *         that value will take precedence.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Amount of time, in seconds, to wait for a request to complete before canceling it
   */
  timeoutSec?: number | undefined;
  /**
   * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit.
   */
  flushPeriodSec?: number | undefined;
  /**
   * Headers to add to all events
   */
  extraHttpHeaders?: Array<ItemsTypeExtraHttpHeaders> | undefined;
  /**
   * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below.
   */
  failedRequestLoggingMode?: FailedRequestLoggingModeOptions | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  /**
   * Output metrics in multiple-metric format
   */
  enableMultiMetrics?: boolean | undefined;
  /**
   * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate
   */
  authType?: AuthenticationMethodOptionsAuthTokensItems | undefined;
  /**
   * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
   */
  responseRetrySettings?: Array<ItemsTypeResponseRetrySettings> | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored.
   */
  responseHonorRetryAfterHeader?: boolean | undefined;
  /**
   * How to handle events when all receivers are exerting backpressure
   */
  onBackpressure?: BackpressureBehaviorOptions | undefined;
  description?: string | undefined;
  /**
   * URL to an endpoint to send events to, such as http://localhost:8088/services/collector/event
   */
  url?: string | undefined;
  /**
   * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Exclude all IPs of the current host from the list of any resolved hostnames
   */
  excludeSelf?: boolean | undefined;
  urls?: Array<OutputWizHecUrl> | undefined;
  /**
   * The interval in which to re-resolve any hostnames and pick up destinations from A records
   */
  dnsResolvePeriodSec?: number | undefined;
  /**
   * How far back in time to keep traffic stats for load balancing purposes
   */
  loadBalanceStatsPeriodSec?: number | undefined;
  /**
   * Wiz Defender Auth token
   */
  token?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

/** @internal */
export const OutputWizHecUrl$inboundSchema: z.ZodType<
  OutputWizHecUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  weight: z.number().optional(),
});
/** @internal */
export type OutputWizHecUrl$Outbound = {
  url: string;
  weight?: number | undefined;
};

/** @internal */
export const OutputWizHecUrl$outboundSchema: z.ZodType<
  OutputWizHecUrl$Outbound,
  z.ZodTypeDef,
  OutputWizHecUrl
> = z.object({
  url: z.string(),
  weight: z.number().optional(),
});

export function outputWizHecUrlToJSON(
  outputWizHecUrl: OutputWizHecUrl,
): string {
  return JSON.stringify(OutputWizHecUrl$outboundSchema.parse(outputWizHecUrl));
}
export function outputWizHecUrlFromJSON(
  jsonString: string,
): SafeParseResult<OutputWizHecUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWizHecUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWizHecUrl' from JSON`,
  );
}

/** @internal */
export const OutputWizHec$inboundSchema: z.ZodType<
  OutputWizHec,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: z.literal("wiz_hec"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  loadBalanced: z.boolean().optional(),
  nextQueue: z.string().optional(),
  tcpRouting: z.string().optional(),
  tls: TlsSettingsClientSideType1$inboundSchema.optional(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  timeoutSec: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  extraHttpHeaders: z.array(ItemsTypeExtraHttpHeaders$inboundSchema).optional(),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$inboundSchema
    .optional(),
  safeHeaders: z.array(z.string()).optional(),
  enableMultiMetrics: z.boolean().optional(),
  authType: AuthenticationMethodOptionsAuthTokensItems$inboundSchema.optional(),
  responseRetrySettings: z.array(ItemsTypeResponseRetrySettings$inboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$inboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  onBackpressure: BackpressureBehaviorOptions$inboundSchema.optional(),
  description: z.string().optional(),
  url: z.string().optional(),
  useRoundRobinDns: z.boolean().optional(),
  excludeSelf: z.boolean().optional(),
  urls: z.array(z.lazy(() => OutputWizHecUrl$inboundSchema)).optional(),
  dnsResolvePeriodSec: z.number().optional(),
  loadBalanceStatsPeriodSec: z.number().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
});
/** @internal */
export type OutputWizHec$Outbound = {
  id?: string | undefined;
  type: "wiz_hec";
  pipeline?: string | undefined;
  systemFields?: Array<string> | undefined;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  loadBalanced?: boolean | undefined;
  nextQueue?: string | undefined;
  tcpRouting?: string | undefined;
  tls?: TlsSettingsClientSideType1$Outbound | undefined;
  concurrency?: number | undefined;
  maxPayloadSizeKB?: number | undefined;
  maxPayloadEvents?: number | undefined;
  compress?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  timeoutSec?: number | undefined;
  flushPeriodSec?: number | undefined;
  extraHttpHeaders?: Array<ItemsTypeExtraHttpHeaders$Outbound> | undefined;
  failedRequestLoggingMode?: string | undefined;
  safeHeaders?: Array<string> | undefined;
  enableMultiMetrics?: boolean | undefined;
  authType?: string | undefined;
  responseRetrySettings?:
    | Array<ItemsTypeResponseRetrySettings$Outbound>
    | undefined;
  timeoutRetrySettings?: TimeoutRetrySettingsType$Outbound | undefined;
  responseHonorRetryAfterHeader?: boolean | undefined;
  onBackpressure?: string | undefined;
  description?: string | undefined;
  url?: string | undefined;
  useRoundRobinDns?: boolean | undefined;
  excludeSelf?: boolean | undefined;
  urls?: Array<OutputWizHecUrl$Outbound> | undefined;
  dnsResolvePeriodSec?: number | undefined;
  loadBalanceStatsPeriodSec?: number | undefined;
  token?: string | undefined;
  textSecret?: string | undefined;
};

/** @internal */
export const OutputWizHec$outboundSchema: z.ZodType<
  OutputWizHec$Outbound,
  z.ZodTypeDef,
  OutputWizHec
> = z.object({
  id: z.string().optional(),
  type: z.literal("wiz_hec"),
  pipeline: z.string().optional(),
  systemFields: z.array(z.string()).optional(),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  loadBalanced: z.boolean().optional(),
  nextQueue: z.string().optional(),
  tcpRouting: z.string().optional(),
  tls: TlsSettingsClientSideType1$outboundSchema.optional(),
  concurrency: z.number().optional(),
  maxPayloadSizeKB: z.number().optional(),
  maxPayloadEvents: z.number().optional(),
  compress: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  timeoutSec: z.number().optional(),
  flushPeriodSec: z.number().optional(),
  extraHttpHeaders: z.array(ItemsTypeExtraHttpHeaders$outboundSchema)
    .optional(),
  failedRequestLoggingMode: FailedRequestLoggingModeOptions$outboundSchema
    .optional(),
  safeHeaders: z.array(z.string()).optional(),
  enableMultiMetrics: z.boolean().optional(),
  authType: AuthenticationMethodOptionsAuthTokensItems$outboundSchema
    .optional(),
  responseRetrySettings: z.array(ItemsTypeResponseRetrySettings$outboundSchema)
    .optional(),
  timeoutRetrySettings: TimeoutRetrySettingsType$outboundSchema.optional(),
  responseHonorRetryAfterHeader: z.boolean().optional(),
  onBackpressure: BackpressureBehaviorOptions$outboundSchema.optional(),
  description: z.string().optional(),
  url: z.string().optional(),
  useRoundRobinDns: z.boolean().optional(),
  excludeSelf: z.boolean().optional(),
  urls: z.array(z.lazy(() => OutputWizHecUrl$outboundSchema)).optional(),
  dnsResolvePeriodSec: z.number().optional(),
  loadBalanceStatsPeriodSec: z.number().optional(),
  token: z.string().optional(),
  textSecret: z.string().optional(),
});

export function outputWizHecToJSON(outputWizHec: OutputWizHec): string {
  return JSON.stringify(OutputWizHec$outboundSchema.parse(outputWizHec));
}
export function outputWizHecFromJSON(
  jsonString: string,
): SafeParseResult<OutputWizHec, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputWizHec$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputWizHec' from JSON`,
  );
}
