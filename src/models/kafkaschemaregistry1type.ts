/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Credentials to use when authenticating with the schema registry using basic HTTP authentication
 */
export type KafkaSchemaRegistry1TypeAuth = {
  disabled?: boolean | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
};

export const KafkaSchemaRegistry1TypeMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type KafkaSchemaRegistry1TypeMinimumTLSVersion = OpenEnum<
  typeof KafkaSchemaRegistry1TypeMinimumTLSVersion
>;

export const KafkaSchemaRegistry1TypeMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type KafkaSchemaRegistry1TypeMaximumTLSVersion = OpenEnum<
  typeof KafkaSchemaRegistry1TypeMaximumTLSVersion
>;

export type KafkaSchemaRegistry1TypeTLSSettingsClientSide = {
  disabled?: boolean | undefined;
  /**
   * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
   *
   * @remarks
   *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
   */
  servername?: string | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  minVersion?: KafkaSchemaRegistry1TypeMinimumTLSVersion | undefined;
  maxVersion?: KafkaSchemaRegistry1TypeMaximumTLSVersion | undefined;
};

export type KafkaSchemaRegistry1Type = {
  disabled?: boolean | undefined;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: KafkaSchemaRegistry1TypeAuth | undefined;
  tls?: KafkaSchemaRegistry1TypeTLSSettingsClientSide | undefined;
  /**
   * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
   */
  defaultKeySchemaId?: number | undefined;
  /**
   * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
   */
  defaultValueSchemaId?: number | undefined;
};

/** @internal */
export const KafkaSchemaRegistry1TypeAuth$inboundSchema: z.ZodType<
  KafkaSchemaRegistry1TypeAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});
/** @internal */
export type KafkaSchemaRegistry1TypeAuth$Outbound = {
  disabled: boolean;
  credentialsSecret?: string | undefined;
};

/** @internal */
export const KafkaSchemaRegistry1TypeAuth$outboundSchema: z.ZodType<
  KafkaSchemaRegistry1TypeAuth$Outbound,
  z.ZodTypeDef,
  KafkaSchemaRegistry1TypeAuth
> = z.object({
  disabled: z.boolean().default(true),
  credentialsSecret: z.string().optional(),
});

export function kafkaSchemaRegistry1TypeAuthToJSON(
  kafkaSchemaRegistry1TypeAuth: KafkaSchemaRegistry1TypeAuth,
): string {
  return JSON.stringify(
    KafkaSchemaRegistry1TypeAuth$outboundSchema.parse(
      kafkaSchemaRegistry1TypeAuth,
    ),
  );
}
export function kafkaSchemaRegistry1TypeAuthFromJSON(
  jsonString: string,
): SafeParseResult<KafkaSchemaRegistry1TypeAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KafkaSchemaRegistry1TypeAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KafkaSchemaRegistry1TypeAuth' from JSON`,
  );
}

/** @internal */
export const KafkaSchemaRegistry1TypeMinimumTLSVersion$inboundSchema: z.ZodType<
  KafkaSchemaRegistry1TypeMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(KafkaSchemaRegistry1TypeMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const KafkaSchemaRegistry1TypeMinimumTLSVersion$outboundSchema:
  z.ZodType<
    KafkaSchemaRegistry1TypeMinimumTLSVersion,
    z.ZodTypeDef,
    KafkaSchemaRegistry1TypeMinimumTLSVersion
  > = z.union([
    z.nativeEnum(KafkaSchemaRegistry1TypeMinimumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/** @internal */
export const KafkaSchemaRegistry1TypeMaximumTLSVersion$inboundSchema: z.ZodType<
  KafkaSchemaRegistry1TypeMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(KafkaSchemaRegistry1TypeMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const KafkaSchemaRegistry1TypeMaximumTLSVersion$outboundSchema:
  z.ZodType<
    KafkaSchemaRegistry1TypeMaximumTLSVersion,
    z.ZodTypeDef,
    KafkaSchemaRegistry1TypeMaximumTLSVersion
  > = z.union([
    z.nativeEnum(KafkaSchemaRegistry1TypeMaximumTLSVersion),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/** @internal */
export const KafkaSchemaRegistry1TypeTLSSettingsClientSide$inboundSchema:
  z.ZodType<
    KafkaSchemaRegistry1TypeTLSSettingsClientSide,
    z.ZodTypeDef,
    unknown
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: KafkaSchemaRegistry1TypeMinimumTLSVersion$inboundSchema
      .optional(),
    maxVersion: KafkaSchemaRegistry1TypeMaximumTLSVersion$inboundSchema
      .optional(),
  });
/** @internal */
export type KafkaSchemaRegistry1TypeTLSSettingsClientSide$Outbound = {
  disabled: boolean;
  rejectUnauthorized: boolean;
  servername?: string | undefined;
  certificateName?: string | undefined;
  caPath?: string | undefined;
  privKeyPath?: string | undefined;
  certPath?: string | undefined;
  passphrase?: string | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const KafkaSchemaRegistry1TypeTLSSettingsClientSide$outboundSchema:
  z.ZodType<
    KafkaSchemaRegistry1TypeTLSSettingsClientSide$Outbound,
    z.ZodTypeDef,
    KafkaSchemaRegistry1TypeTLSSettingsClientSide
  > = z.object({
    disabled: z.boolean().default(true),
    rejectUnauthorized: z.boolean().default(true),
    servername: z.string().optional(),
    certificateName: z.string().optional(),
    caPath: z.string().optional(),
    privKeyPath: z.string().optional(),
    certPath: z.string().optional(),
    passphrase: z.string().optional(),
    minVersion: KafkaSchemaRegistry1TypeMinimumTLSVersion$outboundSchema
      .optional(),
    maxVersion: KafkaSchemaRegistry1TypeMaximumTLSVersion$outboundSchema
      .optional(),
  });

export function kafkaSchemaRegistry1TypeTLSSettingsClientSideToJSON(
  kafkaSchemaRegistry1TypeTLSSettingsClientSide:
    KafkaSchemaRegistry1TypeTLSSettingsClientSide,
): string {
  return JSON.stringify(
    KafkaSchemaRegistry1TypeTLSSettingsClientSide$outboundSchema.parse(
      kafkaSchemaRegistry1TypeTLSSettingsClientSide,
    ),
  );
}
export function kafkaSchemaRegistry1TypeTLSSettingsClientSideFromJSON(
  jsonString: string,
): SafeParseResult<
  KafkaSchemaRegistry1TypeTLSSettingsClientSide,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      KafkaSchemaRegistry1TypeTLSSettingsClientSide$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'KafkaSchemaRegistry1TypeTLSSettingsClientSide' from JSON`,
  );
}

/** @internal */
export const KafkaSchemaRegistry1Type$inboundSchema: z.ZodType<
  KafkaSchemaRegistry1Type,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  schemaRegistryURL: z.string().default("http://localhost:8081"),
  connectionTimeout: z.number().default(30000),
  requestTimeout: z.number().default(30000),
  maxRetries: z.number().default(1),
  auth: z.lazy(() => KafkaSchemaRegistry1TypeAuth$inboundSchema).optional(),
  tls: z.lazy(() => KafkaSchemaRegistry1TypeTLSSettingsClientSide$inboundSchema)
    .optional(),
  defaultKeySchemaId: z.number().optional(),
  defaultValueSchemaId: z.number().optional(),
});
/** @internal */
export type KafkaSchemaRegistry1Type$Outbound = {
  disabled: boolean;
  schemaRegistryURL: string;
  connectionTimeout: number;
  requestTimeout: number;
  maxRetries: number;
  auth?: KafkaSchemaRegistry1TypeAuth$Outbound | undefined;
  tls?: KafkaSchemaRegistry1TypeTLSSettingsClientSide$Outbound | undefined;
  defaultKeySchemaId?: number | undefined;
  defaultValueSchemaId?: number | undefined;
};

/** @internal */
export const KafkaSchemaRegistry1Type$outboundSchema: z.ZodType<
  KafkaSchemaRegistry1Type$Outbound,
  z.ZodTypeDef,
  KafkaSchemaRegistry1Type
> = z.object({
  disabled: z.boolean().default(true),
  schemaRegistryURL: z.string().default("http://localhost:8081"),
  connectionTimeout: z.number().default(30000),
  requestTimeout: z.number().default(30000),
  maxRetries: z.number().default(1),
  auth: z.lazy(() => KafkaSchemaRegistry1TypeAuth$outboundSchema).optional(),
  tls: z.lazy(() =>
    KafkaSchemaRegistry1TypeTLSSettingsClientSide$outboundSchema
  ).optional(),
  defaultKeySchemaId: z.number().optional(),
  defaultValueSchemaId: z.number().optional(),
});

export function kafkaSchemaRegistry1TypeToJSON(
  kafkaSchemaRegistry1Type: KafkaSchemaRegistry1Type,
): string {
  return JSON.stringify(
    KafkaSchemaRegistry1Type$outboundSchema.parse(kafkaSchemaRegistry1Type),
  );
}
export function kafkaSchemaRegistry1TypeFromJSON(
  jsonString: string,
): SafeParseResult<KafkaSchemaRegistry1Type, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KafkaSchemaRegistry1Type$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KafkaSchemaRegistry1Type' from JSON`,
  );
}
