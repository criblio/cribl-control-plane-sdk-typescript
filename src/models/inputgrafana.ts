/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const InputGrafanaType = {
  Grafana: "grafana",
} as const;
export type InputGrafanaType = ClosedEnum<typeof InputGrafanaType>;

export type InputGrafanaConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputGrafanaMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputGrafanaMode = ClosedEnum<typeof InputGrafanaMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputGrafanaCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputGrafanaCompression = ClosedEnum<
  typeof InputGrafanaCompression
>;

export type InputGrafanaPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputGrafanaMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputGrafanaCompression | undefined;
};

export const InputGrafanaMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputGrafanaMinimumTLSVersion = ClosedEnum<
  typeof InputGrafanaMinimumTLSVersion
>;

export const InputGrafanaMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputGrafanaMaximumTLSVersion = ClosedEnum<
  typeof InputGrafanaMaximumTLSVersion
>;

export type InputGrafanaTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputGrafanaMinimumTLSVersion | undefined;
  maxVersion?: InputGrafanaMaximumTLSVersion | undefined;
};

/**
 * Remote Write authentication type
 */
export const InputGrafanaPrometheusAuthAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Remote Write authentication type
 */
export type InputGrafanaPrometheusAuthAuthenticationType = ClosedEnum<
  typeof InputGrafanaPrometheusAuthAuthenticationType
>;

export type PrometheusAuthOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type PrometheusAuthOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputGrafanaPrometheusAuth = {
  /**
   * Remote Write authentication type
   */
  authType?: InputGrafanaPrometheusAuthAuthenticationType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<PrometheusAuthOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<PrometheusAuthOauthHeader> | undefined;
};

/**
 * Loki logs authentication type
 */
export const InputGrafanaLokiAuthAuthenticationType = {
  None: "none",
  Basic: "basic",
  CredentialsSecret: "credentialsSecret",
  Token: "token",
  TextSecret: "textSecret",
  Oauth: "oauth",
} as const;
/**
 * Loki logs authentication type
 */
export type InputGrafanaLokiAuthAuthenticationType = ClosedEnum<
  typeof InputGrafanaLokiAuthAuthenticationType
>;

export type LokiAuthOauthParam = {
  /**
   * OAuth parameter name
   */
  name: string;
  /**
   * OAuth parameter value
   */
  value: string;
};

export type LokiAuthOauthHeader = {
  /**
   * OAuth header name
   */
  name: string;
  /**
   * OAuth header value
   */
  value: string;
};

export type InputGrafanaLokiAuth = {
  /**
   * Loki logs authentication type
   */
  authType?: InputGrafanaLokiAuthAuthenticationType | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Bearer token to include in the authorization header
   */
  token?: string | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
  /**
   * URL for OAuth
   */
  loginUrl?: string | undefined;
  /**
   * Secret parameter name to pass in request body
   */
  secretParamName?: string | undefined;
  /**
   * Secret parameter value to pass in request body
   */
  secret?: string | undefined;
  /**
   * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
   */
  tokenAttributeName?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`.
   */
  authHeaderExpr?: string | undefined;
  /**
   * How often the OAuth token should be refreshed.
   */
  tokenTimeoutSecs?: number | undefined;
  /**
   * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthParams?: Array<LokiAuthOauthParam> | undefined;
  /**
   * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
   */
  oauthHeaders?: Array<LokiAuthOauthHeader> | undefined;
};

export type InputGrafanaMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputGrafana = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputGrafanaType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputGrafanaConnection> | undefined;
  pq?: InputGrafanaPq | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: InputGrafanaTLSSettingsServerSide | undefined;
  /**
   * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput.
   */
  maxActiveReq?: number | undefined;
  /**
   * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited).
   */
  maxRequestsPerSocket?: number | undefined;
  /**
   * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction.
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Add request headers to events, in the __headers field
   */
  captureHeaders?: boolean | undefined;
  /**
   * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc.
   */
  activityLogSampleRate?: number | undefined;
  /**
   * How long to wait for an incoming request to complete before aborting it. Use 0 to disable.
   */
  requestTimeout?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0.
   */
  socketTimeout?: number | undefined;
  /**
   * Maximum time to wait for additional data, after the last response was sent, before closing a socket connection. This can be very useful when Grafana Agent remote write's request frequency is high so, reusing connections, would help mitigating the cost of creating a new connection per request. Note that Grafana Agent's embedded Prometheus would attempt to keep connections open for up to 5 minutes.
   */
  keepAliveTimeout?: number | undefined;
  /**
   * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy
   */
  enableHealthCheck?: boolean | undefined;
  /**
   * Messages from matched IP addresses will be processed, unless also matched by the denylist
   */
  ipAllowlistRegex?: string | undefined;
  /**
   * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist.
   */
  ipDenylistRegex?: string | undefined;
  /**
   * Absolute path on which to listen for Grafana Agent's Remote Write requests. Defaults to /api/prom/push, which will expand as: 'http://<your‑upstream‑URL>:<your‑port>/api/prom/push'. Either this field or 'Logs API endpoint' must be configured.
   */
  prometheusAPI?: string | undefined;
  /**
   * Absolute path on which to listen for Loki logs requests. Defaults to /loki/api/v1/push, which will (in this example) expand as: 'http://<your‑upstream‑URL>:<your‑port>/loki/api/v1/push'. Either this field or 'Remote Write API endpoint' must be configured.
   */
  lokiAPI?: string | undefined;
  /**
   * Extract structured metadata from the Loki 3.5.3+ format and place it in the __structuredMetadata field. When disabled, uses legacy Loki parsing for backward compatibility.
   */
  extractStructuredMetadata?: boolean | undefined;
  prometheusAuth?: InputGrafanaPrometheusAuth | undefined;
  lokiAuth?: InputGrafanaLokiAuth | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputGrafanaMetadatum> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputGrafanaType$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaType
> = z.nativeEnum(InputGrafanaType);

/** @internal */
export const InputGrafanaType$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaType
> = InputGrafanaType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaType$ {
  /** @deprecated use `InputGrafanaType$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaType$inboundSchema;
  /** @deprecated use `InputGrafanaType$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaType$outboundSchema;
}

/** @internal */
export const InputGrafanaConnection$inboundSchema: z.ZodType<
  InputGrafanaConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputGrafanaConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputGrafanaConnection$outboundSchema: z.ZodType<
  InputGrafanaConnection$Outbound,
  z.ZodTypeDef,
  InputGrafanaConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaConnection$ {
  /** @deprecated use `InputGrafanaConnection$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaConnection$inboundSchema;
  /** @deprecated use `InputGrafanaConnection$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaConnection$outboundSchema;
  /** @deprecated use `InputGrafanaConnection$Outbound` instead. */
  export type Outbound = InputGrafanaConnection$Outbound;
}

export function inputGrafanaConnectionToJSON(
  inputGrafanaConnection: InputGrafanaConnection,
): string {
  return JSON.stringify(
    InputGrafanaConnection$outboundSchema.parse(inputGrafanaConnection),
  );
}

export function inputGrafanaConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaConnection' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMode$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMode
> = z.nativeEnum(InputGrafanaMode);

/** @internal */
export const InputGrafanaMode$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMode
> = InputGrafanaMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMode$ {
  /** @deprecated use `InputGrafanaMode$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMode$inboundSchema;
  /** @deprecated use `InputGrafanaMode$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMode$outboundSchema;
}

/** @internal */
export const InputGrafanaCompression$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaCompression
> = z.nativeEnum(InputGrafanaCompression);

/** @internal */
export const InputGrafanaCompression$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaCompression
> = InputGrafanaCompression$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaCompression$ {
  /** @deprecated use `InputGrafanaCompression$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaCompression$inboundSchema;
  /** @deprecated use `InputGrafanaCompression$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaCompression$outboundSchema;
}

/** @internal */
export const InputGrafanaPq$inboundSchema: z.ZodType<
  InputGrafanaPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputGrafanaMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGrafanaCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputGrafanaPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputGrafanaPq$outboundSchema: z.ZodType<
  InputGrafanaPq$Outbound,
  z.ZodTypeDef,
  InputGrafanaPq
> = z.object({
  mode: InputGrafanaMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputGrafanaCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaPq$ {
  /** @deprecated use `InputGrafanaPq$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaPq$inboundSchema;
  /** @deprecated use `InputGrafanaPq$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaPq$outboundSchema;
  /** @deprecated use `InputGrafanaPq$Outbound` instead. */
  export type Outbound = InputGrafanaPq$Outbound;
}

export function inputGrafanaPqToJSON(inputGrafanaPq: InputGrafanaPq): string {
  return JSON.stringify(InputGrafanaPq$outboundSchema.parse(inputGrafanaPq));
}

export function inputGrafanaPqFromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaPq' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMinimumTLSVersion$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMinimumTLSVersion
> = z.nativeEnum(InputGrafanaMinimumTLSVersion);

/** @internal */
export const InputGrafanaMinimumTLSVersion$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMinimumTLSVersion
> = InputGrafanaMinimumTLSVersion$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMinimumTLSVersion$ {
  /** @deprecated use `InputGrafanaMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputGrafanaMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputGrafanaMaximumTLSVersion$inboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMaximumTLSVersion
> = z.nativeEnum(InputGrafanaMaximumTLSVersion);

/** @internal */
export const InputGrafanaMaximumTLSVersion$outboundSchema: z.ZodNativeEnum<
  typeof InputGrafanaMaximumTLSVersion
> = InputGrafanaMaximumTLSVersion$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMaximumTLSVersion$ {
  /** @deprecated use `InputGrafanaMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputGrafanaMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputGrafanaTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputGrafanaTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputGrafanaMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputGrafanaMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputGrafanaTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputGrafanaTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputGrafanaTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputGrafanaTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputGrafanaMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputGrafanaMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaTLSSettingsServerSide$ {
  /** @deprecated use `InputGrafanaTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputGrafanaTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputGrafanaTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputGrafanaTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputGrafanaTLSSettingsServerSide$Outbound;
}

export function inputGrafanaTLSSettingsServerSideToJSON(
  inputGrafanaTLSSettingsServerSide: InputGrafanaTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputGrafanaTLSSettingsServerSide$outboundSchema.parse(
      inputGrafanaTLSSettingsServerSide,
    ),
  );
}

export function inputGrafanaTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputGrafanaPrometheusAuthAuthenticationType$inboundSchema:
  z.ZodNativeEnum<typeof InputGrafanaPrometheusAuthAuthenticationType> = z
    .nativeEnum(InputGrafanaPrometheusAuthAuthenticationType);

/** @internal */
export const InputGrafanaPrometheusAuthAuthenticationType$outboundSchema:
  z.ZodNativeEnum<typeof InputGrafanaPrometheusAuthAuthenticationType> =
    InputGrafanaPrometheusAuthAuthenticationType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaPrometheusAuthAuthenticationType$ {
  /** @deprecated use `InputGrafanaPrometheusAuthAuthenticationType$inboundSchema` instead. */
  export const inboundSchema =
    InputGrafanaPrometheusAuthAuthenticationType$inboundSchema;
  /** @deprecated use `InputGrafanaPrometheusAuthAuthenticationType$outboundSchema` instead. */
  export const outboundSchema =
    InputGrafanaPrometheusAuthAuthenticationType$outboundSchema;
}

/** @internal */
export const PrometheusAuthOauthParam$inboundSchema: z.ZodType<
  PrometheusAuthOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type PrometheusAuthOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const PrometheusAuthOauthParam$outboundSchema: z.ZodType<
  PrometheusAuthOauthParam$Outbound,
  z.ZodTypeDef,
  PrometheusAuthOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthOauthParam$ {
  /** @deprecated use `PrometheusAuthOauthParam$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthOauthParam$inboundSchema;
  /** @deprecated use `PrometheusAuthOauthParam$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuthOauthParam$outboundSchema;
  /** @deprecated use `PrometheusAuthOauthParam$Outbound` instead. */
  export type Outbound = PrometheusAuthOauthParam$Outbound;
}

export function prometheusAuthOauthParamToJSON(
  prometheusAuthOauthParam: PrometheusAuthOauthParam,
): string {
  return JSON.stringify(
    PrometheusAuthOauthParam$outboundSchema.parse(prometheusAuthOauthParam),
  );
}

export function prometheusAuthOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthOauthParam' from JSON`,
  );
}

/** @internal */
export const PrometheusAuthOauthHeader$inboundSchema: z.ZodType<
  PrometheusAuthOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type PrometheusAuthOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const PrometheusAuthOauthHeader$outboundSchema: z.ZodType<
  PrometheusAuthOauthHeader$Outbound,
  z.ZodTypeDef,
  PrometheusAuthOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrometheusAuthOauthHeader$ {
  /** @deprecated use `PrometheusAuthOauthHeader$inboundSchema` instead. */
  export const inboundSchema = PrometheusAuthOauthHeader$inboundSchema;
  /** @deprecated use `PrometheusAuthOauthHeader$outboundSchema` instead. */
  export const outboundSchema = PrometheusAuthOauthHeader$outboundSchema;
  /** @deprecated use `PrometheusAuthOauthHeader$Outbound` instead. */
  export type Outbound = PrometheusAuthOauthHeader$Outbound;
}

export function prometheusAuthOauthHeaderToJSON(
  prometheusAuthOauthHeader: PrometheusAuthOauthHeader,
): string {
  return JSON.stringify(
    PrometheusAuthOauthHeader$outboundSchema.parse(prometheusAuthOauthHeader),
  );
}

export function prometheusAuthOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<PrometheusAuthOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrometheusAuthOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrometheusAuthOauthHeader' from JSON`,
  );
}

/** @internal */
export const InputGrafanaPrometheusAuth$inboundSchema: z.ZodType<
  InputGrafanaPrometheusAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: InputGrafanaPrometheusAuthAuthenticationType$inboundSchema.default(
    "none",
  ),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => PrometheusAuthOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => PrometheusAuthOauthHeader$inboundSchema))
    .optional(),
});

/** @internal */
export type InputGrafanaPrometheusAuth$Outbound = {
  authType: string;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<PrometheusAuthOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<PrometheusAuthOauthHeader$Outbound> | undefined;
};

/** @internal */
export const InputGrafanaPrometheusAuth$outboundSchema: z.ZodType<
  InputGrafanaPrometheusAuth$Outbound,
  z.ZodTypeDef,
  InputGrafanaPrometheusAuth
> = z.object({
  authType: InputGrafanaPrometheusAuthAuthenticationType$outboundSchema.default(
    "none",
  ),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => PrometheusAuthOauthParam$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => PrometheusAuthOauthHeader$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaPrometheusAuth$ {
  /** @deprecated use `InputGrafanaPrometheusAuth$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaPrometheusAuth$inboundSchema;
  /** @deprecated use `InputGrafanaPrometheusAuth$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaPrometheusAuth$outboundSchema;
  /** @deprecated use `InputGrafanaPrometheusAuth$Outbound` instead. */
  export type Outbound = InputGrafanaPrometheusAuth$Outbound;
}

export function inputGrafanaPrometheusAuthToJSON(
  inputGrafanaPrometheusAuth: InputGrafanaPrometheusAuth,
): string {
  return JSON.stringify(
    InputGrafanaPrometheusAuth$outboundSchema.parse(inputGrafanaPrometheusAuth),
  );
}

export function inputGrafanaPrometheusAuthFromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaPrometheusAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaPrometheusAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaPrometheusAuth' from JSON`,
  );
}

/** @internal */
export const InputGrafanaLokiAuthAuthenticationType$inboundSchema:
  z.ZodNativeEnum<typeof InputGrafanaLokiAuthAuthenticationType> = z.nativeEnum(
    InputGrafanaLokiAuthAuthenticationType,
  );

/** @internal */
export const InputGrafanaLokiAuthAuthenticationType$outboundSchema:
  z.ZodNativeEnum<typeof InputGrafanaLokiAuthAuthenticationType> =
    InputGrafanaLokiAuthAuthenticationType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaLokiAuthAuthenticationType$ {
  /** @deprecated use `InputGrafanaLokiAuthAuthenticationType$inboundSchema` instead. */
  export const inboundSchema =
    InputGrafanaLokiAuthAuthenticationType$inboundSchema;
  /** @deprecated use `InputGrafanaLokiAuthAuthenticationType$outboundSchema` instead. */
  export const outboundSchema =
    InputGrafanaLokiAuthAuthenticationType$outboundSchema;
}

/** @internal */
export const LokiAuthOauthParam$inboundSchema: z.ZodType<
  LokiAuthOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type LokiAuthOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const LokiAuthOauthParam$outboundSchema: z.ZodType<
  LokiAuthOauthParam$Outbound,
  z.ZodTypeDef,
  LokiAuthOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthOauthParam$ {
  /** @deprecated use `LokiAuthOauthParam$inboundSchema` instead. */
  export const inboundSchema = LokiAuthOauthParam$inboundSchema;
  /** @deprecated use `LokiAuthOauthParam$outboundSchema` instead. */
  export const outboundSchema = LokiAuthOauthParam$outboundSchema;
  /** @deprecated use `LokiAuthOauthParam$Outbound` instead. */
  export type Outbound = LokiAuthOauthParam$Outbound;
}

export function lokiAuthOauthParamToJSON(
  lokiAuthOauthParam: LokiAuthOauthParam,
): string {
  return JSON.stringify(
    LokiAuthOauthParam$outboundSchema.parse(lokiAuthOauthParam),
  );
}

export function lokiAuthOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<LokiAuthOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuthOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuthOauthParam' from JSON`,
  );
}

/** @internal */
export const LokiAuthOauthHeader$inboundSchema: z.ZodType<
  LokiAuthOauthHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type LokiAuthOauthHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const LokiAuthOauthHeader$outboundSchema: z.ZodType<
  LokiAuthOauthHeader$Outbound,
  z.ZodTypeDef,
  LokiAuthOauthHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace LokiAuthOauthHeader$ {
  /** @deprecated use `LokiAuthOauthHeader$inboundSchema` instead. */
  export const inboundSchema = LokiAuthOauthHeader$inboundSchema;
  /** @deprecated use `LokiAuthOauthHeader$outboundSchema` instead. */
  export const outboundSchema = LokiAuthOauthHeader$outboundSchema;
  /** @deprecated use `LokiAuthOauthHeader$Outbound` instead. */
  export type Outbound = LokiAuthOauthHeader$Outbound;
}

export function lokiAuthOauthHeaderToJSON(
  lokiAuthOauthHeader: LokiAuthOauthHeader,
): string {
  return JSON.stringify(
    LokiAuthOauthHeader$outboundSchema.parse(lokiAuthOauthHeader),
  );
}

export function lokiAuthOauthHeaderFromJSON(
  jsonString: string,
): SafeParseResult<LokiAuthOauthHeader, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LokiAuthOauthHeader$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LokiAuthOauthHeader' from JSON`,
  );
}

/** @internal */
export const InputGrafanaLokiAuth$inboundSchema: z.ZodType<
  InputGrafanaLokiAuth,
  z.ZodTypeDef,
  unknown
> = z.object({
  authType: InputGrafanaLokiAuthAuthenticationType$inboundSchema.default(
    "none",
  ),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => LokiAuthOauthParam$inboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => LokiAuthOauthHeader$inboundSchema))
    .optional(),
});

/** @internal */
export type InputGrafanaLokiAuth$Outbound = {
  authType: string;
  username?: string | undefined;
  password?: string | undefined;
  token?: string | undefined;
  credentialsSecret?: string | undefined;
  textSecret?: string | undefined;
  loginUrl?: string | undefined;
  secretParamName?: string | undefined;
  secret?: string | undefined;
  tokenAttributeName?: string | undefined;
  authHeaderExpr: string;
  tokenTimeoutSecs: number;
  oauthParams?: Array<LokiAuthOauthParam$Outbound> | undefined;
  oauthHeaders?: Array<LokiAuthOauthHeader$Outbound> | undefined;
};

/** @internal */
export const InputGrafanaLokiAuth$outboundSchema: z.ZodType<
  InputGrafanaLokiAuth$Outbound,
  z.ZodTypeDef,
  InputGrafanaLokiAuth
> = z.object({
  authType: InputGrafanaLokiAuthAuthenticationType$outboundSchema.default(
    "none",
  ),
  username: z.string().optional(),
  password: z.string().optional(),
  token: z.string().optional(),
  credentialsSecret: z.string().optional(),
  textSecret: z.string().optional(),
  loginUrl: z.string().optional(),
  secretParamName: z.string().optional(),
  secret: z.string().optional(),
  tokenAttributeName: z.string().optional(),
  authHeaderExpr: z.string().default("`Bearer ${token}`"),
  tokenTimeoutSecs: z.number().default(3600),
  oauthParams: z.array(z.lazy(() => LokiAuthOauthParam$outboundSchema))
    .optional(),
  oauthHeaders: z.array(z.lazy(() => LokiAuthOauthHeader$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaLokiAuth$ {
  /** @deprecated use `InputGrafanaLokiAuth$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaLokiAuth$inboundSchema;
  /** @deprecated use `InputGrafanaLokiAuth$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaLokiAuth$outboundSchema;
  /** @deprecated use `InputGrafanaLokiAuth$Outbound` instead. */
  export type Outbound = InputGrafanaLokiAuth$Outbound;
}

export function inputGrafanaLokiAuthToJSON(
  inputGrafanaLokiAuth: InputGrafanaLokiAuth,
): string {
  return JSON.stringify(
    InputGrafanaLokiAuth$outboundSchema.parse(inputGrafanaLokiAuth),
  );
}

export function inputGrafanaLokiAuthFromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaLokiAuth, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaLokiAuth$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaLokiAuth' from JSON`,
  );
}

/** @internal */
export const InputGrafanaMetadatum$inboundSchema: z.ZodType<
  InputGrafanaMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputGrafanaMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputGrafanaMetadatum$outboundSchema: z.ZodType<
  InputGrafanaMetadatum$Outbound,
  z.ZodTypeDef,
  InputGrafanaMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafanaMetadatum$ {
  /** @deprecated use `InputGrafanaMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputGrafanaMetadatum$inboundSchema;
  /** @deprecated use `InputGrafanaMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputGrafanaMetadatum$outboundSchema;
  /** @deprecated use `InputGrafanaMetadatum$Outbound` instead. */
  export type Outbound = InputGrafanaMetadatum$Outbound;
}

export function inputGrafanaMetadatumToJSON(
  inputGrafanaMetadatum: InputGrafanaMetadatum,
): string {
  return JSON.stringify(
    InputGrafanaMetadatum$outboundSchema.parse(inputGrafanaMetadatum),
  );
}

export function inputGrafanaMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputGrafanaMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafanaMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafanaMetadatum' from JSON`,
  );
}

/** @internal */
export const InputGrafana$inboundSchema: z.ZodType<
  InputGrafana,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: InputGrafanaType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGrafanaConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputGrafanaPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputGrafanaTLSSettingsServerSide$inboundSchema).optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/api/prom/push"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  extractStructuredMetadata: z.boolean().default(false),
  prometheusAuth: z.lazy(() => InputGrafanaPrometheusAuth$inboundSchema)
    .optional(),
  lokiAuth: z.lazy(() => InputGrafanaLokiAuth$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputGrafanaMetadatum$inboundSchema))
    .optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputGrafana$Outbound = {
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputGrafanaConnection$Outbound> | undefined;
  pq?: InputGrafanaPq$Outbound | undefined;
  host: string;
  port: number;
  tls?: InputGrafanaTLSSettingsServerSide$Outbound | undefined;
  maxActiveReq: number;
  maxRequestsPerSocket: number;
  enableProxyHeader: boolean;
  captureHeaders: boolean;
  activityLogSampleRate: number;
  requestTimeout: number;
  socketTimeout: number;
  keepAliveTimeout: number;
  enableHealthCheck: boolean;
  ipAllowlistRegex: string;
  ipDenylistRegex: string;
  prometheusAPI: string;
  lokiAPI: string;
  extractStructuredMetadata: boolean;
  prometheusAuth?: InputGrafanaPrometheusAuth$Outbound | undefined;
  lokiAuth?: InputGrafanaLokiAuth$Outbound | undefined;
  metadata?: Array<InputGrafanaMetadatum$Outbound> | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputGrafana$outboundSchema: z.ZodType<
  InputGrafana$Outbound,
  z.ZodTypeDef,
  InputGrafana
> = z.object({
  id: z.string().optional(),
  type: InputGrafanaType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputGrafanaConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputGrafanaPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: z.lazy(() => InputGrafanaTLSSettingsServerSide$outboundSchema)
    .optional(),
  maxActiveReq: z.number().default(256),
  maxRequestsPerSocket: z.number().int().default(0),
  enableProxyHeader: z.boolean().default(false),
  captureHeaders: z.boolean().default(false),
  activityLogSampleRate: z.number().default(100),
  requestTimeout: z.number().default(0),
  socketTimeout: z.number().default(0),
  keepAliveTimeout: z.number().default(5),
  enableHealthCheck: z.boolean().default(false),
  ipAllowlistRegex: z.string().default("/.*/"),
  ipDenylistRegex: z.string().default("/^$/"),
  prometheusAPI: z.string().default("/api/prom/push"),
  lokiAPI: z.string().default("/loki/api/v1/push"),
  extractStructuredMetadata: z.boolean().default(false),
  prometheusAuth: z.lazy(() => InputGrafanaPrometheusAuth$outboundSchema)
    .optional(),
  lokiAuth: z.lazy(() => InputGrafanaLokiAuth$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputGrafanaMetadatum$outboundSchema))
    .optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputGrafana$ {
  /** @deprecated use `InputGrafana$inboundSchema` instead. */
  export const inboundSchema = InputGrafana$inboundSchema;
  /** @deprecated use `InputGrafana$outboundSchema` instead. */
  export const outboundSchema = InputGrafana$outboundSchema;
  /** @deprecated use `InputGrafana$Outbound` instead. */
  export type Outbound = InputGrafana$Outbound;
}

export function inputGrafanaToJSON(inputGrafana: InputGrafana): string {
  return JSON.stringify(InputGrafana$outboundSchema.parse(inputGrafana));
}

export function inputGrafanaFromJSON(
  jsonString: string,
): SafeParseResult<InputGrafana, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputGrafana$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputGrafana' from JSON`,
  );
}
