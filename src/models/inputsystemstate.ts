/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeConnections,
  ItemsTypeConnections$inboundSchema,
  ItemsTypeConnections$Outbound,
  ItemsTypeConnections$outboundSchema,
} from "./itemstypeconnections.js";
import {
  ItemsTypeNotificationMetadata,
  ItemsTypeNotificationMetadata$inboundSchema,
  ItemsTypeNotificationMetadata$Outbound,
  ItemsTypeNotificationMetadata$outboundSchema,
} from "./itemstypenotificationmetadata.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";

export const InputSystemStateType = {
  SystemState: "system_state",
} as const;
export type InputSystemStateType = ClosedEnum<typeof InputSystemStateType>;

/**
 * Creates events based on entries collected from the hosts file
 */
export type HostsFile = {
  enable?: boolean | undefined;
};

/**
 * Creates events for each of the host’s network interfaces
 */
export type Interfaces = {
  enable?: boolean | undefined;
};

/**
 * Creates events for physical disks, partitions, and file systems
 */
export type DisksAndFileSystems = {
  enable?: boolean | undefined;
};

/**
 * Creates events based on the host system’s current state
 */
export type HostInfo = {
  enable?: boolean | undefined;
};

/**
 * Creates events based on entries collected from the host’s network routes
 */
export type InputSystemStateRoutes = {
  enable?: boolean | undefined;
};

/**
 * Creates events for DNS resolvers and search entries
 */
export type Dns = {
  enable?: boolean | undefined;
};

/**
 * Creates events for local users and groups
 */
export type UsersAndGroups = {
  enable?: boolean | undefined;
};

/**
 * Creates events for Firewall rules entries
 */
export type Firewall = {
  enable?: boolean | undefined;
};

/**
 * Creates events from the list of services
 */
export type Services = {
  enable?: boolean | undefined;
};

/**
 * Creates events from list of listening ports
 */
export type ListeningPorts = {
  enable?: boolean | undefined;
};

/**
 * Creates events from list of logged-in users
 */
export type LoggedInUsers = {
  enable?: boolean | undefined;
};

export type Collectors = {
  /**
   * Creates events based on entries collected from the hosts file
   */
  hostsfile?: HostsFile | undefined;
  /**
   * Creates events for each of the host’s network interfaces
   */
  interfaces?: Interfaces | undefined;
  /**
   * Creates events for physical disks, partitions, and file systems
   */
  disk?: DisksAndFileSystems | undefined;
  /**
   * Creates events based on the host system’s current state
   */
  metadata?: HostInfo | undefined;
  /**
   * Creates events based on entries collected from the host’s network routes
   */
  routes?: InputSystemStateRoutes | undefined;
  /**
   * Creates events for DNS resolvers and search entries
   */
  dns?: Dns | undefined;
  /**
   * Creates events for local users and groups
   */
  user?: UsersAndGroups | undefined;
  /**
   * Creates events for Firewall rules entries
   */
  firewall?: Firewall | undefined;
  /**
   * Creates events from the list of services
   */
  services?: Services | undefined;
  /**
   * Creates events from list of listening ports
   */
  ports?: ListeningPorts | undefined;
  /**
   * Creates events from list of logged-in users
   */
  loginUsers?: LoggedInUsers | undefined;
};

export const DataCompressionFormat = {
  None: "none",
  Gzip: "gzip",
} as const;
export type DataCompressionFormat = OpenEnum<typeof DataCompressionFormat>;

export type InputSystemStatePersistence = {
  /**
   * Spool metrics to disk for Cribl Edge and Search
   */
  enable?: boolean | undefined;
  /**
   * Time span for each file bucket
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
   */
  maxDataTime?: string | undefined;
  compress?: DataCompressionFormat | undefined;
  /**
   * Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_state
   */
  destPath?: string | undefined;
};

export type InputSystemStatePqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  pq?: PqType | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSystemStateType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
   */
  interval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  collectors?: Collectors | undefined;
  persistence?: InputSystemStatePersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputSystemStatePqEnabledFalseWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  pq?: PqType | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSystemStateType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
   */
  interval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  collectors?: Collectors | undefined;
  persistence?: InputSystemStatePersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputSystemStateSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSystemStateType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: PqType | undefined;
  /**
   * Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
   */
  interval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  collectors?: Collectors | undefined;
  persistence?: InputSystemStatePersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputSystemStateSendToRoutesTrueWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputSystemStateType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: PqType | undefined;
  /**
   * Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes).
   */
  interval?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  collectors?: Collectors | undefined;
  persistence?: InputSystemStatePersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputSystemState =
  | InputSystemStateSendToRoutesTrueWithConnectionsConstraint
  | InputSystemStateSendToRoutesFalseWithConnectionsConstraint
  | InputSystemStatePqEnabledFalseWithPqConstraint
  | InputSystemStatePqEnabledTrueWithPqConstraint;

/** @internal */
export const InputSystemStateType$inboundSchema: z.ZodNativeEnum<
  typeof InputSystemStateType
> = z.nativeEnum(InputSystemStateType);
/** @internal */
export const InputSystemStateType$outboundSchema: z.ZodNativeEnum<
  typeof InputSystemStateType
> = InputSystemStateType$inboundSchema;

/** @internal */
export const HostsFile$inboundSchema: z.ZodType<
  HostsFile,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(true),
});
/** @internal */
export type HostsFile$Outbound = {
  enable: boolean;
};

/** @internal */
export const HostsFile$outboundSchema: z.ZodType<
  HostsFile$Outbound,
  z.ZodTypeDef,
  HostsFile
> = z.object({
  enable: z.boolean().default(true),
});

export function hostsFileToJSON(hostsFile: HostsFile): string {
  return JSON.stringify(HostsFile$outboundSchema.parse(hostsFile));
}
export function hostsFileFromJSON(
  jsonString: string,
): SafeParseResult<HostsFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HostsFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HostsFile' from JSON`,
  );
}

/** @internal */
export const Interfaces$inboundSchema: z.ZodType<
  Interfaces,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(true),
});
/** @internal */
export type Interfaces$Outbound = {
  enable: boolean;
};

/** @internal */
export const Interfaces$outboundSchema: z.ZodType<
  Interfaces$Outbound,
  z.ZodTypeDef,
  Interfaces
> = z.object({
  enable: z.boolean().default(true),
});

export function interfacesToJSON(interfaces: Interfaces): string {
  return JSON.stringify(Interfaces$outboundSchema.parse(interfaces));
}
export function interfacesFromJSON(
  jsonString: string,
): SafeParseResult<Interfaces, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Interfaces$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Interfaces' from JSON`,
  );
}

/** @internal */
export const DisksAndFileSystems$inboundSchema: z.ZodType<
  DisksAndFileSystems,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(true),
});
/** @internal */
export type DisksAndFileSystems$Outbound = {
  enable: boolean;
};

/** @internal */
export const DisksAndFileSystems$outboundSchema: z.ZodType<
  DisksAndFileSystems$Outbound,
  z.ZodTypeDef,
  DisksAndFileSystems
> = z.object({
  enable: z.boolean().default(true),
});

export function disksAndFileSystemsToJSON(
  disksAndFileSystems: DisksAndFileSystems,
): string {
  return JSON.stringify(
    DisksAndFileSystems$outboundSchema.parse(disksAndFileSystems),
  );
}
export function disksAndFileSystemsFromJSON(
  jsonString: string,
): SafeParseResult<DisksAndFileSystems, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DisksAndFileSystems$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DisksAndFileSystems' from JSON`,
  );
}

/** @internal */
export const HostInfo$inboundSchema: z.ZodType<
  HostInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(true),
});
/** @internal */
export type HostInfo$Outbound = {
  enable: boolean;
};

/** @internal */
export const HostInfo$outboundSchema: z.ZodType<
  HostInfo$Outbound,
  z.ZodTypeDef,
  HostInfo
> = z.object({
  enable: z.boolean().default(true),
});

export function hostInfoToJSON(hostInfo: HostInfo): string {
  return JSON.stringify(HostInfo$outboundSchema.parse(hostInfo));
}
export function hostInfoFromJSON(
  jsonString: string,
): SafeParseResult<HostInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HostInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HostInfo' from JSON`,
  );
}

/** @internal */
export const InputSystemStateRoutes$inboundSchema: z.ZodType<
  InputSystemStateRoutes,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(true),
});
/** @internal */
export type InputSystemStateRoutes$Outbound = {
  enable: boolean;
};

/** @internal */
export const InputSystemStateRoutes$outboundSchema: z.ZodType<
  InputSystemStateRoutes$Outbound,
  z.ZodTypeDef,
  InputSystemStateRoutes
> = z.object({
  enable: z.boolean().default(true),
});

export function inputSystemStateRoutesToJSON(
  inputSystemStateRoutes: InputSystemStateRoutes,
): string {
  return JSON.stringify(
    InputSystemStateRoutes$outboundSchema.parse(inputSystemStateRoutes),
  );
}
export function inputSystemStateRoutesFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemStateRoutes, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemStateRoutes$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemStateRoutes' from JSON`,
  );
}

/** @internal */
export const Dns$inboundSchema: z.ZodType<Dns, z.ZodTypeDef, unknown> = z
  .object({
    enable: z.boolean().default(true),
  });
/** @internal */
export type Dns$Outbound = {
  enable: boolean;
};

/** @internal */
export const Dns$outboundSchema: z.ZodType<Dns$Outbound, z.ZodTypeDef, Dns> = z
  .object({
    enable: z.boolean().default(true),
  });

export function dnsToJSON(dns: Dns): string {
  return JSON.stringify(Dns$outboundSchema.parse(dns));
}
export function dnsFromJSON(
  jsonString: string,
): SafeParseResult<Dns, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Dns$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Dns' from JSON`,
  );
}

/** @internal */
export const UsersAndGroups$inboundSchema: z.ZodType<
  UsersAndGroups,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(true),
});
/** @internal */
export type UsersAndGroups$Outbound = {
  enable: boolean;
};

/** @internal */
export const UsersAndGroups$outboundSchema: z.ZodType<
  UsersAndGroups$Outbound,
  z.ZodTypeDef,
  UsersAndGroups
> = z.object({
  enable: z.boolean().default(true),
});

export function usersAndGroupsToJSON(usersAndGroups: UsersAndGroups): string {
  return JSON.stringify(UsersAndGroups$outboundSchema.parse(usersAndGroups));
}
export function usersAndGroupsFromJSON(
  jsonString: string,
): SafeParseResult<UsersAndGroups, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsersAndGroups$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsersAndGroups' from JSON`,
  );
}

/** @internal */
export const Firewall$inboundSchema: z.ZodType<
  Firewall,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(true),
});
/** @internal */
export type Firewall$Outbound = {
  enable: boolean;
};

/** @internal */
export const Firewall$outboundSchema: z.ZodType<
  Firewall$Outbound,
  z.ZodTypeDef,
  Firewall
> = z.object({
  enable: z.boolean().default(true),
});

export function firewallToJSON(firewall: Firewall): string {
  return JSON.stringify(Firewall$outboundSchema.parse(firewall));
}
export function firewallFromJSON(
  jsonString: string,
): SafeParseResult<Firewall, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Firewall$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Firewall' from JSON`,
  );
}

/** @internal */
export const Services$inboundSchema: z.ZodType<
  Services,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(true),
});
/** @internal */
export type Services$Outbound = {
  enable: boolean;
};

/** @internal */
export const Services$outboundSchema: z.ZodType<
  Services$Outbound,
  z.ZodTypeDef,
  Services
> = z.object({
  enable: z.boolean().default(true),
});

export function servicesToJSON(services: Services): string {
  return JSON.stringify(Services$outboundSchema.parse(services));
}
export function servicesFromJSON(
  jsonString: string,
): SafeParseResult<Services, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Services$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Services' from JSON`,
  );
}

/** @internal */
export const ListeningPorts$inboundSchema: z.ZodType<
  ListeningPorts,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(true),
});
/** @internal */
export type ListeningPorts$Outbound = {
  enable: boolean;
};

/** @internal */
export const ListeningPorts$outboundSchema: z.ZodType<
  ListeningPorts$Outbound,
  z.ZodTypeDef,
  ListeningPorts
> = z.object({
  enable: z.boolean().default(true),
});

export function listeningPortsToJSON(listeningPorts: ListeningPorts): string {
  return JSON.stringify(ListeningPorts$outboundSchema.parse(listeningPorts));
}
export function listeningPortsFromJSON(
  jsonString: string,
): SafeParseResult<ListeningPorts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListeningPorts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListeningPorts' from JSON`,
  );
}

/** @internal */
export const LoggedInUsers$inboundSchema: z.ZodType<
  LoggedInUsers,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(true),
});
/** @internal */
export type LoggedInUsers$Outbound = {
  enable: boolean;
};

/** @internal */
export const LoggedInUsers$outboundSchema: z.ZodType<
  LoggedInUsers$Outbound,
  z.ZodTypeDef,
  LoggedInUsers
> = z.object({
  enable: z.boolean().default(true),
});

export function loggedInUsersToJSON(loggedInUsers: LoggedInUsers): string {
  return JSON.stringify(LoggedInUsers$outboundSchema.parse(loggedInUsers));
}
export function loggedInUsersFromJSON(
  jsonString: string,
): SafeParseResult<LoggedInUsers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LoggedInUsers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LoggedInUsers' from JSON`,
  );
}

/** @internal */
export const Collectors$inboundSchema: z.ZodType<
  Collectors,
  z.ZodTypeDef,
  unknown
> = z.object({
  hostsfile: z.lazy(() => HostsFile$inboundSchema).optional(),
  interfaces: z.lazy(() => Interfaces$inboundSchema).optional(),
  disk: z.lazy(() => DisksAndFileSystems$inboundSchema).optional(),
  metadata: z.lazy(() => HostInfo$inboundSchema).optional(),
  routes: z.lazy(() => InputSystemStateRoutes$inboundSchema).optional(),
  dns: z.lazy(() => Dns$inboundSchema).optional(),
  user: z.lazy(() => UsersAndGroups$inboundSchema).optional(),
  firewall: z.lazy(() => Firewall$inboundSchema).optional(),
  services: z.lazy(() => Services$inboundSchema).optional(),
  ports: z.lazy(() => ListeningPorts$inboundSchema).optional(),
  loginUsers: z.lazy(() => LoggedInUsers$inboundSchema).optional(),
});
/** @internal */
export type Collectors$Outbound = {
  hostsfile?: HostsFile$Outbound | undefined;
  interfaces?: Interfaces$Outbound | undefined;
  disk?: DisksAndFileSystems$Outbound | undefined;
  metadata?: HostInfo$Outbound | undefined;
  routes?: InputSystemStateRoutes$Outbound | undefined;
  dns?: Dns$Outbound | undefined;
  user?: UsersAndGroups$Outbound | undefined;
  firewall?: Firewall$Outbound | undefined;
  services?: Services$Outbound | undefined;
  ports?: ListeningPorts$Outbound | undefined;
  loginUsers?: LoggedInUsers$Outbound | undefined;
};

/** @internal */
export const Collectors$outboundSchema: z.ZodType<
  Collectors$Outbound,
  z.ZodTypeDef,
  Collectors
> = z.object({
  hostsfile: z.lazy(() => HostsFile$outboundSchema).optional(),
  interfaces: z.lazy(() => Interfaces$outboundSchema).optional(),
  disk: z.lazy(() => DisksAndFileSystems$outboundSchema).optional(),
  metadata: z.lazy(() => HostInfo$outboundSchema).optional(),
  routes: z.lazy(() => InputSystemStateRoutes$outboundSchema).optional(),
  dns: z.lazy(() => Dns$outboundSchema).optional(),
  user: z.lazy(() => UsersAndGroups$outboundSchema).optional(),
  firewall: z.lazy(() => Firewall$outboundSchema).optional(),
  services: z.lazy(() => Services$outboundSchema).optional(),
  ports: z.lazy(() => ListeningPorts$outboundSchema).optional(),
  loginUsers: z.lazy(() => LoggedInUsers$outboundSchema).optional(),
});

export function collectorsToJSON(collectors: Collectors): string {
  return JSON.stringify(Collectors$outboundSchema.parse(collectors));
}
export function collectorsFromJSON(
  jsonString: string,
): SafeParseResult<Collectors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Collectors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Collectors' from JSON`,
  );
}

/** @internal */
export const DataCompressionFormat$inboundSchema: z.ZodType<
  DataCompressionFormat,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(DataCompressionFormat);
/** @internal */
export const DataCompressionFormat$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  DataCompressionFormat
> = openEnums.outboundSchema(DataCompressionFormat);

/** @internal */
export const InputSystemStatePersistence$inboundSchema: z.ZodType<
  InputSystemStatePersistence,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: DataCompressionFormat$inboundSchema.default("none"),
  destPath: z.string().default("$CRIBL_HOME/state/system_state"),
});
/** @internal */
export type InputSystemStatePersistence$Outbound = {
  enable: boolean;
  timeWindow: string;
  maxDataSize: string;
  maxDataTime: string;
  compress: string;
  destPath: string;
};

/** @internal */
export const InputSystemStatePersistence$outboundSchema: z.ZodType<
  InputSystemStatePersistence$Outbound,
  z.ZodTypeDef,
  InputSystemStatePersistence
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: DataCompressionFormat$outboundSchema.default("none"),
  destPath: z.string().default("$CRIBL_HOME/state/system_state"),
});

export function inputSystemStatePersistenceToJSON(
  inputSystemStatePersistence: InputSystemStatePersistence,
): string {
  return JSON.stringify(
    InputSystemStatePersistence$outboundSchema.parse(
      inputSystemStatePersistence,
    ),
  );
}
export function inputSystemStatePersistenceFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemStatePersistence, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemStatePersistence$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemStatePersistence' from JSON`,
  );
}

/** @internal */
export const InputSystemStatePqEnabledTrueWithPqConstraint$inboundSchema:
  z.ZodType<
    InputSystemStatePqEnabledTrueWithPqConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$inboundSchema.optional(),
    id: z.string().optional(),
    type: InputSystemStateType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    interval: z.number().default(300),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    collectors: z.lazy(() => Collectors$inboundSchema).optional(),
    persistence: z.lazy(() => InputSystemStatePersistence$inboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });
/** @internal */
export type InputSystemStatePqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: PqType$Outbound | undefined;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  interval: number;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  collectors?: Collectors$Outbound | undefined;
  persistence?: InputSystemStatePersistence$Outbound | undefined;
  disableNativeModule: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputSystemStatePqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputSystemStatePqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputSystemStatePqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$outboundSchema.optional(),
    id: z.string().optional(),
    type: InputSystemStateType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    interval: z.number().default(300),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    collectors: z.lazy(() => Collectors$outboundSchema).optional(),
    persistence: z.lazy(() => InputSystemStatePersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });

export function inputSystemStatePqEnabledTrueWithPqConstraintToJSON(
  inputSystemStatePqEnabledTrueWithPqConstraint:
    InputSystemStatePqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputSystemStatePqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputSystemStatePqEnabledTrueWithPqConstraint,
    ),
  );
}
export function inputSystemStatePqEnabledTrueWithPqConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputSystemStatePqEnabledTrueWithPqConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputSystemStatePqEnabledTrueWithPqConstraint$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputSystemStatePqEnabledTrueWithPqConstraint' from JSON`,
  );
}

/** @internal */
export const InputSystemStatePqEnabledFalseWithPqConstraint$inboundSchema:
  z.ZodType<
    InputSystemStatePqEnabledFalseWithPqConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$inboundSchema.optional(),
    id: z.string().optional(),
    type: InputSystemStateType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    interval: z.number().default(300),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    collectors: z.lazy(() => Collectors$inboundSchema).optional(),
    persistence: z.lazy(() => InputSystemStatePersistence$inboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });
/** @internal */
export type InputSystemStatePqEnabledFalseWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: PqType$Outbound | undefined;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  interval: number;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  collectors?: Collectors$Outbound | undefined;
  persistence?: InputSystemStatePersistence$Outbound | undefined;
  disableNativeModule: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputSystemStatePqEnabledFalseWithPqConstraint$outboundSchema:
  z.ZodType<
    InputSystemStatePqEnabledFalseWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputSystemStatePqEnabledFalseWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$outboundSchema.optional(),
    id: z.string().optional(),
    type: InputSystemStateType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    interval: z.number().default(300),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    collectors: z.lazy(() => Collectors$outboundSchema).optional(),
    persistence: z.lazy(() => InputSystemStatePersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });

export function inputSystemStatePqEnabledFalseWithPqConstraintToJSON(
  inputSystemStatePqEnabledFalseWithPqConstraint:
    InputSystemStatePqEnabledFalseWithPqConstraint,
): string {
  return JSON.stringify(
    InputSystemStatePqEnabledFalseWithPqConstraint$outboundSchema.parse(
      inputSystemStatePqEnabledFalseWithPqConstraint,
    ),
  );
}
export function inputSystemStatePqEnabledFalseWithPqConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputSystemStatePqEnabledFalseWithPqConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputSystemStatePqEnabledFalseWithPqConstraint$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputSystemStatePqEnabledFalseWithPqConstraint' from JSON`,
  );
}

/** @internal */
export const InputSystemStateSendToRoutesFalseWithConnectionsConstraint$inboundSchema:
  z.ZodType<
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    id: z.string().optional(),
    type: InputSystemStateType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$inboundSchema.optional(),
    interval: z.number().default(300),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    collectors: z.lazy(() => Collectors$inboundSchema).optional(),
    persistence: z.lazy(() => InputSystemStatePersistence$inboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });
/** @internal */
export type InputSystemStateSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?: Array<ItemsTypeConnections$Outbound> | undefined;
    id?: string | undefined;
    type: string;
    disabled: boolean;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled: boolean;
    streamtags?: Array<string> | undefined;
    pq?: PqType$Outbound | undefined;
    interval: number;
    metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
    collectors?: Collectors$Outbound | undefined;
    persistence?: InputSystemStatePersistence$Outbound | undefined;
    disableNativeModule: boolean;
    description?: string | undefined;
  };

/** @internal */
export const InputSystemStateSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    id: z.string().optional(),
    type: InputSystemStateType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$outboundSchema.optional(),
    interval: z.number().default(300),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    collectors: z.lazy(() => Collectors$outboundSchema).optional(),
    persistence: z.lazy(() => InputSystemStatePersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });

export function inputSystemStateSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputSystemStateSendToRoutesFalseWithConnectionsConstraint:
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputSystemStateSendToRoutesFalseWithConnectionsConstraint),
  );
}
export function inputSystemStateSendToRoutesFalseWithConnectionsConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputSystemStateSendToRoutesFalseWithConnectionsConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputSystemStateSendToRoutesFalseWithConnectionsConstraint$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'InputSystemStateSendToRoutesFalseWithConnectionsConstraint' from JSON`,
  );
}

/** @internal */
export const InputSystemStateSendToRoutesTrueWithConnectionsConstraint$inboundSchema:
  z.ZodType<
    InputSystemStateSendToRoutesTrueWithConnectionsConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
    id: z.string().optional(),
    type: InputSystemStateType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$inboundSchema.optional(),
    interval: z.number().default(300),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    collectors: z.lazy(() => Collectors$inboundSchema).optional(),
    persistence: z.lazy(() => InputSystemStatePersistence$inboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });
/** @internal */
export type InputSystemStateSendToRoutesTrueWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?: Array<ItemsTypeConnections$Outbound> | undefined;
    id?: string | undefined;
    type: string;
    disabled: boolean;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled: boolean;
    streamtags?: Array<string> | undefined;
    pq?: PqType$Outbound | undefined;
    interval: number;
    metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
    collectors?: Collectors$Outbound | undefined;
    persistence?: InputSystemStatePersistence$Outbound | undefined;
    disableNativeModule: boolean;
    description?: string | undefined;
  };

/** @internal */
export const InputSystemStateSendToRoutesTrueWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputSystemStateSendToRoutesTrueWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputSystemStateSendToRoutesTrueWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
    id: z.string().optional(),
    type: InputSystemStateType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$outboundSchema.optional(),
    interval: z.number().default(300),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    collectors: z.lazy(() => Collectors$outboundSchema).optional(),
    persistence: z.lazy(() => InputSystemStatePersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });

export function inputSystemStateSendToRoutesTrueWithConnectionsConstraintToJSON(
  inputSystemStateSendToRoutesTrueWithConnectionsConstraint:
    InputSystemStateSendToRoutesTrueWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputSystemStateSendToRoutesTrueWithConnectionsConstraint$outboundSchema
      .parse(inputSystemStateSendToRoutesTrueWithConnectionsConstraint),
  );
}
export function inputSystemStateSendToRoutesTrueWithConnectionsConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputSystemStateSendToRoutesTrueWithConnectionsConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputSystemStateSendToRoutesTrueWithConnectionsConstraint$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'InputSystemStateSendToRoutesTrueWithConnectionsConstraint' from JSON`,
  );
}

/** @internal */
export const InputSystemState$inboundSchema: z.ZodType<
  InputSystemState,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() =>
    InputSystemStateSendToRoutesTrueWithConnectionsConstraint$inboundSchema
  ),
  z.lazy(() =>
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint$inboundSchema
  ),
  z.lazy(() => InputSystemStatePqEnabledFalseWithPqConstraint$inboundSchema),
  z.lazy(() => InputSystemStatePqEnabledTrueWithPqConstraint$inboundSchema),
]);
/** @internal */
export type InputSystemState$Outbound =
  | InputSystemStateSendToRoutesTrueWithConnectionsConstraint$Outbound
  | InputSystemStateSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputSystemStatePqEnabledFalseWithPqConstraint$Outbound
  | InputSystemStatePqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputSystemState$outboundSchema: z.ZodType<
  InputSystemState$Outbound,
  z.ZodTypeDef,
  InputSystemState
> = z.union([
  z.lazy(() =>
    InputSystemStateSendToRoutesTrueWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() =>
    InputSystemStateSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputSystemStatePqEnabledFalseWithPqConstraint$outboundSchema),
  z.lazy(() => InputSystemStatePqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputSystemStateToJSON(
  inputSystemState: InputSystemState,
): string {
  return JSON.stringify(
    InputSystemState$outboundSchema.parse(inputSystemState),
  );
}
export function inputSystemStateFromJSON(
  jsonString: string,
): SafeParseResult<InputSystemState, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSystemState$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSystemState' from JSON`,
  );
}
