/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeConnections,
  ItemsTypeConnections$inboundSchema,
  ItemsTypeConnections$Outbound,
  ItemsTypeConnections$outboundSchema,
} from "./itemstypeconnections.js";
import {
  ItemsTypeNotificationMetadata,
  ItemsTypeNotificationMetadata$inboundSchema,
  ItemsTypeNotificationMetadata$Outbound,
  ItemsTypeNotificationMetadata$outboundSchema,
} from "./itemstypenotificationmetadata.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  SignatureVersionOptions2,
  SignatureVersionOptions2$inboundSchema,
  SignatureVersionOptions2$outboundSchema,
} from "./signatureversionoptions2.js";

/**
 * Location at which to start reading a shard for the first time
 */
export const ShardIteratorStart = {
  /**
   * Earliest record
   */
  TrimHorizon: "TRIM_HORIZON",
  /**
   * Latest record
   */
  Latest: "LATEST",
} as const;
/**
 * Location at which to start reading a shard for the first time
 */
export type ShardIteratorStart = OpenEnum<typeof ShardIteratorStart>;

/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export const RecordDataFormat = {
  /**
   * Cribl
   */
  Cribl: "cribl",
  /**
   * Newline JSON
   */
  Ndjson: "ndjson",
  /**
   * Cloudwatch Logs
   */
  Cloudwatch: "cloudwatch",
  /**
   * Event per line
   */
  Line: "line",
} as const;
/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export type RecordDataFormat = OpenEnum<typeof RecordDataFormat>;

/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export const ShardLoadBalancing = {
  /**
   * Consistent Hashing
   */
  ConsistentHashing: "ConsistentHashing",
  /**
   * Round Robin
   */
  RoundRobin: "RoundRobin",
} as const;
/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export type ShardLoadBalancing = OpenEnum<typeof ShardLoadBalancing>;

export type InputKinesis = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: "kinesis";
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnections> | undefined;
  pq?: PqType | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: string | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing Kinesis stream requests
   */
  signatureVersion?: SignatureVersionOptions2 | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

/** @internal */
export const ShardIteratorStart$inboundSchema: z.ZodType<
  ShardIteratorStart,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ShardIteratorStart);
/** @internal */
export const ShardIteratorStart$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ShardIteratorStart
> = openEnums.outboundSchema(ShardIteratorStart);

/** @internal */
export const RecordDataFormat$inboundSchema: z.ZodType<
  RecordDataFormat,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(RecordDataFormat);
/** @internal */
export const RecordDataFormat$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  RecordDataFormat
> = openEnums.outboundSchema(RecordDataFormat);

/** @internal */
export const ShardLoadBalancing$inboundSchema: z.ZodType<
  ShardLoadBalancing,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ShardLoadBalancing);
/** @internal */
export const ShardLoadBalancing$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ShardLoadBalancing
> = openEnums.outboundSchema(ShardLoadBalancing);

/** @internal */
export const InputKinesis$inboundSchema: z.ZodType<
  InputKinesis,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: z.literal("kinesis"),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ItemsTypeConnections$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart$inboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat$inboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing$inboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: z.string().default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions2$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});
/** @internal */
export type InputKinesis$Outbound = {
  id?: string | undefined;
  type: "kinesis";
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnections$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  streamName: string;
  serviceInterval: number;
  shardExpr: string;
  shardIteratorType: string;
  payloadFormat: string;
  getRecordsLimit: number;
  getRecordsLimitTotal: number;
  loadBalancingAlgorithm: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  verifyKPLCheckSums: boolean;
  avoidDuplicates: boolean;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesis$outboundSchema: z.ZodType<
  InputKinesis$Outbound,
  z.ZodTypeDef,
  InputKinesis
> = z.object({
  id: z.string().optional(),
  type: z.literal("kinesis"),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ItemsTypeConnections$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart$outboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat$outboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing$outboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: z.string().default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions2$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

export function inputKinesisToJSON(inputKinesis: InputKinesis): string {
  return JSON.stringify(InputKinesis$outboundSchema.parse(inputKinesis));
}
export function inputKinesisFromJSON(
  jsonString: string,
): SafeParseResult<InputKinesis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesis' from JSON`,
  );
}
