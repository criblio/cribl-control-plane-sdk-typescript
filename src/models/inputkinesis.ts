/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AwsAuthenticationMethodOptions,
  AwsAuthenticationMethodOptions$inboundSchema,
  AwsAuthenticationMethodOptions$outboundSchema,
} from "./awsauthenticationmethodoptions.js";
import {
  ConnectionsType,
  ConnectionsType$inboundSchema,
  ConnectionsType$Outbound,
  ConnectionsType$outboundSchema,
} from "./connectionstype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata1Type,
  Metadata1Type$inboundSchema,
  Metadata1Type$Outbound,
  Metadata1Type$outboundSchema,
} from "./metadata1type.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  SignatureVersionOptions,
  SignatureVersionOptions$inboundSchema,
  SignatureVersionOptions$outboundSchema,
} from "./signatureversionoptions.js";
import {
  TypeKinesisOption,
  TypeKinesisOption$inboundSchema,
  TypeKinesisOption$outboundSchema,
} from "./typekinesisoption.js";

/**
 * Location at which to start reading a shard for the first time
 */
export const ShardIteratorStart7 = {
  /**
   * Earliest record
   */
  TrimHorizon: "TRIM_HORIZON",
  /**
   * Latest record
   */
  Latest: "LATEST",
} as const;
/**
 * Location at which to start reading a shard for the first time
 */
export type ShardIteratorStart7 = OpenEnum<typeof ShardIteratorStart7>;

/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export const RecordDataFormat7 = {
  /**
   * Cribl
   */
  Cribl: "cribl",
  /**
   * Newline JSON
   */
  Ndjson: "ndjson",
  /**
   * Cloudwatch Logs
   */
  Cloudwatch: "cloudwatch",
  /**
   * Event per line
   */
  Line: "line",
} as const;
/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export type RecordDataFormat7 = OpenEnum<typeof RecordDataFormat7>;

/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export const ShardLoadBalancing7 = {
  /**
   * Consistent Hashing
   */
  ConsistentHashing: "ConsistentHashing",
  /**
   * Round Robin
   */
  RoundRobin: "RoundRobin",
} as const;
/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export type ShardLoadBalancing7 = OpenEnum<typeof ShardLoadBalancing7>;

export type InputKinesisKinesis7 = {
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypeKinesisOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart7 | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat7 | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing7 | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret: string;
};

/**
 * Location at which to start reading a shard for the first time
 */
export const ShardIteratorStart6 = {
  /**
   * Earliest record
   */
  TrimHorizon: "TRIM_HORIZON",
  /**
   * Latest record
   */
  Latest: "LATEST",
} as const;
/**
 * Location at which to start reading a shard for the first time
 */
export type ShardIteratorStart6 = OpenEnum<typeof ShardIteratorStart6>;

/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export const RecordDataFormat6 = {
  /**
   * Cribl
   */
  Cribl: "cribl",
  /**
   * Newline JSON
   */
  Ndjson: "ndjson",
  /**
   * Cloudwatch Logs
   */
  Cloudwatch: "cloudwatch",
  /**
   * Event per line
   */
  Line: "line",
} as const;
/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export type RecordDataFormat6 = OpenEnum<typeof RecordDataFormat6>;

/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export const ShardLoadBalancing6 = {
  /**
   * Consistent Hashing
   */
  ConsistentHashing: "ConsistentHashing",
  /**
   * Round Robin
   */
  RoundRobin: "RoundRobin",
} as const;
/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export type ShardLoadBalancing6 = OpenEnum<typeof ShardLoadBalancing6>;

export type InputKinesisKinesis6 = {
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypeKinesisOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart6 | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat6 | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing6 | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  awsApiKey: string;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

/**
 * Location at which to start reading a shard for the first time
 */
export const ShardIteratorStart5 = {
  /**
   * Earliest record
   */
  TrimHorizon: "TRIM_HORIZON",
  /**
   * Latest record
   */
  Latest: "LATEST",
} as const;
/**
 * Location at which to start reading a shard for the first time
 */
export type ShardIteratorStart5 = OpenEnum<typeof ShardIteratorStart5>;

/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export const RecordDataFormat5 = {
  /**
   * Cribl
   */
  Cribl: "cribl",
  /**
   * Newline JSON
   */
  Ndjson: "ndjson",
  /**
   * Cloudwatch Logs
   */
  Cloudwatch: "cloudwatch",
  /**
   * Event per line
   */
  Line: "line",
} as const;
/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export type RecordDataFormat5 = OpenEnum<typeof RecordDataFormat5>;

/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export const ShardLoadBalancing5 = {
  /**
   * Consistent Hashing
   */
  ConsistentHashing: "ConsistentHashing",
  /**
   * Round Robin
   */
  RoundRobin: "RoundRobin",
} as const;
/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export type ShardLoadBalancing5 = OpenEnum<typeof ShardLoadBalancing5>;

export type InputKinesisKinesis5 = {
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypeKinesisOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart5 | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat5 | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing5 | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

/**
 * Location at which to start reading a shard for the first time
 */
export const ShardIteratorStart4 = {
  /**
   * Earliest record
   */
  TrimHorizon: "TRIM_HORIZON",
  /**
   * Latest record
   */
  Latest: "LATEST",
} as const;
/**
 * Location at which to start reading a shard for the first time
 */
export type ShardIteratorStart4 = OpenEnum<typeof ShardIteratorStart4>;

/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export const RecordDataFormat4 = {
  /**
   * Cribl
   */
  Cribl: "cribl",
  /**
   * Newline JSON
   */
  Ndjson: "ndjson",
  /**
   * Cloudwatch Logs
   */
  Cloudwatch: "cloudwatch",
  /**
   * Event per line
   */
  Line: "line",
} as const;
/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export type RecordDataFormat4 = OpenEnum<typeof RecordDataFormat4>;

/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export const ShardLoadBalancing4 = {
  /**
   * Consistent Hashing
   */
  ConsistentHashing: "ConsistentHashing",
  /**
   * Round Robin
   */
  RoundRobin: "RoundRobin",
} as const;
/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export type ShardLoadBalancing4 = OpenEnum<typeof ShardLoadBalancing4>;

export type InputKinesisKinesis4 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypeKinesisOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq: PqType;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart4 | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat4 | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing4 | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

/**
 * Location at which to start reading a shard for the first time
 */
export const ShardIteratorStart3 = {
  /**
   * Earliest record
   */
  TrimHorizon: "TRIM_HORIZON",
  /**
   * Latest record
   */
  Latest: "LATEST",
} as const;
/**
 * Location at which to start reading a shard for the first time
 */
export type ShardIteratorStart3 = OpenEnum<typeof ShardIteratorStart3>;

/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export const RecordDataFormat3 = {
  /**
   * Cribl
   */
  Cribl: "cribl",
  /**
   * Newline JSON
   */
  Ndjson: "ndjson",
  /**
   * Cloudwatch Logs
   */
  Cloudwatch: "cloudwatch",
  /**
   * Event per line
   */
  Line: "line",
} as const;
/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export type RecordDataFormat3 = OpenEnum<typeof RecordDataFormat3>;

/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export const ShardLoadBalancing3 = {
  /**
   * Consistent Hashing
   */
  ConsistentHashing: "ConsistentHashing",
  /**
   * Round Robin
   */
  RoundRobin: "RoundRobin",
} as const;
/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export type ShardLoadBalancing3 = OpenEnum<typeof ShardLoadBalancing3>;

export type InputKinesisKinesis3 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypeKinesisOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart3 | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat3 | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing3 | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

/**
 * Location at which to start reading a shard for the first time
 */
export const ShardIteratorStart2 = {
  /**
   * Earliest record
   */
  TrimHorizon: "TRIM_HORIZON",
  /**
   * Latest record
   */
  Latest: "LATEST",
} as const;
/**
 * Location at which to start reading a shard for the first time
 */
export type ShardIteratorStart2 = OpenEnum<typeof ShardIteratorStart2>;

/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export const RecordDataFormat2 = {
  /**
   * Cribl
   */
  Cribl: "cribl",
  /**
   * Newline JSON
   */
  Ndjson: "ndjson",
  /**
   * Cloudwatch Logs
   */
  Cloudwatch: "cloudwatch",
  /**
   * Event per line
   */
  Line: "line",
} as const;
/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export type RecordDataFormat2 = OpenEnum<typeof RecordDataFormat2>;

/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export const ShardLoadBalancing2 = {
  /**
   * Consistent Hashing
   */
  ConsistentHashing: "ConsistentHashing",
  /**
   * Round Robin
   */
  RoundRobin: "RoundRobin",
} as const;
/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export type ShardLoadBalancing2 = OpenEnum<typeof ShardLoadBalancing2>;

export type InputKinesisKinesis2 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypeKinesisOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections: Array<ConnectionsType>;
  pq?: PqType | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart2 | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat2 | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing2 | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

/**
 * Location at which to start reading a shard for the first time
 */
export const ShardIteratorStart1 = {
  /**
   * Earliest record
   */
  TrimHorizon: "TRIM_HORIZON",
  /**
   * Latest record
   */
  Latest: "LATEST",
} as const;
/**
 * Location at which to start reading a shard for the first time
 */
export type ShardIteratorStart1 = OpenEnum<typeof ShardIteratorStart1>;

/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export const RecordDataFormat1 = {
  /**
   * Cribl
   */
  Cribl: "cribl",
  /**
   * Newline JSON
   */
  Ndjson: "ndjson",
  /**
   * Cloudwatch Logs
   */
  Cloudwatch: "cloudwatch",
  /**
   * Event per line
   */
  Line: "line",
} as const;
/**
 * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
 */
export type RecordDataFormat1 = OpenEnum<typeof RecordDataFormat1>;

/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export const ShardLoadBalancing1 = {
  /**
   * Consistent Hashing
   */
  ConsistentHashing: "ConsistentHashing",
  /**
   * Round Robin
   */
  RoundRobin: "RoundRobin",
} as const;
/**
 * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
 */
export type ShardLoadBalancing1 = OpenEnum<typeof ShardLoadBalancing1>;

export type InputKinesisKinesis1 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: TypeKinesisOption;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Kinesis Data Stream to read data from
   */
  streamName: string;
  /**
   * Time interval in minutes between consecutive service calls
   */
  serviceInterval?: number | undefined;
  /**
   * A JavaScript expression to be called with each shardId for the stream. If the expression evaluates to a truthy value, the shard will be processed.
   */
  shardExpr?: string | undefined;
  /**
   * Location at which to start reading a shard for the first time
   */
  shardIteratorType?: ShardIteratorStart1 | undefined;
  /**
   * Format of data inside the Kinesis Stream records. Gzip compression is automatically detected.
   */
  payloadFormat?: RecordDataFormat1 | undefined;
  /**
   * Maximum number of records per getRecords call
   */
  getRecordsLimit?: number | undefined;
  /**
   * Maximum number of records, across all shards, to pull down at once per Worker Process
   */
  getRecordsLimitTotal?: number | undefined;
  /**
   * The load-balancing algorithm to use for spreading out shards across Workers and Worker Processes
   */
  loadBalancingAlgorithm?: ShardLoadBalancing1 | undefined;
  /**
   * AWS authentication method. Choose Auto to use IAM roles.
   */
  awsAuthenticationMethod?: AwsAuthenticationMethodOptions | undefined;
  awsSecretKey?: string | undefined;
  /**
   * Region where the Kinesis stream is located
   */
  region: string;
  /**
   * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Signature version to use for signing MSK cluster requests
   */
  signatureVersion?: SignatureVersionOptions | undefined;
  /**
   * Reuse connections between requests, which can improve performance
   */
  reuseConnections?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Use Assume Role credentials to access Kinesis stream
   */
  enableAssumeRole?: boolean | undefined;
  /**
   * Amazon Resource Name (ARN) of the role to assume
   */
  assumeRoleArn?: string | undefined;
  /**
   * External ID to use when assuming role
   */
  assumeRoleExternalId?: string | undefined;
  /**
   * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours).
   */
  durationSeconds?: number | undefined;
  /**
   * Verify Kinesis Producer Library (KPL) event checksums
   */
  verifyKPLCheckSums?: boolean | undefined;
  /**
   * When resuming streaming from a stored state, Stream will read the next available record, rather than rereading the last-read record. Enabling this setting can cause data loss after a Worker Node's unexpected shutdown or restart.
   */
  avoidDuplicates?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  /**
   * Select or create a stored secret that references your access key and secret key
   */
  awsSecret?: string | undefined;
};

export type InputKinesis =
  | InputKinesisKinesis2
  | InputKinesisKinesis4
  | InputKinesisKinesis6
  | InputKinesisKinesis7
  | InputKinesisKinesis1
  | InputKinesisKinesis3
  | InputKinesisKinesis5;

/** @internal */
export const ShardIteratorStart7$inboundSchema: z.ZodType<
  ShardIteratorStart7,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardIteratorStart7),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardIteratorStart7$outboundSchema: z.ZodType<
  ShardIteratorStart7,
  z.ZodTypeDef,
  ShardIteratorStart7
> = z.union([
  z.nativeEnum(ShardIteratorStart7),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const RecordDataFormat7$inboundSchema: z.ZodType<
  RecordDataFormat7,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RecordDataFormat7),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const RecordDataFormat7$outboundSchema: z.ZodType<
  RecordDataFormat7,
  z.ZodTypeDef,
  RecordDataFormat7
> = z.union([
  z.nativeEnum(RecordDataFormat7),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const ShardLoadBalancing7$inboundSchema: z.ZodType<
  ShardLoadBalancing7,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardLoadBalancing7),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardLoadBalancing7$outboundSchema: z.ZodType<
  ShardLoadBalancing7,
  z.ZodTypeDef,
  ShardLoadBalancing7
> = z.union([
  z.nativeEnum(ShardLoadBalancing7),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputKinesisKinesis7$inboundSchema: z.ZodType<
  InputKinesisKinesis7,
  z.ZodTypeDef,
  unknown
> = z.object({
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  id: z.string().optional(),
  type: TypeKinesisOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart7$inboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat7$inboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing7$inboundSchema.default(
    "ConsistentHashing",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string(),
});
/** @internal */
export type InputKinesisKinesis7$Outbound = {
  awsAuthenticationMethod: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  streamName: string;
  serviceInterval: number;
  shardExpr: string;
  shardIteratorType: string;
  payloadFormat: string;
  getRecordsLimit: number;
  getRecordsLimitTotal: number;
  loadBalancingAlgorithm: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  verifyKPLCheckSums: boolean;
  avoidDuplicates: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret: string;
};

/** @internal */
export const InputKinesisKinesis7$outboundSchema: z.ZodType<
  InputKinesisKinesis7$Outbound,
  z.ZodTypeDef,
  InputKinesisKinesis7
> = z.object({
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  id: z.string().optional(),
  type: TypeKinesisOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart7$outboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat7$outboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing7$outboundSchema.default(
    "ConsistentHashing",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string(),
});

export function inputKinesisKinesis7ToJSON(
  inputKinesisKinesis7: InputKinesisKinesis7,
): string {
  return JSON.stringify(
    InputKinesisKinesis7$outboundSchema.parse(inputKinesisKinesis7),
  );
}
export function inputKinesisKinesis7FromJSON(
  jsonString: string,
): SafeParseResult<InputKinesisKinesis7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesisKinesis7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesisKinesis7' from JSON`,
  );
}

/** @internal */
export const ShardIteratorStart6$inboundSchema: z.ZodType<
  ShardIteratorStart6,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardIteratorStart6),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardIteratorStart6$outboundSchema: z.ZodType<
  ShardIteratorStart6,
  z.ZodTypeDef,
  ShardIteratorStart6
> = z.union([
  z.nativeEnum(ShardIteratorStart6),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const RecordDataFormat6$inboundSchema: z.ZodType<
  RecordDataFormat6,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RecordDataFormat6),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const RecordDataFormat6$outboundSchema: z.ZodType<
  RecordDataFormat6,
  z.ZodTypeDef,
  RecordDataFormat6
> = z.union([
  z.nativeEnum(RecordDataFormat6),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const ShardLoadBalancing6$inboundSchema: z.ZodType<
  ShardLoadBalancing6,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardLoadBalancing6),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardLoadBalancing6$outboundSchema: z.ZodType<
  ShardLoadBalancing6,
  z.ZodTypeDef,
  ShardLoadBalancing6
> = z.union([
  z.nativeEnum(ShardLoadBalancing6),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputKinesisKinesis6$inboundSchema: z.ZodType<
  InputKinesisKinesis6,
  z.ZodTypeDef,
  unknown
> = z.object({
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  id: z.string().optional(),
  type: TypeKinesisOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart6$inboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat6$inboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing6$inboundSchema.default(
    "ConsistentHashing",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string(),
  awsSecret: z.string().optional(),
});
/** @internal */
export type InputKinesisKinesis6$Outbound = {
  awsAuthenticationMethod: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  streamName: string;
  serviceInterval: number;
  shardExpr: string;
  shardIteratorType: string;
  payloadFormat: string;
  getRecordsLimit: number;
  getRecordsLimitTotal: number;
  loadBalancingAlgorithm: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  verifyKPLCheckSums: boolean;
  avoidDuplicates: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey: string;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesisKinesis6$outboundSchema: z.ZodType<
  InputKinesisKinesis6$Outbound,
  z.ZodTypeDef,
  InputKinesisKinesis6
> = z.object({
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  id: z.string().optional(),
  type: TypeKinesisOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart6$outboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat6$outboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing6$outboundSchema.default(
    "ConsistentHashing",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string(),
  awsSecret: z.string().optional(),
});

export function inputKinesisKinesis6ToJSON(
  inputKinesisKinesis6: InputKinesisKinesis6,
): string {
  return JSON.stringify(
    InputKinesisKinesis6$outboundSchema.parse(inputKinesisKinesis6),
  );
}
export function inputKinesisKinesis6FromJSON(
  jsonString: string,
): SafeParseResult<InputKinesisKinesis6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesisKinesis6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesisKinesis6' from JSON`,
  );
}

/** @internal */
export const ShardIteratorStart5$inboundSchema: z.ZodType<
  ShardIteratorStart5,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardIteratorStart5),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardIteratorStart5$outboundSchema: z.ZodType<
  ShardIteratorStart5,
  z.ZodTypeDef,
  ShardIteratorStart5
> = z.union([
  z.nativeEnum(ShardIteratorStart5),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const RecordDataFormat5$inboundSchema: z.ZodType<
  RecordDataFormat5,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RecordDataFormat5),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const RecordDataFormat5$outboundSchema: z.ZodType<
  RecordDataFormat5,
  z.ZodTypeDef,
  RecordDataFormat5
> = z.union([
  z.nativeEnum(RecordDataFormat5),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const ShardLoadBalancing5$inboundSchema: z.ZodType<
  ShardLoadBalancing5,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardLoadBalancing5),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardLoadBalancing5$outboundSchema: z.ZodType<
  ShardLoadBalancing5,
  z.ZodTypeDef,
  ShardLoadBalancing5
> = z.union([
  z.nativeEnum(ShardLoadBalancing5),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputKinesisKinesis5$inboundSchema: z.ZodType<
  InputKinesisKinesis5,
  z.ZodTypeDef,
  unknown
> = z.object({
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  id: z.string().optional(),
  type: TypeKinesisOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart5$inboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat5$inboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing5$inboundSchema.default(
    "ConsistentHashing",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});
/** @internal */
export type InputKinesisKinesis5$Outbound = {
  awsAuthenticationMethod: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  streamName: string;
  serviceInterval: number;
  shardExpr: string;
  shardIteratorType: string;
  payloadFormat: string;
  getRecordsLimit: number;
  getRecordsLimitTotal: number;
  loadBalancingAlgorithm: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  verifyKPLCheckSums: boolean;
  avoidDuplicates: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesisKinesis5$outboundSchema: z.ZodType<
  InputKinesisKinesis5$Outbound,
  z.ZodTypeDef,
  InputKinesisKinesis5
> = z.object({
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  id: z.string().optional(),
  type: TypeKinesisOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart5$outboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat5$outboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing5$outboundSchema.default(
    "ConsistentHashing",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

export function inputKinesisKinesis5ToJSON(
  inputKinesisKinesis5: InputKinesisKinesis5,
): string {
  return JSON.stringify(
    InputKinesisKinesis5$outboundSchema.parse(inputKinesisKinesis5),
  );
}
export function inputKinesisKinesis5FromJSON(
  jsonString: string,
): SafeParseResult<InputKinesisKinesis5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesisKinesis5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesisKinesis5' from JSON`,
  );
}

/** @internal */
export const ShardIteratorStart4$inboundSchema: z.ZodType<
  ShardIteratorStart4,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardIteratorStart4),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardIteratorStart4$outboundSchema: z.ZodType<
  ShardIteratorStart4,
  z.ZodTypeDef,
  ShardIteratorStart4
> = z.union([
  z.nativeEnum(ShardIteratorStart4),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const RecordDataFormat4$inboundSchema: z.ZodType<
  RecordDataFormat4,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RecordDataFormat4),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const RecordDataFormat4$outboundSchema: z.ZodType<
  RecordDataFormat4,
  z.ZodTypeDef,
  RecordDataFormat4
> = z.union([
  z.nativeEnum(RecordDataFormat4),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const ShardLoadBalancing4$inboundSchema: z.ZodType<
  ShardLoadBalancing4,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardLoadBalancing4),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardLoadBalancing4$outboundSchema: z.ZodType<
  ShardLoadBalancing4,
  z.ZodTypeDef,
  ShardLoadBalancing4
> = z.union([
  z.nativeEnum(ShardLoadBalancing4),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputKinesisKinesis4$inboundSchema: z.ZodType<
  InputKinesisKinesis4,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: TypeKinesisOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema,
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart4$inboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat4$inboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing4$inboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});
/** @internal */
export type InputKinesisKinesis4$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq: PqType$Outbound;
  streamName: string;
  serviceInterval: number;
  shardExpr: string;
  shardIteratorType: string;
  payloadFormat: string;
  getRecordsLimit: number;
  getRecordsLimitTotal: number;
  loadBalancingAlgorithm: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  verifyKPLCheckSums: boolean;
  avoidDuplicates: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesisKinesis4$outboundSchema: z.ZodType<
  InputKinesisKinesis4$Outbound,
  z.ZodTypeDef,
  InputKinesisKinesis4
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: TypeKinesisOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema,
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart4$outboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat4$outboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing4$outboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

export function inputKinesisKinesis4ToJSON(
  inputKinesisKinesis4: InputKinesisKinesis4,
): string {
  return JSON.stringify(
    InputKinesisKinesis4$outboundSchema.parse(inputKinesisKinesis4),
  );
}
export function inputKinesisKinesis4FromJSON(
  jsonString: string,
): SafeParseResult<InputKinesisKinesis4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesisKinesis4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesisKinesis4' from JSON`,
  );
}

/** @internal */
export const ShardIteratorStart3$inboundSchema: z.ZodType<
  ShardIteratorStart3,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardIteratorStart3),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardIteratorStart3$outboundSchema: z.ZodType<
  ShardIteratorStart3,
  z.ZodTypeDef,
  ShardIteratorStart3
> = z.union([
  z.nativeEnum(ShardIteratorStart3),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const RecordDataFormat3$inboundSchema: z.ZodType<
  RecordDataFormat3,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RecordDataFormat3),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const RecordDataFormat3$outboundSchema: z.ZodType<
  RecordDataFormat3,
  z.ZodTypeDef,
  RecordDataFormat3
> = z.union([
  z.nativeEnum(RecordDataFormat3),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const ShardLoadBalancing3$inboundSchema: z.ZodType<
  ShardLoadBalancing3,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardLoadBalancing3),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardLoadBalancing3$outboundSchema: z.ZodType<
  ShardLoadBalancing3,
  z.ZodTypeDef,
  ShardLoadBalancing3
> = z.union([
  z.nativeEnum(ShardLoadBalancing3),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputKinesisKinesis3$inboundSchema: z.ZodType<
  InputKinesisKinesis3,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: TypeKinesisOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart3$inboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat3$inboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing3$inboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});
/** @internal */
export type InputKinesisKinesis3$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  streamName: string;
  serviceInterval: number;
  shardExpr: string;
  shardIteratorType: string;
  payloadFormat: string;
  getRecordsLimit: number;
  getRecordsLimitTotal: number;
  loadBalancingAlgorithm: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  verifyKPLCheckSums: boolean;
  avoidDuplicates: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesisKinesis3$outboundSchema: z.ZodType<
  InputKinesisKinesis3$Outbound,
  z.ZodTypeDef,
  InputKinesisKinesis3
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: TypeKinesisOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart3$outboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat3$outboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing3$outboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

export function inputKinesisKinesis3ToJSON(
  inputKinesisKinesis3: InputKinesisKinesis3,
): string {
  return JSON.stringify(
    InputKinesisKinesis3$outboundSchema.parse(inputKinesisKinesis3),
  );
}
export function inputKinesisKinesis3FromJSON(
  jsonString: string,
): SafeParseResult<InputKinesisKinesis3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesisKinesis3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesisKinesis3' from JSON`,
  );
}

/** @internal */
export const ShardIteratorStart2$inboundSchema: z.ZodType<
  ShardIteratorStart2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardIteratorStart2),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardIteratorStart2$outboundSchema: z.ZodType<
  ShardIteratorStart2,
  z.ZodTypeDef,
  ShardIteratorStart2
> = z.union([
  z.nativeEnum(ShardIteratorStart2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const RecordDataFormat2$inboundSchema: z.ZodType<
  RecordDataFormat2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RecordDataFormat2),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const RecordDataFormat2$outboundSchema: z.ZodType<
  RecordDataFormat2,
  z.ZodTypeDef,
  RecordDataFormat2
> = z.union([
  z.nativeEnum(RecordDataFormat2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const ShardLoadBalancing2$inboundSchema: z.ZodType<
  ShardLoadBalancing2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardLoadBalancing2),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardLoadBalancing2$outboundSchema: z.ZodType<
  ShardLoadBalancing2,
  z.ZodTypeDef,
  ShardLoadBalancing2
> = z.union([
  z.nativeEnum(ShardLoadBalancing2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputKinesisKinesis2$inboundSchema: z.ZodType<
  InputKinesisKinesis2,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: TypeKinesisOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema),
  pq: PqType$inboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart2$inboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat2$inboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing2$inboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});
/** @internal */
export type InputKinesisKinesis2$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections: Array<ConnectionsType$Outbound>;
  pq?: PqType$Outbound | undefined;
  streamName: string;
  serviceInterval: number;
  shardExpr: string;
  shardIteratorType: string;
  payloadFormat: string;
  getRecordsLimit: number;
  getRecordsLimitTotal: number;
  loadBalancingAlgorithm: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  verifyKPLCheckSums: boolean;
  avoidDuplicates: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesisKinesis2$outboundSchema: z.ZodType<
  InputKinesisKinesis2$Outbound,
  z.ZodTypeDef,
  InputKinesisKinesis2
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: TypeKinesisOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema),
  pq: PqType$outboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart2$outboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat2$outboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing2$outboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

export function inputKinesisKinesis2ToJSON(
  inputKinesisKinesis2: InputKinesisKinesis2,
): string {
  return JSON.stringify(
    InputKinesisKinesis2$outboundSchema.parse(inputKinesisKinesis2),
  );
}
export function inputKinesisKinesis2FromJSON(
  jsonString: string,
): SafeParseResult<InputKinesisKinesis2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesisKinesis2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesisKinesis2' from JSON`,
  );
}

/** @internal */
export const ShardIteratorStart1$inboundSchema: z.ZodType<
  ShardIteratorStart1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardIteratorStart1),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardIteratorStart1$outboundSchema: z.ZodType<
  ShardIteratorStart1,
  z.ZodTypeDef,
  ShardIteratorStart1
> = z.union([
  z.nativeEnum(ShardIteratorStart1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const RecordDataFormat1$inboundSchema: z.ZodType<
  RecordDataFormat1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(RecordDataFormat1),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const RecordDataFormat1$outboundSchema: z.ZodType<
  RecordDataFormat1,
  z.ZodTypeDef,
  RecordDataFormat1
> = z.union([
  z.nativeEnum(RecordDataFormat1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const ShardLoadBalancing1$inboundSchema: z.ZodType<
  ShardLoadBalancing1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ShardLoadBalancing1),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ShardLoadBalancing1$outboundSchema: z.ZodType<
  ShardLoadBalancing1,
  z.ZodTypeDef,
  ShardLoadBalancing1
> = z.union([
  z.nativeEnum(ShardLoadBalancing1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputKinesisKinesis1$inboundSchema: z.ZodType<
  InputKinesisKinesis1,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: TypeKinesisOption$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart1$inboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat1$inboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing1$inboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$inboundSchema.default(
    "auto",
  ),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$inboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});
/** @internal */
export type InputKinesisKinesis1$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  streamName: string;
  serviceInterval: number;
  shardExpr: string;
  shardIteratorType: string;
  payloadFormat: string;
  getRecordsLimit: number;
  getRecordsLimitTotal: number;
  loadBalancingAlgorithm: string;
  awsAuthenticationMethod: string;
  awsSecretKey?: string | undefined;
  region: string;
  endpoint?: string | undefined;
  signatureVersion: string;
  reuseConnections: boolean;
  rejectUnauthorized: boolean;
  enableAssumeRole: boolean;
  assumeRoleArn?: string | undefined;
  assumeRoleExternalId?: string | undefined;
  durationSeconds: number;
  verifyKPLCheckSums: boolean;
  avoidDuplicates: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  awsApiKey?: string | undefined;
  awsSecret?: string | undefined;
};

/** @internal */
export const InputKinesisKinesis1$outboundSchema: z.ZodType<
  InputKinesisKinesis1$Outbound,
  z.ZodTypeDef,
  InputKinesisKinesis1
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: TypeKinesisOption$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  streamName: z.string(),
  serviceInterval: z.number().default(1),
  shardExpr: z.string().default("true"),
  shardIteratorType: ShardIteratorStart1$outboundSchema.default("TRIM_HORIZON"),
  payloadFormat: RecordDataFormat1$outboundSchema.default("cribl"),
  getRecordsLimit: z.number().default(5000),
  getRecordsLimitTotal: z.number().default(20000),
  loadBalancingAlgorithm: ShardLoadBalancing1$outboundSchema.default(
    "ConsistentHashing",
  ),
  awsAuthenticationMethod: AwsAuthenticationMethodOptions$outboundSchema
    .default("auto"),
  awsSecretKey: z.string().optional(),
  region: z.string(),
  endpoint: z.string().optional(),
  signatureVersion: SignatureVersionOptions$outboundSchema.default("v4"),
  reuseConnections: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(true),
  enableAssumeRole: z.boolean().default(false),
  assumeRoleArn: z.string().optional(),
  assumeRoleExternalId: z.string().optional(),
  durationSeconds: z.number().default(3600),
  verifyKPLCheckSums: z.boolean().default(false),
  avoidDuplicates: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  awsApiKey: z.string().optional(),
  awsSecret: z.string().optional(),
});

export function inputKinesisKinesis1ToJSON(
  inputKinesisKinesis1: InputKinesisKinesis1,
): string {
  return JSON.stringify(
    InputKinesisKinesis1$outboundSchema.parse(inputKinesisKinesis1),
  );
}
export function inputKinesisKinesis1FromJSON(
  jsonString: string,
): SafeParseResult<InputKinesisKinesis1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesisKinesis1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesisKinesis1' from JSON`,
  );
}

/** @internal */
export const InputKinesis$inboundSchema: z.ZodType<
  InputKinesis,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputKinesisKinesis2$inboundSchema),
  z.lazy(() => InputKinesisKinesis4$inboundSchema),
  z.lazy(() => InputKinesisKinesis6$inboundSchema),
  z.lazy(() => InputKinesisKinesis7$inboundSchema),
  z.lazy(() => InputKinesisKinesis1$inboundSchema),
  z.lazy(() => InputKinesisKinesis3$inboundSchema),
  z.lazy(() => InputKinesisKinesis5$inboundSchema),
]);
/** @internal */
export type InputKinesis$Outbound =
  | InputKinesisKinesis2$Outbound
  | InputKinesisKinesis4$Outbound
  | InputKinesisKinesis6$Outbound
  | InputKinesisKinesis7$Outbound
  | InputKinesisKinesis1$Outbound
  | InputKinesisKinesis3$Outbound
  | InputKinesisKinesis5$Outbound;

/** @internal */
export const InputKinesis$outboundSchema: z.ZodType<
  InputKinesis$Outbound,
  z.ZodTypeDef,
  InputKinesis
> = z.union([
  z.lazy(() => InputKinesisKinesis2$outboundSchema),
  z.lazy(() => InputKinesisKinesis4$outboundSchema),
  z.lazy(() => InputKinesisKinesis6$outboundSchema),
  z.lazy(() => InputKinesisKinesis7$outboundSchema),
  z.lazy(() => InputKinesisKinesis1$outboundSchema),
  z.lazy(() => InputKinesisKinesis3$outboundSchema),
  z.lazy(() => InputKinesisKinesis5$outboundSchema),
]);

export function inputKinesisToJSON(inputKinesis: InputKinesis): string {
  return JSON.stringify(InputKinesis$outboundSchema.parse(inputKinesis));
}
export function inputKinesisFromJSON(
  jsonString: string,
): SafeParseResult<InputKinesis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputKinesis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputKinesis' from JSON`,
  );
}
