/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Enter credentials directly, or select a stored secret
 */
export const SaslTypeAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
} as const;
/**
 * Enter credentials directly, or select a stored secret
 */
export type SaslTypeAuthenticationMethod = OpenEnum<
  typeof SaslTypeAuthenticationMethod
>;

export const SASLTypeSASLMechanism = {
  /**
   * PLAIN
   */
  Plain: "plain",
  /**
   * SCRAM-SHA-256
   */
  ScramSha256: "scram-sha-256",
  /**
   * SCRAM-SHA-512
   */
  ScramSha512: "scram-sha-512",
  /**
   * GSSAPI/Kerberos
   */
  Kerberos: "kerberos",
} as const;
export type SASLTypeSASLMechanism = OpenEnum<typeof SASLTypeSASLMechanism>;

export type SaslTypeOauthParam = {
  name: string;
  value: string;
};

export type SaslExtension = {
  name: string;
  value: string;
};

/**
 * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
 */
export type SaslType = {
  disabled?: boolean | undefined;
  username?: string | undefined;
  password?: string | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: SaslTypeAuthenticationMethod | undefined;
  /**
   * Select or create a secret that references your credentials
   */
  credentialsSecret?: string | undefined;
  mechanism?: SASLTypeSASLMechanism | undefined;
  /**
   * Location of keytab file for authentication principal
   */
  keytabLocation?: string | undefined;
  /**
   * Authentication principal, such as `kafka_user@example.com`
   */
  principal?: string | undefined;
  /**
   * Kerberos service class for Kafka brokers, such as `kafka`
   */
  brokerServiceClass?: string | undefined;
  /**
   * Enable OAuth authentication
   */
  oauthEnabled?: boolean | undefined;
  /**
   * URL of the token endpoint to use for OAuth authentication
   */
  tokenUrl?: string | undefined;
  /**
   * Client ID to use for OAuth authentication
   */
  clientId?: string | undefined;
  oauthSecretType?: string | undefined;
  /**
   * Select or create a stored text secret
   */
  clientTextSecret?: string | undefined;
  /**
   * Additional fields to send to the token endpoint, such as scope or audience
   */
  oauthParams?: Array<SaslTypeOauthParam> | undefined;
  /**
   * Additional SASL extension fields, such as Confluent's logicalCluster or identityPoolId
   */
  saslExtensions?: Array<SaslExtension> | undefined;
};

/** @internal */
export const SaslTypeAuthenticationMethod$inboundSchema: z.ZodType<
  SaslTypeAuthenticationMethod,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SaslTypeAuthenticationMethod),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const SaslTypeAuthenticationMethod$outboundSchema: z.ZodType<
  SaslTypeAuthenticationMethod,
  z.ZodTypeDef,
  SaslTypeAuthenticationMethod
> = z.union([
  z.nativeEnum(SaslTypeAuthenticationMethod),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const SASLTypeSASLMechanism$inboundSchema: z.ZodType<
  SASLTypeSASLMechanism,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(SASLTypeSASLMechanism),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const SASLTypeSASLMechanism$outboundSchema: z.ZodType<
  SASLTypeSASLMechanism,
  z.ZodTypeDef,
  SASLTypeSASLMechanism
> = z.union([
  z.nativeEnum(SASLTypeSASLMechanism),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const SaslTypeOauthParam$inboundSchema: z.ZodType<
  SaslTypeOauthParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type SaslTypeOauthParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SaslTypeOauthParam$outboundSchema: z.ZodType<
  SaslTypeOauthParam$Outbound,
  z.ZodTypeDef,
  SaslTypeOauthParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function saslTypeOauthParamToJSON(
  saslTypeOauthParam: SaslTypeOauthParam,
): string {
  return JSON.stringify(
    SaslTypeOauthParam$outboundSchema.parse(saslTypeOauthParam),
  );
}
export function saslTypeOauthParamFromJSON(
  jsonString: string,
): SafeParseResult<SaslTypeOauthParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SaslTypeOauthParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SaslTypeOauthParam' from JSON`,
  );
}

/** @internal */
export const SaslExtension$inboundSchema: z.ZodType<
  SaslExtension,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type SaslExtension$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SaslExtension$outboundSchema: z.ZodType<
  SaslExtension$Outbound,
  z.ZodTypeDef,
  SaslExtension
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function saslExtensionToJSON(saslExtension: SaslExtension): string {
  return JSON.stringify(SaslExtension$outboundSchema.parse(saslExtension));
}
export function saslExtensionFromJSON(
  jsonString: string,
): SafeParseResult<SaslExtension, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SaslExtension$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SaslExtension' from JSON`,
  );
}

/** @internal */
export const SaslType$inboundSchema: z.ZodType<
  SaslType,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  username: z.string().optional(),
  password: z.string().optional(),
  authType: SaslTypeAuthenticationMethod$inboundSchema.default("manual"),
  credentialsSecret: z.string().optional(),
  mechanism: SASLTypeSASLMechanism$inboundSchema.default("plain"),
  keytabLocation: z.string().optional(),
  principal: z.string().optional(),
  brokerServiceClass: z.string().optional(),
  oauthEnabled: z.boolean().default(false),
  tokenUrl: z.string().optional(),
  clientId: z.string().optional(),
  oauthSecretType: z.string().default("secret"),
  clientTextSecret: z.string().optional(),
  oauthParams: z.array(z.lazy(() => SaslTypeOauthParam$inboundSchema))
    .optional(),
  saslExtensions: z.array(z.lazy(() => SaslExtension$inboundSchema)).optional(),
});
/** @internal */
export type SaslType$Outbound = {
  disabled: boolean;
  username?: string | undefined;
  password?: string | undefined;
  authType: string;
  credentialsSecret?: string | undefined;
  mechanism: string;
  keytabLocation?: string | undefined;
  principal?: string | undefined;
  brokerServiceClass?: string | undefined;
  oauthEnabled: boolean;
  tokenUrl?: string | undefined;
  clientId?: string | undefined;
  oauthSecretType: string;
  clientTextSecret?: string | undefined;
  oauthParams?: Array<SaslTypeOauthParam$Outbound> | undefined;
  saslExtensions?: Array<SaslExtension$Outbound> | undefined;
};

/** @internal */
export const SaslType$outboundSchema: z.ZodType<
  SaslType$Outbound,
  z.ZodTypeDef,
  SaslType
> = z.object({
  disabled: z.boolean().default(true),
  username: z.string().optional(),
  password: z.string().optional(),
  authType: SaslTypeAuthenticationMethod$outboundSchema.default("manual"),
  credentialsSecret: z.string().optional(),
  mechanism: SASLTypeSASLMechanism$outboundSchema.default("plain"),
  keytabLocation: z.string().optional(),
  principal: z.string().optional(),
  brokerServiceClass: z.string().optional(),
  oauthEnabled: z.boolean().default(false),
  tokenUrl: z.string().optional(),
  clientId: z.string().optional(),
  oauthSecretType: z.string().default("secret"),
  clientTextSecret: z.string().optional(),
  oauthParams: z.array(z.lazy(() => SaslTypeOauthParam$outboundSchema))
    .optional(),
  saslExtensions: z.array(z.lazy(() => SaslExtension$outboundSchema))
    .optional(),
});

export function saslTypeToJSON(saslType: SaslType): string {
  return JSON.stringify(SaslType$outboundSchema.parse(saslType));
}
export function saslTypeFromJSON(
  jsonString: string,
): SafeParseResult<SaslType, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SaslType$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SaslType' from JSON`,
  );
}
