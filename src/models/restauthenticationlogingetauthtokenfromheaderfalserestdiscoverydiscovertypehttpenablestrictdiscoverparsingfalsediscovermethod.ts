/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeRestCollectMethodGetCollectRequestParams,
  ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema,
  ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound,
  ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
} from "./itemstyperestcollectmethodgetcollectrequestparams.js";
import {
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$inboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$outboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$inboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$Outbound,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$outboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound,
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema,
} from "./restauthenticationloginsecretgetauthtokenfromheadertruerestpaginationtyperesponsebody.js";

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone =
  {
    type: "none";
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between a failed request and the first retry
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
     */
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between a failed request and the first retry
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
     */
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone =
  {
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: "none";
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
      & { type: "backoff" }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking =
  {
    /**
     * Track collection progress between consecutive scheduled executions
     */
    enabled?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking
      | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue = {
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication;
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling
    | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication =
  {
    None: "none",
    Basic: "basic",
    BasicSecret: "basicSecret",
    Login: "login",
    LoginSecret: "loginSecret",
    Oauth: "oauth",
    OauthSecret: "oauthSecret",
    GoogleOauth: "google_oauth",
    GoogleOauthSecret: "google_oauthSecret",
    Hmac: "hmac",
  } as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "none";
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "list";
    /**
     * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
     */
    itemList: Array<string>;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "json";
    /**
     * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
     */
    manualDiscoverResult: string;
    /**
     * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
     */
    discoverDataField?: string | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    /**
     * Custom HTTP method to use for the Discover operation
     */
    discoverVerb: string;
    /**
     * Template for body to send with the discover request
     */
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    /**
     * Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`
     */
    discoverBody: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * If 'Strict discover response parsing' parsing is enabled, provide the response format
     */
    discoverResponseFormat: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery =
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod =
  OpenEnum<
    typeof RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod
  >;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage =
  {
    type: "request_page";
    /**
     * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    pageField: string;
    /**
     * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
     */
    page?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    sizeField: string;
    /**
     * Maximum number of records to collect per page
     */
    size: number;
    /**
     * Name of the attribute in the response that contains the total number of pages for the query
     */
    totalPageField?: string | undefined;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset =
  {
    type: "request_offset";
    /**
     * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    offsetField: string;
    /**
     * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
     */
    offset?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    limitField: string;
    /**
     * Maximum number of records to collect per request
     */
    limit: number;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader =
  {
    type: "response_header";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody =
  {
    type: "response_body";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
     */
    lastPageExpr?: string | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone =
  {
    type: "none";
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between a failed request and the first retry
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
     */
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between a failed request and the first retry
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
     */
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone =
  {
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: "none";
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue
      & { type: "backoff" }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking =
  {
    /**
     * Track collection progress between consecutive scheduled executions
     */
    enabled?: boolean | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking
      | undefined;
  };

export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse = {
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Path to token attribute in login response body. Nested attributes are OK. Leave blank if the response content type is text/plain; the entire response body will be used to derive the authorization header.
   */
  tokenRespAttribute?: string | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication;
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  /**
   * Select or create a stored secret that references your login credentials
   */
  credentialsSecret: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling
    | undefined;
};

export type RestAuthenticationLoginSecret =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue;

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication = {
  None: "none",
  Basic: "basic",
  BasicSecret: "basicSecret",
  Login: "login",
  LoginSecret: "loginSecret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  GoogleOauth: "google_oauth",
  GoogleOauthSecret: "google_oauthSecret",
  Hmac: "hmac",
} as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "none";
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "list";
    /**
     * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
     */
    itemList: Array<string>;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "json";
    /**
     * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
     */
    manualDiscoverResult: string;
    /**
     * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
     */
    discoverDataField?: string | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    /**
     * Custom HTTP method to use for the Discover operation
     */
    discoverVerb: string;
    /**
     * Template for body to send with the discover request
     */
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    /**
     * Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`
     */
    discoverBody: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * If 'Strict discover response parsing' parsing is enabled, provide the response format
     */
    discoverResponseFormat: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  | discriminatedUnionTypes.Unknown<"discoverMethod">;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery =
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
    | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
      discoverType: "http";
    }
  )
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone
  | discriminatedUnionTypes.Unknown<"discoverType">;

export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod = {
  /**
   * GET
   */
  Get: "get",
  /**
   * POST
   */
  Post: "post",
  /**
   * POST with Body
   */
  PostWithBody: "post_with_body",
  /**
   * Other
   */
  Other: "other",
} as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage =
  {
    type: "request_page";
    /**
     * Query string parameter that sets the page index to be returned. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    pageField: string;
    /**
     * Page number from which to start request. Defaults to undefined, which will start collection from the first page.
     */
    page?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&page_size=100&page_number=0
     */
    sizeField: string;
    /**
     * Maximum number of records to collect per page
     */
    size: number;
    /**
     * Name of the attribute in the response that contains the total number of pages for the query
     */
    totalPageField?: string | undefined;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset =
  {
    type: "request_offset";
    /**
     * Query string parameter that sets the index from which to begin returning records. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    offsetField: string;
    /**
     * Offset index from which to start request. Defaults to undefined, which will start collection from the first record.
     */
    offset?: number | undefined;
    /**
     * Query string parameter that sets the number of records retrieved per request. Example: /api/v1/query?term=cribl&limit=100&offset=0
     */
    limitField: string;
    /**
     * Maximum number of records to collect per request
     */
    limit: number;
    /**
     * Name of the attribute in the response that contains the total number of records for the query
     */
    totalRecordField?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * Enable to indicate that the first page in the requested data is at index 0. Disabled by default, which indicates index 1.
     */
    zeroIndexed: boolean;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink =
  {
    type: "response_header_link";
    /**
     * Relation name used in the link header that refers to the next page in the result set. Example: rel="next" refers to the next page of results: <https://myHost/nextPage>; rel="next"
     */
    nextRelationAttribute: string;
    /**
     * Relation name used in the link header that refers to the current result set. Example: rel="self" refers to the current page of results: <https://myHost/curPage>; rel="self"
     */
    curRelationAttribute?: string | undefined;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader =
  {
    type: "response_header";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody =
  {
    type: "response_body";
    /**
     * Names of attributes within the response that contain next-page information
     */
    attribute: Array<string>;
    /**
     * Maximum number of pages to retrieve per collection task. Defaults to 50 pages. Set to 0 to retrieve all pages.
     */
    maxPages: number;
    /**
     * JavaScript expression used to determine when the last page has been reached. The values tested by this expression must be in the Response attributes section.
     */
    lastPageExpr?: string | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone =
  {
    type: "none";
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between a failed request and the first retry
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
     */
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between a failed request and the first retry
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * Base for exponential backoff. Example: base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on.
     */
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse =
  {
    /**
     * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to the `Longest interval between retries (ms)` value, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
     */
    enableHeader?: boolean | undefined;
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: string;
    /**
     * Time interval between retries. Maximum allowed value is 20,000 ms (1/3 minute).
     */
    interval?: number | undefined;
    /**
     * Maximum number of times to retry a failed HTTP request
     */
    limit?: number | undefined;
    /**
     * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503.
     */
    codes?: Array<number> | undefined;
    /**
     * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
     */
    retryConnectTimeout?: boolean | undefined;
    /**
     * Retry request when a connection reset (ECONNRESET) error occurs
     */
    retryConnectReset?: boolean | undefined;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone =
  {
    /**
     * The algorithm to use when performing HTTP retries
     */
    type: "none";
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
      & { type: "backoff" }
  )
  | discriminatedUnionTypes.Unknown<"type">;

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking = {
  /**
   * Track collection progress between consecutive scheduled executions
   */
  enabled?: boolean | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling = {
  stateTracking?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking
    | undefined;
};

export type RestAuthenticationLoginGetAuthTokenFromHeaderTrue = {
  /**
   * Extract the auth token from the HTTP 'Authorization' response header instead of the standard JSON body of the login response
   */
  getAuthTokenFromHeader?: boolean | undefined;
  /**
   * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
   */
  authentication:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication;
  /**
   * URL to use for login API call. This call is expected to be a POST.
   */
  loginUrl: string;
  username: string;
  password: string;
  /**
   * Template for POST body to send with login request. ${username} and ${password} are used to specify location of these attributes in the message.
   */
  loginBody: string;
  /**
   * Authorization header key to pass in Discover and Collect calls. Defaults to the literal name 'Authorization'.
   */
  authHeaderKey?: string | undefined;
  /**
   * JavaScript expression used to compute the Authorization header to pass in Discover and Collect calls. The value ${token} is used to reference the token obtained from login.
   */
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
      | discriminatedUnionTypes.Unknown<"discoverMethod"> & {
        discoverType: "http";
      }
    )
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone
    | discriminatedUnionTypes.Unknown<"discoverType">
    | undefined;
  /**
   * URL (constant or JavaScript expression) to use for the Collect operation
   */
  collectUrl: string;
  collectMethod: RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
    | undefined;
  pagination?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 to disable.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable Collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Decode the URL before sending requests (including pagination requests)
   */
  decodeUrl?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Enable to add response headers to the resHeaders field under the __collectible object
   */
  captureHeaders?: boolean | undefined;
  /**
   * Stop pagination when the Event Breaker produces no events
   */
  stopOnEmptyResults?: boolean | undefined;
  /**
   * List of headers that are safe to log in plain text
   */
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
        & { type: "backoff" }
    )
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling
    | undefined;
};

/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication =
  {
    None: "none",
    Basic: "basic",
    BasicSecret: "basicSecret",
    Login: "login",
    LoginSecret: "loginSecret",
    Oauth: "oauth",
    OauthSecret: "oauthSecret",
    GoogleOauth: "google_oauth",
    GoogleOauthSecret: "google_oauthSecret",
    Hmac: "hmac",
  } as const;
/**
 * Authentication method for Discover and Collect REST calls. You can specify API key–based authentication by adding the appropriate Collect headers.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "none";
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "list";
    /**
     * Comma-separated list of items to return from the Discover task. Each item returned generates a Collect task and can be referenced using `${id}` in the Collect URL, headers, or parameters.
     */
    itemList: Array<string>;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson =
  {
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType: "json";
    /**
     * Allows hard-coding the Discover result. Must be a JSON object or array. Works with Discover data field.
     */
    manualDiscoverResult: string;
    /**
     * Within the response JSON, the name of the field to pull results from, typically a JSON array. Leave blank if the result itself is an array of values. Sample entry: items, json: { items: [{id: 'first'},{id: 'second'}] }
     */
    discoverDataField?: string | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther =
  {
    discoverMethod: "other";
    /**
     * Custom HTTP method to use for the Discover operation
     */
    discoverVerb: string;
    /**
     * Template for body to send with the discover request
     */
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody =
  {
    discoverMethod: "post_with_body";
    /**
     * Template for POST body to send with the discover request. To reference global variables or functions, use template parameters: `{ myVar: ${C.vars.myVar}, secret: ${C.Secret('mySecret','text').value} }`
     */
    discoverBody: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Custom JavaScript code to format the discover result through the __e variable which is a JSON object or array containing the original discover results. The object or array passed should be manipulated to contain the desired discover results, i.e.: __e['myResult'] = [{lat: -1.1234, long: 2.345, zip: 11111},{lat: -1.235, long 2.346, zip: 22222}] or ['11111','22222']. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
     */
    formatResultCode?: string | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse =
  {
    enableDiscoverCode?: boolean | undefined;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  >;

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination =
  {
    type: string;
  };

export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue =
  {
    /**
     * Explicitly set the discover response format. When disabled, best effort parsing is used.
     */
    enableStrictDiscoverParsing?: boolean | undefined;
    /**
     * If 'Strict discover response parsing' parsing is enabled, provide the response format
     */
    discoverResponseFormat: string;
    /**
     * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
     */
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType;
    /**
     * URL to use for the Discover operation. Can be a constant URL, or a JavaScript expression to derive the URL.
     */
    discoverUrl: string;
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
      | undefined;
    /**
     * Path to field in the response object that contains discovery results (ex: level1.name). Leave blank if the result is an array.
     */
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  {
    Http: "http",
    Json: "json",
    List: "list",
    None: "none",
  } as const;
/**
 * Defines how task discovery will be performed. Each entry returned by the Discover operation will result in a Collect task.
 */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  >;

export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  {
    /**
     * GET
     */
    Get: "get",
    /**
     * POST
     */
    Post: "post",
    /**
     * POST with Body
     */
    PostWithBody: "post_with_body",
    /**
     * Other
     */
    Other: "other",
  } as const;
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod =
  OpenEnum<
    typeof RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  >;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
    ),
    response_body:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema,
    response_header:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema,
    response_header_link:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema,
    request_offset:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema,
    request_page:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema,
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
    ),
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema,
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnionToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTruePaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRulesToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$Outbound =
  {
    enabled?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTrackingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$Outbound =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueSchedulingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    getAuthTokenFromHeader: types.optional(types.boolean()),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$inboundSchema,
    loginUrl: types.string(),
    credentialsSecret: types.string(),
    loginBody: types.string(),
    authHeaderKey: types.optional(types.string()),
    authHeaderExpr: types.string(),
    authRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discovery: types.optional(
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$inboundSchema,
    ),
    collectUrl: types.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema,
    collectRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
      ),
      response_body:
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema,
      response_header:
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema,
      response_header_link:
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema,
      request_offset:
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema,
      request_page:
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema,
    })),
    timeout: types.optional(types.number()),
    useRoundRobinDns: types.optional(types.boolean()),
    disableTimeFilter: types.optional(types.boolean()),
    decodeUrl: types.optional(types.boolean()),
    rejectUnauthorized: types.optional(types.boolean()),
    captureHeaders: types.optional(types.boolean()),
    stopOnEmptyResults: types.optional(types.boolean()),
    safeHeaders: types.optional(z.array(types.string())),
    retryRules: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
      ),
      static: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      backoff: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    })),
    __scheduling: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$Outbound = {
  getAuthTokenFromHeader?: boolean | undefined;
  authentication: string;
  loginUrl: string;
  credentialsSecret: string;
  loginBody: string;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueAuthentication$outboundSchema,
    loginUrl: z.string(),
    credentialsSecret: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discovery:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueDiscovery$outboundSchema
        .optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema,
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
      ),
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema,
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema,
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema,
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema,
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema,
    ]).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
      ),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    ]).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrueScheduling$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderTrue),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.string(),
    discoverBody: types.optional(types.string()),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb: string;
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.string(),
    discoverBody: z.string().optional(),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.string(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody: string;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.string(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.string(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat: string;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.string(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$Outbound =
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery
  > = z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoveryToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod,
  );
/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod,
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPageToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBodyToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnionToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalsePaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNoneToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]);

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRulesToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$Outbound =
  {
    enabled?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTrackingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$Outbound =
  {
    stateTracking?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseSchedulingToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$outboundSchema
      .parse(
        restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
      ),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    getAuthTokenFromHeader: types.optional(types.boolean()),
    tokenRespAttribute: types.optional(types.string()),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$inboundSchema,
    loginUrl: types.string(),
    credentialsSecret: types.string(),
    loginBody: types.string(),
    authHeaderKey: types.optional(types.string()),
    authHeaderExpr: types.string(),
    authRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discovery: types.optional(discriminatedUnion("discoverType", {
      http: discriminatedUnion("discoverMethod", {
        get: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        ),
        post: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        ),
        post_with_body: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        ),
        other: z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        ),
      }).and(z.object({ discoverType: z.literal("http") })),
      json: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema
      ),
      list: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema
      ),
      none: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema
      ),
    })),
    collectUrl: types.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$inboundSchema,
    collectRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$inboundSchema
      ),
      response_body: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$inboundSchema
      ),
      response_header: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$inboundSchema
      ),
      response_header_link: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$inboundSchema
      ),
      request_offset: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$inboundSchema
      ),
      request_page: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$inboundSchema
      ),
    })),
    timeout: types.optional(types.number()),
    useRoundRobinDns: types.optional(types.boolean()),
    disableTimeFilter: types.optional(types.boolean()),
    decodeUrl: types.optional(types.boolean()),
    rejectUnauthorized: types.optional(types.boolean()),
    captureHeaders: types.optional(types.boolean()),
    stopOnEmptyResults: types.optional(types.boolean()),
    safeHeaders: types.optional(z.array(types.string())),
    retryRules: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$inboundSchema
      ),
      static: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      backoff: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    })),
    __scheduling: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$Outbound =
  {
    getAuthTokenFromHeader?: boolean | undefined;
    tokenRespAttribute?: string | undefined;
    authentication: string;
    loginUrl: string;
    credentialsSecret: string;
    loginBody: string;
    authHeaderKey?: string | undefined;
    authHeaderExpr: string;
    authRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discovery?:
      | (
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
          & { discoverType: "http" }
      )
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound
      | undefined;
    collectUrl: string;
    collectMethod: string;
    collectRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$Outbound
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$Outbound
      | undefined;
    timeout?: number | undefined;
    useRoundRobinDns?: boolean | undefined;
    disableTimeFilter?: boolean | undefined;
    decodeUrl?: boolean | undefined;
    rejectUnauthorized?: boolean | undefined;
    captureHeaders?: boolean | undefined;
    stopOnEmptyResults?: boolean | undefined;
    safeHeaders?: Array<string> | undefined;
    retryRules?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$Outbound
      | (
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
          & { type: "static" }
      )
      | (
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
        | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
          & { type: "backoff" }
      )
      | undefined;
    __scheduling?:
      | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    tokenRespAttribute: z.string().optional(),
    authentication:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseAuthentication$outboundSchema,
    loginUrl: z.string(),
    credentialsSecret: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discovery: z.union([
      z.union([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
        ),
      ]).and(z.object({ discoverType: z.literal("http") })),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema
      ),
    ]).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseCollectMethod$outboundSchema,
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeNone$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeader$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeResponseHeaderLink$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestOffset$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestPaginationTypeRequestPage$outboundSchema
      ),
    ]).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.union([
      z.lazy(() =>
        RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeNone$outboundSchema
      ),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    ]).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalseScheduling$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseToJSON(
  restAuthenticationLoginSecretGetAuthTokenFromHeaderFalse:
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$outboundSchema
      .parse(restAuthenticationLoginSecretGetAuthTokenFromHeaderFalse),
  );
}
export function restAuthenticationLoginSecretGetAuthTokenFromHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginSecret$inboundSchema: z.ZodType<
  RestAuthenticationLoginSecret,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$inboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$inboundSchema
  ),
]);
/** @internal */
export type RestAuthenticationLoginSecret$Outbound =
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$Outbound
  | RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginSecret$outboundSchema: z.ZodType<
  RestAuthenticationLoginSecret$Outbound,
  z.ZodTypeDef,
  RestAuthenticationLoginSecret
> = smartUnion([
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderFalse$outboundSchema
  ),
  z.lazy(() =>
    RestAuthenticationLoginSecretGetAuthTokenFromHeaderTrue$outboundSchema
  ),
]);

export function restAuthenticationLoginSecretToJSON(
  restAuthenticationLoginSecret: RestAuthenticationLoginSecret,
): string {
  return JSON.stringify(
    RestAuthenticationLoginSecret$outboundSchema.parse(
      restAuthenticationLoginSecret,
    ),
  );
}
export function restAuthenticationLoginSecretFromJSON(
  jsonString: string,
): SafeParseResult<RestAuthenticationLoginSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RestAuthenticationLoginSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginSecret' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.string(),
    discoverBody: types.optional(types.string()),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb: string;
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.string(),
    discoverBody: z.string().optional(),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.string(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody: string;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.string(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.string(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat: string;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.string(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverMethod", {
    get: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
    ),
    post: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
    ),
    post_with_body: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
    ),
    other: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttp' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("discoverType", {
    http: discriminatedUnion("discoverMethod", {
      get: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
      ),
      post: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
      ),
      post_with_body: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
      ),
      other: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
      ),
    }).and(z.object({ discoverType: z.literal("http") })),
    json: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema
    ),
    list: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema
    ),
    none: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$Outbound =
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
      & { discoverType: "http" }
  )
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery
  > = z.union([
    z.union([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      ),
    ]).and(z.object({ discoverType: z.literal("http") })),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoveryToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueDiscoveryFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueDiscovery' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_page"),
    pageField: types.string(),
    page: types.optional(types.number()),
    sizeField: types.string(),
    size: types.number(),
    totalPageField: types.optional(types.string()),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound =
  {
    type: "request_page";
    pageField: string;
    page?: number | undefined;
    sizeField: string;
    size: number;
    totalPageField?: string | undefined;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage
  > = z.object({
    type: z.literal("request_page"),
    pageField: z.string(),
    page: z.number().optional(),
    sizeField: z.string(),
    size: z.number(),
    totalPageField: z.string().optional(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPageToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPageFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("request_offset"),
    offsetField: types.string(),
    offset: types.optional(types.number()),
    limitField: types.string(),
    limit: types.number(),
    totalRecordField: types.optional(types.string()),
    maxPages: types.number(),
    zeroIndexed: types.boolean(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound =
  {
    type: "request_offset";
    offsetField: string;
    offset?: number | undefined;
    limitField: string;
    limit: number;
    totalRecordField?: string | undefined;
    maxPages: number;
    zeroIndexed: boolean;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset
  > = z.object({
    type: z.literal("request_offset"),
    offsetField: z.string(),
    offset: z.number().optional(),
    limitField: z.string(),
    limit: z.number(),
    totalRecordField: z.string().optional(),
    maxPages: z.number(),
    zeroIndexed: z.boolean(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffsetToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffsetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header_link"),
    nextRelationAttribute: types.string(),
    curRelationAttribute: types.optional(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound =
  {
    type: "response_header_link";
    nextRelationAttribute: string;
    curRelationAttribute?: string | undefined;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink
  > = z.object({
    type: z.literal("response_header_link"),
    nextRelationAttribute: z.string(),
    curRelationAttribute: z.string().optional(),
    maxPages: z.number(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLinkToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_header"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound =
  {
    type: "response_header";
    attribute: Array<string>;
    maxPages: number;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader
  > = z.object({
    type: z.literal("response_header"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("response_body"),
    attribute: z.array(types.string()),
    maxPages: types.number(),
    lastPageExpr: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound =
  {
    type: "response_body";
    attribute: Array<string>;
    maxPages: number;
    lastPageExpr?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody
  > = z.object({
    type: z.literal("response_body"),
    attribute: z.array(z.string()),
    maxPages: z.number(),
    lastPageExpr: z.string().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBodyToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNoneToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
    ),
    response_body: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema
    ),
    response_header: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema
    ),
    response_header_link: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema
    ),
    request_offset: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema
    ),
    request_page: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnionToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion:
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnionFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTruePaginationUnion' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    multiplier: types.optional(types.number()),
    maxIntervalMs: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    multiplier?: number | undefined;
    maxIntervalMs?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    multiplier: z.number().optional(),
    maxIntervalMs: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    retryHeaderName: types.optional(types.string()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound =
  {
    enableHeader?: boolean | undefined;
    retryHeaderName?: string | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue
  > = z.object({
    enableHeader: z.boolean().optional(),
    retryHeaderName: z.string().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableHeader: types.optional(types.boolean()),
    type: types.string(),
    interval: types.optional(types.number()),
    limit: types.optional(types.number()),
    codes: types.optional(z.array(types.number())),
    retryConnectTimeout: types.optional(types.boolean()),
    retryConnectReset: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound =
  {
    enableHeader?: boolean | undefined;
    type: string;
    interval?: number | undefined;
    limit?: number | undefined;
    codes?: Array<number> | undefined;
    retryConnectTimeout?: boolean | undefined;
    retryConnectReset?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse
  > = z.object({
    enableHeader: z.boolean().optional(),
    type: z.string(),
    interval: z.number().optional(),
    limit: z.number().optional(),
    codes: z.array(z.number()).optional(),
    retryConnectTimeout: z.boolean().optional(),
    retryConnectReset: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
    ),
  ]);
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound;

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic
  > = smartUnion([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
    ),
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
    ),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound =
  {
    type: "none";
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNoneToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules,
    z.ZodTypeDef,
    unknown
  > = discriminatedUnion("type", {
    none: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
    ),
    static: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    backoff: smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$Outbound =
  | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
      & { type: "static" }
  )
  | (
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
      & { type: "backoff" }
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules
  > = z.union([
    z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
    ),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("static") })),
    smartUnion([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
      ),
    ]).and(z.object({ type: z.literal("backoff") })),
  ]);

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRulesToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueRetryRules' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$Outbound =
  {
    enabled?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTrackingToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueStateTrackingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling,
    z.ZodTypeDef,
    unknown
  > = z.object({
    stateTracking: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$Outbound =
  {
    stateTracking?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$Outbound
      | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling
  > = z.object({
    stateTracking: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueStateTracking$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueSchedulingToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$outboundSchema
      .parse(restAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueSchedulingFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    getAuthTokenFromHeader: types.optional(types.boolean()),
    authentication:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$inboundSchema,
    loginUrl: types.string(),
    username: types.string(),
    password: types.string(),
    loginBody: types.string(),
    authHeaderKey: types.optional(types.string()),
    authHeaderExpr: types.string(),
    authRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discovery: types.optional(discriminatedUnion("discoverType", {
      http: discriminatedUnion("discoverMethod", {
        get: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        ),
        post: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        ),
        post_with_body: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        ),
        other: z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        ),
      }).and(z.object({ discoverType: z.literal("http") })),
      json: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$inboundSchema
      ),
      list: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$inboundSchema
      ),
      none: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$inboundSchema
      ),
    })),
    collectUrl: types.string(),
    collectMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$inboundSchema,
    collectRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$inboundSchema
      ),
      response_body: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$inboundSchema
      ),
      response_header: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$inboundSchema
      ),
      response_header_link: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$inboundSchema
      ),
      request_offset: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$inboundSchema
      ),
      request_page: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$inboundSchema
      ),
    })),
    timeout: types.optional(types.number()),
    useRoundRobinDns: types.optional(types.boolean()),
    disableTimeFilter: types.optional(types.boolean()),
    decodeUrl: types.optional(types.boolean()),
    rejectUnauthorized: types.optional(types.boolean()),
    captureHeaders: types.optional(types.boolean()),
    stopOnEmptyResults: types.optional(types.boolean()),
    safeHeaders: types.optional(z.array(types.string())),
    retryRules: types.optional(discriminatedUnion("type", {
      none: z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$inboundSchema
      ),
      static: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      backoff: smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$inboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$inboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    })),
    __scheduling: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$inboundSchema
      ),
    ),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderTrue$Outbound = {
  getAuthTokenFromHeader?: boolean | undefined;
  authentication: string;
  loginUrl: string;
  username: string;
  password: string;
  loginBody: string;
  authHeaderKey?: string | undefined;
  authHeaderExpr: string;
  authRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  discovery?:
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound
        & { discoverType: "http" }
    )
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$Outbound
    | undefined;
  collectUrl: string;
  collectMethod: string;
  collectRequestHeaders?:
    | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
    | undefined;
  pagination?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$Outbound
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$Outbound
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  decodeUrl?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  captureHeaders?: boolean | undefined;
  stopOnEmptyResults?: boolean | undefined;
  safeHeaders?: Array<string> | undefined;
  retryRules?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$Outbound
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$Outbound
        & { type: "static" }
    )
    | (
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$Outbound
      | RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$Outbound
        & { type: "backoff" }
    )
    | undefined;
  __scheduling?:
    | RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$Outbound
    | undefined;
};

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue
  > = z.object({
    getAuthTokenFromHeader: z.boolean().optional(),
    authentication:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueAuthentication$outboundSchema,
    loginUrl: z.string(),
    username: z.string(),
    password: z.string(),
    loginBody: z.string(),
    authHeaderKey: z.string().optional(),
    authHeaderExpr: z.string(),
    authRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discovery: z.union([
      z.union([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
        ),
      ]).and(z.object({ discoverType: z.literal("http") })),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeJson$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeList$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestDiscoveryDiscoverTypeNone$outboundSchema
      ),
    ]).optional(),
    collectUrl: z.string(),
    collectMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueCollectMethod$outboundSchema,
    collectRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.union([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeNone$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseBody$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeader$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeResponseHeaderLink$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestOffset$outboundSchema
      ),
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestPaginationTypeRequestPage$outboundSchema
      ),
    ]).optional(),
    timeout: z.number().optional(),
    useRoundRobinDns: z.boolean().optional(),
    disableTimeFilter: z.boolean().optional(),
    decodeUrl: z.boolean().optional(),
    rejectUnauthorized: z.boolean().optional(),
    captureHeaders: z.boolean().optional(),
    stopOnEmptyResults: z.boolean().optional(),
    safeHeaders: z.array(z.string()).optional(),
    retryRules: z.union([
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeNone$outboundSchema
      ),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeStaticEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("static") })),
      smartUnion([
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderFalse$outboundSchema
        ),
        z.lazy(() =>
          RestAuthenticationLoginGetAuthTokenFromHeaderTrueRestRetryRulesTypeBackoffEnableHeaderTrue$outboundSchema
        ),
      ]).and(z.object({ type: z.literal("backoff") })),
    ]).optional(),
    __scheduling: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrueScheduling$outboundSchema
    ).optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderTrue$outboundSchema.parse(
      restAuthenticationLoginGetAuthTokenFromHeaderTrue,
    ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderTrue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseAuthentication,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("none"),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound =
  {
    discoverType: "none";
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone
  > = z.object({
    discoverType: z.literal("none"),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeNone' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("list"),
    itemList: z.array(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound =
  {
    discoverType: "list";
    itemList: Array<string>;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList
  > = z.object({
    discoverType: z.literal("list"),
    itemList: z.array(z.string()),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeListFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeList' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverType: types.literal("json"),
    manualDiscoverResult: types.string(),
    discoverDataField: types.optional(types.string()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound =
  {
    discoverType: "json";
    manualDiscoverResult: string;
    discoverDataField?: string | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson
  > = z.object({
    discoverType: z.literal("json"),
    manualDiscoverResult: z.string(),
    discoverDataField: z.string().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJsonToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeJson' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("other"),
    discoverVerb: types.string(),
    discoverBody: types.optional(types.string()),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound =
  {
    discoverMethod: "other";
    discoverVerb: string;
    discoverBody?: string | undefined;
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther
  > = z.object({
    discoverMethod: z.literal("other"),
    discoverVerb: z.string(),
    discoverBody: z.string().optional(),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOtherFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodOther' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post_with_body"),
    discoverBody: types.string(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound =
  {
    discoverMethod: "post_with_body";
    discoverBody: string;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody
  > = z.object({
    discoverMethod: z.literal("post_with_body"),
    discoverBody: z.string(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostWithBody' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("post"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound =
  {
    discoverMethod: "post";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost
  > = z.object({
    discoverMethod: z.literal("post"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPostFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodPost' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
    z.ZodTypeDef,
    unknown
  > = z.object({
    discoverMethod: types.literal("get"),
    discoverRequestParams: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound =
  {
    discoverMethod: "get";
    discoverRequestParams?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet
  > = z.object({
    discoverMethod: z.literal("get"),
    discoverRequestParams: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetPagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGetFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpDiscoverMethodGet' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    formatResultCode: types.optional(types.string()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    formatResultCode?: string | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    formatResultCode: z.string().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableDiscoverCode: types.optional(types.boolean()),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableStrictDiscoverParsing: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound =
  {
    enableDiscoverCode?: boolean | undefined;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableStrictDiscoverParsing?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse
  > = z.object({
    enableDiscoverCode: z.boolean().optional(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalsePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableStrictDiscoverParsing: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableDiscoverCodeFalse' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound =
  {
    type: string;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination
  > = z.object({
    type: z.string(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePaginationFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enableStrictDiscoverParsing: types.optional(types.boolean()),
    discoverResponseFormat: types.string(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$inboundSchema,
    discoverUrl: types.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$inboundSchema,
    discoverRequestHeaders: types.optional(
      z.array(ItemsTypeRestCollectMethodGetCollectRequestParams$inboundSchema),
    ),
    pagination: types.optional(
      z.lazy(() =>
        RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$inboundSchema
      ),
    ),
    discoverDataField: types.optional(types.string()),
    enableDiscoverCode: types.optional(types.boolean()),
  });
/** @internal */
export type RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound =
  {
    enableStrictDiscoverParsing?: boolean | undefined;
    discoverResponseFormat: string;
    discoverType: string;
    discoverUrl: string;
    discoverMethod: string;
    discoverRequestHeaders?:
      | Array<ItemsTypeRestCollectMethodGetCollectRequestParams$Outbound>
      | undefined;
    pagination?:
      | RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$Outbound
      | undefined;
    discoverDataField?: string | undefined;
    enableDiscoverCode?: boolean | undefined;
  };

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$Outbound,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue
  > = z.object({
    enableStrictDiscoverParsing: z.boolean().optional(),
    discoverResponseFormat: z.string(),
    discoverType:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverType$outboundSchema,
    discoverUrl: z.string(),
    discoverMethod:
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueDiscoverMethod$outboundSchema,
    discoverRequestHeaders: z.array(
      ItemsTypeRestCollectMethodGetCollectRequestParams$outboundSchema,
    ).optional(),
    pagination: z.lazy(() =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTruePagination$outboundSchema
    ).optional(),
    discoverDataField: z.string().optional(),
    enableDiscoverCode: z.boolean().optional(),
  });

export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueToJSON(
  restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue:
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
): string {
  return JSON.stringify(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$outboundSchema
      .parse(
        restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
      ),
  );
}
export function restAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingTrue' from JSON`,
  );
}

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverType,
  );

/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$inboundSchema:
  z.ZodType<
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
/** @internal */
export const RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod
  > = openEnums.outboundSchema(
    RestAuthenticationLoginGetAuthTokenFromHeaderFalseRestDiscoveryDiscoverTypeHttpEnableStrictDiscoverParsingFalseDiscoverMethod,
  );
