/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const InputOffice365MsgTraceType = {
  Office365MsgTrace: "office365_msg_trace",
} as const;
export type InputOffice365MsgTraceType = OpenEnum<
  typeof InputOffice365MsgTraceType
>;

export type InputOffice365MsgTraceConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputOffice365MsgTraceMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputOffice365MsgTraceMode = OpenEnum<
  typeof InputOffice365MsgTraceMode
>;

/**
 * Codec to use to compress the persisted data
 */
export const InputOffice365MsgTraceCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputOffice365MsgTraceCompression = OpenEnum<
  typeof InputOffice365MsgTraceCompression
>;

export type InputOffice365MsgTracePq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputOffice365MsgTraceMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputOffice365MsgTraceCompression | undefined;
};

/**
 * Select authentication method.
 */
export const InputOffice365MsgTraceAuthenticationMethod = {
  Manual: "manual",
  Secret: "secret",
  Oauth: "oauth",
  OauthSecret: "oauthSecret",
  OauthCert: "oauthCert",
} as const;
/**
 * Select authentication method.
 */
export type InputOffice365MsgTraceAuthenticationMethod = OpenEnum<
  typeof InputOffice365MsgTraceAuthenticationMethod
>;

/**
 * Log Level (verbosity) for collection runtime behavior.
 */
export const InputOffice365MsgTraceLogLevel = {
  Error: "error",
  Warn: "warn",
  Info: "info",
  Debug: "debug",
  Silly: "silly",
} as const;
/**
 * Log Level (verbosity) for collection runtime behavior.
 */
export type InputOffice365MsgTraceLogLevel = OpenEnum<
  typeof InputOffice365MsgTraceLogLevel
>;

export type InputOffice365MsgTraceMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

/**
 * The algorithm to use when performing HTTP retries
 */
export const InputOffice365MsgTraceRetryType = {
  None: "none",
  Backoff: "backoff",
  Static: "static",
} as const;
/**
 * The algorithm to use when performing HTTP retries
 */
export type InputOffice365MsgTraceRetryType = OpenEnum<
  typeof InputOffice365MsgTraceRetryType
>;

export type InputOffice365MsgTraceRetryRules = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type?: InputOffice365MsgTraceRetryType | undefined;
  /**
   * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute).
   */
  interval?: number | undefined;
  /**
   * The maximum number of times to retry a failed HTTP request
   */
  limit?: number | undefined;
  /**
   * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on
   */
  multiplier?: number | undefined;
  /**
   * List of http codes that trigger a retry. Leave empty to use the default list of 429, 500, and 503.
   */
  codes?: Array<number> | undefined;
  /**
   * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored.
   */
  enableHeader?: boolean | undefined;
  /**
   * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs
   */
  retryConnectTimeout?: boolean | undefined;
  /**
   * Retry request when a connection reset (ECONNRESET) error occurs
   */
  retryConnectReset?: boolean | undefined;
};

/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export const InputOffice365MsgTraceSubscriptionPlan = {
  EnterpriseGcc: "enterprise_gcc",
  Gcc: "gcc",
  GccHigh: "gcc_high",
  Dod: "dod",
} as const;
/**
 * Office 365 subscription plan for your organization, typically Office 365 Enterprise
 */
export type InputOffice365MsgTraceSubscriptionPlan = OpenEnum<
  typeof InputOffice365MsgTraceSubscriptionPlan
>;

export type CertOptions = {
  /**
   * The name of the predefined certificate.
   */
  certificateName?: string | undefined;
  /**
   * Path to the private key to use. Key should be in PEM format. Can reference $ENV_VARS.
   */
  privKeyPath: string;
  /**
   * Passphrase to use to decrypt the private key.
   */
  passphrase?: string | undefined;
  /**
   * Path to the certificate to use. Certificate should be in PEM format. Can reference $ENV_VARS.
   */
  certPath: string;
};

export type InputOffice365MsgTrace = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputOffice365MsgTraceType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputOffice365MsgTraceConnection> | undefined;
  pq?: InputOffice365MsgTracePq | undefined;
  /**
   * URL to use when retrieving report data.
   */
  url?: string | undefined;
  /**
   * How often (in minutes) to run the report. Must divide evenly into 60 minutes to create a predictable schedule, or Save will fail.
   */
  interval?: number | undefined;
  /**
   * Backward offset for the search range's head. (E.g.: -3h@h) Message Trace data is delayed; this parameter (with Date range end) compensates for delay and gaps.
   */
  startDate?: string | undefined;
  /**
   * Backward offset for the search range's tail. (E.g.: -2h@h) Message Trace data is delayed; this parameter (with Date range start) compensates for delay and gaps.
   */
  endDate?: string | undefined;
  /**
   * HTTP request inactivity timeout. Maximum is 2400 (40 minutes); enter 0 to wait indefinitely.
   */
  timeout?: number | undefined;
  /**
   * Disables time filtering of events when a date range is specified.
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Select authentication method.
   */
  authType?: InputOffice365MsgTraceAuthenticationMethod | undefined;
  /**
   * Reschedule tasks that failed with non-fatal errors
   */
  rescheduleDroppedTasks?: boolean | undefined;
  /**
   * Maximum number of times a task can be rescheduled
   */
  maxTaskReschedule?: number | undefined;
  /**
   * Log Level (verbosity) for collection runtime behavior.
   */
  logLevel?: InputOffice365MsgTraceLogLevel | undefined;
  /**
   * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time.
   */
  jobTimeout?: string | undefined;
  /**
   * How often workers should check in with the scheduler to keep job subscription alive
   */
  keepAliveTime?: number | undefined;
  /**
   * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked.
   */
  maxMissedKeepAlives?: number | undefined;
  /**
   * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector.
   */
  ttl?: string | undefined;
  /**
   * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live.
   */
  ignoreGroupJobsLimit?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputOffice365MsgTraceMetadatum> | undefined;
  retryRules?: InputOffice365MsgTraceRetryRules | undefined;
  description?: string | undefined;
  /**
   * Username to run Message Trace API call.
   */
  username?: string | undefined;
  /**
   * Password to run Message Trace API call.
   */
  password?: string | undefined;
  /**
   * Select or create a secret that references your credentials.
   */
  credentialsSecret?: string | undefined;
  /**
   * client_secret to pass in the OAuth request parameter.
   */
  clientSecret?: string | undefined;
  /**
   * Directory ID (tenant identifier) in Azure Active Directory.
   */
  tenantId?: string | undefined;
  /**
   * client_id to pass in the OAuth request parameter.
   */
  clientId?: string | undefined;
  /**
   * Resource to pass in the OAuth request parameter.
   */
  resource?: string | undefined;
  /**
   * Office 365 subscription plan for your organization, typically Office 365 Enterprise
   */
  planType?: InputOffice365MsgTraceSubscriptionPlan | undefined;
  /**
   * Select or create a secret that references your client_secret to pass in the OAuth request parameter.
   */
  textSecret?: string | undefined;
  certOptions?: CertOptions | undefined;
};

/** @internal */
export const InputOffice365MsgTraceType$inboundSchema: z.ZodType<
  InputOffice365MsgTraceType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceType$outboundSchema: z.ZodType<
  InputOffice365MsgTraceType,
  z.ZodTypeDef,
  InputOffice365MsgTraceType
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceType$ {
  /** @deprecated use `InputOffice365MsgTraceType$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceType$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceType$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceType$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTraceConnection$inboundSchema: z.ZodType<
  InputOffice365MsgTraceConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputOffice365MsgTraceConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputOffice365MsgTraceConnection$outboundSchema: z.ZodType<
  InputOffice365MsgTraceConnection$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTraceConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceConnection$ {
  /** @deprecated use `InputOffice365MsgTraceConnection$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceConnection$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceConnection$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceConnection$outboundSchema;
  /** @deprecated use `InputOffice365MsgTraceConnection$Outbound` instead. */
  export type Outbound = InputOffice365MsgTraceConnection$Outbound;
}

export function inputOffice365MsgTraceConnectionToJSON(
  inputOffice365MsgTraceConnection: InputOffice365MsgTraceConnection,
): string {
  return JSON.stringify(
    InputOffice365MsgTraceConnection$outboundSchema.parse(
      inputOffice365MsgTraceConnection,
    ),
  );
}

export function inputOffice365MsgTraceConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MsgTraceConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MsgTraceConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MsgTraceConnection' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTraceMode$inboundSchema: z.ZodType<
  InputOffice365MsgTraceMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceMode$outboundSchema: z.ZodType<
  InputOffice365MsgTraceMode,
  z.ZodTypeDef,
  InputOffice365MsgTraceMode
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceMode$ {
  /** @deprecated use `InputOffice365MsgTraceMode$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceMode$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceMode$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceMode$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTraceCompression$inboundSchema: z.ZodType<
  InputOffice365MsgTraceCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceCompression$outboundSchema: z.ZodType<
  InputOffice365MsgTraceCompression,
  z.ZodTypeDef,
  InputOffice365MsgTraceCompression
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceCompression$ {
  /** @deprecated use `InputOffice365MsgTraceCompression$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceCompression$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceCompression$outboundSchema` instead. */
  export const outboundSchema =
    InputOffice365MsgTraceCompression$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTracePq$inboundSchema: z.ZodType<
  InputOffice365MsgTracePq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputOffice365MsgTraceMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputOffice365MsgTraceCompression$inboundSchema.default("none"),
});

/** @internal */
export type InputOffice365MsgTracePq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
};

/** @internal */
export const InputOffice365MsgTracePq$outboundSchema: z.ZodType<
  InputOffice365MsgTracePq$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTracePq
> = z.object({
  mode: InputOffice365MsgTraceMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputOffice365MsgTraceCompression$outboundSchema.default("none"),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTracePq$ {
  /** @deprecated use `InputOffice365MsgTracePq$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTracePq$inboundSchema;
  /** @deprecated use `InputOffice365MsgTracePq$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTracePq$outboundSchema;
  /** @deprecated use `InputOffice365MsgTracePq$Outbound` instead. */
  export type Outbound = InputOffice365MsgTracePq$Outbound;
}

export function inputOffice365MsgTracePqToJSON(
  inputOffice365MsgTracePq: InputOffice365MsgTracePq,
): string {
  return JSON.stringify(
    InputOffice365MsgTracePq$outboundSchema.parse(inputOffice365MsgTracePq),
  );
}

export function inputOffice365MsgTracePqFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MsgTracePq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MsgTracePq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MsgTracePq' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTraceAuthenticationMethod$inboundSchema:
  z.ZodType<InputOffice365MsgTraceAuthenticationMethod, z.ZodTypeDef, unknown> =
    z
      .union([
        z.nativeEnum(InputOffice365MsgTraceAuthenticationMethod),
        z.string().transform(catchUnrecognizedEnum),
      ]);

/** @internal */
export const InputOffice365MsgTraceAuthenticationMethod$outboundSchema:
  z.ZodType<
    InputOffice365MsgTraceAuthenticationMethod,
    z.ZodTypeDef,
    InputOffice365MsgTraceAuthenticationMethod
  > = z.union([
    z.nativeEnum(InputOffice365MsgTraceAuthenticationMethod),
    z.string().and(z.custom<Unrecognized<string>>()),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceAuthenticationMethod$ {
  /** @deprecated use `InputOffice365MsgTraceAuthenticationMethod$inboundSchema` instead. */
  export const inboundSchema =
    InputOffice365MsgTraceAuthenticationMethod$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceAuthenticationMethod$outboundSchema` instead. */
  export const outboundSchema =
    InputOffice365MsgTraceAuthenticationMethod$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTraceLogLevel$inboundSchema: z.ZodType<
  InputOffice365MsgTraceLogLevel,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceLogLevel),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceLogLevel$outboundSchema: z.ZodType<
  InputOffice365MsgTraceLogLevel,
  z.ZodTypeDef,
  InputOffice365MsgTraceLogLevel
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceLogLevel),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceLogLevel$ {
  /** @deprecated use `InputOffice365MsgTraceLogLevel$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceLogLevel$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceLogLevel$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceLogLevel$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTraceMetadatum$inboundSchema: z.ZodType<
  InputOffice365MsgTraceMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputOffice365MsgTraceMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputOffice365MsgTraceMetadatum$outboundSchema: z.ZodType<
  InputOffice365MsgTraceMetadatum$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTraceMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceMetadatum$ {
  /** @deprecated use `InputOffice365MsgTraceMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceMetadatum$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceMetadatum$outboundSchema;
  /** @deprecated use `InputOffice365MsgTraceMetadatum$Outbound` instead. */
  export type Outbound = InputOffice365MsgTraceMetadatum$Outbound;
}

export function inputOffice365MsgTraceMetadatumToJSON(
  inputOffice365MsgTraceMetadatum: InputOffice365MsgTraceMetadatum,
): string {
  return JSON.stringify(
    InputOffice365MsgTraceMetadatum$outboundSchema.parse(
      inputOffice365MsgTraceMetadatum,
    ),
  );
}

export function inputOffice365MsgTraceMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MsgTraceMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MsgTraceMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MsgTraceMetadatum' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTraceRetryType$inboundSchema: z.ZodType<
  InputOffice365MsgTraceRetryType,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceRetryType),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceRetryType$outboundSchema: z.ZodType<
  InputOffice365MsgTraceRetryType,
  z.ZodTypeDef,
  InputOffice365MsgTraceRetryType
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceRetryType),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceRetryType$ {
  /** @deprecated use `InputOffice365MsgTraceRetryType$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceRetryType$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceRetryType$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceRetryType$outboundSchema;
}

/** @internal */
export const InputOffice365MsgTraceRetryRules$inboundSchema: z.ZodType<
  InputOffice365MsgTraceRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InputOffice365MsgTraceRetryType$inboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/** @internal */
export type InputOffice365MsgTraceRetryRules$Outbound = {
  type: string;
  interval: number;
  limit: number;
  multiplier: number;
  codes?: Array<number> | undefined;
  enableHeader: boolean;
  retryConnectTimeout: boolean;
  retryConnectReset: boolean;
};

/** @internal */
export const InputOffice365MsgTraceRetryRules$outboundSchema: z.ZodType<
  InputOffice365MsgTraceRetryRules$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTraceRetryRules
> = z.object({
  type: InputOffice365MsgTraceRetryType$outboundSchema.default("backoff"),
  interval: z.number().default(1000),
  limit: z.number().default(5),
  multiplier: z.number().default(2),
  codes: z.array(z.number()).optional(),
  enableHeader: z.boolean().default(true),
  retryConnectTimeout: z.boolean().default(false),
  retryConnectReset: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceRetryRules$ {
  /** @deprecated use `InputOffice365MsgTraceRetryRules$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTraceRetryRules$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceRetryRules$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTraceRetryRules$outboundSchema;
  /** @deprecated use `InputOffice365MsgTraceRetryRules$Outbound` instead. */
  export type Outbound = InputOffice365MsgTraceRetryRules$Outbound;
}

export function inputOffice365MsgTraceRetryRulesToJSON(
  inputOffice365MsgTraceRetryRules: InputOffice365MsgTraceRetryRules,
): string {
  return JSON.stringify(
    InputOffice365MsgTraceRetryRules$outboundSchema.parse(
      inputOffice365MsgTraceRetryRules,
    ),
  );
}

export function inputOffice365MsgTraceRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MsgTraceRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MsgTraceRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MsgTraceRetryRules' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTraceSubscriptionPlan$inboundSchema: z.ZodType<
  InputOffice365MsgTraceSubscriptionPlan,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputOffice365MsgTraceSubscriptionPlan),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputOffice365MsgTraceSubscriptionPlan$outboundSchema: z.ZodType<
  InputOffice365MsgTraceSubscriptionPlan,
  z.ZodTypeDef,
  InputOffice365MsgTraceSubscriptionPlan
> = z.union([
  z.nativeEnum(InputOffice365MsgTraceSubscriptionPlan),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTraceSubscriptionPlan$ {
  /** @deprecated use `InputOffice365MsgTraceSubscriptionPlan$inboundSchema` instead. */
  export const inboundSchema =
    InputOffice365MsgTraceSubscriptionPlan$inboundSchema;
  /** @deprecated use `InputOffice365MsgTraceSubscriptionPlan$outboundSchema` instead. */
  export const outboundSchema =
    InputOffice365MsgTraceSubscriptionPlan$outboundSchema;
}

/** @internal */
export const CertOptions$inboundSchema: z.ZodType<
  CertOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
});

/** @internal */
export type CertOptions$Outbound = {
  certificateName?: string | undefined;
  privKeyPath: string;
  passphrase?: string | undefined;
  certPath: string;
};

/** @internal */
export const CertOptions$outboundSchema: z.ZodType<
  CertOptions$Outbound,
  z.ZodTypeDef,
  CertOptions
> = z.object({
  certificateName: z.string().optional(),
  privKeyPath: z.string(),
  passphrase: z.string().optional(),
  certPath: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CertOptions$ {
  /** @deprecated use `CertOptions$inboundSchema` instead. */
  export const inboundSchema = CertOptions$inboundSchema;
  /** @deprecated use `CertOptions$outboundSchema` instead. */
  export const outboundSchema = CertOptions$outboundSchema;
  /** @deprecated use `CertOptions$Outbound` instead. */
  export type Outbound = CertOptions$Outbound;
}

export function certOptionsToJSON(certOptions: CertOptions): string {
  return JSON.stringify(CertOptions$outboundSchema.parse(certOptions));
}

export function certOptionsFromJSON(
  jsonString: string,
): SafeParseResult<CertOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CertOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CertOptions' from JSON`,
  );
}

/** @internal */
export const InputOffice365MsgTrace$inboundSchema: z.ZodType<
  InputOffice365MsgTrace,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: InputOffice365MsgTraceType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputOffice365MsgTraceConnection$inboundSchema),
  ).optional(),
  pq: z.lazy(() => InputOffice365MsgTracePq$inboundSchema).optional(),
  url: z.string().default(
    "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace",
  ),
  interval: z.number().default(60),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  timeout: z.number().default(300),
  disableTimeFilter: z.boolean().default(true),
  authType: InputOffice365MsgTraceAuthenticationMethod$inboundSchema.default(
    "oauth",
  ),
  rescheduleDroppedTasks: z.boolean().default(true),
  maxTaskReschedule: z.number().default(1),
  logLevel: InputOffice365MsgTraceLogLevel$inboundSchema.default("info"),
  jobTimeout: z.string().default("0"),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(z.lazy(() => InputOffice365MsgTraceMetadatum$inboundSchema))
    .optional(),
  retryRules: z.lazy(() => InputOffice365MsgTraceRetryRules$inboundSchema)
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  clientSecret: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  resource: z.string().default("https://outlook.office365.com"),
  planType: InputOffice365MsgTraceSubscriptionPlan$inboundSchema.default(
    "enterprise_gcc",
  ),
  textSecret: z.string().optional(),
  certOptions: z.lazy(() => CertOptions$inboundSchema).optional(),
});

/** @internal */
export type InputOffice365MsgTrace$Outbound = {
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputOffice365MsgTraceConnection$Outbound> | undefined;
  pq?: InputOffice365MsgTracePq$Outbound | undefined;
  url: string;
  interval: number;
  startDate?: string | undefined;
  endDate?: string | undefined;
  timeout: number;
  disableTimeFilter: boolean;
  authType: string;
  rescheduleDroppedTasks: boolean;
  maxTaskReschedule: number;
  logLevel: string;
  jobTimeout: string;
  keepAliveTime: number;
  maxMissedKeepAlives: number;
  ttl: string;
  ignoreGroupJobsLimit: boolean;
  metadata?: Array<InputOffice365MsgTraceMetadatum$Outbound> | undefined;
  retryRules?: InputOffice365MsgTraceRetryRules$Outbound | undefined;
  description?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  credentialsSecret?: string | undefined;
  clientSecret?: string | undefined;
  tenantId?: string | undefined;
  clientId?: string | undefined;
  resource: string;
  planType: string;
  textSecret?: string | undefined;
  certOptions?: CertOptions$Outbound | undefined;
};

/** @internal */
export const InputOffice365MsgTrace$outboundSchema: z.ZodType<
  InputOffice365MsgTrace$Outbound,
  z.ZodTypeDef,
  InputOffice365MsgTrace
> = z.object({
  id: z.string().optional(),
  type: InputOffice365MsgTraceType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputOffice365MsgTraceConnection$outboundSchema),
  ).optional(),
  pq: z.lazy(() => InputOffice365MsgTracePq$outboundSchema).optional(),
  url: z.string().default(
    "https://reports.office365.com/ecp/reportingwebservice/reporting.svc/MessageTrace",
  ),
  interval: z.number().default(60),
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  timeout: z.number().default(300),
  disableTimeFilter: z.boolean().default(true),
  authType: InputOffice365MsgTraceAuthenticationMethod$outboundSchema.default(
    "oauth",
  ),
  rescheduleDroppedTasks: z.boolean().default(true),
  maxTaskReschedule: z.number().default(1),
  logLevel: InputOffice365MsgTraceLogLevel$outboundSchema.default("info"),
  jobTimeout: z.string().default("0"),
  keepAliveTime: z.number().default(30),
  maxMissedKeepAlives: z.number().default(3),
  ttl: z.string().default("4h"),
  ignoreGroupJobsLimit: z.boolean().default(false),
  metadata: z.array(
    z.lazy(() => InputOffice365MsgTraceMetadatum$outboundSchema),
  ).optional(),
  retryRules: z.lazy(() => InputOffice365MsgTraceRetryRules$outboundSchema)
    .optional(),
  description: z.string().optional(),
  username: z.string().optional(),
  password: z.string().optional(),
  credentialsSecret: z.string().optional(),
  clientSecret: z.string().optional(),
  tenantId: z.string().optional(),
  clientId: z.string().optional(),
  resource: z.string().default("https://outlook.office365.com"),
  planType: InputOffice365MsgTraceSubscriptionPlan$outboundSchema.default(
    "enterprise_gcc",
  ),
  textSecret: z.string().optional(),
  certOptions: z.lazy(() => CertOptions$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputOffice365MsgTrace$ {
  /** @deprecated use `InputOffice365MsgTrace$inboundSchema` instead. */
  export const inboundSchema = InputOffice365MsgTrace$inboundSchema;
  /** @deprecated use `InputOffice365MsgTrace$outboundSchema` instead. */
  export const outboundSchema = InputOffice365MsgTrace$outboundSchema;
  /** @deprecated use `InputOffice365MsgTrace$Outbound` instead. */
  export type Outbound = InputOffice365MsgTrace$Outbound;
}

export function inputOffice365MsgTraceToJSON(
  inputOffice365MsgTrace: InputOffice365MsgTrace,
): string {
  return JSON.stringify(
    InputOffice365MsgTrace$outboundSchema.parse(inputOffice365MsgTrace),
  );
}

export function inputOffice365MsgTraceFromJSON(
  jsonString: string,
): SafeParseResult<InputOffice365MsgTrace, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputOffice365MsgTrace$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputOffice365MsgTrace' from JSON`,
  );
}
