/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  DataCompressionFormatOptionsPersistence,
  DataCompressionFormatOptionsPersistence$inboundSchema,
  DataCompressionFormatOptionsPersistence$outboundSchema,
} from "./datacompressionformatoptionspersistence.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeConnectionsOptional,
  ItemsTypeConnectionsOptional$inboundSchema,
  ItemsTypeConnectionsOptional$Outbound,
  ItemsTypeConnectionsOptional$outboundSchema,
} from "./itemstypeconnectionsoptional.js";
import {
  ItemsTypeNotificationMetadata,
  ItemsTypeNotificationMetadata$inboundSchema,
  ItemsTypeNotificationMetadata$Outbound,
  ItemsTypeNotificationMetadata$outboundSchema,
} from "./itemstypenotificationmetadata.js";
import {
  ModeOptionsHost,
  ModeOptionsHost$inboundSchema,
  ModeOptionsHost$outboundSchema,
} from "./modeoptionshost.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  ProcessType,
  ProcessType$inboundSchema,
  ProcessType$Outbound,
  ProcessType$outboundSchema,
} from "./processtype.js";

export const InputWindowsMetricsType = {
  WindowsMetrics: "windows_metrics",
} as const;
export type InputWindowsMetricsType = ClosedEnum<
  typeof InputWindowsMetricsType
>;

/**
 * Select the level of details for system metrics
 */
export const InputWindowsMetricsSystemMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for system metrics
 */
export type InputWindowsMetricsSystemMode = OpenEnum<
  typeof InputWindowsMetricsSystemMode
>;

export type InputWindowsMetricsSystem = {
  /**
   * Select the level of details for system metrics
   */
  mode?: InputWindowsMetricsSystemMode | undefined;
  /**
   * Generate metrics for all system information
   */
  detail?: boolean | undefined;
};

/**
 * Select the level of details for CPU metrics
 */
export const InputWindowsMetricsCpuMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for CPU metrics
 */
export type InputWindowsMetricsCpuMode = OpenEnum<
  typeof InputWindowsMetricsCpuMode
>;

export type InputWindowsMetricsCpu = {
  /**
   * Select the level of details for CPU metrics
   */
  mode?: InputWindowsMetricsCpuMode | undefined;
  /**
   * Generate metrics for each CPU
   */
  perCpu?: boolean | undefined;
  /**
   * Generate metrics for all CPU states
   */
  detail?: boolean | undefined;
  /**
   * Generate raw, monotonic CPU time counters
   */
  time?: boolean | undefined;
};

/**
 * Select the level of details for memory metrics
 */
export const InputWindowsMetricsMemoryMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for memory metrics
 */
export type InputWindowsMetricsMemoryMode = OpenEnum<
  typeof InputWindowsMetricsMemoryMode
>;

export type InputWindowsMetricsMemory = {
  /**
   * Select the level of details for memory metrics
   */
  mode?: InputWindowsMetricsMemoryMode | undefined;
  /**
   * Generate metrics for all memory states
   */
  detail?: boolean | undefined;
};

/**
 * Select the level of details for network metrics
 */
export const InputWindowsMetricsNetworkMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for network metrics
 */
export type InputWindowsMetricsNetworkMode = OpenEnum<
  typeof InputWindowsMetricsNetworkMode
>;

export type InputWindowsMetricsNetwork = {
  /**
   * Select the level of details for network metrics
   */
  mode?: InputWindowsMetricsNetworkMode | undefined;
  /**
   * Generate full network metrics
   */
  detail?: boolean | undefined;
  /**
   * Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
   */
  protocols?: boolean | undefined;
  /**
   * Network interfaces to include/exclude. All interfaces are included if this list is empty.
   */
  devices?: Array<string> | undefined;
  /**
   * Generate separate metrics for each interface
   */
  perInterface?: boolean | undefined;
};

/**
 * Select the level of details for disk metrics
 */
export const InputWindowsMetricsDiskMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for disk metrics
 */
export type InputWindowsMetricsDiskMode = OpenEnum<
  typeof InputWindowsMetricsDiskMode
>;

export type InputWindowsMetricsDisk = {
  /**
   * Select the level of details for disk metrics
   */
  mode?: InputWindowsMetricsDiskMode | undefined;
  /**
   * Generate separate metrics for each volume
   */
  perVolume?: boolean | undefined;
  /**
   * Generate full disk metrics
   */
  detail?: boolean | undefined;
  /**
   * Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty.
   */
  volumes?: Array<string> | undefined;
};

export type InputWindowsMetricsCustom = {
  system?: InputWindowsMetricsSystem | undefined;
  cpu?: InputWindowsMetricsCpu | undefined;
  memory?: InputWindowsMetricsMemory | undefined;
  network?: InputWindowsMetricsNetwork | undefined;
  disk?: InputWindowsMetricsDisk | undefined;
};

export type InputWindowsMetricsHost = {
  /**
   * Select level of detail for host metrics
   */
  mode?: ModeOptionsHost | undefined;
  custom?: InputWindowsMetricsCustom | undefined;
};

export type InputWindowsMetricsPersistence = {
  /**
   * Spool metrics to disk for Cribl Edge and Search
   */
  enable?: boolean | undefined;
  /**
   * Time span for each file bucket
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
   */
  maxDataTime?: string | undefined;
  compress?: DataCompressionFormatOptionsPersistence | undefined;
  /**
   * Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics
   */
  destPath?: string | undefined;
};

export type InputWindowsMetricsPqEnabledTrueWithPqConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  pq?: PqType | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWindowsMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnectionsOptional> | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputWindowsMetricsHost | undefined;
  process?: ProcessType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputWindowsMetricsPersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputWindowsMetricsPqEnabledFalseConstraint = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWindowsMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnectionsOptional> | undefined;
  pq?: PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputWindowsMetricsHost | undefined;
  process?: ProcessType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputWindowsMetricsPersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnectionsOptional> | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWindowsMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  pq?: PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputWindowsMetricsHost | undefined;
  process?: ProcessType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputWindowsMetricsPersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputWindowsMetricsSendToRoutesTrueConstraint = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputWindowsMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnectionsOptional> | undefined;
  pq?: PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputWindowsMetricsHost | undefined;
  process?: ProcessType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputWindowsMetricsPersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

export type InputWindowsMetrics =
  | InputWindowsMetricsSendToRoutesTrueConstraint
  | InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint
  | InputWindowsMetricsPqEnabledFalseConstraint
  | InputWindowsMetricsPqEnabledTrueWithPqConstraint;

/** @internal */
export const InputWindowsMetricsType$inboundSchema: z.ZodNativeEnum<
  typeof InputWindowsMetricsType
> = z.nativeEnum(InputWindowsMetricsType);
/** @internal */
export const InputWindowsMetricsType$outboundSchema: z.ZodNativeEnum<
  typeof InputWindowsMetricsType
> = InputWindowsMetricsType$inboundSchema;

/** @internal */
export const InputWindowsMetricsSystemMode$inboundSchema: z.ZodType<
  InputWindowsMetricsSystemMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsSystemMode);
/** @internal */
export const InputWindowsMetricsSystemMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsSystemMode
> = openEnums.outboundSchema(InputWindowsMetricsSystemMode);

/** @internal */
export const InputWindowsMetricsSystem$inboundSchema: z.ZodType<
  InputWindowsMetricsSystem,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsSystemMode$inboundSchema.default("basic"),
  detail: z.boolean().default(false),
});
/** @internal */
export type InputWindowsMetricsSystem$Outbound = {
  mode: string;
  detail: boolean;
};

/** @internal */
export const InputWindowsMetricsSystem$outboundSchema: z.ZodType<
  InputWindowsMetricsSystem$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsSystem
> = z.object({
  mode: InputWindowsMetricsSystemMode$outboundSchema.default("basic"),
  detail: z.boolean().default(false),
});

export function inputWindowsMetricsSystemToJSON(
  inputWindowsMetricsSystem: InputWindowsMetricsSystem,
): string {
  return JSON.stringify(
    InputWindowsMetricsSystem$outboundSchema.parse(inputWindowsMetricsSystem),
  );
}
export function inputWindowsMetricsSystemFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsSystem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsSystem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsSystem' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsCpuMode$inboundSchema: z.ZodType<
  InputWindowsMetricsCpuMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsCpuMode);
/** @internal */
export const InputWindowsMetricsCpuMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsCpuMode
> = openEnums.outboundSchema(InputWindowsMetricsCpuMode);

/** @internal */
export const InputWindowsMetricsCpu$inboundSchema: z.ZodType<
  InputWindowsMetricsCpu,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsCpuMode$inboundSchema.default("basic"),
  perCpu: z.boolean().default(false),
  detail: z.boolean().default(false),
  time: z.boolean().default(false),
});
/** @internal */
export type InputWindowsMetricsCpu$Outbound = {
  mode: string;
  perCpu: boolean;
  detail: boolean;
  time: boolean;
};

/** @internal */
export const InputWindowsMetricsCpu$outboundSchema: z.ZodType<
  InputWindowsMetricsCpu$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsCpu
> = z.object({
  mode: InputWindowsMetricsCpuMode$outboundSchema.default("basic"),
  perCpu: z.boolean().default(false),
  detail: z.boolean().default(false),
  time: z.boolean().default(false),
});

export function inputWindowsMetricsCpuToJSON(
  inputWindowsMetricsCpu: InputWindowsMetricsCpu,
): string {
  return JSON.stringify(
    InputWindowsMetricsCpu$outboundSchema.parse(inputWindowsMetricsCpu),
  );
}
export function inputWindowsMetricsCpuFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsCpu, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsCpu$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsCpu' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsMemoryMode$inboundSchema: z.ZodType<
  InputWindowsMetricsMemoryMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsMemoryMode);
/** @internal */
export const InputWindowsMetricsMemoryMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsMemoryMode
> = openEnums.outboundSchema(InputWindowsMetricsMemoryMode);

/** @internal */
export const InputWindowsMetricsMemory$inboundSchema: z.ZodType<
  InputWindowsMetricsMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsMemoryMode$inboundSchema.default("basic"),
  detail: z.boolean().default(false),
});
/** @internal */
export type InputWindowsMetricsMemory$Outbound = {
  mode: string;
  detail: boolean;
};

/** @internal */
export const InputWindowsMetricsMemory$outboundSchema: z.ZodType<
  InputWindowsMetricsMemory$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsMemory
> = z.object({
  mode: InputWindowsMetricsMemoryMode$outboundSchema.default("basic"),
  detail: z.boolean().default(false),
});

export function inputWindowsMetricsMemoryToJSON(
  inputWindowsMetricsMemory: InputWindowsMetricsMemory,
): string {
  return JSON.stringify(
    InputWindowsMetricsMemory$outboundSchema.parse(inputWindowsMetricsMemory),
  );
}
export function inputWindowsMetricsMemoryFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsMemory' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsNetworkMode$inboundSchema: z.ZodType<
  InputWindowsMetricsNetworkMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsNetworkMode);
/** @internal */
export const InputWindowsMetricsNetworkMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsNetworkMode
> = openEnums.outboundSchema(InputWindowsMetricsNetworkMode);

/** @internal */
export const InputWindowsMetricsNetwork$inboundSchema: z.ZodType<
  InputWindowsMetricsNetwork,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsNetworkMode$inboundSchema.default("basic"),
  detail: z.boolean().default(false),
  protocols: z.boolean().default(false),
  devices: z.array(z.string()).optional(),
  perInterface: z.boolean().default(false),
});
/** @internal */
export type InputWindowsMetricsNetwork$Outbound = {
  mode: string;
  detail: boolean;
  protocols: boolean;
  devices?: Array<string> | undefined;
  perInterface: boolean;
};

/** @internal */
export const InputWindowsMetricsNetwork$outboundSchema: z.ZodType<
  InputWindowsMetricsNetwork$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsNetwork
> = z.object({
  mode: InputWindowsMetricsNetworkMode$outboundSchema.default("basic"),
  detail: z.boolean().default(false),
  protocols: z.boolean().default(false),
  devices: z.array(z.string()).optional(),
  perInterface: z.boolean().default(false),
});

export function inputWindowsMetricsNetworkToJSON(
  inputWindowsMetricsNetwork: InputWindowsMetricsNetwork,
): string {
  return JSON.stringify(
    InputWindowsMetricsNetwork$outboundSchema.parse(inputWindowsMetricsNetwork),
  );
}
export function inputWindowsMetricsNetworkFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsNetwork, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsNetwork$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsNetwork' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsDiskMode$inboundSchema: z.ZodType<
  InputWindowsMetricsDiskMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsDiskMode);
/** @internal */
export const InputWindowsMetricsDiskMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsDiskMode
> = openEnums.outboundSchema(InputWindowsMetricsDiskMode);

/** @internal */
export const InputWindowsMetricsDisk$inboundSchema: z.ZodType<
  InputWindowsMetricsDisk,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsDiskMode$inboundSchema.default("basic"),
  perVolume: z.boolean().default(false),
  detail: z.boolean().default(false),
  volumes: z.array(z.string()).optional(),
});
/** @internal */
export type InputWindowsMetricsDisk$Outbound = {
  mode: string;
  perVolume: boolean;
  detail: boolean;
  volumes?: Array<string> | undefined;
};

/** @internal */
export const InputWindowsMetricsDisk$outboundSchema: z.ZodType<
  InputWindowsMetricsDisk$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsDisk
> = z.object({
  mode: InputWindowsMetricsDiskMode$outboundSchema.default("basic"),
  perVolume: z.boolean().default(false),
  detail: z.boolean().default(false),
  volumes: z.array(z.string()).optional(),
});

export function inputWindowsMetricsDiskToJSON(
  inputWindowsMetricsDisk: InputWindowsMetricsDisk,
): string {
  return JSON.stringify(
    InputWindowsMetricsDisk$outboundSchema.parse(inputWindowsMetricsDisk),
  );
}
export function inputWindowsMetricsDiskFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsDisk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsDisk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsDisk' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsCustom$inboundSchema: z.ZodType<
  InputWindowsMetricsCustom,
  z.ZodTypeDef,
  unknown
> = z.object({
  system: z.lazy(() => InputWindowsMetricsSystem$inboundSchema).optional(),
  cpu: z.lazy(() => InputWindowsMetricsCpu$inboundSchema).optional(),
  memory: z.lazy(() => InputWindowsMetricsMemory$inboundSchema).optional(),
  network: z.lazy(() => InputWindowsMetricsNetwork$inboundSchema).optional(),
  disk: z.lazy(() => InputWindowsMetricsDisk$inboundSchema).optional(),
});
/** @internal */
export type InputWindowsMetricsCustom$Outbound = {
  system?: InputWindowsMetricsSystem$Outbound | undefined;
  cpu?: InputWindowsMetricsCpu$Outbound | undefined;
  memory?: InputWindowsMetricsMemory$Outbound | undefined;
  network?: InputWindowsMetricsNetwork$Outbound | undefined;
  disk?: InputWindowsMetricsDisk$Outbound | undefined;
};

/** @internal */
export const InputWindowsMetricsCustom$outboundSchema: z.ZodType<
  InputWindowsMetricsCustom$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsCustom
> = z.object({
  system: z.lazy(() => InputWindowsMetricsSystem$outboundSchema).optional(),
  cpu: z.lazy(() => InputWindowsMetricsCpu$outboundSchema).optional(),
  memory: z.lazy(() => InputWindowsMetricsMemory$outboundSchema).optional(),
  network: z.lazy(() => InputWindowsMetricsNetwork$outboundSchema).optional(),
  disk: z.lazy(() => InputWindowsMetricsDisk$outboundSchema).optional(),
});

export function inputWindowsMetricsCustomToJSON(
  inputWindowsMetricsCustom: InputWindowsMetricsCustom,
): string {
  return JSON.stringify(
    InputWindowsMetricsCustom$outboundSchema.parse(inputWindowsMetricsCustom),
  );
}
export function inputWindowsMetricsCustomFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsCustom, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsCustom$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsCustom' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsHost$inboundSchema: z.ZodType<
  InputWindowsMetricsHost,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeOptionsHost$inboundSchema.default("basic"),
  custom: z.lazy(() => InputWindowsMetricsCustom$inboundSchema).optional(),
});
/** @internal */
export type InputWindowsMetricsHost$Outbound = {
  mode: string;
  custom?: InputWindowsMetricsCustom$Outbound | undefined;
};

/** @internal */
export const InputWindowsMetricsHost$outboundSchema: z.ZodType<
  InputWindowsMetricsHost$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsHost
> = z.object({
  mode: ModeOptionsHost$outboundSchema.default("basic"),
  custom: z.lazy(() => InputWindowsMetricsCustom$outboundSchema).optional(),
});

export function inputWindowsMetricsHostToJSON(
  inputWindowsMetricsHost: InputWindowsMetricsHost,
): string {
  return JSON.stringify(
    InputWindowsMetricsHost$outboundSchema.parse(inputWindowsMetricsHost),
  );
}
export function inputWindowsMetricsHostFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsHost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsHost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsHost' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsPersistence$inboundSchema: z.ZodType<
  InputWindowsMetricsPersistence,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: DataCompressionFormatOptionsPersistence$inboundSchema.default(
    "gzip",
  ),
  destPath: z.string().default("$CRIBL_HOME/state/windows_metrics"),
});
/** @internal */
export type InputWindowsMetricsPersistence$Outbound = {
  enable: boolean;
  timeWindow: string;
  maxDataSize: string;
  maxDataTime: string;
  compress: string;
  destPath: string;
};

/** @internal */
export const InputWindowsMetricsPersistence$outboundSchema: z.ZodType<
  InputWindowsMetricsPersistence$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsPersistence
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: DataCompressionFormatOptionsPersistence$outboundSchema.default(
    "gzip",
  ),
  destPath: z.string().default("$CRIBL_HOME/state/windows_metrics"),
});

export function inputWindowsMetricsPersistenceToJSON(
  inputWindowsMetricsPersistence: InputWindowsMetricsPersistence,
): string {
  return JSON.stringify(
    InputWindowsMetricsPersistence$outboundSchema.parse(
      inputWindowsMetricsPersistence,
    ),
  );
}
export function inputWindowsMetricsPersistenceFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsPersistence, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsPersistence$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsPersistence' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsPqEnabledTrueWithPqConstraint$inboundSchema:
  z.ZodType<
    InputWindowsMetricsPqEnabledTrueWithPqConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$inboundSchema.optional(),
    id: z.string().optional(),
    type: InputWindowsMetricsType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnectionsOptional$inboundSchema).optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputWindowsMetricsHost$inboundSchema).optional(),
    process: ProcessType$inboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$inboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });
/** @internal */
export type InputWindowsMetricsPqEnabledTrueWithPqConstraint$Outbound = {
  pqEnabled: boolean;
  pq?: PqType$Outbound | undefined;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnectionsOptional$Outbound> | undefined;
  interval: number;
  host?: InputWindowsMetricsHost$Outbound | undefined;
  process?: ProcessType$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputWindowsMetricsPersistence$Outbound | undefined;
  disableNativeModule: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputWindowsMetricsPqEnabledTrueWithPqConstraint$outboundSchema:
  z.ZodType<
    InputWindowsMetricsPqEnabledTrueWithPqConstraint$Outbound,
    z.ZodTypeDef,
    InputWindowsMetricsPqEnabledTrueWithPqConstraint
  > = z.object({
    pqEnabled: z.boolean().default(false),
    pq: PqType$outboundSchema.optional(),
    id: z.string().optional(),
    type: InputWindowsMetricsType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputWindowsMetricsHost$outboundSchema).optional(),
    process: ProcessType$outboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });

export function inputWindowsMetricsPqEnabledTrueWithPqConstraintToJSON(
  inputWindowsMetricsPqEnabledTrueWithPqConstraint:
    InputWindowsMetricsPqEnabledTrueWithPqConstraint,
): string {
  return JSON.stringify(
    InputWindowsMetricsPqEnabledTrueWithPqConstraint$outboundSchema.parse(
      inputWindowsMetricsPqEnabledTrueWithPqConstraint,
    ),
  );
}
export function inputWindowsMetricsPqEnabledTrueWithPqConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputWindowsMetricsPqEnabledTrueWithPqConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputWindowsMetricsPqEnabledTrueWithPqConstraint$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputWindowsMetricsPqEnabledTrueWithPqConstraint' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsPqEnabledFalseConstraint$inboundSchema:
  z.ZodType<
    InputWindowsMetricsPqEnabledFalseConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    pqEnabled: z.boolean().default(false),
    id: z.string().optional(),
    type: InputWindowsMetricsType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnectionsOptional$inboundSchema).optional(),
    pq: PqType$inboundSchema.optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputWindowsMetricsHost$inboundSchema).optional(),
    process: ProcessType$inboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$inboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });
/** @internal */
export type InputWindowsMetricsPqEnabledFalseConstraint$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  interval: number;
  host?: InputWindowsMetricsHost$Outbound | undefined;
  process?: ProcessType$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputWindowsMetricsPersistence$Outbound | undefined;
  disableNativeModule: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputWindowsMetricsPqEnabledFalseConstraint$outboundSchema:
  z.ZodType<
    InputWindowsMetricsPqEnabledFalseConstraint$Outbound,
    z.ZodTypeDef,
    InputWindowsMetricsPqEnabledFalseConstraint
  > = z.object({
    pqEnabled: z.boolean().default(false),
    id: z.string().optional(),
    type: InputWindowsMetricsType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    sendToRoutes: z.boolean().default(true),
    environment: z.string().optional(),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: PqType$outboundSchema.optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputWindowsMetricsHost$outboundSchema).optional(),
    process: ProcessType$outboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });

export function inputWindowsMetricsPqEnabledFalseConstraintToJSON(
  inputWindowsMetricsPqEnabledFalseConstraint:
    InputWindowsMetricsPqEnabledFalseConstraint,
): string {
  return JSON.stringify(
    InputWindowsMetricsPqEnabledFalseConstraint$outboundSchema.parse(
      inputWindowsMetricsPqEnabledFalseConstraint,
    ),
  );
}
export function inputWindowsMetricsPqEnabledFalseConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputWindowsMetricsPqEnabledFalseConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputWindowsMetricsPqEnabledFalseConstraint$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputWindowsMetricsPqEnabledFalseConstraint' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$inboundSchema:
  z.ZodType<
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnectionsOptional$inboundSchema).optional(),
    id: z.string().optional(),
    type: InputWindowsMetricsType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$inboundSchema.optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputWindowsMetricsHost$inboundSchema).optional(),
    process: ProcessType$inboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$inboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });
/** @internal */
export type InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound =
  {
    sendToRoutes: boolean;
    connections?: Array<ItemsTypeConnectionsOptional$Outbound> | undefined;
    id?: string | undefined;
    type: string;
    disabled: boolean;
    pipeline?: string | undefined;
    environment?: string | undefined;
    pqEnabled: boolean;
    streamtags?: Array<string> | undefined;
    pq?: PqType$Outbound | undefined;
    interval: number;
    host?: InputWindowsMetricsHost$Outbound | undefined;
    process?: ProcessType$Outbound | undefined;
    metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
    persistence?: InputWindowsMetricsPersistence$Outbound | undefined;
    disableNativeModule: boolean;
    description?: string | undefined;
  };

/** @internal */
export const InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema:
  z.ZodType<
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound,
    z.ZodTypeDef,
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    connections: z.array(ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    id: z.string().optional(),
    type: InputWindowsMetricsType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    pq: PqType$outboundSchema.optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputWindowsMetricsHost$outboundSchema).optional(),
    process: ProcessType$outboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });

export function inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraintToJSON(
  inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint:
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint,
): string {
  return JSON.stringify(
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
      .parse(inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint),
  );
}
export function inputWindowsMetricsSendToRoutesFalseWithConnectionsConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsSendToRoutesTrueConstraint$inboundSchema:
  z.ZodType<
    InputWindowsMetricsSendToRoutesTrueConstraint,
    z.ZodTypeDef,
    unknown
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    id: z.string().optional(),
    type: InputWindowsMetricsType$inboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnectionsOptional$inboundSchema).optional(),
    pq: PqType$inboundSchema.optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputWindowsMetricsHost$inboundSchema).optional(),
    process: ProcessType$inboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$inboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });
/** @internal */
export type InputWindowsMetricsSendToRoutesTrueConstraint$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  interval: number;
  host?: InputWindowsMetricsHost$Outbound | undefined;
  process?: ProcessType$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputWindowsMetricsPersistence$Outbound | undefined;
  disableNativeModule: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputWindowsMetricsSendToRoutesTrueConstraint$outboundSchema:
  z.ZodType<
    InputWindowsMetricsSendToRoutesTrueConstraint$Outbound,
    z.ZodTypeDef,
    InputWindowsMetricsSendToRoutesTrueConstraint
  > = z.object({
    sendToRoutes: z.boolean().default(true),
    id: z.string().optional(),
    type: InputWindowsMetricsType$outboundSchema,
    disabled: z.boolean().default(false),
    pipeline: z.string().optional(),
    environment: z.string().optional(),
    pqEnabled: z.boolean().default(false),
    streamtags: z.array(z.string()).optional(),
    connections: z.array(ItemsTypeConnectionsOptional$outboundSchema)
      .optional(),
    pq: PqType$outboundSchema.optional(),
    interval: z.number().default(10),
    host: z.lazy(() => InputWindowsMetricsHost$outboundSchema).optional(),
    process: ProcessType$outboundSchema.optional(),
    metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
    persistence: z.lazy(() => InputWindowsMetricsPersistence$outboundSchema)
      .optional(),
    disableNativeModule: z.boolean().default(false),
    description: z.string().optional(),
  });

export function inputWindowsMetricsSendToRoutesTrueConstraintToJSON(
  inputWindowsMetricsSendToRoutesTrueConstraint:
    InputWindowsMetricsSendToRoutesTrueConstraint,
): string {
  return JSON.stringify(
    InputWindowsMetricsSendToRoutesTrueConstraint$outboundSchema.parse(
      inputWindowsMetricsSendToRoutesTrueConstraint,
    ),
  );
}
export function inputWindowsMetricsSendToRoutesTrueConstraintFromJSON(
  jsonString: string,
): SafeParseResult<
  InputWindowsMetricsSendToRoutesTrueConstraint,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InputWindowsMetricsSendToRoutesTrueConstraint$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InputWindowsMetricsSendToRoutesTrueConstraint' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetrics$inboundSchema: z.ZodType<
  InputWindowsMetrics,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputWindowsMetricsSendToRoutesTrueConstraint$inboundSchema),
  z.lazy(() =>
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$inboundSchema
  ),
  z.lazy(() => InputWindowsMetricsPqEnabledFalseConstraint$inboundSchema),
  z.lazy(() => InputWindowsMetricsPqEnabledTrueWithPqConstraint$inboundSchema),
]);
/** @internal */
export type InputWindowsMetrics$Outbound =
  | InputWindowsMetricsSendToRoutesTrueConstraint$Outbound
  | InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$Outbound
  | InputWindowsMetricsPqEnabledFalseConstraint$Outbound
  | InputWindowsMetricsPqEnabledTrueWithPqConstraint$Outbound;

/** @internal */
export const InputWindowsMetrics$outboundSchema: z.ZodType<
  InputWindowsMetrics$Outbound,
  z.ZodTypeDef,
  InputWindowsMetrics
> = z.union([
  z.lazy(() => InputWindowsMetricsSendToRoutesTrueConstraint$outboundSchema),
  z.lazy(() =>
    InputWindowsMetricsSendToRoutesFalseWithConnectionsConstraint$outboundSchema
  ),
  z.lazy(() => InputWindowsMetricsPqEnabledFalseConstraint$outboundSchema),
  z.lazy(() => InputWindowsMetricsPqEnabledTrueWithPqConstraint$outboundSchema),
]);

export function inputWindowsMetricsToJSON(
  inputWindowsMetrics: InputWindowsMetrics,
): string {
  return JSON.stringify(
    InputWindowsMetrics$outboundSchema.parse(inputWindowsMetrics),
  );
}
export function inputWindowsMetricsFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetrics' from JSON`,
  );
}
