/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  DataCompressionFormatOptionsPersistence,
  DataCompressionFormatOptionsPersistence$inboundSchema,
  DataCompressionFormatOptionsPersistence$outboundSchema,
} from "./datacompressionformatoptionspersistence.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  ItemsTypeConnectionsOptional,
  ItemsTypeConnectionsOptional$inboundSchema,
  ItemsTypeConnectionsOptional$Outbound,
  ItemsTypeConnectionsOptional$outboundSchema,
} from "./itemstypeconnectionsoptional.js";
import {
  ItemsTypeNotificationMetadata,
  ItemsTypeNotificationMetadata$inboundSchema,
  ItemsTypeNotificationMetadata$Outbound,
  ItemsTypeNotificationMetadata$outboundSchema,
} from "./itemstypenotificationmetadata.js";
import {
  ModeOptionsHost,
  ModeOptionsHost$inboundSchema,
  ModeOptionsHost$outboundSchema,
} from "./modeoptionshost.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  ProcessType,
  ProcessType$inboundSchema,
  ProcessType$Outbound,
  ProcessType$outboundSchema,
} from "./processtype.js";

/**
 * Select the level of details for system metrics
 */
export const InputWindowsMetricsSystemMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for system metrics
 */
export type InputWindowsMetricsSystemMode = OpenEnum<
  typeof InputWindowsMetricsSystemMode
>;

export type InputWindowsMetricsSystem = {
  /**
   * Select the level of details for system metrics
   */
  mode?: InputWindowsMetricsSystemMode | undefined;
  /**
   * Generate metrics for all system information
   */
  detail?: boolean | undefined;
};

/**
 * Select the level of details for CPU metrics
 */
export const InputWindowsMetricsCpuMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for CPU metrics
 */
export type InputWindowsMetricsCpuMode = OpenEnum<
  typeof InputWindowsMetricsCpuMode
>;

export type InputWindowsMetricsCpu = {
  /**
   * Select the level of details for CPU metrics
   */
  mode?: InputWindowsMetricsCpuMode | undefined;
  /**
   * Generate metrics for each CPU
   */
  perCpu?: boolean | undefined;
  /**
   * Generate metrics for all CPU states
   */
  detail?: boolean | undefined;
  /**
   * Generate raw, monotonic CPU time counters
   */
  time?: boolean | undefined;
};

/**
 * Select the level of details for memory metrics
 */
export const InputWindowsMetricsMemoryMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for memory metrics
 */
export type InputWindowsMetricsMemoryMode = OpenEnum<
  typeof InputWindowsMetricsMemoryMode
>;

export type InputWindowsMetricsMemory = {
  /**
   * Select the level of details for memory metrics
   */
  mode?: InputWindowsMetricsMemoryMode | undefined;
  /**
   * Generate metrics for all memory states
   */
  detail?: boolean | undefined;
};

/**
 * Select the level of details for network metrics
 */
export const InputWindowsMetricsNetworkMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for network metrics
 */
export type InputWindowsMetricsNetworkMode = OpenEnum<
  typeof InputWindowsMetricsNetworkMode
>;

export type InputWindowsMetricsNetwork = {
  /**
   * Select the level of details for network metrics
   */
  mode?: InputWindowsMetricsNetworkMode | undefined;
  /**
   * Generate full network metrics
   */
  detail?: boolean | undefined;
  /**
   * Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
   */
  protocols?: boolean | undefined;
  /**
   * Network interfaces to include/exclude. All interfaces are included if this list is empty.
   */
  devices?: Array<string> | undefined;
  /**
   * Generate separate metrics for each interface
   */
  perInterface?: boolean | undefined;
};

/**
 * Select the level of details for disk metrics
 */
export const InputWindowsMetricsDiskMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for disk metrics
 */
export type InputWindowsMetricsDiskMode = OpenEnum<
  typeof InputWindowsMetricsDiskMode
>;

export type InputWindowsMetricsDisk = {
  /**
   * Select the level of details for disk metrics
   */
  mode?: InputWindowsMetricsDiskMode | undefined;
  /**
   * Generate separate metrics for each volume
   */
  perVolume?: boolean | undefined;
  /**
   * Generate full disk metrics
   */
  detail?: boolean | undefined;
  /**
   * Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty.
   */
  volumes?: Array<string> | undefined;
};

export type InputWindowsMetricsCustom = {
  system?: InputWindowsMetricsSystem | undefined;
  cpu?: InputWindowsMetricsCpu | undefined;
  memory?: InputWindowsMetricsMemory | undefined;
  network?: InputWindowsMetricsNetwork | undefined;
  disk?: InputWindowsMetricsDisk | undefined;
};

export type InputWindowsMetricsHost = {
  /**
   * Select level of detail for host metrics
   */
  mode?: ModeOptionsHost | undefined;
  custom?: InputWindowsMetricsCustom | undefined;
};

export type InputWindowsMetricsPersistence = {
  /**
   * Spool metrics to disk for Cribl Edge and Search
   */
  enable?: boolean | undefined;
  /**
   * Time span for each file bucket
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
   */
  maxDataTime?: string | undefined;
  compress?: DataCompressionFormatOptionsPersistence | undefined;
  /**
   * Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics
   */
  destPath?: string | undefined;
};

export type InputWindowsMetrics = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: "windows_metrics";
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ItemsTypeConnectionsOptional> | undefined;
  pq?: PqType | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputWindowsMetricsHost | undefined;
  process?: ProcessType | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<ItemsTypeNotificationMetadata> | undefined;
  persistence?: InputWindowsMetricsPersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputWindowsMetricsSystemMode$inboundSchema: z.ZodType<
  InputWindowsMetricsSystemMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsSystemMode);
/** @internal */
export const InputWindowsMetricsSystemMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsSystemMode
> = openEnums.outboundSchema(InputWindowsMetricsSystemMode);

/** @internal */
export const InputWindowsMetricsSystem$inboundSchema: z.ZodType<
  InputWindowsMetricsSystem,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsSystemMode$inboundSchema.optional(),
  detail: z.boolean().optional(),
});
/** @internal */
export type InputWindowsMetricsSystem$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
};

/** @internal */
export const InputWindowsMetricsSystem$outboundSchema: z.ZodType<
  InputWindowsMetricsSystem$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsSystem
> = z.object({
  mode: InputWindowsMetricsSystemMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
});

export function inputWindowsMetricsSystemToJSON(
  inputWindowsMetricsSystem: InputWindowsMetricsSystem,
): string {
  return JSON.stringify(
    InputWindowsMetricsSystem$outboundSchema.parse(inputWindowsMetricsSystem),
  );
}
export function inputWindowsMetricsSystemFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsSystem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsSystem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsSystem' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsCpuMode$inboundSchema: z.ZodType<
  InputWindowsMetricsCpuMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsCpuMode);
/** @internal */
export const InputWindowsMetricsCpuMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsCpuMode
> = openEnums.outboundSchema(InputWindowsMetricsCpuMode);

/** @internal */
export const InputWindowsMetricsCpu$inboundSchema: z.ZodType<
  InputWindowsMetricsCpu,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsCpuMode$inboundSchema.optional(),
  perCpu: z.boolean().optional(),
  detail: z.boolean().optional(),
  time: z.boolean().optional(),
});
/** @internal */
export type InputWindowsMetricsCpu$Outbound = {
  mode?: string | undefined;
  perCpu?: boolean | undefined;
  detail?: boolean | undefined;
  time?: boolean | undefined;
};

/** @internal */
export const InputWindowsMetricsCpu$outboundSchema: z.ZodType<
  InputWindowsMetricsCpu$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsCpu
> = z.object({
  mode: InputWindowsMetricsCpuMode$outboundSchema.optional(),
  perCpu: z.boolean().optional(),
  detail: z.boolean().optional(),
  time: z.boolean().optional(),
});

export function inputWindowsMetricsCpuToJSON(
  inputWindowsMetricsCpu: InputWindowsMetricsCpu,
): string {
  return JSON.stringify(
    InputWindowsMetricsCpu$outboundSchema.parse(inputWindowsMetricsCpu),
  );
}
export function inputWindowsMetricsCpuFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsCpu, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsCpu$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsCpu' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsMemoryMode$inboundSchema: z.ZodType<
  InputWindowsMetricsMemoryMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsMemoryMode);
/** @internal */
export const InputWindowsMetricsMemoryMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsMemoryMode
> = openEnums.outboundSchema(InputWindowsMetricsMemoryMode);

/** @internal */
export const InputWindowsMetricsMemory$inboundSchema: z.ZodType<
  InputWindowsMetricsMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsMemoryMode$inboundSchema.optional(),
  detail: z.boolean().optional(),
});
/** @internal */
export type InputWindowsMetricsMemory$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
};

/** @internal */
export const InputWindowsMetricsMemory$outboundSchema: z.ZodType<
  InputWindowsMetricsMemory$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsMemory
> = z.object({
  mode: InputWindowsMetricsMemoryMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
});

export function inputWindowsMetricsMemoryToJSON(
  inputWindowsMetricsMemory: InputWindowsMetricsMemory,
): string {
  return JSON.stringify(
    InputWindowsMetricsMemory$outboundSchema.parse(inputWindowsMetricsMemory),
  );
}
export function inputWindowsMetricsMemoryFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsMemory' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsNetworkMode$inboundSchema: z.ZodType<
  InputWindowsMetricsNetworkMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsNetworkMode);
/** @internal */
export const InputWindowsMetricsNetworkMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsNetworkMode
> = openEnums.outboundSchema(InputWindowsMetricsNetworkMode);

/** @internal */
export const InputWindowsMetricsNetwork$inboundSchema: z.ZodType<
  InputWindowsMetricsNetwork,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsNetworkMode$inboundSchema.optional(),
  detail: z.boolean().optional(),
  protocols: z.boolean().optional(),
  devices: z.array(z.string()).optional(),
  perInterface: z.boolean().optional(),
});
/** @internal */
export type InputWindowsMetricsNetwork$Outbound = {
  mode?: string | undefined;
  detail?: boolean | undefined;
  protocols?: boolean | undefined;
  devices?: Array<string> | undefined;
  perInterface?: boolean | undefined;
};

/** @internal */
export const InputWindowsMetricsNetwork$outboundSchema: z.ZodType<
  InputWindowsMetricsNetwork$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsNetwork
> = z.object({
  mode: InputWindowsMetricsNetworkMode$outboundSchema.optional(),
  detail: z.boolean().optional(),
  protocols: z.boolean().optional(),
  devices: z.array(z.string()).optional(),
  perInterface: z.boolean().optional(),
});

export function inputWindowsMetricsNetworkToJSON(
  inputWindowsMetricsNetwork: InputWindowsMetricsNetwork,
): string {
  return JSON.stringify(
    InputWindowsMetricsNetwork$outboundSchema.parse(inputWindowsMetricsNetwork),
  );
}
export function inputWindowsMetricsNetworkFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsNetwork, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsNetwork$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsNetwork' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsDiskMode$inboundSchema: z.ZodType<
  InputWindowsMetricsDiskMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsDiskMode);
/** @internal */
export const InputWindowsMetricsDiskMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsDiskMode
> = openEnums.outboundSchema(InputWindowsMetricsDiskMode);

/** @internal */
export const InputWindowsMetricsDisk$inboundSchema: z.ZodType<
  InputWindowsMetricsDisk,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsDiskMode$inboundSchema.optional(),
  perVolume: z.boolean().optional(),
  detail: z.boolean().optional(),
  volumes: z.array(z.string()).optional(),
});
/** @internal */
export type InputWindowsMetricsDisk$Outbound = {
  mode?: string | undefined;
  perVolume?: boolean | undefined;
  detail?: boolean | undefined;
  volumes?: Array<string> | undefined;
};

/** @internal */
export const InputWindowsMetricsDisk$outboundSchema: z.ZodType<
  InputWindowsMetricsDisk$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsDisk
> = z.object({
  mode: InputWindowsMetricsDiskMode$outboundSchema.optional(),
  perVolume: z.boolean().optional(),
  detail: z.boolean().optional(),
  volumes: z.array(z.string()).optional(),
});

export function inputWindowsMetricsDiskToJSON(
  inputWindowsMetricsDisk: InputWindowsMetricsDisk,
): string {
  return JSON.stringify(
    InputWindowsMetricsDisk$outboundSchema.parse(inputWindowsMetricsDisk),
  );
}
export function inputWindowsMetricsDiskFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsDisk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsDisk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsDisk' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsCustom$inboundSchema: z.ZodType<
  InputWindowsMetricsCustom,
  z.ZodTypeDef,
  unknown
> = z.object({
  system: z.lazy(() => InputWindowsMetricsSystem$inboundSchema).optional(),
  cpu: z.lazy(() => InputWindowsMetricsCpu$inboundSchema).optional(),
  memory: z.lazy(() => InputWindowsMetricsMemory$inboundSchema).optional(),
  network: z.lazy(() => InputWindowsMetricsNetwork$inboundSchema).optional(),
  disk: z.lazy(() => InputWindowsMetricsDisk$inboundSchema).optional(),
});
/** @internal */
export type InputWindowsMetricsCustom$Outbound = {
  system?: InputWindowsMetricsSystem$Outbound | undefined;
  cpu?: InputWindowsMetricsCpu$Outbound | undefined;
  memory?: InputWindowsMetricsMemory$Outbound | undefined;
  network?: InputWindowsMetricsNetwork$Outbound | undefined;
  disk?: InputWindowsMetricsDisk$Outbound | undefined;
};

/** @internal */
export const InputWindowsMetricsCustom$outboundSchema: z.ZodType<
  InputWindowsMetricsCustom$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsCustom
> = z.object({
  system: z.lazy(() => InputWindowsMetricsSystem$outboundSchema).optional(),
  cpu: z.lazy(() => InputWindowsMetricsCpu$outboundSchema).optional(),
  memory: z.lazy(() => InputWindowsMetricsMemory$outboundSchema).optional(),
  network: z.lazy(() => InputWindowsMetricsNetwork$outboundSchema).optional(),
  disk: z.lazy(() => InputWindowsMetricsDisk$outboundSchema).optional(),
});

export function inputWindowsMetricsCustomToJSON(
  inputWindowsMetricsCustom: InputWindowsMetricsCustom,
): string {
  return JSON.stringify(
    InputWindowsMetricsCustom$outboundSchema.parse(inputWindowsMetricsCustom),
  );
}
export function inputWindowsMetricsCustomFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsCustom, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsCustom$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsCustom' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsHost$inboundSchema: z.ZodType<
  InputWindowsMetricsHost,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: ModeOptionsHost$inboundSchema.optional(),
  custom: z.lazy(() => InputWindowsMetricsCustom$inboundSchema).optional(),
});
/** @internal */
export type InputWindowsMetricsHost$Outbound = {
  mode?: string | undefined;
  custom?: InputWindowsMetricsCustom$Outbound | undefined;
};

/** @internal */
export const InputWindowsMetricsHost$outboundSchema: z.ZodType<
  InputWindowsMetricsHost$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsHost
> = z.object({
  mode: ModeOptionsHost$outboundSchema.optional(),
  custom: z.lazy(() => InputWindowsMetricsCustom$outboundSchema).optional(),
});

export function inputWindowsMetricsHostToJSON(
  inputWindowsMetricsHost: InputWindowsMetricsHost,
): string {
  return JSON.stringify(
    InputWindowsMetricsHost$outboundSchema.parse(inputWindowsMetricsHost),
  );
}
export function inputWindowsMetricsHostFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsHost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsHost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsHost' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsPersistence$inboundSchema: z.ZodType<
  InputWindowsMetricsPersistence,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().optional(),
  timeWindow: z.string().optional(),
  maxDataSize: z.string().optional(),
  maxDataTime: z.string().optional(),
  compress: DataCompressionFormatOptionsPersistence$inboundSchema.optional(),
  destPath: z.string().optional(),
});
/** @internal */
export type InputWindowsMetricsPersistence$Outbound = {
  enable?: boolean | undefined;
  timeWindow?: string | undefined;
  maxDataSize?: string | undefined;
  maxDataTime?: string | undefined;
  compress?: string | undefined;
  destPath?: string | undefined;
};

/** @internal */
export const InputWindowsMetricsPersistence$outboundSchema: z.ZodType<
  InputWindowsMetricsPersistence$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsPersistence
> = z.object({
  enable: z.boolean().optional(),
  timeWindow: z.string().optional(),
  maxDataSize: z.string().optional(),
  maxDataTime: z.string().optional(),
  compress: DataCompressionFormatOptionsPersistence$outboundSchema.optional(),
  destPath: z.string().optional(),
});

export function inputWindowsMetricsPersistenceToJSON(
  inputWindowsMetricsPersistence: InputWindowsMetricsPersistence,
): string {
  return JSON.stringify(
    InputWindowsMetricsPersistence$outboundSchema.parse(
      inputWindowsMetricsPersistence,
    ),
  );
}
export function inputWindowsMetricsPersistenceFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsPersistence, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsPersistence$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsPersistence' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetrics$inboundSchema: z.ZodType<
  InputWindowsMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: z.literal("windows_metrics"),
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ItemsTypeConnectionsOptional$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  interval: z.number().optional(),
  host: z.lazy(() => InputWindowsMetricsHost$inboundSchema).optional(),
  process: ProcessType$inboundSchema.optional(),
  metadata: z.array(ItemsTypeNotificationMetadata$inboundSchema).optional(),
  persistence: z.lazy(() => InputWindowsMetricsPersistence$inboundSchema)
    .optional(),
  disableNativeModule: z.boolean().optional(),
  description: z.string().optional(),
});
/** @internal */
export type InputWindowsMetrics$Outbound = {
  id?: string | undefined;
  type: "windows_metrics";
  disabled?: boolean | undefined;
  pipeline?: string | undefined;
  sendToRoutes?: boolean | undefined;
  environment?: string | undefined;
  pqEnabled?: boolean | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ItemsTypeConnectionsOptional$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  interval?: number | undefined;
  host?: InputWindowsMetricsHost$Outbound | undefined;
  process?: ProcessType$Outbound | undefined;
  metadata?: Array<ItemsTypeNotificationMetadata$Outbound> | undefined;
  persistence?: InputWindowsMetricsPersistence$Outbound | undefined;
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputWindowsMetrics$outboundSchema: z.ZodType<
  InputWindowsMetrics$Outbound,
  z.ZodTypeDef,
  InputWindowsMetrics
> = z.object({
  id: z.string().optional(),
  type: z.literal("windows_metrics"),
  disabled: z.boolean().optional(),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ItemsTypeConnectionsOptional$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  interval: z.number().optional(),
  host: z.lazy(() => InputWindowsMetricsHost$outboundSchema).optional(),
  process: ProcessType$outboundSchema.optional(),
  metadata: z.array(ItemsTypeNotificationMetadata$outboundSchema).optional(),
  persistence: z.lazy(() => InputWindowsMetricsPersistence$outboundSchema)
    .optional(),
  disableNativeModule: z.boolean().optional(),
  description: z.string().optional(),
});

export function inputWindowsMetricsToJSON(
  inputWindowsMetrics: InputWindowsMetrics,
): string {
  return JSON.stringify(
    InputWindowsMetrics$outboundSchema.parse(inputWindowsMetrics),
  );
}
export function inputWindowsMetricsFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetrics' from JSON`,
  );
}
