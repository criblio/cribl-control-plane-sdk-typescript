/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export type InputWindowsMetricsConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputWindowsMetricsPqMode = {
  /**
   * Smart
   */
  Smart: "smart",
  /**
   * Always On
   */
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputWindowsMetricsPqMode = OpenEnum<
  typeof InputWindowsMetricsPqMode
>;

/**
 * Codec to use to compress the persisted data
 */
export const InputWindowsMetricsCompression = {
  /**
   * None
   */
  None: "none",
  /**
   * Gzip
   */
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputWindowsMetricsCompression = OpenEnum<
  typeof InputWindowsMetricsCompression
>;

export type InputWindowsMetricsPqControls = {};

export type InputWindowsMetricsPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputWindowsMetricsPqMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputWindowsMetricsCompression | undefined;
  pqControls?: InputWindowsMetricsPqControls | undefined;
};

/**
 * Select level of detail for host metrics
 */
export const InputWindowsMetricsHostMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select level of detail for host metrics
 */
export type InputWindowsMetricsHostMode = OpenEnum<
  typeof InputWindowsMetricsHostMode
>;

/**
 * Select the level of details for system metrics
 */
export const InputWindowsMetricsSystemMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for system metrics
 */
export type InputWindowsMetricsSystemMode = OpenEnum<
  typeof InputWindowsMetricsSystemMode
>;

export type InputWindowsMetricsSystem = {
  /**
   * Select the level of details for system metrics
   */
  mode?: InputWindowsMetricsSystemMode | undefined;
  /**
   * Generate metrics for all system information
   */
  detail?: boolean | undefined;
};

/**
 * Select the level of details for CPU metrics
 */
export const InputWindowsMetricsCpuMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for CPU metrics
 */
export type InputWindowsMetricsCpuMode = OpenEnum<
  typeof InputWindowsMetricsCpuMode
>;

export type InputWindowsMetricsCpu = {
  /**
   * Select the level of details for CPU metrics
   */
  mode?: InputWindowsMetricsCpuMode | undefined;
  /**
   * Generate metrics for each CPU
   */
  perCpu?: boolean | undefined;
  /**
   * Generate metrics for all CPU states
   */
  detail?: boolean | undefined;
  /**
   * Generate raw, monotonic CPU time counters
   */
  time?: boolean | undefined;
};

/**
 * Select the level of details for memory metrics
 */
export const InputWindowsMetricsMemoryMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for memory metrics
 */
export type InputWindowsMetricsMemoryMode = OpenEnum<
  typeof InputWindowsMetricsMemoryMode
>;

export type InputWindowsMetricsMemory = {
  /**
   * Select the level of details for memory metrics
   */
  mode?: InputWindowsMetricsMemoryMode | undefined;
  /**
   * Generate metrics for all memory states
   */
  detail?: boolean | undefined;
};

/**
 * Select the level of details for network metrics
 */
export const InputWindowsMetricsNetworkMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for network metrics
 */
export type InputWindowsMetricsNetworkMode = OpenEnum<
  typeof InputWindowsMetricsNetworkMode
>;

export type InputWindowsMetricsNetwork = {
  /**
   * Select the level of details for network metrics
   */
  mode?: InputWindowsMetricsNetworkMode | undefined;
  /**
   * Generate full network metrics
   */
  detail?: boolean | undefined;
  /**
   * Generate protocol metrics for ICMP, ICMPMsg, IP, TCP, UDP and UDPLite
   */
  protocols?: boolean | undefined;
  /**
   * Network interfaces to include/exclude. All interfaces are included if this list is empty.
   */
  devices?: Array<string> | undefined;
  /**
   * Generate separate metrics for each interface
   */
  perInterface?: boolean | undefined;
};

/**
 * Select the level of details for disk metrics
 */
export const InputWindowsMetricsDiskMode = {
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * All
   */
  All: "all",
  /**
   * Custom
   */
  Custom: "custom",
  /**
   * Disabled
   */
  Disabled: "disabled",
} as const;
/**
 * Select the level of details for disk metrics
 */
export type InputWindowsMetricsDiskMode = OpenEnum<
  typeof InputWindowsMetricsDiskMode
>;

export type InputWindowsMetricsDisk = {
  /**
   * Select the level of details for disk metrics
   */
  mode?: InputWindowsMetricsDiskMode | undefined;
  /**
   * Generate separate metrics for each volume
   */
  perVolume?: boolean | undefined;
  /**
   * Generate full disk metrics
   */
  detail?: boolean | undefined;
  /**
   * Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty.
   */
  volumes?: Array<string> | undefined;
};

export type InputWindowsMetricsCustom = {
  system?: InputWindowsMetricsSystem | undefined;
  cpu?: InputWindowsMetricsCpu | undefined;
  memory?: InputWindowsMetricsMemory | undefined;
  network?: InputWindowsMetricsNetwork | undefined;
  disk?: InputWindowsMetricsDisk | undefined;
};

export type InputWindowsMetricsHost = {
  /**
   * Select level of detail for host metrics
   */
  mode?: InputWindowsMetricsHostMode | undefined;
  custom?: InputWindowsMetricsCustom | undefined;
};

export type InputWindowsMetricsSet = {
  name: string;
  filter: string;
  includeChildren?: boolean | undefined;
};

export type InputWindowsMetricsProcess = {
  /**
   * Configure sets to collect process metrics
   */
  sets?: Array<InputWindowsMetricsSet> | undefined;
};

export type InputWindowsMetricsMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export const InputWindowsMetricsDataCompressionFormat = {
  None: "none",
  Gzip: "gzip",
} as const;
export type InputWindowsMetricsDataCompressionFormat = OpenEnum<
  typeof InputWindowsMetricsDataCompressionFormat
>;

export type InputWindowsMetricsPersistence = {
  /**
   * Spool metrics to disk for Cribl Edge and Search
   */
  enable?: boolean | undefined;
  /**
   * Time span for each file bucket
   */
  timeWindow?: string | undefined;
  /**
   * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted.
   */
  maxDataSize?: string | undefined;
  /**
   * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted.
   */
  maxDataTime?: string | undefined;
  compress?: InputWindowsMetricsDataCompressionFormat | undefined;
  /**
   * Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics
   */
  destPath?: string | undefined;
};

export type InputWindowsMetrics = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: "windows_metrics";
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputWindowsMetricsConnection> | undefined;
  pq?: InputWindowsMetricsPq | undefined;
  /**
   * Time, in seconds, between consecutive metric collections. Default is 10 seconds.
   */
  interval?: number | undefined;
  host?: InputWindowsMetricsHost | undefined;
  process?: InputWindowsMetricsProcess | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputWindowsMetricsMetadatum> | undefined;
  persistence?: InputWindowsMetricsPersistence | undefined;
  /**
   * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab)
   */
  disableNativeModule?: boolean | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputWindowsMetricsConnection$inboundSchema: z.ZodType<
  InputWindowsMetricsConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});
/** @internal */
export type InputWindowsMetricsConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputWindowsMetricsConnection$outboundSchema: z.ZodType<
  InputWindowsMetricsConnection$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

export function inputWindowsMetricsConnectionToJSON(
  inputWindowsMetricsConnection: InputWindowsMetricsConnection,
): string {
  return JSON.stringify(
    InputWindowsMetricsConnection$outboundSchema.parse(
      inputWindowsMetricsConnection,
    ),
  );
}
export function inputWindowsMetricsConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsConnection' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsPqMode$inboundSchema: z.ZodType<
  InputWindowsMetricsPqMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsPqMode);
/** @internal */
export const InputWindowsMetricsPqMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsPqMode
> = openEnums.outboundSchema(InputWindowsMetricsPqMode);

/** @internal */
export const InputWindowsMetricsCompression$inboundSchema: z.ZodType<
  InputWindowsMetricsCompression,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsCompression);
/** @internal */
export const InputWindowsMetricsCompression$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsCompression
> = openEnums.outboundSchema(InputWindowsMetricsCompression);

/** @internal */
export const InputWindowsMetricsPqControls$inboundSchema: z.ZodType<
  InputWindowsMetricsPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type InputWindowsMetricsPqControls$Outbound = {};

/** @internal */
export const InputWindowsMetricsPqControls$outboundSchema: z.ZodType<
  InputWindowsMetricsPqControls$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsPqControls
> = z.object({});

export function inputWindowsMetricsPqControlsToJSON(
  inputWindowsMetricsPqControls: InputWindowsMetricsPqControls,
): string {
  return JSON.stringify(
    InputWindowsMetricsPqControls$outboundSchema.parse(
      inputWindowsMetricsPqControls,
    ),
  );
}
export function inputWindowsMetricsPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsPqControls' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsPq$inboundSchema: z.ZodType<
  InputWindowsMetricsPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsPqMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWindowsMetricsCompression$inboundSchema.default("none"),
  pqControls: z.lazy(() => InputWindowsMetricsPqControls$inboundSchema)
    .optional(),
});
/** @internal */
export type InputWindowsMetricsPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
  pqControls?: InputWindowsMetricsPqControls$Outbound | undefined;
};

/** @internal */
export const InputWindowsMetricsPq$outboundSchema: z.ZodType<
  InputWindowsMetricsPq$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsPq
> = z.object({
  mode: InputWindowsMetricsPqMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputWindowsMetricsCompression$outboundSchema.default("none"),
  pqControls: z.lazy(() => InputWindowsMetricsPqControls$outboundSchema)
    .optional(),
});

export function inputWindowsMetricsPqToJSON(
  inputWindowsMetricsPq: InputWindowsMetricsPq,
): string {
  return JSON.stringify(
    InputWindowsMetricsPq$outboundSchema.parse(inputWindowsMetricsPq),
  );
}
export function inputWindowsMetricsPqFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsPq' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsHostMode$inboundSchema: z.ZodType<
  InputWindowsMetricsHostMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsHostMode);
/** @internal */
export const InputWindowsMetricsHostMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsHostMode
> = openEnums.outboundSchema(InputWindowsMetricsHostMode);

/** @internal */
export const InputWindowsMetricsSystemMode$inboundSchema: z.ZodType<
  InputWindowsMetricsSystemMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsSystemMode);
/** @internal */
export const InputWindowsMetricsSystemMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsSystemMode
> = openEnums.outboundSchema(InputWindowsMetricsSystemMode);

/** @internal */
export const InputWindowsMetricsSystem$inboundSchema: z.ZodType<
  InputWindowsMetricsSystem,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsSystemMode$inboundSchema.default("basic"),
  detail: z.boolean().default(false),
});
/** @internal */
export type InputWindowsMetricsSystem$Outbound = {
  mode: string;
  detail: boolean;
};

/** @internal */
export const InputWindowsMetricsSystem$outboundSchema: z.ZodType<
  InputWindowsMetricsSystem$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsSystem
> = z.object({
  mode: InputWindowsMetricsSystemMode$outboundSchema.default("basic"),
  detail: z.boolean().default(false),
});

export function inputWindowsMetricsSystemToJSON(
  inputWindowsMetricsSystem: InputWindowsMetricsSystem,
): string {
  return JSON.stringify(
    InputWindowsMetricsSystem$outboundSchema.parse(inputWindowsMetricsSystem),
  );
}
export function inputWindowsMetricsSystemFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsSystem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsSystem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsSystem' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsCpuMode$inboundSchema: z.ZodType<
  InputWindowsMetricsCpuMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsCpuMode);
/** @internal */
export const InputWindowsMetricsCpuMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsCpuMode
> = openEnums.outboundSchema(InputWindowsMetricsCpuMode);

/** @internal */
export const InputWindowsMetricsCpu$inboundSchema: z.ZodType<
  InputWindowsMetricsCpu,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsCpuMode$inboundSchema.default("basic"),
  perCpu: z.boolean().default(false),
  detail: z.boolean().default(false),
  time: z.boolean().default(false),
});
/** @internal */
export type InputWindowsMetricsCpu$Outbound = {
  mode: string;
  perCpu: boolean;
  detail: boolean;
  time: boolean;
};

/** @internal */
export const InputWindowsMetricsCpu$outboundSchema: z.ZodType<
  InputWindowsMetricsCpu$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsCpu
> = z.object({
  mode: InputWindowsMetricsCpuMode$outboundSchema.default("basic"),
  perCpu: z.boolean().default(false),
  detail: z.boolean().default(false),
  time: z.boolean().default(false),
});

export function inputWindowsMetricsCpuToJSON(
  inputWindowsMetricsCpu: InputWindowsMetricsCpu,
): string {
  return JSON.stringify(
    InputWindowsMetricsCpu$outboundSchema.parse(inputWindowsMetricsCpu),
  );
}
export function inputWindowsMetricsCpuFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsCpu, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsCpu$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsCpu' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsMemoryMode$inboundSchema: z.ZodType<
  InputWindowsMetricsMemoryMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsMemoryMode);
/** @internal */
export const InputWindowsMetricsMemoryMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsMemoryMode
> = openEnums.outboundSchema(InputWindowsMetricsMemoryMode);

/** @internal */
export const InputWindowsMetricsMemory$inboundSchema: z.ZodType<
  InputWindowsMetricsMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsMemoryMode$inboundSchema.default("basic"),
  detail: z.boolean().default(false),
});
/** @internal */
export type InputWindowsMetricsMemory$Outbound = {
  mode: string;
  detail: boolean;
};

/** @internal */
export const InputWindowsMetricsMemory$outboundSchema: z.ZodType<
  InputWindowsMetricsMemory$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsMemory
> = z.object({
  mode: InputWindowsMetricsMemoryMode$outboundSchema.default("basic"),
  detail: z.boolean().default(false),
});

export function inputWindowsMetricsMemoryToJSON(
  inputWindowsMetricsMemory: InputWindowsMetricsMemory,
): string {
  return JSON.stringify(
    InputWindowsMetricsMemory$outboundSchema.parse(inputWindowsMetricsMemory),
  );
}
export function inputWindowsMetricsMemoryFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsMemory' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsNetworkMode$inboundSchema: z.ZodType<
  InputWindowsMetricsNetworkMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsNetworkMode);
/** @internal */
export const InputWindowsMetricsNetworkMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsNetworkMode
> = openEnums.outboundSchema(InputWindowsMetricsNetworkMode);

/** @internal */
export const InputWindowsMetricsNetwork$inboundSchema: z.ZodType<
  InputWindowsMetricsNetwork,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsNetworkMode$inboundSchema.default("basic"),
  detail: z.boolean().default(false),
  protocols: z.boolean().default(false),
  devices: z.array(z.string()).optional(),
  perInterface: z.boolean().default(false),
});
/** @internal */
export type InputWindowsMetricsNetwork$Outbound = {
  mode: string;
  detail: boolean;
  protocols: boolean;
  devices?: Array<string> | undefined;
  perInterface: boolean;
};

/** @internal */
export const InputWindowsMetricsNetwork$outboundSchema: z.ZodType<
  InputWindowsMetricsNetwork$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsNetwork
> = z.object({
  mode: InputWindowsMetricsNetworkMode$outboundSchema.default("basic"),
  detail: z.boolean().default(false),
  protocols: z.boolean().default(false),
  devices: z.array(z.string()).optional(),
  perInterface: z.boolean().default(false),
});

export function inputWindowsMetricsNetworkToJSON(
  inputWindowsMetricsNetwork: InputWindowsMetricsNetwork,
): string {
  return JSON.stringify(
    InputWindowsMetricsNetwork$outboundSchema.parse(inputWindowsMetricsNetwork),
  );
}
export function inputWindowsMetricsNetworkFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsNetwork, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsNetwork$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsNetwork' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsDiskMode$inboundSchema: z.ZodType<
  InputWindowsMetricsDiskMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsDiskMode);
/** @internal */
export const InputWindowsMetricsDiskMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsDiskMode
> = openEnums.outboundSchema(InputWindowsMetricsDiskMode);

/** @internal */
export const InputWindowsMetricsDisk$inboundSchema: z.ZodType<
  InputWindowsMetricsDisk,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsDiskMode$inboundSchema.default("basic"),
  perVolume: z.boolean().default(false),
  detail: z.boolean().default(false),
  volumes: z.array(z.string()).optional(),
});
/** @internal */
export type InputWindowsMetricsDisk$Outbound = {
  mode: string;
  perVolume: boolean;
  detail: boolean;
  volumes?: Array<string> | undefined;
};

/** @internal */
export const InputWindowsMetricsDisk$outboundSchema: z.ZodType<
  InputWindowsMetricsDisk$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsDisk
> = z.object({
  mode: InputWindowsMetricsDiskMode$outboundSchema.default("basic"),
  perVolume: z.boolean().default(false),
  detail: z.boolean().default(false),
  volumes: z.array(z.string()).optional(),
});

export function inputWindowsMetricsDiskToJSON(
  inputWindowsMetricsDisk: InputWindowsMetricsDisk,
): string {
  return JSON.stringify(
    InputWindowsMetricsDisk$outboundSchema.parse(inputWindowsMetricsDisk),
  );
}
export function inputWindowsMetricsDiskFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsDisk, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsDisk$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsDisk' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsCustom$inboundSchema: z.ZodType<
  InputWindowsMetricsCustom,
  z.ZodTypeDef,
  unknown
> = z.object({
  system: z.lazy(() => InputWindowsMetricsSystem$inboundSchema).optional(),
  cpu: z.lazy(() => InputWindowsMetricsCpu$inboundSchema).optional(),
  memory: z.lazy(() => InputWindowsMetricsMemory$inboundSchema).optional(),
  network: z.lazy(() => InputWindowsMetricsNetwork$inboundSchema).optional(),
  disk: z.lazy(() => InputWindowsMetricsDisk$inboundSchema).optional(),
});
/** @internal */
export type InputWindowsMetricsCustom$Outbound = {
  system?: InputWindowsMetricsSystem$Outbound | undefined;
  cpu?: InputWindowsMetricsCpu$Outbound | undefined;
  memory?: InputWindowsMetricsMemory$Outbound | undefined;
  network?: InputWindowsMetricsNetwork$Outbound | undefined;
  disk?: InputWindowsMetricsDisk$Outbound | undefined;
};

/** @internal */
export const InputWindowsMetricsCustom$outboundSchema: z.ZodType<
  InputWindowsMetricsCustom$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsCustom
> = z.object({
  system: z.lazy(() => InputWindowsMetricsSystem$outboundSchema).optional(),
  cpu: z.lazy(() => InputWindowsMetricsCpu$outboundSchema).optional(),
  memory: z.lazy(() => InputWindowsMetricsMemory$outboundSchema).optional(),
  network: z.lazy(() => InputWindowsMetricsNetwork$outboundSchema).optional(),
  disk: z.lazy(() => InputWindowsMetricsDisk$outboundSchema).optional(),
});

export function inputWindowsMetricsCustomToJSON(
  inputWindowsMetricsCustom: InputWindowsMetricsCustom,
): string {
  return JSON.stringify(
    InputWindowsMetricsCustom$outboundSchema.parse(inputWindowsMetricsCustom),
  );
}
export function inputWindowsMetricsCustomFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsCustom, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsCustom$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsCustom' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsHost$inboundSchema: z.ZodType<
  InputWindowsMetricsHost,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputWindowsMetricsHostMode$inboundSchema.default("basic"),
  custom: z.lazy(() => InputWindowsMetricsCustom$inboundSchema).optional(),
});
/** @internal */
export type InputWindowsMetricsHost$Outbound = {
  mode: string;
  custom?: InputWindowsMetricsCustom$Outbound | undefined;
};

/** @internal */
export const InputWindowsMetricsHost$outboundSchema: z.ZodType<
  InputWindowsMetricsHost$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsHost
> = z.object({
  mode: InputWindowsMetricsHostMode$outboundSchema.default("basic"),
  custom: z.lazy(() => InputWindowsMetricsCustom$outboundSchema).optional(),
});

export function inputWindowsMetricsHostToJSON(
  inputWindowsMetricsHost: InputWindowsMetricsHost,
): string {
  return JSON.stringify(
    InputWindowsMetricsHost$outboundSchema.parse(inputWindowsMetricsHost),
  );
}
export function inputWindowsMetricsHostFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsHost, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsHost$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsHost' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsSet$inboundSchema: z.ZodType<
  InputWindowsMetricsSet,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  filter: z.string(),
  includeChildren: z.boolean().default(false),
});
/** @internal */
export type InputWindowsMetricsSet$Outbound = {
  name: string;
  filter: string;
  includeChildren: boolean;
};

/** @internal */
export const InputWindowsMetricsSet$outboundSchema: z.ZodType<
  InputWindowsMetricsSet$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsSet
> = z.object({
  name: z.string(),
  filter: z.string(),
  includeChildren: z.boolean().default(false),
});

export function inputWindowsMetricsSetToJSON(
  inputWindowsMetricsSet: InputWindowsMetricsSet,
): string {
  return JSON.stringify(
    InputWindowsMetricsSet$outboundSchema.parse(inputWindowsMetricsSet),
  );
}
export function inputWindowsMetricsSetFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsSet, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsSet$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsSet' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsProcess$inboundSchema: z.ZodType<
  InputWindowsMetricsProcess,
  z.ZodTypeDef,
  unknown
> = z.object({
  sets: z.array(z.lazy(() => InputWindowsMetricsSet$inboundSchema)).optional(),
});
/** @internal */
export type InputWindowsMetricsProcess$Outbound = {
  sets?: Array<InputWindowsMetricsSet$Outbound> | undefined;
};

/** @internal */
export const InputWindowsMetricsProcess$outboundSchema: z.ZodType<
  InputWindowsMetricsProcess$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsProcess
> = z.object({
  sets: z.array(z.lazy(() => InputWindowsMetricsSet$outboundSchema)).optional(),
});

export function inputWindowsMetricsProcessToJSON(
  inputWindowsMetricsProcess: InputWindowsMetricsProcess,
): string {
  return JSON.stringify(
    InputWindowsMetricsProcess$outboundSchema.parse(inputWindowsMetricsProcess),
  );
}
export function inputWindowsMetricsProcessFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsProcess, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsProcess$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsProcess' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsMetadatum$inboundSchema: z.ZodType<
  InputWindowsMetricsMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type InputWindowsMetricsMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputWindowsMetricsMetadatum$outboundSchema: z.ZodType<
  InputWindowsMetricsMetadatum$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function inputWindowsMetricsMetadatumToJSON(
  inputWindowsMetricsMetadatum: InputWindowsMetricsMetadatum,
): string {
  return JSON.stringify(
    InputWindowsMetricsMetadatum$outboundSchema.parse(
      inputWindowsMetricsMetadatum,
    ),
  );
}
export function inputWindowsMetricsMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsMetadatum' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetricsDataCompressionFormat$inboundSchema: z.ZodType<
  InputWindowsMetricsDataCompressionFormat,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(InputWindowsMetricsDataCompressionFormat);
/** @internal */
export const InputWindowsMetricsDataCompressionFormat$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  InputWindowsMetricsDataCompressionFormat
> = openEnums.outboundSchema(InputWindowsMetricsDataCompressionFormat);

/** @internal */
export const InputWindowsMetricsPersistence$inboundSchema: z.ZodType<
  InputWindowsMetricsPersistence,
  z.ZodTypeDef,
  unknown
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: InputWindowsMetricsDataCompressionFormat$inboundSchema.default(
    "gzip",
  ),
  destPath: z.string().default("$CRIBL_HOME/state/windows_metrics"),
});
/** @internal */
export type InputWindowsMetricsPersistence$Outbound = {
  enable: boolean;
  timeWindow: string;
  maxDataSize: string;
  maxDataTime: string;
  compress: string;
  destPath: string;
};

/** @internal */
export const InputWindowsMetricsPersistence$outboundSchema: z.ZodType<
  InputWindowsMetricsPersistence$Outbound,
  z.ZodTypeDef,
  InputWindowsMetricsPersistence
> = z.object({
  enable: z.boolean().default(false),
  timeWindow: z.string().default("10m"),
  maxDataSize: z.string().default("1GB"),
  maxDataTime: z.string().default("24h"),
  compress: InputWindowsMetricsDataCompressionFormat$outboundSchema.default(
    "gzip",
  ),
  destPath: z.string().default("$CRIBL_HOME/state/windows_metrics"),
});

export function inputWindowsMetricsPersistenceToJSON(
  inputWindowsMetricsPersistence: InputWindowsMetricsPersistence,
): string {
  return JSON.stringify(
    InputWindowsMetricsPersistence$outboundSchema.parse(
      inputWindowsMetricsPersistence,
    ),
  );
}
export function inputWindowsMetricsPersistenceFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetricsPersistence, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetricsPersistence$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetricsPersistence' from JSON`,
  );
}

/** @internal */
export const InputWindowsMetrics$inboundSchema: z.ZodType<
  InputWindowsMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: z.literal("windows_metrics"),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputWindowsMetricsConnection$inboundSchema),
  ).optional(),
  pq: z.lazy(() => InputWindowsMetricsPq$inboundSchema).optional(),
  interval: z.number().default(10),
  host: z.lazy(() => InputWindowsMetricsHost$inboundSchema).optional(),
  process: z.lazy(() => InputWindowsMetricsProcess$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputWindowsMetricsMetadatum$inboundSchema))
    .optional(),
  persistence: z.lazy(() => InputWindowsMetricsPersistence$inboundSchema)
    .optional(),
  disableNativeModule: z.boolean().default(false),
  description: z.string().optional(),
});
/** @internal */
export type InputWindowsMetrics$Outbound = {
  id?: string | undefined;
  type: "windows_metrics";
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputWindowsMetricsConnection$Outbound> | undefined;
  pq?: InputWindowsMetricsPq$Outbound | undefined;
  interval: number;
  host?: InputWindowsMetricsHost$Outbound | undefined;
  process?: InputWindowsMetricsProcess$Outbound | undefined;
  metadata?: Array<InputWindowsMetricsMetadatum$Outbound> | undefined;
  persistence?: InputWindowsMetricsPersistence$Outbound | undefined;
  disableNativeModule: boolean;
  description?: string | undefined;
};

/** @internal */
export const InputWindowsMetrics$outboundSchema: z.ZodType<
  InputWindowsMetrics$Outbound,
  z.ZodTypeDef,
  InputWindowsMetrics
> = z.object({
  id: z.string().optional(),
  type: z.literal("windows_metrics"),
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(
    z.lazy(() => InputWindowsMetricsConnection$outboundSchema),
  ).optional(),
  pq: z.lazy(() => InputWindowsMetricsPq$outboundSchema).optional(),
  interval: z.number().default(10),
  host: z.lazy(() => InputWindowsMetricsHost$outboundSchema).optional(),
  process: z.lazy(() => InputWindowsMetricsProcess$outboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputWindowsMetricsMetadatum$outboundSchema))
    .optional(),
  persistence: z.lazy(() => InputWindowsMetricsPersistence$outboundSchema)
    .optional(),
  disableNativeModule: z.boolean().default(false),
  description: z.string().optional(),
});

export function inputWindowsMetricsToJSON(
  inputWindowsMetrics: InputWindowsMetrics,
): string {
  return JSON.stringify(
    InputWindowsMetrics$outboundSchema.parse(inputWindowsMetrics),
  );
}
export function inputWindowsMetricsFromJSON(
  jsonString: string,
): SafeParseResult<InputWindowsMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputWindowsMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputWindowsMetrics' from JSON`,
  );
}
