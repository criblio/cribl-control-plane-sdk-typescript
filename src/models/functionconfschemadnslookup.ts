/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * The DNS record type (RR) to return. Defaults to 'A'.
 */
export const ResourceRecordType = {
  /**
   * A
   */
  A: "A",
  /**
   * AAAA
   */
  Aaaa: "AAAA",
  /**
   * ANY
   */
  Any: "ANY",
  /**
   * CNAME
   */
  Cname: "CNAME",
  /**
   * MX
   */
  Mx: "MX",
  /**
   * NAPTR
   */
  Naptr: "NAPTR",
  /**
   * NS
   */
  Ns: "NS",
  /**
   * PTR
   */
  Ptr: "PTR",
  /**
   * SOA
   */
  Soa: "SOA",
  /**
   * SRV
   */
  Srv: "SRV",
  /**
   * TXT
   */
  Txt: "TXT",
} as const;
/**
 * The DNS record type (RR) to return. Defaults to 'A'.
 */
export type ResourceRecordType = OpenEnum<typeof ResourceRecordType>;

export type DnsLookupField = {
  inFieldName?: string | undefined;
  /**
   * The DNS record type (RR) to return. Defaults to 'A'.
   */
  resourceRecordType?: ResourceRecordType | undefined;
  /**
   * Name of field to add lookup results to. Leave blank to overwrite the lookup field.
   */
  outFieldName?: string | undefined;
};

export type ReverseLookupField = {
  /**
   * Name of the field containing the IP to look up. If the field value is not in IPv4 or IPv6 format, the lookup is skipped.
   */
  inFieldName?: string | undefined;
  /**
   * Name of field to add the resolved domain to. Leave blank to overwrite the lookup field.
   */
  outFieldName?: string | undefined;
};

export const LogLevelForFailedLookups = {
  /**
   * silly
   */
  Silly: "silly",
  /**
   * debug
   */
  Debug: "debug",
  /**
   * info
   */
  Info: "info",
  /**
   * warn
   */
  Warn: "warn",
  /**
   * error
   */
  Error: "error",
} as const;
export type LogLevelForFailedLookups = OpenEnum<
  typeof LogLevelForFailedLookups
>;

export type FunctionConfSchemaDnsLookup = {
  /**
   * List of field names on which to perform DNS lookup
   */
  dnsLookupFields?: Array<DnsLookupField> | undefined;
  /**
   * List of field names on which to perform reverse DNS lookup
   */
  reverseLookupFields?: Array<ReverseLookupField> | undefined;
  /**
   * IPs, in RFC 5952 format, of the DNS servers to use for resolution. Examples: IPv4 1.1.1.1, 4.2.2.2:53, or IPv6 [2001:4860:4860::8888], [2001:4860:4860::8888]:1053. If not specified, system's DNS will be used.
   */
  dnsServers?: Array<string> | undefined;
  /**
   * How frequently to expire and refetch DNS cache. Use 0 to disable.
   */
  cacheTTL?: number | undefined;
  /**
   * The maximum number of DNS resolutions to be cached locally. Leave at default unless you understand the implications of changing.
   */
  maxCacheSize?: number | undefined;
  /**
   * Attempt to resolve DNS short names using the search or domain directive from /etc/resolv.conf
   */
  useResolvConf?: boolean | undefined;
  /**
   * If unable to resolve a DNS short name, make a DNS.lookup() call to resolve it. Caution: This might degrade performance in unrelated areas of @{product}.
   */
  lookupFallback?: boolean | undefined;
  /**
   * Specify fallback values for the DNS resolver to use when it cannot resolve a DNS short name
   */
  domainOverrides?: Array<string> | undefined;
  lookupFailLogLevel?: LogLevelForFailedLookups | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

/** @internal */
export const ResourceRecordType$inboundSchema: z.ZodType<
  ResourceRecordType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ResourceRecordType);
/** @internal */
export const ResourceRecordType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  ResourceRecordType
> = openEnums.outboundSchema(ResourceRecordType);

/** @internal */
export const DnsLookupField$inboundSchema: z.ZodType<
  DnsLookupField,
  z.ZodTypeDef,
  unknown
> = z.object({
  inFieldName: z.string().optional(),
  resourceRecordType: ResourceRecordType$inboundSchema.default("A"),
  outFieldName: z.string().optional(),
});
/** @internal */
export type DnsLookupField$Outbound = {
  inFieldName?: string | undefined;
  resourceRecordType: string;
  outFieldName?: string | undefined;
};

/** @internal */
export const DnsLookupField$outboundSchema: z.ZodType<
  DnsLookupField$Outbound,
  z.ZodTypeDef,
  DnsLookupField
> = z.object({
  inFieldName: z.string().optional(),
  resourceRecordType: ResourceRecordType$outboundSchema.default("A"),
  outFieldName: z.string().optional(),
});

export function dnsLookupFieldToJSON(dnsLookupField: DnsLookupField): string {
  return JSON.stringify(DnsLookupField$outboundSchema.parse(dnsLookupField));
}
export function dnsLookupFieldFromJSON(
  jsonString: string,
): SafeParseResult<DnsLookupField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DnsLookupField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DnsLookupField' from JSON`,
  );
}

/** @internal */
export const ReverseLookupField$inboundSchema: z.ZodType<
  ReverseLookupField,
  z.ZodTypeDef,
  unknown
> = z.object({
  inFieldName: z.string().optional(),
  outFieldName: z.string().optional(),
});
/** @internal */
export type ReverseLookupField$Outbound = {
  inFieldName?: string | undefined;
  outFieldName?: string | undefined;
};

/** @internal */
export const ReverseLookupField$outboundSchema: z.ZodType<
  ReverseLookupField$Outbound,
  z.ZodTypeDef,
  ReverseLookupField
> = z.object({
  inFieldName: z.string().optional(),
  outFieldName: z.string().optional(),
});

export function reverseLookupFieldToJSON(
  reverseLookupField: ReverseLookupField,
): string {
  return JSON.stringify(
    ReverseLookupField$outboundSchema.parse(reverseLookupField),
  );
}
export function reverseLookupFieldFromJSON(
  jsonString: string,
): SafeParseResult<ReverseLookupField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReverseLookupField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReverseLookupField' from JSON`,
  );
}

/** @internal */
export const LogLevelForFailedLookups$inboundSchema: z.ZodType<
  LogLevelForFailedLookups,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(LogLevelForFailedLookups);
/** @internal */
export const LogLevelForFailedLookups$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  LogLevelForFailedLookups
> = openEnums.outboundSchema(LogLevelForFailedLookups);

/** @internal */
export const FunctionConfSchemaDnsLookup$inboundSchema: z.ZodType<
  FunctionConfSchemaDnsLookup,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    dnsLookupFields: z.array(z.lazy(() => DnsLookupField$inboundSchema))
      .optional(),
    reverseLookupFields: z.array(z.lazy(() => ReverseLookupField$inboundSchema))
      .optional(),
    dnsServers: z.array(z.string()).optional(),
    cacheTTL: z.number().default(30),
    maxCacheSize: z.number().default(5000),
    useResolvConf: z.boolean().default(false),
    lookupFallback: z.boolean().default(false),
    domainOverrides: z.array(z.string()).optional(),
    lookupFailLogLevel: LogLevelForFailedLookups$inboundSchema.default("error"),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type FunctionConfSchemaDnsLookup$Outbound = {
  dnsLookupFields?: Array<DnsLookupField$Outbound> | undefined;
  reverseLookupFields?: Array<ReverseLookupField$Outbound> | undefined;
  dnsServers?: Array<string> | undefined;
  cacheTTL: number;
  maxCacheSize: number;
  useResolvConf: boolean;
  lookupFallback: boolean;
  domainOverrides?: Array<string> | undefined;
  lookupFailLogLevel: string;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const FunctionConfSchemaDnsLookup$outboundSchema: z.ZodType<
  FunctionConfSchemaDnsLookup$Outbound,
  z.ZodTypeDef,
  FunctionConfSchemaDnsLookup
> = z.object({
  dnsLookupFields: z.array(z.lazy(() => DnsLookupField$outboundSchema))
    .optional(),
  reverseLookupFields: z.array(z.lazy(() => ReverseLookupField$outboundSchema))
    .optional(),
  dnsServers: z.array(z.string()).optional(),
  cacheTTL: z.number().default(30),
  maxCacheSize: z.number().default(5000),
  useResolvConf: z.boolean().default(false),
  lookupFallback: z.boolean().default(false),
  domainOverrides: z.array(z.string()).optional(),
  lookupFailLogLevel: LogLevelForFailedLookups$outboundSchema.default("error"),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function functionConfSchemaDnsLookupToJSON(
  functionConfSchemaDnsLookup: FunctionConfSchemaDnsLookup,
): string {
  return JSON.stringify(
    FunctionConfSchemaDnsLookup$outboundSchema.parse(
      functionConfSchemaDnsLookup,
    ),
  );
}
export function functionConfSchemaDnsLookupFromJSON(
  jsonString: string,
): SafeParseResult<FunctionConfSchemaDnsLookup, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionConfSchemaDnsLookup$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionConfSchemaDnsLookup' from JSON`,
  );
}
