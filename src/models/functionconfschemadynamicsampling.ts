/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Defines how sample rate will be derived: log(previousPeriodCount) or sqrt(previousPeriodCount)
 */
export const SampleMode = {
  /**
   * Logarithmic
   */
  Log: "log",
  /**
   * Square Root
   */
  Sqrt: "sqrt",
} as const;
/**
 * Defines how sample rate will be derived: log(previousPeriodCount) or sqrt(previousPeriodCount)
 */
export type SampleMode = OpenEnum<typeof SampleMode>;

export type FunctionConfSchemaDynamicSampling = {
  /**
   * Defines how sample rate will be derived: log(previousPeriodCount) or sqrt(previousPeriodCount)
   */
  mode?: SampleMode | undefined;
  /**
   * Expression used to derive sample group key. Example:`${domain}:${status}`. Each sample group will have its own derived sampling rate based on volume. Defaults to `${host}`.
   */
  keyExpr?: string | undefined;
  /**
   * How often (in seconds) sample rates will be adjusted
   */
  samplePeriod?: number | undefined;
  /**
   * Minimum number of events that must be received in previous sample period for sampling mode to be applied to current period. If the number of events received for a sample group is less than this minimum, a sample rate of 1:1 is used.
   */
  minEvents?: number | undefined;
  /**
   * Maximum sampling rate. If computed sampling rate is above this value, it will be limited to this value.
   */
  maxSampleRate?: number | undefined;
};

/** @internal */
export const SampleMode$inboundSchema: z.ZodType<
  SampleMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(SampleMode);
/** @internal */
export const SampleMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  SampleMode
> = openEnums.outboundSchema(SampleMode);

/** @internal */
export const FunctionConfSchemaDynamicSampling$inboundSchema: z.ZodType<
  FunctionConfSchemaDynamicSampling,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: SampleMode$inboundSchema.optional(),
  keyExpr: z.string().optional(),
  samplePeriod: z.number().optional(),
  minEvents: z.number().optional(),
  maxSampleRate: z.number().optional(),
});
/** @internal */
export type FunctionConfSchemaDynamicSampling$Outbound = {
  mode?: string | undefined;
  keyExpr?: string | undefined;
  samplePeriod?: number | undefined;
  minEvents?: number | undefined;
  maxSampleRate?: number | undefined;
};

/** @internal */
export const FunctionConfSchemaDynamicSampling$outboundSchema: z.ZodType<
  FunctionConfSchemaDynamicSampling$Outbound,
  z.ZodTypeDef,
  FunctionConfSchemaDynamicSampling
> = z.object({
  mode: SampleMode$outboundSchema.optional(),
  keyExpr: z.string().optional(),
  samplePeriod: z.number().optional(),
  minEvents: z.number().optional(),
  maxSampleRate: z.number().optional(),
});

export function functionConfSchemaDynamicSamplingToJSON(
  functionConfSchemaDynamicSampling: FunctionConfSchemaDynamicSampling,
): string {
  return JSON.stringify(
    FunctionConfSchemaDynamicSampling$outboundSchema.parse(
      functionConfSchemaDynamicSampling,
    ),
  );
}
export function functionConfSchemaDynamicSamplingFromJSON(
  jsonString: string,
): SafeParseResult<FunctionConfSchemaDynamicSampling, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionConfSchemaDynamicSampling$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionConfSchemaDynamicSampling' from JSON`,
  );
}
