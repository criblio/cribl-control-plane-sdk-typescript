/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  AuthType2Options,
  AuthType2Options$inboundSchema,
  AuthType2Options$outboundSchema,
} from "./authtype2options.js";
import {
  ConnectionsType,
  ConnectionsType$inboundSchema,
  ConnectionsType$Outbound,
  ConnectionsType$outboundSchema,
} from "./connectionstype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata1Type,
  Metadata1Type$inboundSchema,
  Metadata1Type$Outbound,
  Metadata1Type$outboundSchema,
} from "./metadata1type.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  PreprocessType,
  PreprocessType$inboundSchema,
  PreprocessType$Outbound,
  PreprocessType$outboundSchema,
} from "./preprocesstype.js";
import {
  Tls2Type,
  Tls2Type$inboundSchema,
  Tls2Type$Outbound,
  Tls2Type$outboundSchema,
} from "./tls2type.js";

export const InputTcpType6 = {
  Tcp: "tcp",
} as const;
export type InputTcpType6 = ClosedEnum<typeof InputTcpType6>;

export type InputTcptcp6 = {
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputTcpType6;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: Tls2Type | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  preprocess?: PreprocessType | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputTcpType5 = {
  Tcp: "tcp",
} as const;
export type InputTcpType5 = ClosedEnum<typeof InputTcpType5>;

export type InputTcptcp5 = {
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputTcpType5;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: Tls2Type | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  preprocess?: PreprocessType | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputTcpType4 = {
  Tcp: "tcp",
} as const;
export type InputTcpType4 = ClosedEnum<typeof InputTcpType4>;

export type InputTcptcp4 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputTcpType4;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq: PqType;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: Tls2Type | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  preprocess?: PreprocessType | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputTcpType3 = {
  Tcp: "tcp",
} as const;
export type InputTcpType3 = ClosedEnum<typeof InputTcpType3>;

export type InputTcptcp3 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputTcpType3;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: Tls2Type | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  preprocess?: PreprocessType | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputTcpType2 = {
  Tcp: "tcp",
} as const;
export type InputTcpType2 = ClosedEnum<typeof InputTcpType2>;

export type InputTcptcp2 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputTcpType2;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections: Array<ConnectionsType>;
  pq?: PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: Tls2Type | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  preprocess?: PreprocessType | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export const InputTcpType1 = {
  Tcp: "tcp",
} as const;
export type InputTcpType1 = ClosedEnum<typeof InputTcpType1>;

export type InputTcptcp1 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputTcpType1;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Address to bind on. Defaults to 0.0.0.0 (all addresses).
   */
  host?: string | undefined;
  /**
   * Port to listen on
   */
  port: number;
  tls?: Tls2Type | undefined;
  /**
   * Regex matching IP addresses that are allowed to establish a connection
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited.
   */
  maxActiveCxn?: number | undefined;
  /**
   * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring.
   */
  socketIdleTimeout?: number | undefined;
  /**
   * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring.
   */
  socketEndingMaxWait?: number | undefined;
  /**
   * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable.
   */
  socketMaxLifespan?: number | undefined;
  /**
   * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2
   */
  enableProxyHeader?: boolean | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }
   */
  enableHeader?: boolean | undefined;
  preprocess?: PreprocessType | undefined;
  description?: string | undefined;
  /**
   * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted.
   */
  authToken?: string | undefined;
  /**
   * Enter credentials directly, or select a stored secret
   */
  authType?: AuthType2Options | undefined;
  /**
   * Select or create a stored text secret
   */
  textSecret?: string | undefined;
};

export type InputTcp =
  | InputTcptcp2
  | InputTcptcp4
  | InputTcptcp1
  | InputTcptcp3
  | InputTcptcp5
  | InputTcptcp6;

/** @internal */
export const InputTcpType6$inboundSchema: z.ZodNativeEnum<
  typeof InputTcpType6
> = z.nativeEnum(InputTcpType6);
/** @internal */
export const InputTcpType6$outboundSchema: z.ZodNativeEnum<
  typeof InputTcpType6
> = InputTcpType6$inboundSchema;

/** @internal */
export const InputTcptcp6$inboundSchema: z.ZodType<
  InputTcptcp6,
  z.ZodTypeDef,
  unknown
> = z.object({
  enableHeader: z.boolean().default(false),
  id: z.string().optional(),
  type: InputTcpType6$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  preprocess: PreprocessType$inboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$inboundSchema.default("manual"),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputTcptcp6$Outbound = {
  enableHeader: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: Tls2Type$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  preprocess?: PreprocessType$Outbound | undefined;
  description?: string | undefined;
  authToken: string;
  authType: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcptcp6$outboundSchema: z.ZodType<
  InputTcptcp6$Outbound,
  z.ZodTypeDef,
  InputTcptcp6
> = z.object({
  enableHeader: z.boolean().default(false),
  id: z.string().optional(),
  type: InputTcpType6$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  preprocess: PreprocessType$outboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$outboundSchema.default("manual"),
  textSecret: z.string().optional(),
});

export function inputTCPTCP6ToJSON(inputTcptcp6: InputTcptcp6): string {
  return JSON.stringify(InputTcptcp6$outboundSchema.parse(inputTcptcp6));
}
export function inputTCPTCP6FromJSON(
  jsonString: string,
): SafeParseResult<InputTcptcp6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcptcp6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcptcp6' from JSON`,
  );
}

/** @internal */
export const InputTcpType5$inboundSchema: z.ZodNativeEnum<
  typeof InputTcpType5
> = z.nativeEnum(InputTcpType5);
/** @internal */
export const InputTcpType5$outboundSchema: z.ZodNativeEnum<
  typeof InputTcpType5
> = InputTcpType5$inboundSchema;

/** @internal */
export const InputTcptcp5$inboundSchema: z.ZodType<
  InputTcptcp5,
  z.ZodTypeDef,
  unknown
> = z.object({
  enableHeader: z.boolean().default(false),
  id: z.string().optional(),
  type: InputTcpType5$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  preprocess: PreprocessType$inboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$inboundSchema.default("manual"),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputTcptcp5$Outbound = {
  enableHeader: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: Tls2Type$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  preprocess?: PreprocessType$Outbound | undefined;
  description?: string | undefined;
  authToken: string;
  authType: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcptcp5$outboundSchema: z.ZodType<
  InputTcptcp5$Outbound,
  z.ZodTypeDef,
  InputTcptcp5
> = z.object({
  enableHeader: z.boolean().default(false),
  id: z.string().optional(),
  type: InputTcpType5$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  preprocess: PreprocessType$outboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$outboundSchema.default("manual"),
  textSecret: z.string().optional(),
});

export function inputTCPTCP5ToJSON(inputTcptcp5: InputTcptcp5): string {
  return JSON.stringify(InputTcptcp5$outboundSchema.parse(inputTcptcp5));
}
export function inputTCPTCP5FromJSON(
  jsonString: string,
): SafeParseResult<InputTcptcp5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcptcp5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcptcp5' from JSON`,
  );
}

/** @internal */
export const InputTcpType4$inboundSchema: z.ZodNativeEnum<
  typeof InputTcpType4
> = z.nativeEnum(InputTcpType4);
/** @internal */
export const InputTcpType4$outboundSchema: z.ZodNativeEnum<
  typeof InputTcpType4
> = InputTcpType4$inboundSchema;

/** @internal */
export const InputTcptcp4$inboundSchema: z.ZodType<
  InputTcptcp4,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputTcpType4$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema,
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: PreprocessType$inboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$inboundSchema.default("manual"),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputTcptcp4$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq: PqType$Outbound;
  host: string;
  port: number;
  tls?: Tls2Type$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableHeader: boolean;
  preprocess?: PreprocessType$Outbound | undefined;
  description?: string | undefined;
  authToken: string;
  authType: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcptcp4$outboundSchema: z.ZodType<
  InputTcptcp4$Outbound,
  z.ZodTypeDef,
  InputTcptcp4
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputTcpType4$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema,
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: PreprocessType$outboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$outboundSchema.default("manual"),
  textSecret: z.string().optional(),
});

export function inputTCPTCP4ToJSON(inputTcptcp4: InputTcptcp4): string {
  return JSON.stringify(InputTcptcp4$outboundSchema.parse(inputTcptcp4));
}
export function inputTCPTCP4FromJSON(
  jsonString: string,
): SafeParseResult<InputTcptcp4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcptcp4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcptcp4' from JSON`,
  );
}

/** @internal */
export const InputTcpType3$inboundSchema: z.ZodNativeEnum<
  typeof InputTcpType3
> = z.nativeEnum(InputTcpType3);
/** @internal */
export const InputTcpType3$outboundSchema: z.ZodNativeEnum<
  typeof InputTcpType3
> = InputTcpType3$inboundSchema;

/** @internal */
export const InputTcptcp3$inboundSchema: z.ZodType<
  InputTcptcp3,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputTcpType3$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: PreprocessType$inboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$inboundSchema.default("manual"),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputTcptcp3$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: Tls2Type$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableHeader: boolean;
  preprocess?: PreprocessType$Outbound | undefined;
  description?: string | undefined;
  authToken: string;
  authType: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcptcp3$outboundSchema: z.ZodType<
  InputTcptcp3$Outbound,
  z.ZodTypeDef,
  InputTcptcp3
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputTcpType3$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: PreprocessType$outboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$outboundSchema.default("manual"),
  textSecret: z.string().optional(),
});

export function inputTCPTCP3ToJSON(inputTcptcp3: InputTcptcp3): string {
  return JSON.stringify(InputTcptcp3$outboundSchema.parse(inputTcptcp3));
}
export function inputTCPTCP3FromJSON(
  jsonString: string,
): SafeParseResult<InputTcptcp3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcptcp3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcptcp3' from JSON`,
  );
}

/** @internal */
export const InputTcpType2$inboundSchema: z.ZodNativeEnum<
  typeof InputTcpType2
> = z.nativeEnum(InputTcpType2);
/** @internal */
export const InputTcpType2$outboundSchema: z.ZodNativeEnum<
  typeof InputTcpType2
> = InputTcpType2$inboundSchema;

/** @internal */
export const InputTcptcp2$inboundSchema: z.ZodType<
  InputTcptcp2,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputTcpType2$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema),
  pq: PqType$inboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: PreprocessType$inboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$inboundSchema.default("manual"),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputTcptcp2$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections: Array<ConnectionsType$Outbound>;
  pq?: PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: Tls2Type$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableHeader: boolean;
  preprocess?: PreprocessType$Outbound | undefined;
  description?: string | undefined;
  authToken: string;
  authType: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcptcp2$outboundSchema: z.ZodType<
  InputTcptcp2$Outbound,
  z.ZodTypeDef,
  InputTcptcp2
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputTcpType2$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema),
  pq: PqType$outboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: PreprocessType$outboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$outboundSchema.default("manual"),
  textSecret: z.string().optional(),
});

export function inputTCPTCP2ToJSON(inputTcptcp2: InputTcptcp2): string {
  return JSON.stringify(InputTcptcp2$outboundSchema.parse(inputTcptcp2));
}
export function inputTCPTCP2FromJSON(
  jsonString: string,
): SafeParseResult<InputTcptcp2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcptcp2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcptcp2' from JSON`,
  );
}

/** @internal */
export const InputTcpType1$inboundSchema: z.ZodNativeEnum<
  typeof InputTcpType1
> = z.nativeEnum(InputTcpType1);
/** @internal */
export const InputTcpType1$outboundSchema: z.ZodNativeEnum<
  typeof InputTcpType1
> = InputTcpType1$inboundSchema;

/** @internal */
export const InputTcptcp1$inboundSchema: z.ZodType<
  InputTcptcp1,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputTcpType1$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$inboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: PreprocessType$inboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$inboundSchema.default("manual"),
  textSecret: z.string().optional(),
});
/** @internal */
export type InputTcptcp1$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  host: string;
  port: number;
  tls?: Tls2Type$Outbound | undefined;
  ipWhitelistRegex: string;
  maxActiveCxn: number;
  socketIdleTimeout: number;
  socketEndingMaxWait: number;
  socketMaxLifespan: number;
  enableProxyHeader: boolean;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  enableHeader: boolean;
  preprocess?: PreprocessType$Outbound | undefined;
  description?: string | undefined;
  authToken: string;
  authType: string;
  textSecret?: string | undefined;
};

/** @internal */
export const InputTcptcp1$outboundSchema: z.ZodType<
  InputTcptcp1$Outbound,
  z.ZodTypeDef,
  InputTcptcp1
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputTcpType1$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  port: z.number(),
  tls: Tls2Type$outboundSchema.optional(),
  ipWhitelistRegex: z.string().default("/.*/"),
  maxActiveCxn: z.number().default(1000),
  socketIdleTimeout: z.number().default(0),
  socketEndingMaxWait: z.number().default(30),
  socketMaxLifespan: z.number().default(0),
  enableProxyHeader: z.boolean().default(false),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  enableHeader: z.boolean().default(false),
  preprocess: PreprocessType$outboundSchema.optional(),
  description: z.string().optional(),
  authToken: z.string().default(""),
  authType: AuthType2Options$outboundSchema.default("manual"),
  textSecret: z.string().optional(),
});

export function inputTCPTCP1ToJSON(inputTcptcp1: InputTcptcp1): string {
  return JSON.stringify(InputTcptcp1$outboundSchema.parse(inputTcptcp1));
}
export function inputTCPTCP1FromJSON(
  jsonString: string,
): SafeParseResult<InputTcptcp1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcptcp1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcptcp1' from JSON`,
  );
}

/** @internal */
export const InputTcp$inboundSchema: z.ZodType<
  InputTcp,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputTcptcp2$inboundSchema),
  z.lazy(() => InputTcptcp4$inboundSchema),
  z.lazy(() => InputTcptcp1$inboundSchema),
  z.lazy(() => InputTcptcp3$inboundSchema),
  z.lazy(() => InputTcptcp5$inboundSchema),
  z.lazy(() => InputTcptcp6$inboundSchema),
]);
/** @internal */
export type InputTcp$Outbound =
  | InputTcptcp2$Outbound
  | InputTcptcp4$Outbound
  | InputTcptcp1$Outbound
  | InputTcptcp3$Outbound
  | InputTcptcp5$Outbound
  | InputTcptcp6$Outbound;

/** @internal */
export const InputTcp$outboundSchema: z.ZodType<
  InputTcp$Outbound,
  z.ZodTypeDef,
  InputTcp
> = z.union([
  z.lazy(() => InputTcptcp2$outboundSchema),
  z.lazy(() => InputTcptcp4$outboundSchema),
  z.lazy(() => InputTcptcp1$outboundSchema),
  z.lazy(() => InputTcptcp3$outboundSchema),
  z.lazy(() => InputTcptcp5$outboundSchema),
  z.lazy(() => InputTcptcp6$outboundSchema),
]);

export function inputTcpToJSON(inputTcp: InputTcp): string {
  return JSON.stringify(InputTcp$outboundSchema.parse(inputTcp));
}
export function inputTcpFromJSON(
  jsonString: string,
): SafeParseResult<InputTcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTcp' from JSON`,
  );
}
