/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  OutputModeOptionsSplunkCollectorConf,
  OutputModeOptionsSplunkCollectorConf$inboundSchema,
  OutputModeOptionsSplunkCollectorConf$outboundSchema,
} from "./outputmodeoptionssplunkcollectorconf.js";

export type SplunkAuthenticationTokenSecretCollectRequestParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type SplunkAuthenticationTokenSecretCollectRequestHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
};

export type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type SplunkAuthenticationTokenSecretRetryRules =
  | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone
  | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic
  | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type SplunkAuthenticationTokenSecret = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication: "tokenSecret";
  /**
   * Select or create a stored secret that references your Bearer token
   */
  tokenSecret: string;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead: string;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint: string;
  /**
   * Format of the returned output
   */
  outputMode: OutputModeOptionsSplunkCollectorConf;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?:
    | Array<SplunkAuthenticationTokenSecretCollectRequestParam>
    | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?:
    | Array<SplunkAuthenticationTokenSecretCollectRequestHeader>
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?:
    | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone
    | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic
    | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
};

export type SplunkAuthenticationTokenCollectRequestParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type SplunkAuthenticationTokenCollectRequestHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type SplunkAuthenticationTokenSplunkRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
};

export type SplunkAuthenticationTokenSplunkRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type SplunkAuthenticationTokenRetryRules =
  | SplunkAuthenticationTokenSplunkRetryRulesTypeNone
  | SplunkAuthenticationTokenSplunkRetryRulesTypeStatic
  | SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type SplunkAuthenticationToken = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication: "token";
  token: string;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead: string;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint: string;
  /**
   * Format of the returned output
   */
  outputMode: OutputModeOptionsSplunkCollectorConf;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?:
    | Array<SplunkAuthenticationTokenCollectRequestParam>
    | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?:
    | Array<SplunkAuthenticationTokenCollectRequestHeader>
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?:
    | SplunkAuthenticationTokenSplunkRetryRulesTypeNone
    | SplunkAuthenticationTokenSplunkRetryRulesTypeStatic
    | SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
};

export type SplunkAuthenticationBasicSecretCollectRequestParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type SplunkAuthenticationBasicSecretCollectRequestHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
};

export type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type SplunkAuthenticationBasicSecretRetryRules =
  | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone
  | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic
  | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type SplunkAuthenticationBasicSecret = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication: "basicSecret";
  /**
   * Select or create a stored secret that references your credentials
   */
  credentialsSecret: string;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead: string;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint: string;
  /**
   * Format of the returned output
   */
  outputMode: OutputModeOptionsSplunkCollectorConf;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?:
    | Array<SplunkAuthenticationBasicSecretCollectRequestParam>
    | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?:
    | Array<SplunkAuthenticationBasicSecretCollectRequestHeader>
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?:
    | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone
    | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic
    | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
};

export type SplunkAuthenticationBasicCollectRequestParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type SplunkAuthenticationBasicCollectRequestHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type SplunkAuthenticationBasicSplunkRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
};

export type SplunkAuthenticationBasicSplunkRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type SplunkAuthenticationBasicRetryRules =
  | SplunkAuthenticationBasicSplunkRetryRulesTypeNone
  | SplunkAuthenticationBasicSplunkRetryRulesTypeStatic
  | SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type SplunkAuthenticationBasic = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication: "basic";
  /**
   * Basic authentication username
   */
  username: string;
  /**
   * Basic authentication password
   */
  password: string;
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead: string;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint: string;
  /**
   * Format of the returned output
   */
  outputMode: OutputModeOptionsSplunkCollectorConf;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?:
    | Array<SplunkAuthenticationBasicCollectRequestParam>
    | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?:
    | Array<SplunkAuthenticationBasicCollectRequestHeader>
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?:
    | SplunkAuthenticationBasicSplunkRetryRulesTypeNone
    | SplunkAuthenticationBasicSplunkRetryRulesTypeStatic
    | SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
};

export type SplunkAuthenticationNoneCollectRequestParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type SplunkAuthenticationNoneCollectRequestHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type SplunkAuthenticationNoneSplunkRetryRulesTypeStatic = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
};

export type SplunkAuthenticationNoneSplunkRetryRulesTypeNone = {
  /**
   * The algorithm to use when performing HTTP retries
   */
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type SplunkAuthenticationNoneRetryRules =
  | SplunkAuthenticationNoneSplunkRetryRulesTypeNone
  | SplunkAuthenticationNoneSplunkRetryRulesTypeStatic
  | SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff
  | discriminatedUnionTypes.Unknown<"type">;

export type SplunkAuthenticationNone = {
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication: "none";
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead: string;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint: string;
  /**
   * Format of the returned output
   */
  outputMode: OutputModeOptionsSplunkCollectorConf;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?:
    | Array<SplunkAuthenticationNoneCollectRequestParam>
    | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?:
    | Array<SplunkAuthenticationNoneCollectRequestHeader>
    | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?:
    | SplunkAuthenticationNoneSplunkRetryRulesTypeNone
    | SplunkAuthenticationNoneSplunkRetryRulesTypeStatic
    | SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff
    | discriminatedUnionTypes.Unknown<"type">
    | undefined;
};

export type SplunkCollectorConf =
  | SplunkAuthenticationNone
  | SplunkAuthenticationBasic
  | SplunkAuthenticationBasicSecret
  | SplunkAuthenticationToken
  | SplunkAuthenticationTokenSecret
  | discriminatedUnionTypes.Unknown<"authentication">;

/** @internal */
export const SplunkAuthenticationTokenSecretCollectRequestParam$inboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSecretCollectRequestParam,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: types.string(),
    value: types.string(),
  });
/** @internal */
export type SplunkAuthenticationTokenSecretCollectRequestParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SplunkAuthenticationTokenSecretCollectRequestParam$outboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSecretCollectRequestParam$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationTokenSecretCollectRequestParam
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function splunkAuthenticationTokenSecretCollectRequestParamToJSON(
  splunkAuthenticationTokenSecretCollectRequestParam:
    SplunkAuthenticationTokenSecretCollectRequestParam,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenSecretCollectRequestParam$outboundSchema.parse(
      splunkAuthenticationTokenSecretCollectRequestParam,
    ),
  );
}
export function splunkAuthenticationTokenSecretCollectRequestParamFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationTokenSecretCollectRequestParam,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenSecretCollectRequestParam$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationTokenSecretCollectRequestParam' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenSecretCollectRequestHeader$inboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSecretCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: types.string(),
    value: types.string(),
  });
/** @internal */
export type SplunkAuthenticationTokenSecretCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SplunkAuthenticationTokenSecretCollectRequestHeader$outboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSecretCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationTokenSecretCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function splunkAuthenticationTokenSecretCollectRequestHeaderToJSON(
  splunkAuthenticationTokenSecretCollectRequestHeader:
    SplunkAuthenticationTokenSecretCollectRequestHeader,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenSecretCollectRequestHeader$outboundSchema.parse(
      splunkAuthenticationTokenSecretCollectRequestHeader,
    ),
  );
}
export function splunkAuthenticationTokenSecretCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationTokenSecretCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenSecretCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationTokenSecretCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$Outbound =
  {
    type: "backoff";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function splunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoffToJSON(
  splunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff:
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$outboundSchema
      .parse(splunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff),
  );
}
export function splunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$Outbound =
  {
    type: "static";
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
  };

/** @internal */
export const SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
  });

export function splunkAuthenticationTokenSecretSplunkRetryRulesTypeStaticToJSON(
  splunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic:
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$outboundSchema
      .parse(splunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic),
  );
}
export function splunkAuthenticationTokenSecretSplunkRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function splunkAuthenticationTokenSecretSplunkRetryRulesTypeNoneToJSON(
  splunkAuthenticationTokenSecretSplunkRetryRulesTypeNone:
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$outboundSchema
      .parse(splunkAuthenticationTokenSecretSplunkRetryRulesTypeNone),
  );
}
export function splunkAuthenticationTokenSecretSplunkRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenSecretRetryRules$inboundSchema: z.ZodType<
  SplunkAuthenticationTokenSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type SplunkAuthenticationTokenSecretRetryRules$Outbound =
  | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$Outbound
  | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$Outbound
  | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$Outbound;

/** @internal */
export const SplunkAuthenticationTokenSecretRetryRules$outboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSecretRetryRules$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationTokenSecretRetryRules
  > = z.union([
    z.lazy(() =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$outboundSchema
    ),
  ]);

export function splunkAuthenticationTokenSecretRetryRulesToJSON(
  splunkAuthenticationTokenSecretRetryRules:
    SplunkAuthenticationTokenSecretRetryRules,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenSecretRetryRules$outboundSchema.parse(
      splunkAuthenticationTokenSecretRetryRules,
    ),
  );
}
export function splunkAuthenticationTokenSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationTokenSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationTokenSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenSecret$inboundSchema: z.ZodType<
  SplunkAuthenticationTokenSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("tokenSecret"),
  tokenSecret: types.string(),
  searchHead: types.string(),
  search: types.string(),
  earliest: types.optional(types.string()),
  latest: types.optional(types.string()),
  endpoint: types.string(),
  outputMode: OutputModeOptionsSplunkCollectorConf$inboundSchema,
  collectRequestParams: types.optional(
    z.array(z.lazy(() =>
      SplunkAuthenticationTokenSecretCollectRequestParam$inboundSchema
    )),
  ),
  collectRequestHeaders: types.optional(
    z.array(z.lazy(() =>
      SplunkAuthenticationTokenSecretCollectRequestHeader$inboundSchema
    )),
  ),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  handleEscapedChars: types.optional(types.boolean()),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$inboundSchema
    ),
  })),
});
/** @internal */
export type SplunkAuthenticationTokenSecret$Outbound = {
  authentication: "tokenSecret";
  tokenSecret: string;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?:
    | Array<SplunkAuthenticationTokenSecretCollectRequestParam$Outbound>
    | undefined;
  collectRequestHeaders?:
    | Array<SplunkAuthenticationTokenSecretCollectRequestHeader$Outbound>
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  handleEscapedChars?: boolean | undefined;
  retryRules?:
    | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$Outbound
    | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$Outbound
    | SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$Outbound
    | undefined;
};

/** @internal */
export const SplunkAuthenticationTokenSecret$outboundSchema: z.ZodType<
  SplunkAuthenticationTokenSecret$Outbound,
  z.ZodTypeDef,
  SplunkAuthenticationTokenSecret
> = z.object({
  authentication: z.literal("tokenSecret"),
  tokenSecret: z.string(),
  searchHead: z.string(),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string(),
  outputMode: OutputModeOptionsSplunkCollectorConf$outboundSchema,
  collectRequestParams: z.array(
    z.lazy(() =>
      SplunkAuthenticationTokenSecretCollectRequestParam$outboundSchema
    ),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      SplunkAuthenticationTokenSecretCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  handleEscapedChars: z.boolean().optional(),
  retryRules: z.union([
    z.lazy(() =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationTokenSecretSplunkRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
});

export function splunkAuthenticationTokenSecretToJSON(
  splunkAuthenticationTokenSecret: SplunkAuthenticationTokenSecret,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenSecret$outboundSchema.parse(
      splunkAuthenticationTokenSecret,
    ),
  );
}
export function splunkAuthenticationTokenSecretFromJSON(
  jsonString: string,
): SafeParseResult<SplunkAuthenticationTokenSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SplunkAuthenticationTokenSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationTokenSecret' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenCollectRequestParam$inboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenCollectRequestParam,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: types.string(),
    value: types.string(),
  });
/** @internal */
export type SplunkAuthenticationTokenCollectRequestParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SplunkAuthenticationTokenCollectRequestParam$outboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenCollectRequestParam$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationTokenCollectRequestParam
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function splunkAuthenticationTokenCollectRequestParamToJSON(
  splunkAuthenticationTokenCollectRequestParam:
    SplunkAuthenticationTokenCollectRequestParam,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenCollectRequestParam$outboundSchema.parse(
      splunkAuthenticationTokenCollectRequestParam,
    ),
  );
}
export function splunkAuthenticationTokenCollectRequestParamFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationTokenCollectRequestParam,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenCollectRequestParam$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationTokenCollectRequestParam' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenCollectRequestHeader$inboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: types.string(),
    value: types.string(),
  });
/** @internal */
export type SplunkAuthenticationTokenCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SplunkAuthenticationTokenCollectRequestHeader$outboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationTokenCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function splunkAuthenticationTokenCollectRequestHeaderToJSON(
  splunkAuthenticationTokenCollectRequestHeader:
    SplunkAuthenticationTokenCollectRequestHeader,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenCollectRequestHeader$outboundSchema.parse(
      splunkAuthenticationTokenCollectRequestHeader,
    ),
  );
}
export function splunkAuthenticationTokenCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationTokenCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationTokenCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function splunkAuthenticationTokenSplunkRetryRulesTypeBackoffToJSON(
  splunkAuthenticationTokenSplunkRetryRulesTypeBackoff:
    SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$outboundSchema.parse(
      splunkAuthenticationTokenSplunkRetryRulesTypeBackoff,
    ),
  );
}
export function splunkAuthenticationTokenSplunkRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSplunkRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
};

/** @internal */
export const SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationTokenSplunkRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
  });

export function splunkAuthenticationTokenSplunkRetryRulesTypeStaticToJSON(
  splunkAuthenticationTokenSplunkRetryRulesTypeStatic:
    SplunkAuthenticationTokenSplunkRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$outboundSchema.parse(
      splunkAuthenticationTokenSplunkRetryRulesTypeStatic,
    ),
  );
}
export function splunkAuthenticationTokenSplunkRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationTokenSplunkRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationTokenSplunkRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenSplunkRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSplunkRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationTokenSplunkRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const SplunkAuthenticationTokenSplunkRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    SplunkAuthenticationTokenSplunkRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationTokenSplunkRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function splunkAuthenticationTokenSplunkRetryRulesTypeNoneToJSON(
  splunkAuthenticationTokenSplunkRetryRulesTypeNone:
    SplunkAuthenticationTokenSplunkRetryRulesTypeNone,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenSplunkRetryRulesTypeNone$outboundSchema.parse(
      splunkAuthenticationTokenSplunkRetryRulesTypeNone,
    ),
  );
}
export function splunkAuthenticationTokenSplunkRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationTokenSplunkRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenSplunkRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationTokenSplunkRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationTokenRetryRules$inboundSchema: z.ZodType<
  SplunkAuthenticationTokenRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    SplunkAuthenticationTokenSplunkRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type SplunkAuthenticationTokenRetryRules$Outbound =
  | SplunkAuthenticationTokenSplunkRetryRulesTypeNone$Outbound
  | SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$Outbound
  | SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$Outbound;

/** @internal */
export const SplunkAuthenticationTokenRetryRules$outboundSchema: z.ZodType<
  SplunkAuthenticationTokenRetryRules$Outbound,
  z.ZodTypeDef,
  SplunkAuthenticationTokenRetryRules
> = z.union([
  z.lazy(() =>
    SplunkAuthenticationTokenSplunkRetryRulesTypeNone$outboundSchema
  ),
  z.lazy(() =>
    SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$outboundSchema
  ),
  z.lazy(() =>
    SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$outboundSchema
  ),
]);

export function splunkAuthenticationTokenRetryRulesToJSON(
  splunkAuthenticationTokenRetryRules: SplunkAuthenticationTokenRetryRules,
): string {
  return JSON.stringify(
    SplunkAuthenticationTokenRetryRules$outboundSchema.parse(
      splunkAuthenticationTokenRetryRules,
    ),
  );
}
export function splunkAuthenticationTokenRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<SplunkAuthenticationTokenRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationTokenRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationTokenRetryRules' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationToken$inboundSchema: z.ZodType<
  SplunkAuthenticationToken,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("token"),
  token: types.string(),
  searchHead: types.string(),
  search: types.string(),
  earliest: types.optional(types.string()),
  latest: types.optional(types.string()),
  endpoint: types.string(),
  outputMode: OutputModeOptionsSplunkCollectorConf$inboundSchema,
  collectRequestParams: types.optional(
    z.array(z.lazy(() =>
      SplunkAuthenticationTokenCollectRequestParam$inboundSchema
    )),
  ),
  collectRequestHeaders: types.optional(
    z.array(z.lazy(() =>
      SplunkAuthenticationTokenCollectRequestHeader$inboundSchema
    )),
  ),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  handleEscapedChars: types.optional(types.boolean()),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      SplunkAuthenticationTokenSplunkRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$inboundSchema
    ),
  })),
});
/** @internal */
export type SplunkAuthenticationToken$Outbound = {
  authentication: "token";
  token: string;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?:
    | Array<SplunkAuthenticationTokenCollectRequestParam$Outbound>
    | undefined;
  collectRequestHeaders?:
    | Array<SplunkAuthenticationTokenCollectRequestHeader$Outbound>
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  handleEscapedChars?: boolean | undefined;
  retryRules?:
    | SplunkAuthenticationTokenSplunkRetryRulesTypeNone$Outbound
    | SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$Outbound
    | SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$Outbound
    | undefined;
};

/** @internal */
export const SplunkAuthenticationToken$outboundSchema: z.ZodType<
  SplunkAuthenticationToken$Outbound,
  z.ZodTypeDef,
  SplunkAuthenticationToken
> = z.object({
  authentication: z.literal("token"),
  token: z.string(),
  searchHead: z.string(),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string(),
  outputMode: OutputModeOptionsSplunkCollectorConf$outboundSchema,
  collectRequestParams: z.array(
    z.lazy(() => SplunkAuthenticationTokenCollectRequestParam$outboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => SplunkAuthenticationTokenCollectRequestHeader$outboundSchema),
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  handleEscapedChars: z.boolean().optional(),
  retryRules: z.union([
    z.lazy(() =>
      SplunkAuthenticationTokenSplunkRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationTokenSplunkRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationTokenSplunkRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
});

export function splunkAuthenticationTokenToJSON(
  splunkAuthenticationToken: SplunkAuthenticationToken,
): string {
  return JSON.stringify(
    SplunkAuthenticationToken$outboundSchema.parse(splunkAuthenticationToken),
  );
}
export function splunkAuthenticationTokenFromJSON(
  jsonString: string,
): SafeParseResult<SplunkAuthenticationToken, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SplunkAuthenticationToken$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationToken' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicSecretCollectRequestParam$inboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSecretCollectRequestParam,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: types.string(),
    value: types.string(),
  });
/** @internal */
export type SplunkAuthenticationBasicSecretCollectRequestParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SplunkAuthenticationBasicSecretCollectRequestParam$outboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSecretCollectRequestParam$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationBasicSecretCollectRequestParam
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function splunkAuthenticationBasicSecretCollectRequestParamToJSON(
  splunkAuthenticationBasicSecretCollectRequestParam:
    SplunkAuthenticationBasicSecretCollectRequestParam,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicSecretCollectRequestParam$outboundSchema.parse(
      splunkAuthenticationBasicSecretCollectRequestParam,
    ),
  );
}
export function splunkAuthenticationBasicSecretCollectRequestParamFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationBasicSecretCollectRequestParam,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicSecretCollectRequestParam$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationBasicSecretCollectRequestParam' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicSecretCollectRequestHeader$inboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSecretCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: types.string(),
    value: types.string(),
  });
/** @internal */
export type SplunkAuthenticationBasicSecretCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SplunkAuthenticationBasicSecretCollectRequestHeader$outboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSecretCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationBasicSecretCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function splunkAuthenticationBasicSecretCollectRequestHeaderToJSON(
  splunkAuthenticationBasicSecretCollectRequestHeader:
    SplunkAuthenticationBasicSecretCollectRequestHeader,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicSecretCollectRequestHeader$outboundSchema.parse(
      splunkAuthenticationBasicSecretCollectRequestHeader,
    ),
  );
}
export function splunkAuthenticationBasicSecretCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationBasicSecretCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicSecretCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationBasicSecretCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$Outbound =
  {
    type: "backoff";
    interval?: any | undefined;
    limit?: any | undefined;
    multiplier?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
  };

/** @internal */
export const SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function splunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoffToJSON(
  splunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff:
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$outboundSchema
      .parse(splunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff),
  );
}
export function splunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$Outbound =
  {
    type: "static";
    interval?: any | undefined;
    limit?: any | undefined;
    codes?: any | undefined;
    enableHeader?: any | undefined;
    retryConnectTimeout?: any | undefined;
    retryConnectReset?: any | undefined;
    multiplier?: any | undefined;
  };

/** @internal */
export const SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
  });

export function splunkAuthenticationBasicSecretSplunkRetryRulesTypeStaticToJSON(
  splunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic:
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$outboundSchema
      .parse(splunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic),
  );
}
export function splunkAuthenticationBasicSecretSplunkRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function splunkAuthenticationBasicSecretSplunkRetryRulesTypeNoneToJSON(
  splunkAuthenticationBasicSecretSplunkRetryRulesTypeNone:
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$outboundSchema
      .parse(splunkAuthenticationBasicSecretSplunkRetryRulesTypeNone),
  );
}
export function splunkAuthenticationBasicSecretSplunkRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicSecretRetryRules$inboundSchema: z.ZodType<
  SplunkAuthenticationBasicSecretRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type SplunkAuthenticationBasicSecretRetryRules$Outbound =
  | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$Outbound
  | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$Outbound
  | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$Outbound;

/** @internal */
export const SplunkAuthenticationBasicSecretRetryRules$outboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSecretRetryRules$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationBasicSecretRetryRules
  > = z.union([
    z.lazy(() =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$outboundSchema
    ),
  ]);

export function splunkAuthenticationBasicSecretRetryRulesToJSON(
  splunkAuthenticationBasicSecretRetryRules:
    SplunkAuthenticationBasicSecretRetryRules,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicSecretRetryRules$outboundSchema.parse(
      splunkAuthenticationBasicSecretRetryRules,
    ),
  );
}
export function splunkAuthenticationBasicSecretRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationBasicSecretRetryRules,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicSecretRetryRules$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationBasicSecretRetryRules' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicSecret$inboundSchema: z.ZodType<
  SplunkAuthenticationBasicSecret,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("basicSecret"),
  credentialsSecret: types.string(),
  searchHead: types.string(),
  search: types.string(),
  earliest: types.optional(types.string()),
  latest: types.optional(types.string()),
  endpoint: types.string(),
  outputMode: OutputModeOptionsSplunkCollectorConf$inboundSchema,
  collectRequestParams: types.optional(
    z.array(z.lazy(() =>
      SplunkAuthenticationBasicSecretCollectRequestParam$inboundSchema
    )),
  ),
  collectRequestHeaders: types.optional(
    z.array(z.lazy(() =>
      SplunkAuthenticationBasicSecretCollectRequestHeader$inboundSchema
    )),
  ),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  handleEscapedChars: types.optional(types.boolean()),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$inboundSchema
    ),
  })),
});
/** @internal */
export type SplunkAuthenticationBasicSecret$Outbound = {
  authentication: "basicSecret";
  credentialsSecret: string;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?:
    | Array<SplunkAuthenticationBasicSecretCollectRequestParam$Outbound>
    | undefined;
  collectRequestHeaders?:
    | Array<SplunkAuthenticationBasicSecretCollectRequestHeader$Outbound>
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  handleEscapedChars?: boolean | undefined;
  retryRules?:
    | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$Outbound
    | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$Outbound
    | SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$Outbound
    | undefined;
};

/** @internal */
export const SplunkAuthenticationBasicSecret$outboundSchema: z.ZodType<
  SplunkAuthenticationBasicSecret$Outbound,
  z.ZodTypeDef,
  SplunkAuthenticationBasicSecret
> = z.object({
  authentication: z.literal("basicSecret"),
  credentialsSecret: z.string(),
  searchHead: z.string(),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string(),
  outputMode: OutputModeOptionsSplunkCollectorConf$outboundSchema,
  collectRequestParams: z.array(
    z.lazy(() =>
      SplunkAuthenticationBasicSecretCollectRequestParam$outboundSchema
    ),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() =>
      SplunkAuthenticationBasicSecretCollectRequestHeader$outboundSchema
    ),
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  handleEscapedChars: z.boolean().optional(),
  retryRules: z.union([
    z.lazy(() =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationBasicSecretSplunkRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
});

export function splunkAuthenticationBasicSecretToJSON(
  splunkAuthenticationBasicSecret: SplunkAuthenticationBasicSecret,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicSecret$outboundSchema.parse(
      splunkAuthenticationBasicSecret,
    ),
  );
}
export function splunkAuthenticationBasicSecretFromJSON(
  jsonString: string,
): SafeParseResult<SplunkAuthenticationBasicSecret, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SplunkAuthenticationBasicSecret$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationBasicSecret' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicCollectRequestParam$inboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicCollectRequestParam,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: types.string(),
    value: types.string(),
  });
/** @internal */
export type SplunkAuthenticationBasicCollectRequestParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SplunkAuthenticationBasicCollectRequestParam$outboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicCollectRequestParam$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationBasicCollectRequestParam
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function splunkAuthenticationBasicCollectRequestParamToJSON(
  splunkAuthenticationBasicCollectRequestParam:
    SplunkAuthenticationBasicCollectRequestParam,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicCollectRequestParam$outboundSchema.parse(
      splunkAuthenticationBasicCollectRequestParam,
    ),
  );
}
export function splunkAuthenticationBasicCollectRequestParamFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationBasicCollectRequestParam,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicCollectRequestParam$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationBasicCollectRequestParam' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicCollectRequestHeader$inboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: types.string(),
    value: types.string(),
  });
/** @internal */
export type SplunkAuthenticationBasicCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SplunkAuthenticationBasicCollectRequestHeader$outboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationBasicCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function splunkAuthenticationBasicCollectRequestHeaderToJSON(
  splunkAuthenticationBasicCollectRequestHeader:
    SplunkAuthenticationBasicCollectRequestHeader,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicCollectRequestHeader$outboundSchema.parse(
      splunkAuthenticationBasicCollectRequestHeader,
    ),
  );
}
export function splunkAuthenticationBasicCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationBasicCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationBasicCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function splunkAuthenticationBasicSplunkRetryRulesTypeBackoffToJSON(
  splunkAuthenticationBasicSplunkRetryRulesTypeBackoff:
    SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$outboundSchema.parse(
      splunkAuthenticationBasicSplunkRetryRulesTypeBackoff,
    ),
  );
}
export function splunkAuthenticationBasicSplunkRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSplunkRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
};

/** @internal */
export const SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationBasicSplunkRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
  });

export function splunkAuthenticationBasicSplunkRetryRulesTypeStaticToJSON(
  splunkAuthenticationBasicSplunkRetryRulesTypeStatic:
    SplunkAuthenticationBasicSplunkRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$outboundSchema.parse(
      splunkAuthenticationBasicSplunkRetryRulesTypeStatic,
    ),
  );
}
export function splunkAuthenticationBasicSplunkRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationBasicSplunkRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationBasicSplunkRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicSplunkRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSplunkRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationBasicSplunkRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const SplunkAuthenticationBasicSplunkRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    SplunkAuthenticationBasicSplunkRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationBasicSplunkRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function splunkAuthenticationBasicSplunkRetryRulesTypeNoneToJSON(
  splunkAuthenticationBasicSplunkRetryRulesTypeNone:
    SplunkAuthenticationBasicSplunkRetryRulesTypeNone,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicSplunkRetryRulesTypeNone$outboundSchema.parse(
      splunkAuthenticationBasicSplunkRetryRulesTypeNone,
    ),
  );
}
export function splunkAuthenticationBasicSplunkRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationBasicSplunkRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicSplunkRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationBasicSplunkRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasicRetryRules$inboundSchema: z.ZodType<
  SplunkAuthenticationBasicRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    SplunkAuthenticationBasicSplunkRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type SplunkAuthenticationBasicRetryRules$Outbound =
  | SplunkAuthenticationBasicSplunkRetryRulesTypeNone$Outbound
  | SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$Outbound
  | SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$Outbound;

/** @internal */
export const SplunkAuthenticationBasicRetryRules$outboundSchema: z.ZodType<
  SplunkAuthenticationBasicRetryRules$Outbound,
  z.ZodTypeDef,
  SplunkAuthenticationBasicRetryRules
> = z.union([
  z.lazy(() =>
    SplunkAuthenticationBasicSplunkRetryRulesTypeNone$outboundSchema
  ),
  z.lazy(() =>
    SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$outboundSchema
  ),
  z.lazy(() =>
    SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$outboundSchema
  ),
]);

export function splunkAuthenticationBasicRetryRulesToJSON(
  splunkAuthenticationBasicRetryRules: SplunkAuthenticationBasicRetryRules,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasicRetryRules$outboundSchema.parse(
      splunkAuthenticationBasicRetryRules,
    ),
  );
}
export function splunkAuthenticationBasicRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<SplunkAuthenticationBasicRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationBasicRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationBasicRetryRules' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationBasic$inboundSchema: z.ZodType<
  SplunkAuthenticationBasic,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("basic"),
  username: types.string(),
  password: types.string(),
  searchHead: types.string(),
  search: types.string(),
  earliest: types.optional(types.string()),
  latest: types.optional(types.string()),
  endpoint: types.string(),
  outputMode: OutputModeOptionsSplunkCollectorConf$inboundSchema,
  collectRequestParams: types.optional(
    z.array(z.lazy(() =>
      SplunkAuthenticationBasicCollectRequestParam$inboundSchema
    )),
  ),
  collectRequestHeaders: types.optional(
    z.array(z.lazy(() =>
      SplunkAuthenticationBasicCollectRequestHeader$inboundSchema
    )),
  ),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  handleEscapedChars: types.optional(types.boolean()),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      SplunkAuthenticationBasicSplunkRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$inboundSchema
    ),
  })),
});
/** @internal */
export type SplunkAuthenticationBasic$Outbound = {
  authentication: "basic";
  username: string;
  password: string;
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?:
    | Array<SplunkAuthenticationBasicCollectRequestParam$Outbound>
    | undefined;
  collectRequestHeaders?:
    | Array<SplunkAuthenticationBasicCollectRequestHeader$Outbound>
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  handleEscapedChars?: boolean | undefined;
  retryRules?:
    | SplunkAuthenticationBasicSplunkRetryRulesTypeNone$Outbound
    | SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$Outbound
    | SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$Outbound
    | undefined;
};

/** @internal */
export const SplunkAuthenticationBasic$outboundSchema: z.ZodType<
  SplunkAuthenticationBasic$Outbound,
  z.ZodTypeDef,
  SplunkAuthenticationBasic
> = z.object({
  authentication: z.literal("basic"),
  username: z.string(),
  password: z.string(),
  searchHead: z.string(),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string(),
  outputMode: OutputModeOptionsSplunkCollectorConf$outboundSchema,
  collectRequestParams: z.array(
    z.lazy(() => SplunkAuthenticationBasicCollectRequestParam$outboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => SplunkAuthenticationBasicCollectRequestHeader$outboundSchema),
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  handleEscapedChars: z.boolean().optional(),
  retryRules: z.union([
    z.lazy(() =>
      SplunkAuthenticationBasicSplunkRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationBasicSplunkRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationBasicSplunkRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
});

export function splunkAuthenticationBasicToJSON(
  splunkAuthenticationBasic: SplunkAuthenticationBasic,
): string {
  return JSON.stringify(
    SplunkAuthenticationBasic$outboundSchema.parse(splunkAuthenticationBasic),
  );
}
export function splunkAuthenticationBasicFromJSON(
  jsonString: string,
): SafeParseResult<SplunkAuthenticationBasic, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SplunkAuthenticationBasic$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationBasic' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationNoneCollectRequestParam$inboundSchema:
  z.ZodType<
    SplunkAuthenticationNoneCollectRequestParam,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: types.string(),
    value: types.string(),
  });
/** @internal */
export type SplunkAuthenticationNoneCollectRequestParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SplunkAuthenticationNoneCollectRequestParam$outboundSchema:
  z.ZodType<
    SplunkAuthenticationNoneCollectRequestParam$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationNoneCollectRequestParam
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function splunkAuthenticationNoneCollectRequestParamToJSON(
  splunkAuthenticationNoneCollectRequestParam:
    SplunkAuthenticationNoneCollectRequestParam,
): string {
  return JSON.stringify(
    SplunkAuthenticationNoneCollectRequestParam$outboundSchema.parse(
      splunkAuthenticationNoneCollectRequestParam,
    ),
  );
}
export function splunkAuthenticationNoneCollectRequestParamFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationNoneCollectRequestParam,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationNoneCollectRequestParam$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationNoneCollectRequestParam' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationNoneCollectRequestHeader$inboundSchema:
  z.ZodType<
    SplunkAuthenticationNoneCollectRequestHeader,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: types.string(),
    value: types.string(),
  });
/** @internal */
export type SplunkAuthenticationNoneCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SplunkAuthenticationNoneCollectRequestHeader$outboundSchema:
  z.ZodType<
    SplunkAuthenticationNoneCollectRequestHeader$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationNoneCollectRequestHeader
  > = z.object({
    name: z.string(),
    value: z.string(),
  });

export function splunkAuthenticationNoneCollectRequestHeaderToJSON(
  splunkAuthenticationNoneCollectRequestHeader:
    SplunkAuthenticationNoneCollectRequestHeader,
): string {
  return JSON.stringify(
    SplunkAuthenticationNoneCollectRequestHeader$outboundSchema.parse(
      splunkAuthenticationNoneCollectRequestHeader,
    ),
  );
}
export function splunkAuthenticationNoneCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationNoneCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationNoneCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationNoneCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$inboundSchema:
  z.ZodType<
    SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("backoff"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$Outbound = {
  type: "backoff";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$outboundSchema:
  z.ZodType<
    SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff
  > = z.object({
    type: z.literal("backoff"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function splunkAuthenticationNoneSplunkRetryRulesTypeBackoffToJSON(
  splunkAuthenticationNoneSplunkRetryRulesTypeBackoff:
    SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff,
): string {
  return JSON.stringify(
    SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$outboundSchema.parse(
      splunkAuthenticationNoneSplunkRetryRulesTypeBackoff,
    ),
  );
}
export function splunkAuthenticationNoneSplunkRetryRulesTypeBackoffFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$inboundSchema:
  z.ZodType<
    SplunkAuthenticationNoneSplunkRetryRulesTypeStatic,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("static"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
    multiplier: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$Outbound = {
  type: "static";
  interval?: any | undefined;
  limit?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
  multiplier?: any | undefined;
};

/** @internal */
export const SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$outboundSchema:
  z.ZodType<
    SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationNoneSplunkRetryRulesTypeStatic
  > = z.object({
    type: z.literal("static"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
    multiplier: z.any().optional(),
  });

export function splunkAuthenticationNoneSplunkRetryRulesTypeStaticToJSON(
  splunkAuthenticationNoneSplunkRetryRulesTypeStatic:
    SplunkAuthenticationNoneSplunkRetryRulesTypeStatic,
): string {
  return JSON.stringify(
    SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$outboundSchema.parse(
      splunkAuthenticationNoneSplunkRetryRulesTypeStatic,
    ),
  );
}
export function splunkAuthenticationNoneSplunkRetryRulesTypeStaticFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationNoneSplunkRetryRulesTypeStatic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationNoneSplunkRetryRulesTypeStatic' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationNoneSplunkRetryRulesTypeNone$inboundSchema:
  z.ZodType<
    SplunkAuthenticationNoneSplunkRetryRulesTypeNone,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.literal("none"),
    interval: types.optional(z.any()),
    limit: types.optional(z.any()),
    multiplier: types.optional(z.any()),
    codes: types.optional(z.any()),
    enableHeader: types.optional(z.any()),
    retryConnectTimeout: types.optional(z.any()),
    retryConnectReset: types.optional(z.any()),
  });
/** @internal */
export type SplunkAuthenticationNoneSplunkRetryRulesTypeNone$Outbound = {
  type: "none";
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const SplunkAuthenticationNoneSplunkRetryRulesTypeNone$outboundSchema:
  z.ZodType<
    SplunkAuthenticationNoneSplunkRetryRulesTypeNone$Outbound,
    z.ZodTypeDef,
    SplunkAuthenticationNoneSplunkRetryRulesTypeNone
  > = z.object({
    type: z.literal("none"),
    interval: z.any().optional(),
    limit: z.any().optional(),
    multiplier: z.any().optional(),
    codes: z.any().optional(),
    enableHeader: z.any().optional(),
    retryConnectTimeout: z.any().optional(),
    retryConnectReset: z.any().optional(),
  });

export function splunkAuthenticationNoneSplunkRetryRulesTypeNoneToJSON(
  splunkAuthenticationNoneSplunkRetryRulesTypeNone:
    SplunkAuthenticationNoneSplunkRetryRulesTypeNone,
): string {
  return JSON.stringify(
    SplunkAuthenticationNoneSplunkRetryRulesTypeNone$outboundSchema.parse(
      splunkAuthenticationNoneSplunkRetryRulesTypeNone,
    ),
  );
}
export function splunkAuthenticationNoneSplunkRetryRulesTypeNoneFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkAuthenticationNoneSplunkRetryRulesTypeNone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationNoneSplunkRetryRulesTypeNone$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkAuthenticationNoneSplunkRetryRulesTypeNone' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationNoneRetryRules$inboundSchema: z.ZodType<
  SplunkAuthenticationNoneRetryRules,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("type", {
  none: z.lazy(() =>
    SplunkAuthenticationNoneSplunkRetryRulesTypeNone$inboundSchema
  ),
  static: z.lazy(() =>
    SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$inboundSchema
  ),
  backoff: z.lazy(() =>
    SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$inboundSchema
  ),
});
/** @internal */
export type SplunkAuthenticationNoneRetryRules$Outbound =
  | SplunkAuthenticationNoneSplunkRetryRulesTypeNone$Outbound
  | SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$Outbound
  | SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$Outbound;

/** @internal */
export const SplunkAuthenticationNoneRetryRules$outboundSchema: z.ZodType<
  SplunkAuthenticationNoneRetryRules$Outbound,
  z.ZodTypeDef,
  SplunkAuthenticationNoneRetryRules
> = z.union([
  z.lazy(() => SplunkAuthenticationNoneSplunkRetryRulesTypeNone$outboundSchema),
  z.lazy(() =>
    SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$outboundSchema
  ),
  z.lazy(() =>
    SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$outboundSchema
  ),
]);

export function splunkAuthenticationNoneRetryRulesToJSON(
  splunkAuthenticationNoneRetryRules: SplunkAuthenticationNoneRetryRules,
): string {
  return JSON.stringify(
    SplunkAuthenticationNoneRetryRules$outboundSchema.parse(
      splunkAuthenticationNoneRetryRules,
    ),
  );
}
export function splunkAuthenticationNoneRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<SplunkAuthenticationNoneRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkAuthenticationNoneRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationNoneRetryRules' from JSON`,
  );
}

/** @internal */
export const SplunkAuthenticationNone$inboundSchema: z.ZodType<
  SplunkAuthenticationNone,
  z.ZodTypeDef,
  unknown
> = z.object({
  authentication: types.literal("none"),
  searchHead: types.string(),
  search: types.string(),
  earliest: types.optional(types.string()),
  latest: types.optional(types.string()),
  endpoint: types.string(),
  outputMode: OutputModeOptionsSplunkCollectorConf$inboundSchema,
  collectRequestParams: types.optional(
    z.array(z.lazy(() =>
      SplunkAuthenticationNoneCollectRequestParam$inboundSchema
    )),
  ),
  collectRequestHeaders: types.optional(
    z.array(z.lazy(() =>
      SplunkAuthenticationNoneCollectRequestHeader$inboundSchema
    )),
  ),
  timeout: types.optional(types.number()),
  useRoundRobinDns: types.optional(types.boolean()),
  disableTimeFilter: types.optional(types.boolean()),
  rejectUnauthorized: types.optional(types.boolean()),
  handleEscapedChars: types.optional(types.boolean()),
  retryRules: types.optional(discriminatedUnion("type", {
    none: z.lazy(() =>
      SplunkAuthenticationNoneSplunkRetryRulesTypeNone$inboundSchema
    ),
    static: z.lazy(() =>
      SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$inboundSchema
    ),
    backoff: z.lazy(() =>
      SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$inboundSchema
    ),
  })),
});
/** @internal */
export type SplunkAuthenticationNone$Outbound = {
  authentication: "none";
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?:
    | Array<SplunkAuthenticationNoneCollectRequestParam$Outbound>
    | undefined;
  collectRequestHeaders?:
    | Array<SplunkAuthenticationNoneCollectRequestHeader$Outbound>
    | undefined;
  timeout?: number | undefined;
  useRoundRobinDns?: boolean | undefined;
  disableTimeFilter?: boolean | undefined;
  rejectUnauthorized?: boolean | undefined;
  handleEscapedChars?: boolean | undefined;
  retryRules?:
    | SplunkAuthenticationNoneSplunkRetryRulesTypeNone$Outbound
    | SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$Outbound
    | SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$Outbound
    | undefined;
};

/** @internal */
export const SplunkAuthenticationNone$outboundSchema: z.ZodType<
  SplunkAuthenticationNone$Outbound,
  z.ZodTypeDef,
  SplunkAuthenticationNone
> = z.object({
  authentication: z.literal("none"),
  searchHead: z.string(),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string(),
  outputMode: OutputModeOptionsSplunkCollectorConf$outboundSchema,
  collectRequestParams: z.array(
    z.lazy(() => SplunkAuthenticationNoneCollectRequestParam$outboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => SplunkAuthenticationNoneCollectRequestHeader$outboundSchema),
  ).optional(),
  timeout: z.number().optional(),
  useRoundRobinDns: z.boolean().optional(),
  disableTimeFilter: z.boolean().optional(),
  rejectUnauthorized: z.boolean().optional(),
  handleEscapedChars: z.boolean().optional(),
  retryRules: z.union([
    z.lazy(() =>
      SplunkAuthenticationNoneSplunkRetryRulesTypeNone$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationNoneSplunkRetryRulesTypeStatic$outboundSchema
    ),
    z.lazy(() =>
      SplunkAuthenticationNoneSplunkRetryRulesTypeBackoff$outboundSchema
    ),
  ]).optional(),
});

export function splunkAuthenticationNoneToJSON(
  splunkAuthenticationNone: SplunkAuthenticationNone,
): string {
  return JSON.stringify(
    SplunkAuthenticationNone$outboundSchema.parse(splunkAuthenticationNone),
  );
}
export function splunkAuthenticationNoneFromJSON(
  jsonString: string,
): SafeParseResult<SplunkAuthenticationNone, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SplunkAuthenticationNone$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplunkAuthenticationNone' from JSON`,
  );
}

/** @internal */
export const SplunkCollectorConf$inboundSchema: z.ZodType<
  SplunkCollectorConf,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("authentication", {
  none: z.lazy(() => SplunkAuthenticationNone$inboundSchema),
  basic: z.lazy(() => SplunkAuthenticationBasic$inboundSchema),
  basicSecret: z.lazy(() => SplunkAuthenticationBasicSecret$inboundSchema),
  token: z.lazy(() => SplunkAuthenticationToken$inboundSchema),
  tokenSecret: z.lazy(() => SplunkAuthenticationTokenSecret$inboundSchema),
});
/** @internal */
export type SplunkCollectorConf$Outbound =
  | SplunkAuthenticationNone$Outbound
  | SplunkAuthenticationBasic$Outbound
  | SplunkAuthenticationBasicSecret$Outbound
  | SplunkAuthenticationToken$Outbound
  | SplunkAuthenticationTokenSecret$Outbound;

/** @internal */
export const SplunkCollectorConf$outboundSchema: z.ZodType<
  SplunkCollectorConf$Outbound,
  z.ZodTypeDef,
  SplunkCollectorConf
> = z.union([
  z.lazy(() => SplunkAuthenticationNone$outboundSchema),
  z.lazy(() => SplunkAuthenticationBasic$outboundSchema),
  z.lazy(() => SplunkAuthenticationBasicSecret$outboundSchema),
  z.lazy(() => SplunkAuthenticationToken$outboundSchema),
  z.lazy(() => SplunkAuthenticationTokenSecret$outboundSchema),
]);

export function splunkCollectorConfToJSON(
  splunkCollectorConf: SplunkCollectorConf,
): string {
  return JSON.stringify(
    SplunkCollectorConf$outboundSchema.parse(splunkCollectorConf),
  );
}
export function splunkCollectorConfFromJSON(
  jsonString: string,
): SafeParseResult<SplunkCollectorConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SplunkCollectorConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplunkCollectorConf' from JSON`,
  );
}
