/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * Format of the returned output
 */
export const SplunkCollectorConfOutputMode = {
  Csv: "csv",
  Json: "json",
} as const;
/**
 * Format of the returned output
 */
export type SplunkCollectorConfOutputMode = OpenEnum<
  typeof SplunkCollectorConfOutputMode
>;

export type CollectRequestParam = {
  name: string;
  /**
   * JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

export type SplunkCollectorConfCollectRequestHeader = {
  name: string;
  /**
   * JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings.
   */
  value: string;
};

/**
 * Authentication method for Discover and Collect REST calls
 */
export const SplunkCollectorConfAuthentication = {
  /**
   * None
   */
  None: "none",
  /**
   * Basic
   */
  Basic: "basic",
  /**
   * Basic (credentials secret)
   */
  BasicSecret: "basicSecret",
  /**
   * Bearer Token
   */
  Token: "token",
  /**
   * Bearer Token (text secret)
   */
  TokenSecret: "tokenSecret",
} as const;
/**
 * Authentication method for Discover and Collect REST calls
 */
export type SplunkCollectorConfAuthentication = OpenEnum<
  typeof SplunkCollectorConfAuthentication
>;

/**
 * Algorithm to use when performing HTTP retries
 */
export const SplunkCollectorConfRetryType = {
  /**
   * Disabled
   */
  None: "none",
  /**
   * Backoff
   */
  Backoff: "backoff",
  /**
   * Static
   */
  Static: "static",
} as const;
/**
 * Algorithm to use when performing HTTP retries
 */
export type SplunkCollectorConfRetryType = OpenEnum<
  typeof SplunkCollectorConfRetryType
>;

export type SplunkCollectorConfRetryRules = {
  /**
   * Algorithm to use when performing HTTP retries
   */
  type?: SplunkCollectorConfRetryType | undefined;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

export type SplunkCollectorConf = {
  /**
   * Search head base URL. Can be an expression. Default is https://localhost:8089.
   */
  searchHead?: string | undefined;
  /**
   * Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
   */
  search: string;
  /**
   * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'
   */
  earliest?: string | undefined;
  /**
   * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'
   */
  latest?: string | undefined;
  /**
   * REST API used to create a search
   */
  endpoint?: string | undefined;
  /**
   * Format of the returned output
   */
  outputMode?: SplunkCollectorConfOutputMode | undefined;
  /**
   * Optional collect request parameters
   */
  collectRequestParams?: Array<CollectRequestParam> | undefined;
  /**
   * Optional collect request headers
   */
  collectRequestHeaders?:
    | Array<SplunkCollectorConfCollectRequestHeader>
    | undefined;
  /**
   * Authentication method for Discover and Collect REST calls
   */
  authentication?: SplunkCollectorConfAuthentication | undefined;
  /**
   * HTTP request inactivity timeout. Use 0 for no timeout.
   */
  timeout?: number | undefined;
  /**
   * Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order.
   */
  useRoundRobinDns?: boolean | undefined;
  /**
   * Disable collector event time filtering when a date range is specified
   */
  disableTimeFilter?: boolean | undefined;
  /**
   * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)
   */
  rejectUnauthorized?: boolean | undefined;
  /**
   * Escape characters (\") in search queries will be passed directly to Splunk
   */
  handleEscapedChars?: boolean | undefined;
  retryRules?: SplunkCollectorConfRetryRules | undefined;
};

/** @internal */
export const SplunkCollectorConfOutputMode$inboundSchema: z.ZodType<
  SplunkCollectorConfOutputMode,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(SplunkCollectorConfOutputMode);
/** @internal */
export const SplunkCollectorConfOutputMode$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  SplunkCollectorConfOutputMode
> = openEnums.outboundSchema(SplunkCollectorConfOutputMode);

/** @internal */
export const CollectRequestParam$inboundSchema: z.ZodType<
  CollectRequestParam,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type CollectRequestParam$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const CollectRequestParam$outboundSchema: z.ZodType<
  CollectRequestParam$Outbound,
  z.ZodTypeDef,
  CollectRequestParam
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function collectRequestParamToJSON(
  collectRequestParam: CollectRequestParam,
): string {
  return JSON.stringify(
    CollectRequestParam$outboundSchema.parse(collectRequestParam),
  );
}
export function collectRequestParamFromJSON(
  jsonString: string,
): SafeParseResult<CollectRequestParam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CollectRequestParam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CollectRequestParam' from JSON`,
  );
}

/** @internal */
export const SplunkCollectorConfCollectRequestHeader$inboundSchema: z.ZodType<
  SplunkCollectorConfCollectRequestHeader,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});
/** @internal */
export type SplunkCollectorConfCollectRequestHeader$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const SplunkCollectorConfCollectRequestHeader$outboundSchema: z.ZodType<
  SplunkCollectorConfCollectRequestHeader$Outbound,
  z.ZodTypeDef,
  SplunkCollectorConfCollectRequestHeader
> = z.object({
  name: z.string(),
  value: z.string(),
});

export function splunkCollectorConfCollectRequestHeaderToJSON(
  splunkCollectorConfCollectRequestHeader:
    SplunkCollectorConfCollectRequestHeader,
): string {
  return JSON.stringify(
    SplunkCollectorConfCollectRequestHeader$outboundSchema.parse(
      splunkCollectorConfCollectRequestHeader,
    ),
  );
}
export function splunkCollectorConfCollectRequestHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  SplunkCollectorConfCollectRequestHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SplunkCollectorConfCollectRequestHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SplunkCollectorConfCollectRequestHeader' from JSON`,
  );
}

/** @internal */
export const SplunkCollectorConfAuthentication$inboundSchema: z.ZodType<
  SplunkCollectorConfAuthentication,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(SplunkCollectorConfAuthentication);
/** @internal */
export const SplunkCollectorConfAuthentication$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  SplunkCollectorConfAuthentication
> = openEnums.outboundSchema(SplunkCollectorConfAuthentication);

/** @internal */
export const SplunkCollectorConfRetryType$inboundSchema: z.ZodType<
  SplunkCollectorConfRetryType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(SplunkCollectorConfRetryType);
/** @internal */
export const SplunkCollectorConfRetryType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  SplunkCollectorConfRetryType
> = openEnums.outboundSchema(SplunkCollectorConfRetryType);

/** @internal */
export const SplunkCollectorConfRetryRules$inboundSchema: z.ZodType<
  SplunkCollectorConfRetryRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: SplunkCollectorConfRetryType$inboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});
/** @internal */
export type SplunkCollectorConfRetryRules$Outbound = {
  type: string;
  interval?: any | undefined;
  limit?: any | undefined;
  multiplier?: any | undefined;
  codes?: any | undefined;
  enableHeader?: any | undefined;
  retryConnectTimeout?: any | undefined;
  retryConnectReset?: any | undefined;
};

/** @internal */
export const SplunkCollectorConfRetryRules$outboundSchema: z.ZodType<
  SplunkCollectorConfRetryRules$Outbound,
  z.ZodTypeDef,
  SplunkCollectorConfRetryRules
> = z.object({
  type: SplunkCollectorConfRetryType$outboundSchema.default("backoff"),
  interval: z.any().optional(),
  limit: z.any().optional(),
  multiplier: z.any().optional(),
  codes: z.any().optional(),
  enableHeader: z.any().optional(),
  retryConnectTimeout: z.any().optional(),
  retryConnectReset: z.any().optional(),
});

export function splunkCollectorConfRetryRulesToJSON(
  splunkCollectorConfRetryRules: SplunkCollectorConfRetryRules,
): string {
  return JSON.stringify(
    SplunkCollectorConfRetryRules$outboundSchema.parse(
      splunkCollectorConfRetryRules,
    ),
  );
}
export function splunkCollectorConfRetryRulesFromJSON(
  jsonString: string,
): SafeParseResult<SplunkCollectorConfRetryRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SplunkCollectorConfRetryRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplunkCollectorConfRetryRules' from JSON`,
  );
}

/** @internal */
export const SplunkCollectorConf$inboundSchema: z.ZodType<
  SplunkCollectorConf,
  z.ZodTypeDef,
  unknown
> = z.object({
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: SplunkCollectorConfOutputMode$inboundSchema.default("json"),
  collectRequestParams: z.array(z.lazy(() => CollectRequestParam$inboundSchema))
    .optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => SplunkCollectorConfCollectRequestHeader$inboundSchema),
  ).optional(),
  authentication: SplunkCollectorConfAuthentication$inboundSchema.default(
    "basic",
  ),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => SplunkCollectorConfRetryRules$inboundSchema)
    .optional(),
});
/** @internal */
export type SplunkCollectorConf$Outbound = {
  searchHead: string;
  search: string;
  earliest?: string | undefined;
  latest?: string | undefined;
  endpoint: string;
  outputMode: string;
  collectRequestParams?: Array<CollectRequestParam$Outbound> | undefined;
  collectRequestHeaders?:
    | Array<SplunkCollectorConfCollectRequestHeader$Outbound>
    | undefined;
  authentication: string;
  timeout: number;
  useRoundRobinDns: boolean;
  disableTimeFilter: boolean;
  rejectUnauthorized: boolean;
  handleEscapedChars: boolean;
  retryRules?: SplunkCollectorConfRetryRules$Outbound | undefined;
};

/** @internal */
export const SplunkCollectorConf$outboundSchema: z.ZodType<
  SplunkCollectorConf$Outbound,
  z.ZodTypeDef,
  SplunkCollectorConf
> = z.object({
  searchHead: z.string().default("https://localhost:8089"),
  search: z.string(),
  earliest: z.string().optional(),
  latest: z.string().optional(),
  endpoint: z.string().default("/services/search/v2/jobs/export"),
  outputMode: SplunkCollectorConfOutputMode$outboundSchema.default("json"),
  collectRequestParams: z.array(
    z.lazy(() => CollectRequestParam$outboundSchema),
  ).optional(),
  collectRequestHeaders: z.array(
    z.lazy(() => SplunkCollectorConfCollectRequestHeader$outboundSchema),
  ).optional(),
  authentication: SplunkCollectorConfAuthentication$outboundSchema.default(
    "basic",
  ),
  timeout: z.number().default(0),
  useRoundRobinDns: z.boolean().default(false),
  disableTimeFilter: z.boolean().default(true),
  rejectUnauthorized: z.boolean().default(false),
  handleEscapedChars: z.boolean().default(false),
  retryRules: z.lazy(() => SplunkCollectorConfRetryRules$outboundSchema)
    .optional(),
});

export function splunkCollectorConfToJSON(
  splunkCollectorConf: SplunkCollectorConf,
): string {
  return JSON.stringify(
    SplunkCollectorConf$outboundSchema.parse(splunkCollectorConf),
  );
}
export function splunkCollectorConfFromJSON(
  jsonString: string,
): SafeParseResult<SplunkCollectorConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SplunkCollectorConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SplunkCollectorConf' from JSON`,
  );
}
