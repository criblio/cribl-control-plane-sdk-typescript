/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import * as openEnums from "../types/enums.js";
import { ClosedEnum, OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

/**
 * The output metric type
 */
export const FunctionAggregateMetricsMetricType = {
  Automatic: "automatic",
  Counter: "counter",
  Distribution: "distribution",
  Gauge: "gauge",
  Histogram: "histogram",
  Summary: "summary",
  Timer: "timer",
} as const;
/**
 * The output metric type
 */
export type FunctionAggregateMetricsMetricType = OpenEnum<
  typeof FunctionAggregateMetricsMetricType
>;

export type Aggregation = {
  /**
   * The output metric type
   */
  metricType?: FunctionAggregateMetricsMetricType | undefined;
  /**
   * Aggregate function to perform on events. Example: sum(bytes).where(action=='REJECT').as(TotalBytes)
   */
  agg: string;
};

export type FunctionAggregateMetricsAdd = {
  name?: string | undefined;
  /**
   * JavaScript expression to compute the value (can be constant)
   */
  value: string;
};

export type FunctionAggregateMetricsConf = {
  /**
   * Pass through the original events along with the aggregation events
   */
  passthrough?: boolean | undefined;
  /**
   * Preserve the structure of the original aggregation event's groupby fields
   */
  preserveGroupBys?: boolean | undefined;
  /**
   * Output only statistics that are sufficient for the supplied aggregations
   */
  sufficientStatsOnly?: boolean | undefined;
  /**
   * A prefix that is prepended to all of the fields output by this Aggregations Function
   */
  prefix?: string | undefined;
  /**
   * The time span of the tumbling window for aggregating events. Must be a valid time string (such as 10s).
   */
  timeWindow?: string | undefined;
  /**
   * Combination of Aggregation function and output metric type
   */
  aggregations: Array<Aggregation>;
  /**
   * Optional: One or more dimensions to group aggregates by. Supports wildcard expressions. Wrap dimension names in quotes if using literal identifiers, such as 'service.name'. Warning: Using wildcard '*' causes all dimensions in the event to be included, which can result in high cardinality and increased memory usage. Exclude dimensions that can result in high cardinality before using wildcards. Example: !_time, !_numericValue, *
   */
  groupbys?: Array<string> | undefined;
  /**
   * The maximum number of events to include in any given aggregation event
   */
  flushEventLimit?: number | undefined;
  /**
   * The memory usage limit to impose upon aggregations. Defaults to unlimited (all available system memory). Accepts numerals with units like KB and MB (example: 4GB).
   */
  flushMemLimit?: string | undefined;
  /**
   * Enable to retain aggregations for cumulative aggregations when flushing out an aggregation table event. When disabled (the default), aggregations are reset to 0 on flush.
   */
  cumulative?: boolean | undefined;
  /**
   * Treat dots in dimension names as literals. This is useful for top-level dimensions that contain dots, such as 'service.name'.
   */
  shouldTreatDotsAsLiterals?: boolean | undefined;
  /**
   * Set of key-value pairs to evaluate and add/set
   */
  add?: Array<FunctionAggregateMetricsAdd> | undefined;
  /**
   * Flush aggregations when an input stream is closed. If disabled, Time Window Settings control flush behavior.
   */
  flushOnInputClose?: boolean | undefined;
};

export const FunctionAggregateMetricsId = {
  AggregateMetrics: "aggregate_metrics",
} as const;
export type FunctionAggregateMetricsId = ClosedEnum<
  typeof FunctionAggregateMetricsId
>;

export type FunctionAggregateMetrics = {
  conf: FunctionAggregateMetricsConf;
  filename: string;
  disabled: boolean;
  group: string;
  id: FunctionAggregateMetricsId;
  initTime: number;
  loadTime: number;
  modTime: number;
  name: string;
  /**
   * JSON Schema Draft-06
   */
  schema: { [k: string]: any };
  uischema: { [k: string]: any };
  version: string;
};

/** @internal */
export const FunctionAggregateMetricsMetricType$inboundSchema: z.ZodType<
  FunctionAggregateMetricsMetricType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(FunctionAggregateMetricsMetricType);

/** @internal */
export const Aggregation$inboundSchema: z.ZodType<
  Aggregation,
  z.ZodTypeDef,
  unknown
> = z.object({
  metricType: FunctionAggregateMetricsMetricType$inboundSchema.default(
    "automatic",
  ),
  agg: z.string(),
});

export function aggregationFromJSON(
  jsonString: string,
): SafeParseResult<Aggregation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Aggregation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Aggregation' from JSON`,
  );
}

/** @internal */
export const FunctionAggregateMetricsAdd$inboundSchema: z.ZodType<
  FunctionAggregateMetricsAdd,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  value: z.string(),
});

export function functionAggregateMetricsAddFromJSON(
  jsonString: string,
): SafeParseResult<FunctionAggregateMetricsAdd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionAggregateMetricsAdd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionAggregateMetricsAdd' from JSON`,
  );
}

/** @internal */
export const FunctionAggregateMetricsConf$inboundSchema: z.ZodType<
  FunctionAggregateMetricsConf,
  z.ZodTypeDef,
  unknown
> = z.object({
  passthrough: z.boolean().default(false),
  preserveGroupBys: z.boolean().default(false),
  sufficientStatsOnly: z.boolean().default(false),
  prefix: z.string().optional(),
  timeWindow: z.string().default("10s"),
  aggregations: z.array(z.lazy(() => Aggregation$inboundSchema)),
  groupbys: z.array(z.string()).optional(),
  flushEventLimit: z.number().optional(),
  flushMemLimit: z.string().optional(),
  cumulative: z.boolean().default(false),
  shouldTreatDotsAsLiterals: z.boolean().default(true),
  add: z.array(z.lazy(() => FunctionAggregateMetricsAdd$inboundSchema))
    .optional(),
  flushOnInputClose: z.boolean().default(true),
});

export function functionAggregateMetricsConfFromJSON(
  jsonString: string,
): SafeParseResult<FunctionAggregateMetricsConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionAggregateMetricsConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionAggregateMetricsConf' from JSON`,
  );
}

/** @internal */
export const FunctionAggregateMetricsId$inboundSchema: z.ZodNativeEnum<
  typeof FunctionAggregateMetricsId
> = z.nativeEnum(FunctionAggregateMetricsId);

/** @internal */
export const FunctionAggregateMetrics$inboundSchema: z.ZodType<
  FunctionAggregateMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  __conf: z.lazy(() => FunctionAggregateMetricsConf$inboundSchema),
  __filename: z.string(),
  disabled: z.boolean(),
  group: z.string(),
  id: FunctionAggregateMetricsId$inboundSchema,
  initTime: z.number(),
  loadTime: z.number(),
  modTime: z.number(),
  name: z.string(),
  schema: z.record(z.any()),
  uischema: z.record(z.any()),
  version: z.string(),
}).transform((v) => {
  return remap$(v, {
    "__conf": "conf",
    "__filename": "filename",
  });
});

export function functionAggregateMetricsFromJSON(
  jsonString: string,
): SafeParseResult<FunctionAggregateMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionAggregateMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionAggregateMetrics' from JSON`,
  );
}
