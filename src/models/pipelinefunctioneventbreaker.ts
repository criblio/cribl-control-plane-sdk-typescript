/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import * as discriminatedUnionTypes from "../types/discriminatedUnion.js";
import { discriminatedUnion } from "../types/discriminatedUnion.js";
import * as openEnums from "../types/enums.js";
import { OpenEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp,
  TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$inboundSchema,
  TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$outboundSchema,
} from "./timestamptypeoptionseventbreakerexistingornewnewtimestamp.js";

export type EventBreakerExistingOrNewExisting = {
  existingOrNew: "existing";
  existingRule?: string | undefined;
  /**
   * Add this Function name to the cribl_breaker field
   */
  shouldMarkCriblBreaker?: boolean | undefined;
};

export const EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew = {
  /**
   * Use Existing
   */
  Existing: "existing",
  /**
   * Create New
   */
  New: "new",
} as const;
export type EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew = OpenEnum<
  typeof EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew
>;

export type EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat = {
  type: TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp;
  length?: number | undefined;
  format?: string | undefined;
};

export type EventBreakerExistingOrNewNewRuleTypeCsv = {
  ruleType: "csv";
  /**
   * Delimiter character to use to split values
   */
  delimiter: string;
  /**
   * Character used to quote literal values
   */
  quoteChar: string;
  /**
   * Character used to escape the quote character in field values
   */
  escapeChar: string;
  /**
   * Optional timestamp field name in extracted events
   */
  timeField?: string | undefined;
  existingOrNew: EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew;
  /**
   * The maximum number of bytes that an event can be before being flushed to the Pipelines
   */
  maxEventBytes?: number | undefined;
  /**
   * Regex to match before attempting timestamp extraction. Use $ (end of string anchor) to not perform extraction.
   */
  timestampAnchorRegex?: string | undefined;
  timestamp?:
    | EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat
    | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * The earliest timestamp value allowed relative to now, such as -42years. Parsed values prior to this date will be set to current time.
   */
  timestampEarliest?: string | undefined;
  /**
   * The latest timestamp value allowed relative to now, such as +42days. Parsed values after this date will be set to current time.
   */
  timestampLatest?: string | undefined;
  /**
   * Add this Function name to the cribl_breaker field
   */
  shouldMarkCriblBreaker?: boolean | undefined;
};

export const EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew = {
  /**
   * Use Existing
   */
  Existing: "existing",
  /**
   * Create New
   */
  New: "new",
} as const;
export type EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew = OpenEnum<
  typeof EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew
>;

export type EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat = {
  type: TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp;
  length?: number | undefined;
  format?: string | undefined;
};

export type EventBreakerExistingOrNewNewRuleTypeHeader = {
  ruleType: "header";
  /**
   * Field delimiter regex
   */
  delimiterRegex: string;
  /**
   * Regex with one capturing group that captures all fields (and delimiters) to be broken by field delimiter
   */
  fieldsLineRegex: string;
  /**
   * Regex matching a file header line
   */
  headerLineRegex: string;
  /**
   * Representation of a null value. Null fields are not added to events.
   */
  nullFieldVal?: string | undefined;
  /**
   * Clean field names by replacing non [a-zA-Z0-9] characters with _
   */
  cleanFields?: boolean | undefined;
  existingOrNew: EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew;
  /**
   * The maximum number of bytes that an event can be before being flushed to the Pipelines
   */
  maxEventBytes?: number | undefined;
  /**
   * Regex to match before attempting timestamp extraction. Use $ (end of string anchor) to not perform extraction.
   */
  timestampAnchorRegex?: string | undefined;
  timestamp?:
    | EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat
    | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * The earliest timestamp value allowed relative to now, such as -42years. Parsed values prior to this date will be set to current time.
   */
  timestampEarliest?: string | undefined;
  /**
   * The latest timestamp value allowed relative to now, such as +42days. Parsed values after this date will be set to current time.
   */
  timestampLatest?: string | undefined;
  /**
   * Add this Function name to the cribl_breaker field
   */
  shouldMarkCriblBreaker?: boolean | undefined;
};

export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew =
  {
    /**
     * Use Existing
     */
    Existing: "existing",
    /**
     * Create New
     */
    New: "new",
  } as const;
export type EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew =
  OpenEnum<
    typeof EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew
  >;

export type EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat =
  {
    type: TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp;
    length?: number | undefined;
    format?: string | undefined;
  };

export type EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse = {
  /**
   * Automatically extract fields from JSON events. When disabled, only _raw and _time are defined on extracted events.
   */
  jsonExtractAll?: boolean | undefined;
  ruleType?: string | undefined;
  /**
   * The path to an array in a JSON event with records to extract, such as Records or level1.level2.events. Leave blank if result itself is an array, such as [{...},{...}]
   */
  jsonArrayField?: string | undefined;
  /**
   * Top-level fields to copy to the output events. Nested fields are not supported. 'Array field' is always excluded. If 'Array field' points to a nested array, the entire top-level object will be excluded. Supports * wildcards. Enclose field names containing special characters in single or double quotes.
   */
  parentFieldsToCopy?: Array<string> | undefined;
  existingOrNew:
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew;
  /**
   * The maximum number of bytes that an event can be before being flushed to the Pipelines
   */
  maxEventBytes?: number | undefined;
  /**
   * Regex to match before attempting timestamp extraction. Use $ (end of string anchor) to not perform extraction.
   */
  timestampAnchorRegex?: string | undefined;
  timestamp?:
    | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat
    | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * The earliest timestamp value allowed relative to now, such as -42years. Parsed values prior to this date will be set to current time.
   */
  timestampEarliest?: string | undefined;
  /**
   * The latest timestamp value allowed relative to now, such as +42days. Parsed values after this date will be set to current time.
   */
  timestampLatest?: string | undefined;
  /**
   * Add this Function name to the cribl_breaker field
   */
  shouldMarkCriblBreaker?: boolean | undefined;
};

export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew =
  {
    /**
     * Use Existing
     */
    Existing: "existing",
    /**
     * Create New
     */
    New: "new",
  } as const;
export type EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew =
  OpenEnum<
    typeof EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew
  >;

export type EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat =
  {
    type: TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp;
    length?: number | undefined;
    format?: string | undefined;
  };

export type EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue = {
  /**
   * Automatically extract fields from JSON events. When disabled, only _raw and _time are defined on extracted events.
   */
  jsonExtractAll?: boolean | undefined;
  /**
   * Optional path to timestamp field in extracted events, such as eventTime or level1.level2.eventTime.
   */
  jsonTimeField?: string | undefined;
  ruleType?: string | undefined;
  /**
   * The path to an array in a JSON event with records to extract, such as Records or level1.level2.events. Leave blank if result itself is an array, such as [{...},{...}]
   */
  jsonArrayField?: string | undefined;
  /**
   * Top-level fields to copy to the output events. Nested fields are not supported. 'Array field' is always excluded. If 'Array field' points to a nested array, the entire top-level object will be excluded. Supports * wildcards. Enclose field names containing special characters in single or double quotes.
   */
  parentFieldsToCopy?: Array<string> | undefined;
  existingOrNew:
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew;
  /**
   * The maximum number of bytes that an event can be before being flushed to the Pipelines
   */
  maxEventBytes?: number | undefined;
  /**
   * Regex to match before attempting timestamp extraction. Use $ (end of string anchor) to not perform extraction.
   */
  timestampAnchorRegex?: string | undefined;
  timestamp?:
    | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat
    | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * The earliest timestamp value allowed relative to now, such as -42years. Parsed values prior to this date will be set to current time.
   */
  timestampEarliest?: string | undefined;
  /**
   * The latest timestamp value allowed relative to now, such as +42days. Parsed values after this date will be set to current time.
   */
  timestampLatest?: string | undefined;
  /**
   * Add this Function name to the cribl_breaker field
   */
  shouldMarkCriblBreaker?: boolean | undefined;
};

export type EventBreakerExistingOrNewNewRuleTypeJsonArray =
  | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue
  | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse;

export const EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew = {
  /**
   * Use Existing
   */
  Existing: "existing",
  /**
   * Create New
   */
  New: "new",
} as const;
export type EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew = OpenEnum<
  typeof EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew
>;

export type EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat = {
  type: TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp;
  length?: number | undefined;
  format?: string | undefined;
};

export type EventBreakerExistingOrNewNewRuleTypeJson = {
  ruleType: "json";
  existingOrNew: EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew;
  /**
   * The maximum number of bytes that an event can be before being flushed to the Pipelines
   */
  maxEventBytes?: number | undefined;
  /**
   * Regex to match before attempting timestamp extraction. Use $ (end of string anchor) to not perform extraction.
   */
  timestampAnchorRegex?: string | undefined;
  timestamp?:
    | EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat
    | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * The earliest timestamp value allowed relative to now, such as -42years. Parsed values prior to this date will be set to current time.
   */
  timestampEarliest?: string | undefined;
  /**
   * The latest timestamp value allowed relative to now, such as +42days. Parsed values after this date will be set to current time.
   */
  timestampLatest?: string | undefined;
  /**
   * Add this Function name to the cribl_breaker field
   */
  shouldMarkCriblBreaker?: boolean | undefined;
};

export const EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew = {
  /**
   * Use Existing
   */
  Existing: "existing",
  /**
   * Create New
   */
  New: "new",
} as const;
export type EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew = OpenEnum<
  typeof EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew
>;

export type EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat = {
  type: TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp;
  length?: number | undefined;
  format?: string | undefined;
};

export type EventBreakerExistingOrNewNewRuleTypeRegex = {
  ruleType: "regex";
  /**
   * The regex used to break the stream into events at the beginning of the match. Matched content will be consumed, unless you use a lookahead regex such as (?=pattern) to keep it. Do NOT use capturing groups in the pattern.
   */
  eventBreakerRegex: string;
  existingOrNew: EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew;
  /**
   * The maximum number of bytes that an event can be before being flushed to the Pipelines
   */
  maxEventBytes?: number | undefined;
  /**
   * Regex to match before attempting timestamp extraction. Use $ (end of string anchor) to not perform extraction.
   */
  timestampAnchorRegex?: string | undefined;
  timestamp?:
    | EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat
    | undefined;
  /**
   * Timezone to assign to timestamps without timezone info
   */
  timestampTimezone?: string | undefined;
  /**
   * The earliest timestamp value allowed relative to now, such as -42years. Parsed values prior to this date will be set to current time.
   */
  timestampEarliest?: string | undefined;
  /**
   * The latest timestamp value allowed relative to now, such as +42days. Parsed values after this date will be set to current time.
   */
  timestampLatest?: string | undefined;
  /**
   * Add this Function name to the cribl_breaker field
   */
  shouldMarkCriblBreaker?: boolean | undefined;
};

export type EventBreakerExistingOrNewNew =
  | EventBreakerExistingOrNewNewRuleTypeRegex
  | EventBreakerExistingOrNewNewRuleTypeJson
  | (
    | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue
    | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse & {
      ruleType: "json_array";
    }
  )
  | EventBreakerExistingOrNewNewRuleTypeHeader
  | EventBreakerExistingOrNewNewRuleTypeCsv
  | discriminatedUnionTypes.Unknown<"ruleType">;

export type PipelineFunctionEventBreakerConf =
  | (
    | EventBreakerExistingOrNewNewRuleTypeRegex
    | EventBreakerExistingOrNewNewRuleTypeJson
    | (
      | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue
      | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse & {
        ruleType: "json_array";
      }
    )
    | EventBreakerExistingOrNewNewRuleTypeHeader
    | EventBreakerExistingOrNewNewRuleTypeCsv
    | discriminatedUnionTypes.Unknown<"ruleType"> & { existingOrNew: "new" }
  )
  | EventBreakerExistingOrNewExisting
  | discriminatedUnionTypes.Unknown<"existingOrNew">;

export type PipelineFunctionEventBreaker = {
  /**
   * Filter that selects data to be fed through this Function
   */
  filter?: string | undefined;
  /**
   * Function ID
   */
  id: "event_breaker";
  /**
   * Simple description of this step
   */
  description?: string | undefined;
  /**
   * If true, data will not be pushed through this function
   */
  disabled?: boolean | undefined;
  /**
   * If enabled, stops the results of this Function from being passed to the downstream Functions
   */
  final?: boolean | undefined;
  conf:
    | (
      | EventBreakerExistingOrNewNewRuleTypeRegex
      | EventBreakerExistingOrNewNewRuleTypeJson
      | (
        | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue
        | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse & {
          ruleType: "json_array";
        }
      )
      | EventBreakerExistingOrNewNewRuleTypeHeader
      | EventBreakerExistingOrNewNewRuleTypeCsv
      | discriminatedUnionTypes.Unknown<"ruleType"> & { existingOrNew: "new" }
    )
    | EventBreakerExistingOrNewExisting
    | discriminatedUnionTypes.Unknown<"existingOrNew">;
  /**
   * Group ID
   */
  groupId?: string | undefined;
};

/** @internal */
export const EventBreakerExistingOrNewExisting$inboundSchema: z.ZodType<
  EventBreakerExistingOrNewExisting,
  z.ZodTypeDef,
  unknown
> = z.object({
  existingOrNew: types.literal("existing"),
  existingRule: types.optional(types.string()),
  shouldMarkCriblBreaker: types.optional(types.boolean()),
});
/** @internal */
export type EventBreakerExistingOrNewExisting$Outbound = {
  existingOrNew: "existing";
  existingRule?: string | undefined;
  shouldMarkCriblBreaker?: boolean | undefined;
};

/** @internal */
export const EventBreakerExistingOrNewExisting$outboundSchema: z.ZodType<
  EventBreakerExistingOrNewExisting$Outbound,
  z.ZodTypeDef,
  EventBreakerExistingOrNewExisting
> = z.object({
  existingOrNew: z.literal("existing"),
  existingRule: z.string().optional(),
  shouldMarkCriblBreaker: z.boolean().optional(),
});

export function eventBreakerExistingOrNewExistingToJSON(
  eventBreakerExistingOrNewExisting: EventBreakerExistingOrNewExisting,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewExisting$outboundSchema.parse(
      eventBreakerExistingOrNewExisting,
    ),
  );
}
export function eventBreakerExistingOrNewExistingFromJSON(
  jsonString: string,
): SafeParseResult<EventBreakerExistingOrNewExisting, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventBreakerExistingOrNewExisting$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerExistingOrNewExisting' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew,
  );
/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew
  > = openEnums.outboundSchema(
    EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew,
  );

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$inboundSchema,
    length: types.optional(types.number()),
    format: types.optional(types.string()),
  });
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat$Outbound = {
  type: string;
  length?: number | undefined;
  format?: string | undefined;
};

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat$outboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat$Outbound,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$outboundSchema,
    length: z.number().optional(),
    format: z.string().optional(),
  });

export function eventBreakerExistingOrNewNewRuleTypeCsvTimestampFormatToJSON(
  eventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat:
    EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat$outboundSchema.parse(
      eventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat,
    ),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeCsvTimestampFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeCsv$inboundSchema: z.ZodType<
  EventBreakerExistingOrNewNewRuleTypeCsv,
  z.ZodTypeDef,
  unknown
> = z.object({
  ruleType: types.literal("csv"),
  delimiter: types.string(),
  quoteChar: types.string(),
  escapeChar: types.string(),
  timeField: types.optional(types.string()),
  existingOrNew:
    EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew$inboundSchema,
  maxEventBytes: types.optional(types.number()),
  timestampAnchorRegex: types.optional(types.string()),
  timestamp: types.optional(
    z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat$inboundSchema
    ),
  ),
  timestampTimezone: types.optional(types.string()),
  timestampEarliest: types.optional(types.string()),
  timestampLatest: types.optional(types.string()),
  shouldMarkCriblBreaker: types.optional(types.boolean()),
});
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeCsv$Outbound = {
  ruleType: "csv";
  delimiter: string;
  quoteChar: string;
  escapeChar: string;
  timeField?: string | undefined;
  existingOrNew: string;
  maxEventBytes?: number | undefined;
  timestampAnchorRegex?: string | undefined;
  timestamp?:
    | EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat$Outbound
    | undefined;
  timestampTimezone?: string | undefined;
  timestampEarliest?: string | undefined;
  timestampLatest?: string | undefined;
  shouldMarkCriblBreaker?: boolean | undefined;
};

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeCsv$outboundSchema: z.ZodType<
  EventBreakerExistingOrNewNewRuleTypeCsv$Outbound,
  z.ZodTypeDef,
  EventBreakerExistingOrNewNewRuleTypeCsv
> = z.object({
  ruleType: z.literal("csv"),
  delimiter: z.string(),
  quoteChar: z.string(),
  escapeChar: z.string(),
  timeField: z.string().optional(),
  existingOrNew:
    EventBreakerExistingOrNewNewRuleTypeCsvExistingOrNew$outboundSchema,
  maxEventBytes: z.number().optional(),
  timestampAnchorRegex: z.string().optional(),
  timestamp: z.lazy(() =>
    EventBreakerExistingOrNewNewRuleTypeCsvTimestampFormat$outboundSchema
  ).optional(),
  timestampTimezone: z.string().optional(),
  timestampEarliest: z.string().optional(),
  timestampLatest: z.string().optional(),
  shouldMarkCriblBreaker: z.boolean().optional(),
});

export function eventBreakerExistingOrNewNewRuleTypeCsvToJSON(
  eventBreakerExistingOrNewNewRuleTypeCsv:
    EventBreakerExistingOrNewNewRuleTypeCsv,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeCsv$outboundSchema.parse(
      eventBreakerExistingOrNewNewRuleTypeCsv,
    ),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeCsvFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeCsv,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeCsv$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeCsv' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew,
  );
/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew
  > = openEnums.outboundSchema(
    EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew,
  );

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$inboundSchema,
    length: types.optional(types.number()),
    format: types.optional(types.string()),
  });
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat$Outbound =
  {
    type: string;
    length?: number | undefined;
    format?: string | undefined;
  };

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat$outboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat$Outbound,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$outboundSchema,
    length: z.number().optional(),
    format: z.string().optional(),
  });

export function eventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormatToJSON(
  eventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat:
    EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat$outboundSchema
      .parse(eventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeHeader$inboundSchema:
  z.ZodType<EventBreakerExistingOrNewNewRuleTypeHeader, z.ZodTypeDef, unknown> =
    z.object({
      ruleType: types.literal("header"),
      delimiterRegex: types.string(),
      fieldsLineRegex: types.string(),
      headerLineRegex: types.string(),
      nullFieldVal: types.optional(types.string()),
      cleanFields: types.optional(types.boolean()),
      existingOrNew:
        EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew$inboundSchema,
      maxEventBytes: types.optional(types.number()),
      timestampAnchorRegex: types.optional(types.string()),
      timestamp: types.optional(
        z.lazy(() =>
          EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat$inboundSchema
        ),
      ),
      timestampTimezone: types.optional(types.string()),
      timestampEarliest: types.optional(types.string()),
      timestampLatest: types.optional(types.string()),
      shouldMarkCriblBreaker: types.optional(types.boolean()),
    });
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeHeader$Outbound = {
  ruleType: "header";
  delimiterRegex: string;
  fieldsLineRegex: string;
  headerLineRegex: string;
  nullFieldVal?: string | undefined;
  cleanFields?: boolean | undefined;
  existingOrNew: string;
  maxEventBytes?: number | undefined;
  timestampAnchorRegex?: string | undefined;
  timestamp?:
    | EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat$Outbound
    | undefined;
  timestampTimezone?: string | undefined;
  timestampEarliest?: string | undefined;
  timestampLatest?: string | undefined;
  shouldMarkCriblBreaker?: boolean | undefined;
};

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeHeader$outboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeHeader$Outbound,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeHeader
  > = z.object({
    ruleType: z.literal("header"),
    delimiterRegex: z.string(),
    fieldsLineRegex: z.string(),
    headerLineRegex: z.string(),
    nullFieldVal: z.string().optional(),
    cleanFields: z.boolean().optional(),
    existingOrNew:
      EventBreakerExistingOrNewNewRuleTypeHeaderExistingOrNew$outboundSchema,
    maxEventBytes: z.number().optional(),
    timestampAnchorRegex: z.string().optional(),
    timestamp: z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeHeaderTimestampFormat$outboundSchema
    ).optional(),
    timestampTimezone: z.string().optional(),
    timestampEarliest: z.string().optional(),
    timestampLatest: z.string().optional(),
    shouldMarkCriblBreaker: z.boolean().optional(),
  });

export function eventBreakerExistingOrNewNewRuleTypeHeaderToJSON(
  eventBreakerExistingOrNewNewRuleTypeHeader:
    EventBreakerExistingOrNewNewRuleTypeHeader,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeHeader$outboundSchema.parse(
      eventBreakerExistingOrNewNewRuleTypeHeader,
    ),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeHeaderFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeHeader,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeHeader$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeHeader' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew,
  );
/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew
  > = openEnums.outboundSchema(
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew,
  );

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$inboundSchema,
    length: types.optional(types.number()),
    format: types.optional(types.string()),
  });
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat$Outbound =
  {
    type: string;
    length?: number | undefined;
    format?: string | undefined;
  };

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat$outboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat$Outbound,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$outboundSchema,
    length: z.number().optional(),
    format: z.string().optional(),
  });

export function eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormatToJSON(
  eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat:
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat$outboundSchema
      .parse(
        eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat,
      ),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse,
    z.ZodTypeDef,
    unknown
  > = z.object({
    jsonExtractAll: types.optional(types.boolean()),
    ruleType: types.optional(types.string()),
    jsonArrayField: types.optional(types.string()),
    parentFieldsToCopy: types.optional(z.array(types.string())),
    existingOrNew:
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew$inboundSchema,
    maxEventBytes: types.optional(types.number()),
    timestampAnchorRegex: types.optional(types.string()),
    timestamp: types.optional(
      z.lazy(() =>
        EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat$inboundSchema
      ),
    ),
    timestampTimezone: types.optional(types.string()),
    timestampEarliest: types.optional(types.string()),
    timestampLatest: types.optional(types.string()),
    shouldMarkCriblBreaker: types.optional(types.boolean()),
  });
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$Outbound =
  {
    jsonExtractAll?: boolean | undefined;
    ruleType?: string | undefined;
    jsonArrayField?: string | undefined;
    parentFieldsToCopy?: Array<string> | undefined;
    existingOrNew: string;
    maxEventBytes?: number | undefined;
    timestampAnchorRegex?: string | undefined;
    timestamp?:
      | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat$Outbound
      | undefined;
    timestampTimezone?: string | undefined;
    timestampEarliest?: string | undefined;
    timestampLatest?: string | undefined;
    shouldMarkCriblBreaker?: boolean | undefined;
  };

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$outboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$Outbound,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse
  > = z.object({
    jsonExtractAll: z.boolean().optional(),
    ruleType: z.string().optional(),
    jsonArrayField: z.string().optional(),
    parentFieldsToCopy: z.array(z.string()).optional(),
    existingOrNew:
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseExistingOrNew$outboundSchema,
    maxEventBytes: z.number().optional(),
    timestampAnchorRegex: z.string().optional(),
    timestamp: z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseTimestampFormat$outboundSchema
    ).optional(),
    timestampTimezone: z.string().optional(),
    timestampEarliest: z.string().optional(),
    timestampLatest: z.string().optional(),
    shouldMarkCriblBreaker: z.boolean().optional(),
  });

export function eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseToJSON(
  eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse:
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$outboundSchema
      .parse(eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalseFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew,
  );
/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew
  > = openEnums.outboundSchema(
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew,
  );

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$inboundSchema,
    length: types.optional(types.number()),
    format: types.optional(types.string()),
  });
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat$Outbound =
  {
    type: string;
    length?: number | undefined;
    format?: string | undefined;
  };

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat$outboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat$Outbound,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$outboundSchema,
    length: z.number().optional(),
    format: z.string().optional(),
  });

export function eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormatToJSON(
  eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat:
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat$outboundSchema
      .parse(
        eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat,
      ),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    jsonExtractAll: types.optional(types.boolean()),
    jsonTimeField: types.optional(types.string()),
    ruleType: types.optional(types.string()),
    jsonArrayField: types.optional(types.string()),
    parentFieldsToCopy: types.optional(z.array(types.string())),
    existingOrNew:
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew$inboundSchema,
    maxEventBytes: types.optional(types.number()),
    timestampAnchorRegex: types.optional(types.string()),
    timestamp: types.optional(
      z.lazy(() =>
        EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat$inboundSchema
      ),
    ),
    timestampTimezone: types.optional(types.string()),
    timestampEarliest: types.optional(types.string()),
    timestampLatest: types.optional(types.string()),
    shouldMarkCriblBreaker: types.optional(types.boolean()),
  });
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$Outbound =
  {
    jsonExtractAll?: boolean | undefined;
    jsonTimeField?: string | undefined;
    ruleType?: string | undefined;
    jsonArrayField?: string | undefined;
    parentFieldsToCopy?: Array<string> | undefined;
    existingOrNew: string;
    maxEventBytes?: number | undefined;
    timestampAnchorRegex?: string | undefined;
    timestamp?:
      | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat$Outbound
      | undefined;
    timestampTimezone?: string | undefined;
    timestampEarliest?: string | undefined;
    timestampLatest?: string | undefined;
    shouldMarkCriblBreaker?: boolean | undefined;
  };

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$outboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$Outbound,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue
  > = z.object({
    jsonExtractAll: z.boolean().optional(),
    jsonTimeField: z.string().optional(),
    ruleType: z.string().optional(),
    jsonArrayField: z.string().optional(),
    parentFieldsToCopy: z.array(z.string()).optional(),
    existingOrNew:
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueExistingOrNew$outboundSchema,
    maxEventBytes: z.number().optional(),
    timestampAnchorRegex: z.string().optional(),
    timestamp: z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueTimestampFormat$outboundSchema
    ).optional(),
    timestampTimezone: z.string().optional(),
    timestampEarliest: z.string().optional(),
    timestampLatest: z.string().optional(),
    shouldMarkCriblBreaker: z.boolean().optional(),
  });

export function eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueToJSON(
  eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue:
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$outboundSchema
      .parse(eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrueFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArray$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArray,
    z.ZodTypeDef,
    unknown
  > = smartUnion([
    z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$inboundSchema
    ),
    z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$inboundSchema
    ),
  ]);
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeJsonArray$Outbound =
  | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$Outbound
  | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$Outbound;

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonArray$outboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonArray$Outbound,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeJsonArray
  > = smartUnion([
    z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$outboundSchema
    ),
    z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$outboundSchema
    ),
  ]);

export function eventBreakerExistingOrNewNewRuleTypeJsonArrayToJSON(
  eventBreakerExistingOrNewNewRuleTypeJsonArray:
    EventBreakerExistingOrNewNewRuleTypeJsonArray,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeJsonArray$outboundSchema.parse(
      eventBreakerExistingOrNewNewRuleTypeJsonArray,
    ),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeJsonArrayFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeJsonArray,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeJsonArray$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeJsonArray' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew,
  );
/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew
  > = openEnums.outboundSchema(
    EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew,
  );

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$inboundSchema,
    length: types.optional(types.number()),
    format: types.optional(types.string()),
  });
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat$Outbound = {
  type: string;
  length?: number | undefined;
  format?: string | undefined;
};

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat$outboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat$Outbound,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$outboundSchema,
    length: z.number().optional(),
    format: z.string().optional(),
  });

export function eventBreakerExistingOrNewNewRuleTypeJsonTimestampFormatToJSON(
  eventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat:
    EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat$outboundSchema
      .parse(eventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeJsonTimestampFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJson$inboundSchema: z.ZodType<
  EventBreakerExistingOrNewNewRuleTypeJson,
  z.ZodTypeDef,
  unknown
> = z.object({
  ruleType: types.literal("json"),
  existingOrNew:
    EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew$inboundSchema,
  maxEventBytes: types.optional(types.number()),
  timestampAnchorRegex: types.optional(types.string()),
  timestamp: types.optional(
    z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat$inboundSchema
    ),
  ),
  timestampTimezone: types.optional(types.string()),
  timestampEarliest: types.optional(types.string()),
  timestampLatest: types.optional(types.string()),
  shouldMarkCriblBreaker: types.optional(types.boolean()),
});
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeJson$Outbound = {
  ruleType: "json";
  existingOrNew: string;
  maxEventBytes?: number | undefined;
  timestampAnchorRegex?: string | undefined;
  timestamp?:
    | EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat$Outbound
    | undefined;
  timestampTimezone?: string | undefined;
  timestampEarliest?: string | undefined;
  timestampLatest?: string | undefined;
  shouldMarkCriblBreaker?: boolean | undefined;
};

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeJson$outboundSchema: z.ZodType<
  EventBreakerExistingOrNewNewRuleTypeJson$Outbound,
  z.ZodTypeDef,
  EventBreakerExistingOrNewNewRuleTypeJson
> = z.object({
  ruleType: z.literal("json"),
  existingOrNew:
    EventBreakerExistingOrNewNewRuleTypeJsonExistingOrNew$outboundSchema,
  maxEventBytes: z.number().optional(),
  timestampAnchorRegex: z.string().optional(),
  timestamp: z.lazy(() =>
    EventBreakerExistingOrNewNewRuleTypeJsonTimestampFormat$outboundSchema
  ).optional(),
  timestampTimezone: z.string().optional(),
  timestampEarliest: z.string().optional(),
  timestampLatest: z.string().optional(),
  shouldMarkCriblBreaker: z.boolean().optional(),
});

export function eventBreakerExistingOrNewNewRuleTypeJsonToJSON(
  eventBreakerExistingOrNewNewRuleTypeJson:
    EventBreakerExistingOrNewNewRuleTypeJson,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeJson$outboundSchema.parse(
      eventBreakerExistingOrNewNewRuleTypeJson,
    ),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeJsonFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeJson,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeJson$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeJson' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew,
    z.ZodTypeDef,
    unknown
  > = openEnums.inboundSchema(
    EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew,
  );
/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew$outboundSchema:
  z.ZodType<
    string,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew
  > = openEnums.outboundSchema(
    EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew,
  );

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat$inboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$inboundSchema,
    length: types.optional(types.number()),
    format: types.optional(types.string()),
  });
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat$Outbound =
  {
    type: string;
    length?: number | undefined;
    format?: string | undefined;
  };

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat$outboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat$Outbound,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat
  > = z.object({
    type:
      TimestampTypeOptionsEventBreakerExistingOrNewNewTimestamp$outboundSchema,
    length: z.number().optional(),
    format: z.string().optional(),
  });

export function eventBreakerExistingOrNewNewRuleTypeRegexTimestampFormatToJSON(
  eventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat:
    EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat$outboundSchema
      .parse(eventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeRegexTimestampFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeRegex$inboundSchema: z.ZodType<
  EventBreakerExistingOrNewNewRuleTypeRegex,
  z.ZodTypeDef,
  unknown
> = z.object({
  ruleType: types.literal("regex"),
  eventBreakerRegex: types.string(),
  existingOrNew:
    EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew$inboundSchema,
  maxEventBytes: types.optional(types.number()),
  timestampAnchorRegex: types.optional(types.string()),
  timestamp: types.optional(
    z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat$inboundSchema
    ),
  ),
  timestampTimezone: types.optional(types.string()),
  timestampEarliest: types.optional(types.string()),
  timestampLatest: types.optional(types.string()),
  shouldMarkCriblBreaker: types.optional(types.boolean()),
});
/** @internal */
export type EventBreakerExistingOrNewNewRuleTypeRegex$Outbound = {
  ruleType: "regex";
  eventBreakerRegex: string;
  existingOrNew: string;
  maxEventBytes?: number | undefined;
  timestampAnchorRegex?: string | undefined;
  timestamp?:
    | EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat$Outbound
    | undefined;
  timestampTimezone?: string | undefined;
  timestampEarliest?: string | undefined;
  timestampLatest?: string | undefined;
  shouldMarkCriblBreaker?: boolean | undefined;
};

/** @internal */
export const EventBreakerExistingOrNewNewRuleTypeRegex$outboundSchema:
  z.ZodType<
    EventBreakerExistingOrNewNewRuleTypeRegex$Outbound,
    z.ZodTypeDef,
    EventBreakerExistingOrNewNewRuleTypeRegex
  > = z.object({
    ruleType: z.literal("regex"),
    eventBreakerRegex: z.string(),
    existingOrNew:
      EventBreakerExistingOrNewNewRuleTypeRegexExistingOrNew$outboundSchema,
    maxEventBytes: z.number().optional(),
    timestampAnchorRegex: z.string().optional(),
    timestamp: z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeRegexTimestampFormat$outboundSchema
    ).optional(),
    timestampTimezone: z.string().optional(),
    timestampEarliest: z.string().optional(),
    timestampLatest: z.string().optional(),
    shouldMarkCriblBreaker: z.boolean().optional(),
  });

export function eventBreakerExistingOrNewNewRuleTypeRegexToJSON(
  eventBreakerExistingOrNewNewRuleTypeRegex:
    EventBreakerExistingOrNewNewRuleTypeRegex,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNewRuleTypeRegex$outboundSchema.parse(
      eventBreakerExistingOrNewNewRuleTypeRegex,
    ),
  );
}
export function eventBreakerExistingOrNewNewRuleTypeRegexFromJSON(
  jsonString: string,
): SafeParseResult<
  EventBreakerExistingOrNewNewRuleTypeRegex,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      EventBreakerExistingOrNewNewRuleTypeRegex$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'EventBreakerExistingOrNewNewRuleTypeRegex' from JSON`,
  );
}

/** @internal */
export const EventBreakerExistingOrNewNew$inboundSchema: z.ZodType<
  EventBreakerExistingOrNewNew,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("ruleType", {
  regex: z.lazy(() => EventBreakerExistingOrNewNewRuleTypeRegex$inboundSchema),
  json: z.lazy(() => EventBreakerExistingOrNewNewRuleTypeJson$inboundSchema),
  json_array: smartUnion([
    z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$inboundSchema
    ),
    z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$inboundSchema
    ),
  ]).and(z.object({ ruleType: z.literal("json_array") })),
  header: z.lazy(() =>
    EventBreakerExistingOrNewNewRuleTypeHeader$inboundSchema
  ),
  csv: z.lazy(() => EventBreakerExistingOrNewNewRuleTypeCsv$inboundSchema),
});
/** @internal */
export type EventBreakerExistingOrNewNew$Outbound =
  | EventBreakerExistingOrNewNewRuleTypeRegex$Outbound
  | EventBreakerExistingOrNewNewRuleTypeJson$Outbound
  | (
    | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$Outbound
    | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$Outbound
      & { ruleType: "json_array" }
  )
  | EventBreakerExistingOrNewNewRuleTypeHeader$Outbound
  | EventBreakerExistingOrNewNewRuleTypeCsv$Outbound;

/** @internal */
export const EventBreakerExistingOrNewNew$outboundSchema: z.ZodType<
  EventBreakerExistingOrNewNew$Outbound,
  z.ZodTypeDef,
  EventBreakerExistingOrNewNew
> = z.union([
  z.lazy(() => EventBreakerExistingOrNewNewRuleTypeRegex$outboundSchema),
  z.lazy(() => EventBreakerExistingOrNewNewRuleTypeJson$outboundSchema),
  smartUnion([
    z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$outboundSchema
    ),
    z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$outboundSchema
    ),
  ]).and(z.object({ ruleType: z.literal("json_array") })),
  z.lazy(() => EventBreakerExistingOrNewNewRuleTypeHeader$outboundSchema),
  z.lazy(() => EventBreakerExistingOrNewNewRuleTypeCsv$outboundSchema),
]);

export function eventBreakerExistingOrNewNewToJSON(
  eventBreakerExistingOrNewNew: EventBreakerExistingOrNewNew,
): string {
  return JSON.stringify(
    EventBreakerExistingOrNewNew$outboundSchema.parse(
      eventBreakerExistingOrNewNew,
    ),
  );
}
export function eventBreakerExistingOrNewNewFromJSON(
  jsonString: string,
): SafeParseResult<EventBreakerExistingOrNewNew, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EventBreakerExistingOrNewNew$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EventBreakerExistingOrNewNew' from JSON`,
  );
}

/** @internal */
export const PipelineFunctionEventBreakerConf$inboundSchema: z.ZodType<
  PipelineFunctionEventBreakerConf,
  z.ZodTypeDef,
  unknown
> = discriminatedUnion("existingOrNew", {
  new: discriminatedUnion("ruleType", {
    regex: z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeRegex$inboundSchema
    ),
    json: z.lazy(() => EventBreakerExistingOrNewNewRuleTypeJson$inboundSchema),
    json_array: smartUnion([
      z.lazy(() =>
        EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$inboundSchema
      ),
      z.lazy(() =>
        EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$inboundSchema
      ),
    ]).and(z.object({ ruleType: z.literal("json_array") })),
    header: z.lazy(() =>
      EventBreakerExistingOrNewNewRuleTypeHeader$inboundSchema
    ),
    csv: z.lazy(() => EventBreakerExistingOrNewNewRuleTypeCsv$inboundSchema),
  }).and(z.object({ existingOrNew: z.literal("new") })),
  existing: z.lazy(() => EventBreakerExistingOrNewExisting$inboundSchema),
});
/** @internal */
export type PipelineFunctionEventBreakerConf$Outbound =
  | (
    | EventBreakerExistingOrNewNewRuleTypeRegex$Outbound
    | EventBreakerExistingOrNewNewRuleTypeJson$Outbound
    | (
      | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$Outbound
      | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$Outbound
        & { ruleType: "json_array" }
    )
    | EventBreakerExistingOrNewNewRuleTypeHeader$Outbound
    | EventBreakerExistingOrNewNewRuleTypeCsv$Outbound & {
      existingOrNew: "new";
    }
  )
  | EventBreakerExistingOrNewExisting$Outbound;

/** @internal */
export const PipelineFunctionEventBreakerConf$outboundSchema: z.ZodType<
  PipelineFunctionEventBreakerConf$Outbound,
  z.ZodTypeDef,
  PipelineFunctionEventBreakerConf
> = z.union([
  z.union([
    z.lazy(() => EventBreakerExistingOrNewNewRuleTypeRegex$outboundSchema),
    z.lazy(() => EventBreakerExistingOrNewNewRuleTypeJson$outboundSchema),
    smartUnion([
      z.lazy(() =>
        EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$outboundSchema
      ),
      z.lazy(() =>
        EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$outboundSchema
      ),
    ]).and(z.object({ ruleType: z.literal("json_array") })),
    z.lazy(() => EventBreakerExistingOrNewNewRuleTypeHeader$outboundSchema),
    z.lazy(() => EventBreakerExistingOrNewNewRuleTypeCsv$outboundSchema),
  ]).and(z.object({ existingOrNew: z.literal("new") })),
  z.lazy(() => EventBreakerExistingOrNewExisting$outboundSchema),
]);

export function pipelineFunctionEventBreakerConfToJSON(
  pipelineFunctionEventBreakerConf: PipelineFunctionEventBreakerConf,
): string {
  return JSON.stringify(
    PipelineFunctionEventBreakerConf$outboundSchema.parse(
      pipelineFunctionEventBreakerConf,
    ),
  );
}
export function pipelineFunctionEventBreakerConfFromJSON(
  jsonString: string,
): SafeParseResult<PipelineFunctionEventBreakerConf, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PipelineFunctionEventBreakerConf$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PipelineFunctionEventBreakerConf' from JSON`,
  );
}

/** @internal */
export const PipelineFunctionEventBreaker$inboundSchema: z.ZodType<
  PipelineFunctionEventBreaker,
  z.ZodTypeDef,
  unknown
> = z.object({
  filter: types.optional(types.string()),
  id: types.literal("event_breaker"),
  description: types.optional(types.string()),
  disabled: types.optional(types.boolean()),
  final: types.optional(types.boolean()),
  conf: discriminatedUnion("existingOrNew", {
    new: discriminatedUnion("ruleType", {
      regex: z.lazy(() =>
        EventBreakerExistingOrNewNewRuleTypeRegex$inboundSchema
      ),
      json: z.lazy(() =>
        EventBreakerExistingOrNewNewRuleTypeJson$inboundSchema
      ),
      json_array: smartUnion([
        z.lazy(() =>
          EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$inboundSchema
        ),
        z.lazy(() =>
          EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$inboundSchema
        ),
      ]).and(z.object({ ruleType: z.literal("json_array") })),
      header: z.lazy(() =>
        EventBreakerExistingOrNewNewRuleTypeHeader$inboundSchema
      ),
      csv: z.lazy(() => EventBreakerExistingOrNewNewRuleTypeCsv$inboundSchema),
    }).and(z.object({ existingOrNew: z.literal("new") })),
    existing: z.lazy(() => EventBreakerExistingOrNewExisting$inboundSchema),
  }),
  groupId: types.optional(types.string()),
});
/** @internal */
export type PipelineFunctionEventBreaker$Outbound = {
  filter?: string | undefined;
  id: "event_breaker";
  description?: string | undefined;
  disabled?: boolean | undefined;
  final?: boolean | undefined;
  conf:
    | (
      | EventBreakerExistingOrNewNewRuleTypeRegex$Outbound
      | EventBreakerExistingOrNewNewRuleTypeJson$Outbound
      | (
        | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$Outbound
        | EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$Outbound
          & { ruleType: "json_array" }
      )
      | EventBreakerExistingOrNewNewRuleTypeHeader$Outbound
      | EventBreakerExistingOrNewNewRuleTypeCsv$Outbound & {
        existingOrNew: "new";
      }
    )
    | EventBreakerExistingOrNewExisting$Outbound;
  groupId?: string | undefined;
};

/** @internal */
export const PipelineFunctionEventBreaker$outboundSchema: z.ZodType<
  PipelineFunctionEventBreaker$Outbound,
  z.ZodTypeDef,
  PipelineFunctionEventBreaker
> = z.object({
  filter: z.string().optional(),
  id: z.literal("event_breaker"),
  description: z.string().optional(),
  disabled: z.boolean().optional(),
  final: z.boolean().optional(),
  conf: z.union([
    z.union([
      z.lazy(() => EventBreakerExistingOrNewNewRuleTypeRegex$outboundSchema),
      z.lazy(() => EventBreakerExistingOrNewNewRuleTypeJson$outboundSchema),
      smartUnion([
        z.lazy(() =>
          EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllTrue$outboundSchema
        ),
        z.lazy(() =>
          EventBreakerExistingOrNewNewRuleTypeJsonArrayJsonExtractAllFalse$outboundSchema
        ),
      ]).and(z.object({ ruleType: z.literal("json_array") })),
      z.lazy(() => EventBreakerExistingOrNewNewRuleTypeHeader$outboundSchema),
      z.lazy(() => EventBreakerExistingOrNewNewRuleTypeCsv$outboundSchema),
    ]).and(z.object({ existingOrNew: z.literal("new") })),
    z.lazy(() => EventBreakerExistingOrNewExisting$outboundSchema),
  ]),
  groupId: z.string().optional(),
});

export function pipelineFunctionEventBreakerToJSON(
  pipelineFunctionEventBreaker: PipelineFunctionEventBreaker,
): string {
  return JSON.stringify(
    PipelineFunctionEventBreaker$outboundSchema.parse(
      pipelineFunctionEventBreaker,
    ),
  );
}
export function pipelineFunctionEventBreakerFromJSON(
  jsonString: string,
): SafeParseResult<PipelineFunctionEventBreaker, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PipelineFunctionEventBreaker$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PipelineFunctionEventBreaker' from JSON`,
  );
}
