/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  ConnectionsType,
  ConnectionsType$inboundSchema,
  ConnectionsType$Outbound,
  ConnectionsType$outboundSchema,
} from "./connectionstype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata1Type,
  Metadata1Type$inboundSchema,
  Metadata1Type$Outbound,
  Metadata1Type$outboundSchema,
} from "./metadata1type.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const ScheduleTypeEnum6 = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type ScheduleTypeEnum6 = OpenEnum<typeof ScheduleTypeEnum6>;

export const InputExecType6 = {
  Exec: "exec",
} as const;
export type InputExecType6 = ClosedEnum<typeof InputExecType6>;

export type InputExec6 = {
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: ScheduleTypeEnum6 | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputExecType6;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const ScheduleTypeEnum5 = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type ScheduleTypeEnum5 = OpenEnum<typeof ScheduleTypeEnum5>;

export const InputExecType5 = {
  Exec: "exec",
} as const;
export type InputExecType5 = ClosedEnum<typeof InputExecType5>;

export type InputExec5 = {
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: ScheduleTypeEnum5 | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputExecType5;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

export const InputExecType4 = {
  Exec: "exec",
} as const;
export type InputExecType4 = ClosedEnum<typeof InputExecType4>;

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const ScheduleTypeEnum4 = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type ScheduleTypeEnum4 = OpenEnum<typeof ScheduleTypeEnum4>;

export type InputExec4 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputExecType4;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq: PqType;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: ScheduleTypeEnum4 | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

export const InputExecType3 = {
  Exec: "exec",
} as const;
export type InputExecType3 = ClosedEnum<typeof InputExecType3>;

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const ScheduleTypeEnum3 = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type ScheduleTypeEnum3 = OpenEnum<typeof ScheduleTypeEnum3>;

export type InputExec3 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputExecType3;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: ScheduleTypeEnum3 | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

export const InputExecType2 = {
  Exec: "exec",
} as const;
export type InputExecType2 = ClosedEnum<typeof InputExecType2>;

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const ScheduleTypeEnum2 = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type ScheduleTypeEnum2 = OpenEnum<typeof ScheduleTypeEnum2>;

export type InputExec2 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputExecType2;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections: Array<ConnectionsType>;
  pq?: PqType | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: ScheduleTypeEnum2 | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

export const InputExecType1 = {
  Exec: "exec",
} as const;
export type InputExecType1 = ClosedEnum<typeof InputExecType1>;

/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export const ScheduleTypeEnum1 = {
  Interval: "interval",
  CronSchedule: "cronSchedule",
} as const;
/**
 * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
 */
export type ScheduleTypeEnum1 = OpenEnum<typeof ScheduleTypeEnum1>;

export type InputExec1 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputExecType1;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Command to execute; supports Bourne shell (or CMD on Windows) syntax
   */
  command: string;
  /**
   * Maximum number of retry attempts in the event that the command fails
   */
  retries?: number | undefined;
  /**
   * Select a schedule type; either an interval (in seconds) or a cron-style schedule.
   */
  scheduleType?: ScheduleTypeEnum1 | undefined;
  /**
   * A list of event-breaking rulesets that will be applied, in order, to the input data stream
   */
  breakerRulesets?: Array<string> | undefined;
  /**
   * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines
   */
  staleChannelFlushMs?: number | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  description?: string | undefined;
  /**
   * Interval between command executions in seconds.
   */
  interval?: number | undefined;
  /**
   * Cron schedule to execute the command on.
   */
  cronSchedule?: string | undefined;
};

export type InputExecUnion =
  | InputExec2
  | InputExec4
  | InputExec1
  | InputExec3
  | InputExec5
  | InputExec6;

/** @internal */
export const ScheduleTypeEnum6$inboundSchema: z.ZodType<
  ScheduleTypeEnum6,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ScheduleTypeEnum6),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ScheduleTypeEnum6$outboundSchema: z.ZodType<
  ScheduleTypeEnum6,
  z.ZodTypeDef,
  ScheduleTypeEnum6
> = z.union([
  z.nativeEnum(ScheduleTypeEnum6),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputExecType6$inboundSchema: z.ZodNativeEnum<
  typeof InputExecType6
> = z.nativeEnum(InputExecType6);
/** @internal */
export const InputExecType6$outboundSchema: z.ZodNativeEnum<
  typeof InputExecType6
> = InputExecType6$inboundSchema;

/** @internal */
export const InputExec6$inboundSchema: z.ZodType<
  InputExec6,
  z.ZodTypeDef,
  unknown
> = z.object({
  scheduleType: ScheduleTypeEnum6$inboundSchema.default("interval"),
  id: z.string().optional(),
  type: InputExecType6$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  command: z.string(),
  retries: z.number().default(10),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});
/** @internal */
export type InputExec6$Outbound = {
  scheduleType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  command: string;
  retries: number;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  interval: number;
  cronSchedule: string;
};

/** @internal */
export const InputExec6$outboundSchema: z.ZodType<
  InputExec6$Outbound,
  z.ZodTypeDef,
  InputExec6
> = z.object({
  scheduleType: ScheduleTypeEnum6$outboundSchema.default("interval"),
  id: z.string().optional(),
  type: InputExecType6$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  command: z.string(),
  retries: z.number().default(10),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

export function inputExec6ToJSON(inputExec6: InputExec6): string {
  return JSON.stringify(InputExec6$outboundSchema.parse(inputExec6));
}
export function inputExec6FromJSON(
  jsonString: string,
): SafeParseResult<InputExec6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExec6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExec6' from JSON`,
  );
}

/** @internal */
export const ScheduleTypeEnum5$inboundSchema: z.ZodType<
  ScheduleTypeEnum5,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ScheduleTypeEnum5),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ScheduleTypeEnum5$outboundSchema: z.ZodType<
  ScheduleTypeEnum5,
  z.ZodTypeDef,
  ScheduleTypeEnum5
> = z.union([
  z.nativeEnum(ScheduleTypeEnum5),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputExecType5$inboundSchema: z.ZodNativeEnum<
  typeof InputExecType5
> = z.nativeEnum(InputExecType5);
/** @internal */
export const InputExecType5$outboundSchema: z.ZodNativeEnum<
  typeof InputExecType5
> = InputExecType5$inboundSchema;

/** @internal */
export const InputExec5$inboundSchema: z.ZodType<
  InputExec5,
  z.ZodTypeDef,
  unknown
> = z.object({
  scheduleType: ScheduleTypeEnum5$inboundSchema.default("interval"),
  id: z.string().optional(),
  type: InputExecType5$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  command: z.string(),
  retries: z.number().default(10),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});
/** @internal */
export type InputExec5$Outbound = {
  scheduleType: string;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  command: string;
  retries: number;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  interval: number;
  cronSchedule: string;
};

/** @internal */
export const InputExec5$outboundSchema: z.ZodType<
  InputExec5$Outbound,
  z.ZodTypeDef,
  InputExec5
> = z.object({
  scheduleType: ScheduleTypeEnum5$outboundSchema.default("interval"),
  id: z.string().optional(),
  type: InputExecType5$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  command: z.string(),
  retries: z.number().default(10),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

export function inputExec5ToJSON(inputExec5: InputExec5): string {
  return JSON.stringify(InputExec5$outboundSchema.parse(inputExec5));
}
export function inputExec5FromJSON(
  jsonString: string,
): SafeParseResult<InputExec5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExec5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExec5' from JSON`,
  );
}

/** @internal */
export const InputExecType4$inboundSchema: z.ZodNativeEnum<
  typeof InputExecType4
> = z.nativeEnum(InputExecType4);
/** @internal */
export const InputExecType4$outboundSchema: z.ZodNativeEnum<
  typeof InputExecType4
> = InputExecType4$inboundSchema;

/** @internal */
export const ScheduleTypeEnum4$inboundSchema: z.ZodType<
  ScheduleTypeEnum4,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ScheduleTypeEnum4),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ScheduleTypeEnum4$outboundSchema: z.ZodType<
  ScheduleTypeEnum4,
  z.ZodTypeDef,
  ScheduleTypeEnum4
> = z.union([
  z.nativeEnum(ScheduleTypeEnum4),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputExec4$inboundSchema: z.ZodType<
  InputExec4,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputExecType4$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema,
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleTypeEnum4$inboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});
/** @internal */
export type InputExec4$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq: PqType$Outbound;
  command: string;
  retries: number;
  scheduleType: string;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  interval: number;
  cronSchedule: string;
};

/** @internal */
export const InputExec4$outboundSchema: z.ZodType<
  InputExec4$Outbound,
  z.ZodTypeDef,
  InputExec4
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputExecType4$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema,
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleTypeEnum4$outboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

export function inputExec4ToJSON(inputExec4: InputExec4): string {
  return JSON.stringify(InputExec4$outboundSchema.parse(inputExec4));
}
export function inputExec4FromJSON(
  jsonString: string,
): SafeParseResult<InputExec4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExec4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExec4' from JSON`,
  );
}

/** @internal */
export const InputExecType3$inboundSchema: z.ZodNativeEnum<
  typeof InputExecType3
> = z.nativeEnum(InputExecType3);
/** @internal */
export const InputExecType3$outboundSchema: z.ZodNativeEnum<
  typeof InputExecType3
> = InputExecType3$inboundSchema;

/** @internal */
export const ScheduleTypeEnum3$inboundSchema: z.ZodType<
  ScheduleTypeEnum3,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ScheduleTypeEnum3),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ScheduleTypeEnum3$outboundSchema: z.ZodType<
  ScheduleTypeEnum3,
  z.ZodTypeDef,
  ScheduleTypeEnum3
> = z.union([
  z.nativeEnum(ScheduleTypeEnum3),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputExec3$inboundSchema: z.ZodType<
  InputExec3,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputExecType3$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleTypeEnum3$inboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});
/** @internal */
export type InputExec3$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  command: string;
  retries: number;
  scheduleType: string;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  interval: number;
  cronSchedule: string;
};

/** @internal */
export const InputExec3$outboundSchema: z.ZodType<
  InputExec3$Outbound,
  z.ZodTypeDef,
  InputExec3
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputExecType3$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleTypeEnum3$outboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

export function inputExec3ToJSON(inputExec3: InputExec3): string {
  return JSON.stringify(InputExec3$outboundSchema.parse(inputExec3));
}
export function inputExec3FromJSON(
  jsonString: string,
): SafeParseResult<InputExec3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExec3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExec3' from JSON`,
  );
}

/** @internal */
export const InputExecType2$inboundSchema: z.ZodNativeEnum<
  typeof InputExecType2
> = z.nativeEnum(InputExecType2);
/** @internal */
export const InputExecType2$outboundSchema: z.ZodNativeEnum<
  typeof InputExecType2
> = InputExecType2$inboundSchema;

/** @internal */
export const ScheduleTypeEnum2$inboundSchema: z.ZodType<
  ScheduleTypeEnum2,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ScheduleTypeEnum2),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ScheduleTypeEnum2$outboundSchema: z.ZodType<
  ScheduleTypeEnum2,
  z.ZodTypeDef,
  ScheduleTypeEnum2
> = z.union([
  z.nativeEnum(ScheduleTypeEnum2),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputExec2$inboundSchema: z.ZodType<
  InputExec2,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputExecType2$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema),
  pq: PqType$inboundSchema.optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleTypeEnum2$inboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});
/** @internal */
export type InputExec2$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections: Array<ConnectionsType$Outbound>;
  pq?: PqType$Outbound | undefined;
  command: string;
  retries: number;
  scheduleType: string;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  interval: number;
  cronSchedule: string;
};

/** @internal */
export const InputExec2$outboundSchema: z.ZodType<
  InputExec2$Outbound,
  z.ZodTypeDef,
  InputExec2
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputExecType2$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema),
  pq: PqType$outboundSchema.optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleTypeEnum2$outboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

export function inputExec2ToJSON(inputExec2: InputExec2): string {
  return JSON.stringify(InputExec2$outboundSchema.parse(inputExec2));
}
export function inputExec2FromJSON(
  jsonString: string,
): SafeParseResult<InputExec2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExec2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExec2' from JSON`,
  );
}

/** @internal */
export const InputExecType1$inboundSchema: z.ZodNativeEnum<
  typeof InputExecType1
> = z.nativeEnum(InputExecType1);
/** @internal */
export const InputExecType1$outboundSchema: z.ZodNativeEnum<
  typeof InputExecType1
> = InputExecType1$inboundSchema;

/** @internal */
export const ScheduleTypeEnum1$inboundSchema: z.ZodType<
  ScheduleTypeEnum1,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(ScheduleTypeEnum1),
    z.string().transform(catchUnrecognizedEnum),
  ]);
/** @internal */
export const ScheduleTypeEnum1$outboundSchema: z.ZodType<
  ScheduleTypeEnum1,
  z.ZodTypeDef,
  ScheduleTypeEnum1
> = z.union([
  z.nativeEnum(ScheduleTypeEnum1),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/** @internal */
export const InputExec1$inboundSchema: z.ZodType<
  InputExec1,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputExecType1$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleTypeEnum1$inboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});
/** @internal */
export type InputExec1$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  command: string;
  retries: number;
  scheduleType: string;
  breakerRulesets?: Array<string> | undefined;
  staleChannelFlushMs: number;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  description?: string | undefined;
  interval: number;
  cronSchedule: string;
};

/** @internal */
export const InputExec1$outboundSchema: z.ZodType<
  InputExec1$Outbound,
  z.ZodTypeDef,
  InputExec1
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputExecType1$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  command: z.string(),
  retries: z.number().default(10),
  scheduleType: ScheduleTypeEnum1$outboundSchema.default("interval"),
  breakerRulesets: z.array(z.string()).optional(),
  staleChannelFlushMs: z.number().default(10000),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  description: z.string().optional(),
  interval: z.number().default(60),
  cronSchedule: z.string().default("* * * * *"),
});

export function inputExec1ToJSON(inputExec1: InputExec1): string {
  return JSON.stringify(InputExec1$outboundSchema.parse(inputExec1));
}
export function inputExec1FromJSON(
  jsonString: string,
): SafeParseResult<InputExec1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExec1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExec1' from JSON`,
  );
}

/** @internal */
export const InputExecUnion$inboundSchema: z.ZodType<
  InputExecUnion,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputExec2$inboundSchema),
  z.lazy(() => InputExec4$inboundSchema),
  z.lazy(() => InputExec1$inboundSchema),
  z.lazy(() => InputExec3$inboundSchema),
  z.lazy(() => InputExec5$inboundSchema),
  z.lazy(() => InputExec6$inboundSchema),
]);
/** @internal */
export type InputExecUnion$Outbound =
  | InputExec2$Outbound
  | InputExec4$Outbound
  | InputExec1$Outbound
  | InputExec3$Outbound
  | InputExec5$Outbound
  | InputExec6$Outbound;

/** @internal */
export const InputExecUnion$outboundSchema: z.ZodType<
  InputExecUnion$Outbound,
  z.ZodTypeDef,
  InputExecUnion
> = z.union([
  z.lazy(() => InputExec2$outboundSchema),
  z.lazy(() => InputExec4$outboundSchema),
  z.lazy(() => InputExec1$outboundSchema),
  z.lazy(() => InputExec3$outboundSchema),
  z.lazy(() => InputExec5$outboundSchema),
  z.lazy(() => InputExec6$outboundSchema),
]);

export function inputExecUnionToJSON(inputExecUnion: InputExecUnion): string {
  return JSON.stringify(InputExecUnion$outboundSchema.parse(inputExecUnion));
}
export function inputExecUnionFromJSON(
  jsonString: string,
): SafeParseResult<InputExecUnion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputExecUnion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputExecUnion' from JSON`,
  );
}
