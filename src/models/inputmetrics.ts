/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import {
  catchUnrecognizedEnum,
  ClosedEnum,
  OpenEnum,
  Unrecognized,
} from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";

export const InputMetricsType = {
  Metrics: "metrics",
} as const;
export type InputMetricsType = ClosedEnum<typeof InputMetricsType>;

export type InputMetricsConnection = {
  pipeline?: string | undefined;
  output: string;
};

/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export const InputMetricsMode = {
  Smart: "smart",
  Always: "always",
} as const;
/**
 * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
 */
export type InputMetricsMode = OpenEnum<typeof InputMetricsMode>;

/**
 * Codec to use to compress the persisted data
 */
export const InputMetricsCompression = {
  None: "none",
  Gzip: "gzip",
} as const;
/**
 * Codec to use to compress the persisted data
 */
export type InputMetricsCompression = OpenEnum<typeof InputMetricsCompression>;

export type InputMetricsPqControls = {};

export type InputMetricsPq = {
  /**
   * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine.
   */
  mode?: InputMetricsMode | undefined;
  /**
   * The maximum number of events to hold in memory before writing the events to disk
   */
  maxBufferSize?: number | undefined;
  /**
   * The number of events to send downstream before committing that Stream has read them
   */
  commitFrequency?: number | undefined;
  /**
   * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc.
   */
  maxFileSize?: string | undefined;
  /**
   * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc.
   */
  maxSize?: string | undefined;
  /**
   * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>
   */
  path?: string | undefined;
  /**
   * Codec to use to compress the persisted data
   */
  compress?: InputMetricsCompression | undefined;
  pqControls?: InputMetricsPqControls | undefined;
};

export const InputMetricsMinimumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputMetricsMinimumTLSVersion = OpenEnum<
  typeof InputMetricsMinimumTLSVersion
>;

export const InputMetricsMaximumTLSVersion = {
  TLSv1: "TLSv1",
  TLSv11: "TLSv1.1",
  TLSv12: "TLSv1.2",
  TLSv13: "TLSv1.3",
} as const;
export type InputMetricsMaximumTLSVersion = OpenEnum<
  typeof InputMetricsMaximumTLSVersion
>;

export type InputMetricsTLSSettingsServerSide = {
  disabled?: boolean | undefined;
  /**
   * The name of the predefined certificate
   */
  certificateName?: string | undefined;
  /**
   * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
   */
  privKeyPath?: string | undefined;
  /**
   * Passphrase to use to decrypt private key
   */
  passphrase?: string | undefined;
  /**
   * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
   */
  certPath?: string | undefined;
  /**
   * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
   */
  caPath?: string | undefined;
  /**
   * Require clients to present their certificates. Used to perform client authentication using SSL certs.
   */
  requestCert?: boolean | undefined;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: InputMetricsMinimumTLSVersion | undefined;
  maxVersion?: InputMetricsMaximumTLSVersion | undefined;
};

export type InputMetricsMetadatum = {
  name: string;
  /**
   * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
   */
  value: string;
};

export type InputMetrics = {
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputMetricsType;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<InputMetricsConnection> | undefined;
  pq?: InputMetricsPq | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  tls?: InputMetricsTLSSettingsServerSide | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<InputMetricsMetadatum> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetricsType$inboundSchema: z.ZodNativeEnum<
  typeof InputMetricsType
> = z.nativeEnum(InputMetricsType);

/** @internal */
export const InputMetricsType$outboundSchema: z.ZodNativeEnum<
  typeof InputMetricsType
> = InputMetricsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsType$ {
  /** @deprecated use `InputMetricsType$inboundSchema` instead. */
  export const inboundSchema = InputMetricsType$inboundSchema;
  /** @deprecated use `InputMetricsType$outboundSchema` instead. */
  export const outboundSchema = InputMetricsType$outboundSchema;
}

/** @internal */
export const InputMetricsConnection$inboundSchema: z.ZodType<
  InputMetricsConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/** @internal */
export type InputMetricsConnection$Outbound = {
  pipeline?: string | undefined;
  output: string;
};

/** @internal */
export const InputMetricsConnection$outboundSchema: z.ZodType<
  InputMetricsConnection$Outbound,
  z.ZodTypeDef,
  InputMetricsConnection
> = z.object({
  pipeline: z.string().optional(),
  output: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsConnection$ {
  /** @deprecated use `InputMetricsConnection$inboundSchema` instead. */
  export const inboundSchema = InputMetricsConnection$inboundSchema;
  /** @deprecated use `InputMetricsConnection$outboundSchema` instead. */
  export const outboundSchema = InputMetricsConnection$outboundSchema;
  /** @deprecated use `InputMetricsConnection$Outbound` instead. */
  export type Outbound = InputMetricsConnection$Outbound;
}

export function inputMetricsConnectionToJSON(
  inputMetricsConnection: InputMetricsConnection,
): string {
  return JSON.stringify(
    InputMetricsConnection$outboundSchema.parse(inputMetricsConnection),
  );
}

export function inputMetricsConnectionFromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsConnection' from JSON`,
  );
}

/** @internal */
export const InputMetricsMode$inboundSchema: z.ZodType<
  InputMetricsMode,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMetricsMode),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMetricsMode$outboundSchema: z.ZodType<
  InputMetricsMode,
  z.ZodTypeDef,
  InputMetricsMode
> = z.union([
  z.nativeEnum(InputMetricsMode),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsMode$ {
  /** @deprecated use `InputMetricsMode$inboundSchema` instead. */
  export const inboundSchema = InputMetricsMode$inboundSchema;
  /** @deprecated use `InputMetricsMode$outboundSchema` instead. */
  export const outboundSchema = InputMetricsMode$outboundSchema;
}

/** @internal */
export const InputMetricsCompression$inboundSchema: z.ZodType<
  InputMetricsCompression,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMetricsCompression),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMetricsCompression$outboundSchema: z.ZodType<
  InputMetricsCompression,
  z.ZodTypeDef,
  InputMetricsCompression
> = z.union([
  z.nativeEnum(InputMetricsCompression),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsCompression$ {
  /** @deprecated use `InputMetricsCompression$inboundSchema` instead. */
  export const inboundSchema = InputMetricsCompression$inboundSchema;
  /** @deprecated use `InputMetricsCompression$outboundSchema` instead. */
  export const outboundSchema = InputMetricsCompression$outboundSchema;
}

/** @internal */
export const InputMetricsPqControls$inboundSchema: z.ZodType<
  InputMetricsPqControls,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type InputMetricsPqControls$Outbound = {};

/** @internal */
export const InputMetricsPqControls$outboundSchema: z.ZodType<
  InputMetricsPqControls$Outbound,
  z.ZodTypeDef,
  InputMetricsPqControls
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsPqControls$ {
  /** @deprecated use `InputMetricsPqControls$inboundSchema` instead. */
  export const inboundSchema = InputMetricsPqControls$inboundSchema;
  /** @deprecated use `InputMetricsPqControls$outboundSchema` instead. */
  export const outboundSchema = InputMetricsPqControls$outboundSchema;
  /** @deprecated use `InputMetricsPqControls$Outbound` instead. */
  export type Outbound = InputMetricsPqControls$Outbound;
}

export function inputMetricsPqControlsToJSON(
  inputMetricsPqControls: InputMetricsPqControls,
): string {
  return JSON.stringify(
    InputMetricsPqControls$outboundSchema.parse(inputMetricsPqControls),
  );
}

export function inputMetricsPqControlsFromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsPqControls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsPqControls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsPqControls' from JSON`,
  );
}

/** @internal */
export const InputMetricsPq$inboundSchema: z.ZodType<
  InputMetricsPq,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: InputMetricsMode$inboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputMetricsCompression$inboundSchema.default("none"),
  pqControls: z.lazy(() => InputMetricsPqControls$inboundSchema).optional(),
});

/** @internal */
export type InputMetricsPq$Outbound = {
  mode: string;
  maxBufferSize: number;
  commitFrequency: number;
  maxFileSize: string;
  maxSize: string;
  path: string;
  compress: string;
  pqControls?: InputMetricsPqControls$Outbound | undefined;
};

/** @internal */
export const InputMetricsPq$outboundSchema: z.ZodType<
  InputMetricsPq$Outbound,
  z.ZodTypeDef,
  InputMetricsPq
> = z.object({
  mode: InputMetricsMode$outboundSchema.default("always"),
  maxBufferSize: z.number().default(1000),
  commitFrequency: z.number().default(42),
  maxFileSize: z.string().default("1 MB"),
  maxSize: z.string().default("5GB"),
  path: z.string().default("$CRIBL_HOME/state/queues"),
  compress: InputMetricsCompression$outboundSchema.default("none"),
  pqControls: z.lazy(() => InputMetricsPqControls$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsPq$ {
  /** @deprecated use `InputMetricsPq$inboundSchema` instead. */
  export const inboundSchema = InputMetricsPq$inboundSchema;
  /** @deprecated use `InputMetricsPq$outboundSchema` instead. */
  export const outboundSchema = InputMetricsPq$outboundSchema;
  /** @deprecated use `InputMetricsPq$Outbound` instead. */
  export type Outbound = InputMetricsPq$Outbound;
}

export function inputMetricsPqToJSON(inputMetricsPq: InputMetricsPq): string {
  return JSON.stringify(InputMetricsPq$outboundSchema.parse(inputMetricsPq));
}

export function inputMetricsPqFromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsPq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsPq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsPq' from JSON`,
  );
}

/** @internal */
export const InputMetricsMinimumTLSVersion$inboundSchema: z.ZodType<
  InputMetricsMinimumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMetricsMinimumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMetricsMinimumTLSVersion$outboundSchema: z.ZodType<
  InputMetricsMinimumTLSVersion,
  z.ZodTypeDef,
  InputMetricsMinimumTLSVersion
> = z.union([
  z.nativeEnum(InputMetricsMinimumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsMinimumTLSVersion$ {
  /** @deprecated use `InputMetricsMinimumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputMetricsMinimumTLSVersion$inboundSchema;
  /** @deprecated use `InputMetricsMinimumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputMetricsMinimumTLSVersion$outboundSchema;
}

/** @internal */
export const InputMetricsMaximumTLSVersion$inboundSchema: z.ZodType<
  InputMetricsMaximumTLSVersion,
  z.ZodTypeDef,
  unknown
> = z
  .union([
    z.nativeEnum(InputMetricsMaximumTLSVersion),
    z.string().transform(catchUnrecognizedEnum),
  ]);

/** @internal */
export const InputMetricsMaximumTLSVersion$outboundSchema: z.ZodType<
  InputMetricsMaximumTLSVersion,
  z.ZodTypeDef,
  InputMetricsMaximumTLSVersion
> = z.union([
  z.nativeEnum(InputMetricsMaximumTLSVersion),
  z.string().and(z.custom<Unrecognized<string>>()),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsMaximumTLSVersion$ {
  /** @deprecated use `InputMetricsMaximumTLSVersion$inboundSchema` instead. */
  export const inboundSchema = InputMetricsMaximumTLSVersion$inboundSchema;
  /** @deprecated use `InputMetricsMaximumTLSVersion$outboundSchema` instead. */
  export const outboundSchema = InputMetricsMaximumTLSVersion$outboundSchema;
}

/** @internal */
export const InputMetricsTLSSettingsServerSide$inboundSchema: z.ZodType<
  InputMetricsTLSSettingsServerSide,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputMetricsMinimumTLSVersion$inboundSchema.optional(),
  maxVersion: InputMetricsMaximumTLSVersion$inboundSchema.optional(),
});

/** @internal */
export type InputMetricsTLSSettingsServerSide$Outbound = {
  disabled: boolean;
  certificateName?: string | undefined;
  privKeyPath?: string | undefined;
  passphrase?: string | undefined;
  certPath?: string | undefined;
  caPath?: string | undefined;
  requestCert: boolean;
  rejectUnauthorized?: any | undefined;
  commonNameRegex?: any | undefined;
  minVersion?: string | undefined;
  maxVersion?: string | undefined;
};

/** @internal */
export const InputMetricsTLSSettingsServerSide$outboundSchema: z.ZodType<
  InputMetricsTLSSettingsServerSide$Outbound,
  z.ZodTypeDef,
  InputMetricsTLSSettingsServerSide
> = z.object({
  disabled: z.boolean().default(true),
  certificateName: z.string().optional(),
  privKeyPath: z.string().optional(),
  passphrase: z.string().optional(),
  certPath: z.string().optional(),
  caPath: z.string().optional(),
  requestCert: z.boolean().default(false),
  rejectUnauthorized: z.any().optional(),
  commonNameRegex: z.any().optional(),
  minVersion: InputMetricsMinimumTLSVersion$outboundSchema.optional(),
  maxVersion: InputMetricsMaximumTLSVersion$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsTLSSettingsServerSide$ {
  /** @deprecated use `InputMetricsTLSSettingsServerSide$inboundSchema` instead. */
  export const inboundSchema = InputMetricsTLSSettingsServerSide$inboundSchema;
  /** @deprecated use `InputMetricsTLSSettingsServerSide$outboundSchema` instead. */
  export const outboundSchema =
    InputMetricsTLSSettingsServerSide$outboundSchema;
  /** @deprecated use `InputMetricsTLSSettingsServerSide$Outbound` instead. */
  export type Outbound = InputMetricsTLSSettingsServerSide$Outbound;
}

export function inputMetricsTLSSettingsServerSideToJSON(
  inputMetricsTLSSettingsServerSide: InputMetricsTLSSettingsServerSide,
): string {
  return JSON.stringify(
    InputMetricsTLSSettingsServerSide$outboundSchema.parse(
      inputMetricsTLSSettingsServerSide,
    ),
  );
}

export function inputMetricsTLSSettingsServerSideFromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsTLSSettingsServerSide, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsTLSSettingsServerSide$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsTLSSettingsServerSide' from JSON`,
  );
}

/** @internal */
export const InputMetricsMetadatum$inboundSchema: z.ZodType<
  InputMetricsMetadatum,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  value: z.string(),
});

/** @internal */
export type InputMetricsMetadatum$Outbound = {
  name: string;
  value: string;
};

/** @internal */
export const InputMetricsMetadatum$outboundSchema: z.ZodType<
  InputMetricsMetadatum$Outbound,
  z.ZodTypeDef,
  InputMetricsMetadatum
> = z.object({
  name: z.string(),
  value: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetricsMetadatum$ {
  /** @deprecated use `InputMetricsMetadatum$inboundSchema` instead. */
  export const inboundSchema = InputMetricsMetadatum$inboundSchema;
  /** @deprecated use `InputMetricsMetadatum$outboundSchema` instead. */
  export const outboundSchema = InputMetricsMetadatum$outboundSchema;
  /** @deprecated use `InputMetricsMetadatum$Outbound` instead. */
  export type Outbound = InputMetricsMetadatum$Outbound;
}

export function inputMetricsMetadatumToJSON(
  inputMetricsMetadatum: InputMetricsMetadatum,
): string {
  return JSON.stringify(
    InputMetricsMetadatum$outboundSchema.parse(inputMetricsMetadatum),
  );
}

export function inputMetricsMetadatumFromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsMetadatum, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsMetadatum$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsMetadatum' from JSON`,
  );
}

/** @internal */
export const InputMetrics$inboundSchema: z.ZodType<
  InputMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: InputMetricsType$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputMetricsConnection$inboundSchema))
    .optional(),
  pq: z.lazy(() => InputMetricsPq$inboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: z.lazy(() => InputMetricsTLSSettingsServerSide$inboundSchema).optional(),
  metadata: z.array(z.lazy(() => InputMetricsMetadatum$inboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

/** @internal */
export type InputMetrics$Outbound = {
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<InputMetricsConnection$Outbound> | undefined;
  pq?: InputMetricsPq$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort?: number | undefined;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  enableProxyHeader: boolean;
  tls?: InputMetricsTLSSettingsServerSide$Outbound | undefined;
  metadata?: Array<InputMetricsMetadatum$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetrics$outboundSchema: z.ZodType<
  InputMetrics$Outbound,
  z.ZodTypeDef,
  InputMetrics
> = z.object({
  id: z.string().optional(),
  type: InputMetricsType$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(z.lazy(() => InputMetricsConnection$outboundSchema))
    .optional(),
  pq: z.lazy(() => InputMetricsPq$outboundSchema).optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: z.lazy(() => InputMetricsTLSSettingsServerSide$outboundSchema)
    .optional(),
  metadata: z.array(z.lazy(() => InputMetricsMetadatum$outboundSchema))
    .optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputMetrics$ {
  /** @deprecated use `InputMetrics$inboundSchema` instead. */
  export const inboundSchema = InputMetrics$inboundSchema;
  /** @deprecated use `InputMetrics$outboundSchema` instead. */
  export const outboundSchema = InputMetrics$outboundSchema;
  /** @deprecated use `InputMetrics$Outbound` instead. */
  export type Outbound = InputMetrics$Outbound;
}

export function inputMetricsToJSON(inputMetrics: InputMetrics): string {
  return JSON.stringify(InputMetrics$outboundSchema.parse(inputMetrics));
}

export function inputMetricsFromJSON(
  jsonString: string,
): SafeParseResult<InputMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetrics' from JSON`,
  );
}
