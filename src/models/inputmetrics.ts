/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  ConnectionsType,
  ConnectionsType$inboundSchema,
  ConnectionsType$Outbound,
  ConnectionsType$outboundSchema,
} from "./connectionstype.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  Metadata1Type,
  Metadata1Type$inboundSchema,
  Metadata1Type$Outbound,
  Metadata1Type$outboundSchema,
} from "./metadata1type.js";
import {
  PqType,
  PqType$inboundSchema,
  PqType$Outbound,
  PqType$outboundSchema,
} from "./pqtype.js";
import {
  Tls2Type,
  Tls2Type$inboundSchema,
  Tls2Type$Outbound,
  Tls2Type$outboundSchema,
} from "./tls2type.js";

export const InputMetricsType4 = {
  Metrics: "metrics",
} as const;
export type InputMetricsType4 = ClosedEnum<typeof InputMetricsType4>;

export type InputMetricsMetrics4 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputMetricsType4;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq: PqType;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

export const InputMetricsType3 = {
  Metrics: "metrics",
} as const;
export type InputMetricsType3 = ClosedEnum<typeof InputMetricsType3>;

export type InputMetricsMetrics3 = {
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputMetricsType3;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

export const InputMetricsType2 = {
  Metrics: "metrics",
} as const;
export type InputMetricsType2 = ClosedEnum<typeof InputMetricsType2>;

export type InputMetricsMetrics2 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputMetricsType2;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections: Array<ConnectionsType>;
  pq?: PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

export const InputMetricsType1 = {
  Metrics: "metrics",
} as const;
export type InputMetricsType1 = ClosedEnum<typeof InputMetricsType1>;

export type InputMetricsMetrics1 = {
  /**
   * Select whether to send data to Routes, or directly to Destinations.
   */
  sendToRoutes?: boolean | undefined;
  /**
   * Unique ID for this input
   */
  id?: string | undefined;
  type: InputMetricsType1;
  disabled?: boolean | undefined;
  /**
   * Pipeline to process data from this Source before sending it through the Routes
   */
  pipeline?: string | undefined;
  /**
   * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
   */
  environment?: string | undefined;
  /**
   * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers).
   */
  pqEnabled?: boolean | undefined;
  /**
   * Tags for filtering and grouping in @{product}
   */
  streamtags?: Array<string> | undefined;
  /**
   * Direct connections to Destinations, and optionally via a Pipeline or a Pack
   */
  connections?: Array<ConnectionsType> | undefined;
  pq?: PqType | undefined;
  /**
   * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address.
   */
  host?: string | undefined;
  /**
   * Enter UDP port number to listen on. Not required if listening on TCP.
   */
  udpPort?: number | undefined;
  /**
   * Enter TCP port number to listen on. Not required if listening on UDP.
   */
  tcpPort?: number | undefined;
  /**
   * Maximum number of events to buffer when downstream is blocking. Only applies to UDP.
   */
  maxBufferSize?: number | undefined;
  /**
   * Regex matching IP addresses that are allowed to send data
   */
  ipWhitelistRegex?: string | undefined;
  /**
   * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2
   */
  enableProxyHeader?: boolean | undefined;
  tls?: Tls2Type | undefined;
  /**
   * Fields to add to events from this input
   */
  metadata?: Array<Metadata1Type> | undefined;
  /**
   * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
   */
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

export type InputMetrics =
  | InputMetricsMetrics2
  | InputMetricsMetrics4
  | InputMetricsMetrics1
  | InputMetricsMetrics3;

/** @internal */
export const InputMetricsType4$inboundSchema: z.ZodNativeEnum<
  typeof InputMetricsType4
> = z.nativeEnum(InputMetricsType4);
/** @internal */
export const InputMetricsType4$outboundSchema: z.ZodNativeEnum<
  typeof InputMetricsType4
> = InputMetricsType4$inboundSchema;

/** @internal */
export const InputMetricsMetrics4$inboundSchema: z.ZodType<
  InputMetricsMetrics4,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputMetricsType4$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema,
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: Tls2Type$inboundSchema.optional(),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});
/** @internal */
export type InputMetricsMetrics4$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq: PqType$Outbound;
  host: string;
  udpPort?: number | undefined;
  tcpPort?: number | undefined;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  enableProxyHeader: boolean;
  tls?: Tls2Type$Outbound | undefined;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetricsMetrics4$outboundSchema: z.ZodType<
  InputMetricsMetrics4$Outbound,
  z.ZodTypeDef,
  InputMetricsMetrics4
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputMetricsType4$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema,
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: Tls2Type$outboundSchema.optional(),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

export function inputMetricsMetrics4ToJSON(
  inputMetricsMetrics4: InputMetricsMetrics4,
): string {
  return JSON.stringify(
    InputMetricsMetrics4$outboundSchema.parse(inputMetricsMetrics4),
  );
}
export function inputMetricsMetrics4FromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsMetrics4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsMetrics4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsMetrics4' from JSON`,
  );
}

/** @internal */
export const InputMetricsType3$inboundSchema: z.ZodNativeEnum<
  typeof InputMetricsType3
> = z.nativeEnum(InputMetricsType3);
/** @internal */
export const InputMetricsType3$outboundSchema: z.ZodNativeEnum<
  typeof InputMetricsType3
> = InputMetricsType3$inboundSchema;

/** @internal */
export const InputMetricsMetrics3$inboundSchema: z.ZodType<
  InputMetricsMetrics3,
  z.ZodTypeDef,
  unknown
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputMetricsType3$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: Tls2Type$inboundSchema.optional(),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});
/** @internal */
export type InputMetricsMetrics3$Outbound = {
  pqEnabled: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  sendToRoutes: boolean;
  environment?: string | undefined;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort?: number | undefined;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  enableProxyHeader: boolean;
  tls?: Tls2Type$Outbound | undefined;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetricsMetrics3$outboundSchema: z.ZodType<
  InputMetricsMetrics3$Outbound,
  z.ZodTypeDef,
  InputMetricsMetrics3
> = z.object({
  pqEnabled: z.boolean().default(false),
  id: z.string().optional(),
  type: InputMetricsType3$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  sendToRoutes: z.boolean().default(true),
  environment: z.string().optional(),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: Tls2Type$outboundSchema.optional(),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

export function inputMetricsMetrics3ToJSON(
  inputMetricsMetrics3: InputMetricsMetrics3,
): string {
  return JSON.stringify(
    InputMetricsMetrics3$outboundSchema.parse(inputMetricsMetrics3),
  );
}
export function inputMetricsMetrics3FromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsMetrics3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsMetrics3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsMetrics3' from JSON`,
  );
}

/** @internal */
export const InputMetricsType2$inboundSchema: z.ZodNativeEnum<
  typeof InputMetricsType2
> = z.nativeEnum(InputMetricsType2);
/** @internal */
export const InputMetricsType2$outboundSchema: z.ZodNativeEnum<
  typeof InputMetricsType2
> = InputMetricsType2$inboundSchema;

/** @internal */
export const InputMetricsMetrics2$inboundSchema: z.ZodType<
  InputMetricsMetrics2,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputMetricsType2$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema),
  pq: PqType$inboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: Tls2Type$inboundSchema.optional(),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});
/** @internal */
export type InputMetricsMetrics2$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections: Array<ConnectionsType$Outbound>;
  pq?: PqType$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort?: number | undefined;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  enableProxyHeader: boolean;
  tls?: Tls2Type$Outbound | undefined;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetricsMetrics2$outboundSchema: z.ZodType<
  InputMetricsMetrics2$Outbound,
  z.ZodTypeDef,
  InputMetricsMetrics2
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputMetricsType2$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema),
  pq: PqType$outboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: Tls2Type$outboundSchema.optional(),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

export function inputMetricsMetrics2ToJSON(
  inputMetricsMetrics2: InputMetricsMetrics2,
): string {
  return JSON.stringify(
    InputMetricsMetrics2$outboundSchema.parse(inputMetricsMetrics2),
  );
}
export function inputMetricsMetrics2FromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsMetrics2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsMetrics2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsMetrics2' from JSON`,
  );
}

/** @internal */
export const InputMetricsType1$inboundSchema: z.ZodNativeEnum<
  typeof InputMetricsType1
> = z.nativeEnum(InputMetricsType1);
/** @internal */
export const InputMetricsType1$outboundSchema: z.ZodNativeEnum<
  typeof InputMetricsType1
> = InputMetricsType1$inboundSchema;

/** @internal */
export const InputMetricsMetrics1$inboundSchema: z.ZodType<
  InputMetricsMetrics1,
  z.ZodTypeDef,
  unknown
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputMetricsType1$inboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$inboundSchema).optional(),
  pq: PqType$inboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: Tls2Type$inboundSchema.optional(),
  metadata: z.array(Metadata1Type$inboundSchema).optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});
/** @internal */
export type InputMetricsMetrics1$Outbound = {
  sendToRoutes: boolean;
  id?: string | undefined;
  type: string;
  disabled: boolean;
  pipeline?: string | undefined;
  environment?: string | undefined;
  pqEnabled: boolean;
  streamtags?: Array<string> | undefined;
  connections?: Array<ConnectionsType$Outbound> | undefined;
  pq?: PqType$Outbound | undefined;
  host: string;
  udpPort?: number | undefined;
  tcpPort?: number | undefined;
  maxBufferSize: number;
  ipWhitelistRegex: string;
  enableProxyHeader: boolean;
  tls?: Tls2Type$Outbound | undefined;
  metadata?: Array<Metadata1Type$Outbound> | undefined;
  udpSocketRxBufSize?: number | undefined;
  description?: string | undefined;
};

/** @internal */
export const InputMetricsMetrics1$outboundSchema: z.ZodType<
  InputMetricsMetrics1$Outbound,
  z.ZodTypeDef,
  InputMetricsMetrics1
> = z.object({
  sendToRoutes: z.boolean().default(true),
  id: z.string().optional(),
  type: InputMetricsType1$outboundSchema,
  disabled: z.boolean().default(false),
  pipeline: z.string().optional(),
  environment: z.string().optional(),
  pqEnabled: z.boolean().default(false),
  streamtags: z.array(z.string()).optional(),
  connections: z.array(ConnectionsType$outboundSchema).optional(),
  pq: PqType$outboundSchema.optional(),
  host: z.string().default("0.0.0.0"),
  udpPort: z.number().optional(),
  tcpPort: z.number().optional(),
  maxBufferSize: z.number().default(1000),
  ipWhitelistRegex: z.string().default("/.*/"),
  enableProxyHeader: z.boolean().default(false),
  tls: Tls2Type$outboundSchema.optional(),
  metadata: z.array(Metadata1Type$outboundSchema).optional(),
  udpSocketRxBufSize: z.number().optional(),
  description: z.string().optional(),
});

export function inputMetricsMetrics1ToJSON(
  inputMetricsMetrics1: InputMetricsMetrics1,
): string {
  return JSON.stringify(
    InputMetricsMetrics1$outboundSchema.parse(inputMetricsMetrics1),
  );
}
export function inputMetricsMetrics1FromJSON(
  jsonString: string,
): SafeParseResult<InputMetricsMetrics1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetricsMetrics1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetricsMetrics1' from JSON`,
  );
}

/** @internal */
export const InputMetrics$inboundSchema: z.ZodType<
  InputMetrics,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InputMetricsMetrics2$inboundSchema),
  z.lazy(() => InputMetricsMetrics4$inboundSchema),
  z.lazy(() => InputMetricsMetrics1$inboundSchema),
  z.lazy(() => InputMetricsMetrics3$inboundSchema),
]);
/** @internal */
export type InputMetrics$Outbound =
  | InputMetricsMetrics2$Outbound
  | InputMetricsMetrics4$Outbound
  | InputMetricsMetrics1$Outbound
  | InputMetricsMetrics3$Outbound;

/** @internal */
export const InputMetrics$outboundSchema: z.ZodType<
  InputMetrics$Outbound,
  z.ZodTypeDef,
  InputMetrics
> = z.union([
  z.lazy(() => InputMetricsMetrics2$outboundSchema),
  z.lazy(() => InputMetricsMetrics4$outboundSchema),
  z.lazy(() => InputMetricsMetrics1$outboundSchema),
  z.lazy(() => InputMetricsMetrics3$outboundSchema),
]);

export function inputMetricsToJSON(inputMetrics: InputMetrics): string {
  return JSON.stringify(InputMetrics$outboundSchema.parse(inputMetrics));
}
export function inputMetricsFromJSON(
  jsonString: string,
): SafeParseResult<InputMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMetrics' from JSON`,
  );
}
