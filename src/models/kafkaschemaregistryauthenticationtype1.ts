/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  AuthTypeKafkaSchemaRegistry,
  AuthTypeKafkaSchemaRegistry$inboundSchema,
  AuthTypeKafkaSchemaRegistry$Outbound,
  AuthTypeKafkaSchemaRegistry$outboundSchema,
} from "./authtypekafkaschemaregistry.js";
import { SDKValidationError } from "./errors/sdkvalidationerror.js";
import {
  TlsSettingsClientSideTypeKafkaSchemaRegistry,
  TlsSettingsClientSideTypeKafkaSchemaRegistry$inboundSchema,
  TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound,
  TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema,
} from "./tlssettingsclientsidetypekafkaschemaregistry.js";

export type KafkaSchemaRegistryAuthenticationType1 = {
  disabled: boolean;
  /**
   * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http.
   */
  schemaRegistryURL?: string | undefined;
  /**
   * Maximum time to wait for a Schema Registry connection to complete successfully
   */
  connectionTimeout?: number | undefined;
  /**
   * Maximum time to wait for the Schema Registry to respond to a request
   */
  requestTimeout?: number | undefined;
  /**
   * Maximum number of times to try fetching schemas from the Schema Registry
   */
  maxRetries?: number | undefined;
  /**
   * Credentials to use when authenticating with the schema registry using basic HTTP authentication
   */
  auth?: AuthTypeKafkaSchemaRegistry | undefined;
  tls?: TlsSettingsClientSideTypeKafkaSchemaRegistry | undefined;
  /**
   * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
   */
  defaultKeySchemaId?: number | undefined;
  /**
   * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
   */
  defaultValueSchemaId?: number | undefined;
};

/** @internal */
export const KafkaSchemaRegistryAuthenticationType1$inboundSchema: z.ZodType<
  KafkaSchemaRegistryAuthenticationType1,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: types.boolean(),
  schemaRegistryURL: types.optional(types.string()),
  connectionTimeout: types.optional(types.number()),
  requestTimeout: types.optional(types.number()),
  maxRetries: types.optional(types.number()),
  auth: types.optional(AuthTypeKafkaSchemaRegistry$inboundSchema),
  tls: types.optional(
    TlsSettingsClientSideTypeKafkaSchemaRegistry$inboundSchema,
  ),
  defaultKeySchemaId: types.optional(types.number()),
  defaultValueSchemaId: types.optional(types.number()),
});
/** @internal */
export type KafkaSchemaRegistryAuthenticationType1$Outbound = {
  disabled: boolean;
  schemaRegistryURL?: string | undefined;
  connectionTimeout?: number | undefined;
  requestTimeout?: number | undefined;
  maxRetries?: number | undefined;
  auth?: AuthTypeKafkaSchemaRegistry$Outbound | undefined;
  tls?: TlsSettingsClientSideTypeKafkaSchemaRegistry$Outbound | undefined;
  defaultKeySchemaId?: number | undefined;
  defaultValueSchemaId?: number | undefined;
};

/** @internal */
export const KafkaSchemaRegistryAuthenticationType1$outboundSchema: z.ZodType<
  KafkaSchemaRegistryAuthenticationType1$Outbound,
  z.ZodTypeDef,
  KafkaSchemaRegistryAuthenticationType1
> = z.object({
  disabled: z.boolean(),
  schemaRegistryURL: z.string().optional(),
  connectionTimeout: z.number().optional(),
  requestTimeout: z.number().optional(),
  maxRetries: z.number().optional(),
  auth: AuthTypeKafkaSchemaRegistry$outboundSchema.optional(),
  tls: TlsSettingsClientSideTypeKafkaSchemaRegistry$outboundSchema.optional(),
  defaultKeySchemaId: z.number().optional(),
  defaultValueSchemaId: z.number().optional(),
});

export function kafkaSchemaRegistryAuthenticationType1ToJSON(
  kafkaSchemaRegistryAuthenticationType1:
    KafkaSchemaRegistryAuthenticationType1,
): string {
  return JSON.stringify(
    KafkaSchemaRegistryAuthenticationType1$outboundSchema.parse(
      kafkaSchemaRegistryAuthenticationType1,
    ),
  );
}
export function kafkaSchemaRegistryAuthenticationType1FromJSON(
  jsonString: string,
): SafeParseResult<KafkaSchemaRegistryAuthenticationType1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      KafkaSchemaRegistryAuthenticationType1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KafkaSchemaRegistryAuthenticationType1' from JSON`,
  );
}
