/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

const LF = 0x0a;
const CR = 0x0d;
const RIGHT_BRACE = 0x7d;
const MESSAGE_BOUNDARIES = [
  new Uint8Array([RIGHT_BRACE, CR, LF]),
  new Uint8Array([RIGHT_BRACE, LF]),
];

export class JsonLStream<Event> {
  private readonly stream: ReadableStream<Uint8Array>;
  private readonly decoder: (rawEvent: string) => Event;

  constructor(init: {
    stream: ReadableStream<Uint8Array>;
    decoder: (rawEvent: string) => Event;
  }) {
    this.stream = init.stream;
    this.decoder = init.decoder;
  }

  async *[Symbol.asyncIterator](): AsyncGenerator<Event, void, unknown> {
    const reader = this.stream.getReader();
    let buffer = new Uint8Array([]);
    let position = 0;

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }

        const newBuffer = new Uint8Array(buffer.length + value.length);
        newBuffer.set(buffer);
        newBuffer.set(value, buffer.length);
        buffer = newBuffer;

        for (let i = position; i < buffer.length; i++) {
          const boundary = findBoundary(buffer, i);
          if (boundary == null) {
            continue;
          }

          const chunk = buffer.slice(position, i + 1);
          position = i + boundary.length;
          const event = parseEvent(chunk, this.decoder);
          if (event != null) {
            yield event;
          }
        }

        if (position > 0) {
          buffer = buffer.slice(position);
          position = 0;
        }
      }

      if (buffer.length > 0) {
        const event = parseEvent(buffer, this.decoder);
        if (event != null) {
          yield event;
        }
      }
    } catch (e: unknown) {
      if (e instanceof Error && e.name === "AbortError") {
        return;
      }

      throw e;
    } finally {
      reader.releaseLock();
    }
  }
}

function findBoundary(buffer: Uint8Array, start: number): Uint8Array | null {
  for (const s of MESSAGE_BOUNDARIES) {
    const seq = peekSequence(start, buffer, s);
    if (seq != null) {
      return seq;
    }
  }

  return null;
}

function peekSequence(
  position: number,
  buffer: Uint8Array,
  sequence: Uint8Array,
): Uint8Array | null {
  if (sequence.length > buffer.length - position) {
    return null;
  }

  for (let i = 0; i < sequence.length; i++) {
    if (buffer[position + i] !== sequence[i]) {
      return null;
    }
  }

  return sequence;
}

function parseEvent<Event>(
  chunk: Uint8Array,
  decoder: (rawEvent: string) => Event,
) {
  if (!chunk.length) {
    return null;
  }

  const td = new TextDecoder();
  const raw = td.decode(chunk);

  try {
    const parsed = JSON.parse(raw);
    return decoder(parsed);
  } catch (e) {
    console.error("Error parsing JSON:", e);
    return null;
  }
}
