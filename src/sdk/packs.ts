/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { packsDelete } from "../funcs/packsDelete.js";
import { packsGet } from "../funcs/packsGet.js";
import { packsInstall } from "../funcs/packsInstall.js";
import { packsList } from "../funcs/packsList.js";
import { packsUpdate } from "../funcs/packsUpdate.js";
import { packsUpload } from "../funcs/packsUpload.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as models from "../models/index.js";
import * as operations from "../models/operations/index.js";
import { unwrapAsync } from "../types/fp.js";
import { PacksSources } from "./packssources.js";

export class Packs extends ClientSDK {
  private _sources?: PacksSources;
  get sources(): PacksSources {
    return (this._sources ??= new PacksSources(this._options));
  }

  /**
   * Install a Pack
   *
   * @remarks
   * Install a Pack.<br><br>To install an uploaded Pack, provide the <code>source</code> value from the <code>PUT /packs</code> response as the <code>source</code> parameter in the request body.<br><br>To install a Pack by importing from a URL, provide the direct URL location of the <code>.crbl</code> file for the Pack as the <code>source</code> parameter in the request body.<br><br>To install a Pack by importing from a Git repository, provide <code>git+<repo-url></code> as the <code>source</code> parameter in the request body.<br><br>If you do not include the <code>source</code> parameter in the request body, an empty Pack is created.
   */
  async install(
    request: models.PackRequestBodyUnion,
    options?: RequestOptions,
  ): Promise<models.CountedPackInstallInfo> {
    return unwrapAsync(packsInstall(
      this,
      request,
      options,
    ));
  }

  /**
   * List all Packs
   *
   * @remarks
   * Get a list of all Packs.
   */
  async list(
    request?: operations.GetPacksRequest | undefined,
    options?: RequestOptions,
  ): Promise<models.CountedPackInfo> {
    return unwrapAsync(packsList(
      this,
      request,
      options,
    ));
  }

  /**
   * Upload a Pack file
   *
   * @remarks
   * Upload a Pack file. Returns the <code>source</code> ID needed to install the Pack with <code>POST /packs source</code>, which you must call separately.
   */
  async upload(
    request: operations.UpdatePacksRequest,
    options?: RequestOptions,
  ): Promise<models.UploadPackResponse> {
    return unwrapAsync(packsUpload(
      this,
      request,
      options,
    ));
  }

  /**
   * Uninstall a Pack
   *
   * @remarks
   * Uninstall the specified Pack.
   */
  async delete(
    request: operations.DeletePacksByIdRequest,
    options?: RequestOptions,
  ): Promise<models.CountedPackUninstallInfo> {
    return unwrapAsync(packsDelete(
      this,
      request,
      options,
    ));
  }

  /**
   * Get a Pack
   *
   * @remarks
   * Get the specified Pack.
   */
  async get(
    request: operations.GetPacksByIdRequest,
    options?: RequestOptions,
  ): Promise<models.CountedPackInfo> {
    return unwrapAsync(packsGet(
      this,
      request,
      options,
    ));
  }

  /**
   * Upgrade a Pack
   *
   * @remarks
   * Upgrade the specified Pack.</br></br>If the Pack includes any userâ€“modified versions of default Cribl Knowledge resources such as lookups, copy the modified files locally for safekeeping before upgrading the Pack.Copy the modified files back to the upgraded Pack after you install it with <code>POST /packs</code> to overwrite the default versions in the Pack.</br></br>After you upgrade the Pack, update any Routes, Pipelines, Sources, and Destinations that use the previous Pack version so that they reference the upgraded Pack.
   */
  async update(
    request: operations.UpdatePacksByIdRequest,
    options?: RequestOptions,
  ): Promise<models.CountedPackInfo> {
    return unwrapAsync(packsUpdate(
      this,
      request,
      options,
    ));
  }
}
